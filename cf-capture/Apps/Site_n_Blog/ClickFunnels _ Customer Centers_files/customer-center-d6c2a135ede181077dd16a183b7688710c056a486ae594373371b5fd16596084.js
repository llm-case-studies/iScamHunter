(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn3, res) => function __init() {
    return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to3, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to3, key) && key !== except)
          __defProp(to3, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to3;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

  // <define:process>
  var define_process_default;
  var init_define_process = __esm({
    "<define:process>"() {
      define_process_default = { env: { NODE_ENV: "production", RAILS_ENV: "production" } };
    }
  });

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function(global3, factory) {
        "use strict";
        if (typeof module2 === "object" && typeof module2.exports === "object") {
          module2.exports = global3.document ? factory(global3, true) : function(w5) {
            if (!w5.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w5);
          };
        } else {
          factory(global3);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction2 = function isFunction3(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc2) {
          doc2 = doc2 || document2;
          var i3, val, script = doc2.createElement("script");
          script.text = code;
          if (node) {
            for (i3 in preservedScriptAttributes) {
              val = node[i3] || node.getAttribute && node.getAttribute(i3);
              if (val) {
                script.setAttribute(i3, val);
              }
            }
          }
          doc2.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version3 = "3.5.1", jQuery2 = function(selector, context2) {
          return new jQuery2.fn.init(selector, context2);
        };
        jQuery2.fn = jQuery2.prototype = {
          // The current version of jQuery being used
          jquery: version3,
          constructor: jQuery2,
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          // Take an array of elements and push it onto the stack
          // (returning the new matched element set)
          pushStack: function(elems) {
            var ret = jQuery2.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          // Execute a callback for every element in the matched set.
          each: function(callback2) {
            return jQuery2.each(this, callback2);
          },
          map: function(callback2) {
            return this.pushStack(jQuery2.map(this, function(elem, i3) {
              return callback2.call(elem, i3, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery2.grep(this, function(_elem, i3) {
              return (i3 + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery2.grep(this, function(_elem, i3) {
              return i3 % 2;
            }));
          },
          eq: function(i3) {
            var len = this.length, j6 = +i3 + (i3 < 0 ? len : 0);
            return this.pushStack(j6 >= 0 && j6 < len ? [this[j6]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          // For internal use only.
          // Behaves like an Array's method, not like a jQuery method.
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery2.extend = jQuery2.fn.extend = function() {
          var options, name2, src, copy3, copyIsArray, clone2, target = arguments[0] || {}, i3 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i3] || {};
            i3++;
          }
          if (typeof target !== "object" && !isFunction2(target)) {
            target = {};
          }
          if (i3 === length) {
            target = this;
            i3--;
          }
          for (; i3 < length; i3++) {
            if ((options = arguments[i3]) != null) {
              for (name2 in options) {
                copy3 = options[name2];
                if (name2 === "__proto__" || target === copy3) {
                  continue;
                }
                if (deep && copy3 && (jQuery2.isPlainObject(copy3) || (copyIsArray = Array.isArray(copy3)))) {
                  src = target[name2];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone2 = [];
                  } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                    clone2 = {};
                  } else {
                    clone2 = src;
                  }
                  copyIsArray = false;
                  target[name2] = jQuery2.extend(deep, clone2, copy3);
                } else if (copy3 !== void 0) {
                  target[name2] = copy3;
                }
              }
            }
          }
          return target;
        };
        jQuery2.extend({
          // Unique for each copy of jQuery on the page
          expando: "jQuery" + (version3 + Math.random()).replace(/\D/g, ""),
          // Assume jQuery is ready without the ready module
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name2;
            for (name2 in obj) {
              return false;
            }
            return true;
          },
          // Evaluates a script in a provided context; falls back to the global one
          // if not specified.
          globalEval: function(code, options, doc2) {
            DOMEval(code, { nonce: options && options.nonce }, doc2);
          },
          each: function(obj, callback2) {
            var length, i3 = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i3 < length; i3++) {
                if (callback2.call(obj[i3], i3, obj[i3]) === false) {
                  break;
                }
              }
            } else {
              for (i3 in obj) {
                if (callback2.call(obj[i3], i3, obj[i3]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          // results is for internal usage only
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery2.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i3) {
            return arr2 == null ? -1 : indexOf.call(arr2, elem, i3);
          },
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          merge: function(first, second) {
            var len = +second.length, j6 = 0, i3 = first.length;
            for (; j6 < len; j6++) {
              first[i3++] = second[j6];
            }
            first.length = i3;
            return first;
          },
          grep: function(elems, callback2, invert) {
            var callbackInverse, matches = [], i3 = 0, length = elems.length, callbackExpect = !invert;
            for (; i3 < length; i3++) {
              callbackInverse = !callback2(elems[i3], i3);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i3]);
              }
            }
            return matches;
          },
          // arg is for internal usage only
          map: function(elems, callback2, arg) {
            var length, value, i3 = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i3 < length; i3++) {
                value = callback2(elems[i3], i3, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i3 in elems) {
                value = callback2(elems[i3], i3, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          // A global GUID counter for objects
          guid: 1,
          // jQuery.support is not used in Core but other projects attach their
          // properties to it so it needs to exist.
          support
        });
        if (typeof Symbol === "function") {
          jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery2.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i2, name2) {
            class2type["[object " + name2 + "]"] = name2.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction2(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        var Sizzle = (
          /*!
           * Sizzle CSS Selector Engine v2.3.5
           * https://sizzlejs.com/
           *
           * Copyright JS Foundation and other contributors
           * Released under the MIT license
           * https://js.foundation/
           *
           * Date: 2020-03-14
           */
          function(window3) {
            var i3, support2, Expr, getText, isXML, tokenize2, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains2, expando = "sizzle" + 1 * /* @__PURE__ */ new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a5, b5) {
              if (a5 === b5) {
                hasDuplicate = true;
              }
              return 0;
            }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list, elem) {
              var i4 = 0, len = list.length;
              for (; i4 < len; i4++) {
                if (list[i4] === elem) {
                  return i4;
                }
              }
              return -1;
            }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
            "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
            // or strings [capture 3 or capture 4]"
            `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim2 = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
              "ID": new RegExp("^#(" + identifier + ")"),
              "CLASS": new RegExp("^\\.(" + identifier + ")"),
              "TAG": new RegExp("^(" + identifier + "|[*])"),
              "ATTR": new RegExp("^" + attributes),
              "PSEUDO": new RegExp("^" + pseudos),
              "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
              "bool": new RegExp("^(?:" + booleans + ")$", "i"),
              // For use in libraries implementing .is()
              // We use this for POS matching in `select`
              "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape3, nonHex) {
              var high = "0x" + escape3.slice(1) - 65536;
              return nonHex ? (
                // Strip the backslash prefix from a non-hex escape sequence
                nonHex
              ) : (
                // Replace a hexadecimal escape sequence with the encoded Unicode code point
                // Support: IE <=11+
                // For values outside the Basic Multilingual Plane (BMP), manually construct a
                // surrogate pair
                high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
              );
            }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
              if (asCodePoint) {
                if (ch === "\0") {
                  return "\uFFFD";
                }
                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
              }
              return "\\" + ch;
            }, unloadHandler = function() {
              setDocument();
            }, inDisabledFieldset = addCombinator(
              function(elem) {
                return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
              },
              { dir: "parentNode", next: "legend" }
            );
            try {
              push2.apply(
                arr2 = slice2.call(preferredDoc.childNodes),
                preferredDoc.childNodes
              );
              arr2[preferredDoc.childNodes.length].nodeType;
            } catch (e2) {
              push2 = {
                apply: arr2.length ? (
                  // Leverage slice if possible
                  function(target, els) {
                    pushNative.apply(target, slice2.call(els));
                  }
                ) : (
                  // Support: IE<9
                  // Otherwise append directly
                  function(target, els) {
                    var j6 = target.length, i4 = 0;
                    while (target[j6++] = els[i4++]) {
                    }
                    target.length = j6 - 1;
                  }
                )
              };
            }
            function Sizzle2(selector, context2, results, seed) {
              var m4, i4, elem, nid, match, groups, newSelector, newContext = context2 && context2.ownerDocument, nodeType = context2 ? context2.nodeType : 9;
              results = results || [];
              if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
              }
              if (!seed) {
                setDocument(context2);
                context2 = context2 || document3;
                if (documentIsHTML) {
                  if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                    if (m4 = match[1]) {
                      if (nodeType === 9) {
                        if (elem = context2.getElementById(m4)) {
                          if (elem.id === m4) {
                            results.push(elem);
                            return results;
                          }
                        } else {
                          return results;
                        }
                      } else {
                        if (newContext && (elem = newContext.getElementById(m4)) && contains2(context2, elem) && elem.id === m4) {
                          results.push(elem);
                          return results;
                        }
                      }
                    } else if (match[2]) {
                      push2.apply(results, context2.getElementsByTagName(selector));
                      return results;
                    } else if ((m4 = match[3]) && support2.getElementsByClassName && context2.getElementsByClassName) {
                      push2.apply(results, context2.getElementsByClassName(m4));
                      return results;
                    }
                  }
                  if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
                  // Exclude object elements
                  (nodeType !== 1 || context2.nodeName.toLowerCase() !== "object")) {
                    newSelector = selector;
                    newContext = context2;
                    if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                      newContext = rsibling.test(selector) && testContext(context2.parentNode) || context2;
                      if (newContext !== context2 || !support2.scope) {
                        if (nid = context2.getAttribute("id")) {
                          nid = nid.replace(rcssescape, fcssescape);
                        } else {
                          context2.setAttribute("id", nid = expando);
                        }
                      }
                      groups = tokenize2(selector);
                      i4 = groups.length;
                      while (i4--) {
                        groups[i4] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i4]);
                      }
                      newSelector = groups.join(",");
                    }
                    try {
                      push2.apply(
                        results,
                        newContext.querySelectorAll(newSelector)
                      );
                      return results;
                    } catch (qsaError) {
                      nonnativeSelectorCache(selector, true);
                    } finally {
                      if (nid === expando) {
                        context2.removeAttribute("id");
                      }
                    }
                  }
                }
              }
              return select(selector.replace(rtrim2, "$1"), context2, results, seed);
            }
            function createCache() {
              var keys = [];
              function cache2(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) {
                  delete cache2[keys.shift()];
                }
                return cache2[key + " "] = value;
              }
              return cache2;
            }
            function markFunction(fn3) {
              fn3[expando] = true;
              return fn3;
            }
            function assert(fn3) {
              var el = document3.createElement("fieldset");
              try {
                return !!fn3(el);
              } catch (e2) {
                return false;
              } finally {
                if (el.parentNode) {
                  el.parentNode.removeChild(el);
                }
                el = null;
              }
            }
            function addHandle(attrs, handler) {
              var arr3 = attrs.split("|"), i4 = arr3.length;
              while (i4--) {
                Expr.attrHandle[arr3[i4]] = handler;
              }
            }
            function siblingCheck(a5, b5) {
              var cur = b5 && a5, diff = cur && a5.nodeType === 1 && b5.nodeType === 1 && a5.sourceIndex - b5.sourceIndex;
              if (diff) {
                return diff;
              }
              if (cur) {
                while (cur = cur.nextSibling) {
                  if (cur === b5) {
                    return -1;
                  }
                }
              }
              return a5 ? 1 : -1;
            }
            function createInputPseudo(type) {
              return function(elem) {
                var name2 = elem.nodeName.toLowerCase();
                return name2 === "input" && elem.type === type;
              };
            }
            function createButtonPseudo(type) {
              return function(elem) {
                var name2 = elem.nodeName.toLowerCase();
                return (name2 === "input" || name2 === "button") && elem.type === type;
              };
            }
            function createDisabledPseudo(disabled) {
              return function(elem) {
                if ("form" in elem) {
                  if (elem.parentNode && elem.disabled === false) {
                    if ("label" in elem) {
                      if ("label" in elem.parentNode) {
                        return elem.parentNode.disabled === disabled;
                      } else {
                        return elem.disabled === disabled;
                      }
                    }
                    return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                    /* jshint -W018 */
                    elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                  }
                  return elem.disabled === disabled;
                } else if ("label" in elem) {
                  return elem.disabled === disabled;
                }
                return false;
              };
            }
            function createPositionalPseudo(fn3) {
              return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches2) {
                  var j6, matchIndexes = fn3([], seed.length, argument), i4 = matchIndexes.length;
                  while (i4--) {
                    if (seed[j6 = matchIndexes[i4]]) {
                      seed[j6] = !(matches2[j6] = seed[j6]);
                    }
                  }
                });
              });
            }
            function testContext(context2) {
              return context2 && typeof context2.getElementsByTagName !== "undefined" && context2;
            }
            support2 = Sizzle2.support = {};
            isXML = Sizzle2.isXML = function(elem) {
              var namespace = elem.namespaceURI, docElem2 = (elem.ownerDocument || elem).documentElement;
              return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
            };
            setDocument = Sizzle2.setDocument = function(node) {
              var hasCompare, subWindow, doc2 = node ? node.ownerDocument || node : preferredDoc;
              if (doc2 == document3 || doc2.nodeType !== 9 || !doc2.documentElement) {
                return document3;
              }
              document3 = doc2;
              docElem = document3.documentElement;
              documentIsHTML = !isXML(document3);
              if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
                if (subWindow.addEventListener) {
                  subWindow.addEventListener("unload", unloadHandler, false);
                } else if (subWindow.attachEvent) {
                  subWindow.attachEvent("onunload", unloadHandler);
                }
              }
              support2.scope = assert(function(el) {
                docElem.appendChild(el).appendChild(document3.createElement("div"));
                return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
              });
              support2.attributes = assert(function(el) {
                el.className = "i";
                return !el.getAttribute("className");
              });
              support2.getElementsByTagName = assert(function(el) {
                el.appendChild(document3.createComment(""));
                return !el.getElementsByTagName("*").length;
              });
              support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
              support2.getById = assert(function(el) {
                docElem.appendChild(el).id = expando;
                return !document3.getElementsByName || !document3.getElementsByName(expando).length;
              });
              if (support2.getById) {
                Expr.filter["ID"] = function(id) {
                  var attrId = id.replace(runescape, funescape);
                  return function(elem) {
                    return elem.getAttribute("id") === attrId;
                  };
                };
                Expr.find["ID"] = function(id, context2) {
                  if (typeof context2.getElementById !== "undefined" && documentIsHTML) {
                    var elem = context2.getElementById(id);
                    return elem ? [elem] : [];
                  }
                };
              } else {
                Expr.filter["ID"] = function(id) {
                  var attrId = id.replace(runescape, funescape);
                  return function(elem) {
                    var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                    return node2 && node2.value === attrId;
                  };
                };
                Expr.find["ID"] = function(id, context2) {
                  if (typeof context2.getElementById !== "undefined" && documentIsHTML) {
                    var node2, i4, elems, elem = context2.getElementById(id);
                    if (elem) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                      elems = context2.getElementsByName(id);
                      i4 = 0;
                      while (elem = elems[i4++]) {
                        node2 = elem.getAttributeNode("id");
                        if (node2 && node2.value === id) {
                          return [elem];
                        }
                      }
                    }
                    return [];
                  }
                };
              }
              Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context2) {
                if (typeof context2.getElementsByTagName !== "undefined") {
                  return context2.getElementsByTagName(tag);
                } else if (support2.qsa) {
                  return context2.querySelectorAll(tag);
                }
              } : function(tag, context2) {
                var elem, tmp = [], i4 = 0, results = context2.getElementsByTagName(tag);
                if (tag === "*") {
                  while (elem = results[i4++]) {
                    if (elem.nodeType === 1) {
                      tmp.push(elem);
                    }
                  }
                  return tmp;
                }
                return results;
              };
              Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context2) {
                if (typeof context2.getElementsByClassName !== "undefined" && documentIsHTML) {
                  return context2.getElementsByClassName(className);
                }
              };
              rbuggyMatches = [];
              rbuggyQSA = [];
              if (support2.qsa = rnative.test(document3.querySelectorAll)) {
                assert(function(el) {
                  var input;
                  docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
                  if (el.querySelectorAll("[msallowcapture^='']").length) {
                    rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
                  }
                  if (!el.querySelectorAll("[selected]").length) {
                    rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                  }
                  if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                    rbuggyQSA.push("~=");
                  }
                  input = document3.createElement("input");
                  input.setAttribute("name", "");
                  el.appendChild(input);
                  if (!el.querySelectorAll("[name='']").length) {
                    rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
                  }
                  if (!el.querySelectorAll(":checked").length) {
                    rbuggyQSA.push(":checked");
                  }
                  if (!el.querySelectorAll("a#" + expando + "+*").length) {
                    rbuggyQSA.push(".#.+[+~]");
                  }
                  el.querySelectorAll("\\\f");
                  rbuggyQSA.push("[\\r\\n\\f]");
                });
                assert(function(el) {
                  el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                  var input = document3.createElement("input");
                  input.setAttribute("type", "hidden");
                  el.appendChild(input).setAttribute("name", "D");
                  if (el.querySelectorAll("[name=d]").length) {
                    rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                  }
                  if (el.querySelectorAll(":enabled").length !== 2) {
                    rbuggyQSA.push(":enabled", ":disabled");
                  }
                  docElem.appendChild(el).disabled = true;
                  if (el.querySelectorAll(":disabled").length !== 2) {
                    rbuggyQSA.push(":enabled", ":disabled");
                  }
                  el.querySelectorAll("*,:x");
                  rbuggyQSA.push(",.*:");
                });
              }
              if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(el) {
                  support2.disconnectedMatch = matches.call(el, "*");
                  matches.call(el, "[s!='']:x");
                  rbuggyMatches.push("!=", pseudos);
                });
              }
              rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
              rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
              hasCompare = rnative.test(docElem.compareDocumentPosition);
              contains2 = hasCompare || rnative.test(docElem.contains) ? function(a5, b5) {
                var adown = a5.nodeType === 9 ? a5.documentElement : a5, bup = b5 && b5.parentNode;
                return a5 === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a5.compareDocumentPosition && a5.compareDocumentPosition(bup) & 16));
              } : function(a5, b5) {
                if (b5) {
                  while (b5 = b5.parentNode) {
                    if (b5 === a5) {
                      return true;
                    }
                  }
                }
                return false;
              };
              sortOrder = hasCompare ? function(a5, b5) {
                if (a5 === b5) {
                  hasDuplicate = true;
                  return 0;
                }
                var compare = !a5.compareDocumentPosition - !b5.compareDocumentPosition;
                if (compare) {
                  return compare;
                }
                compare = (a5.ownerDocument || a5) == (b5.ownerDocument || b5) ? a5.compareDocumentPosition(b5) : (
                  // Otherwise we know they are disconnected
                  1
                );
                if (compare & 1 || !support2.sortDetached && b5.compareDocumentPosition(a5) === compare) {
                  if (a5 == document3 || a5.ownerDocument == preferredDoc && contains2(preferredDoc, a5)) {
                    return -1;
                  }
                  if (b5 == document3 || b5.ownerDocument == preferredDoc && contains2(preferredDoc, b5)) {
                    return 1;
                  }
                  return sortInput ? indexOf2(sortInput, a5) - indexOf2(sortInput, b5) : 0;
                }
                return compare & 4 ? -1 : 1;
              } : function(a5, b5) {
                if (a5 === b5) {
                  hasDuplicate = true;
                  return 0;
                }
                var cur, i4 = 0, aup = a5.parentNode, bup = b5.parentNode, ap = [a5], bp = [b5];
                if (!aup || !bup) {
                  return a5 == document3 ? -1 : b5 == document3 ? 1 : (
                    /* eslint-enable eqeqeq */
                    aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a5) - indexOf2(sortInput, b5) : 0
                  );
                } else if (aup === bup) {
                  return siblingCheck(a5, b5);
                }
                cur = a5;
                while (cur = cur.parentNode) {
                  ap.unshift(cur);
                }
                cur = b5;
                while (cur = cur.parentNode) {
                  bp.unshift(cur);
                }
                while (ap[i4] === bp[i4]) {
                  i4++;
                }
                return i4 ? (
                  // Do a sibling check if the nodes have a common ancestor
                  siblingCheck(ap[i4], bp[i4])
                ) : (
                  // Otherwise nodes in our document sort first
                  // Support: IE 11+, Edge 17 - 18+
                  // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                  // two documents; shallow comparisons work.
                  /* eslint-disable eqeqeq */
                  ap[i4] == preferredDoc ? -1 : bp[i4] == preferredDoc ? 1 : (
                    /* eslint-enable eqeqeq */
                    0
                  )
                );
              };
              return document3;
            };
            Sizzle2.matches = function(expr, elements2) {
              return Sizzle2(expr, null, null, elements2);
            };
            Sizzle2.matchesSelector = function(elem, expr) {
              setDocument(elem);
              if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                  var ret = matches.call(elem, expr);
                  if (ret || support2.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                  // fragment in IE 9
                  elem.document && elem.document.nodeType !== 11) {
                    return ret;
                  }
                } catch (e2) {
                  nonnativeSelectorCache(expr, true);
                }
              }
              return Sizzle2(expr, document3, null, [elem]).length > 0;
            };
            Sizzle2.contains = function(context2, elem) {
              if ((context2.ownerDocument || context2) != document3) {
                setDocument(context2);
              }
              return contains2(context2, elem);
            };
            Sizzle2.attr = function(elem, name2) {
              if ((elem.ownerDocument || elem) != document3) {
                setDocument(elem);
              }
              var fn3 = Expr.attrHandle[name2.toLowerCase()], val = fn3 && hasOwn2.call(Expr.attrHandle, name2.toLowerCase()) ? fn3(elem, name2, !documentIsHTML) : void 0;
              return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
            };
            Sizzle2.escape = function(sel) {
              return (sel + "").replace(rcssescape, fcssescape);
            };
            Sizzle2.error = function(msg) {
              throw new Error("Syntax error, unrecognized expression: " + msg);
            };
            Sizzle2.uniqueSort = function(results) {
              var elem, duplicates = [], j6 = 0, i4 = 0;
              hasDuplicate = !support2.detectDuplicates;
              sortInput = !support2.sortStable && results.slice(0);
              results.sort(sortOrder);
              if (hasDuplicate) {
                while (elem = results[i4++]) {
                  if (elem === results[i4]) {
                    j6 = duplicates.push(i4);
                  }
                }
                while (j6--) {
                  results.splice(duplicates[j6], 1);
                }
              }
              sortInput = null;
              return results;
            };
            getText = Sizzle2.getText = function(elem) {
              var node, ret = "", i4 = 0, nodeType = elem.nodeType;
              if (!nodeType) {
                while (node = elem[i4++]) {
                  ret += getText(node);
                }
              } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                  return elem.textContent;
                } else {
                  for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    ret += getText(elem);
                  }
                }
              } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
              }
              return ret;
            };
            Expr = Sizzle2.selectors = {
              // Can be adjusted by the user
              cacheLength: 50,
              createPseudo: markFunction,
              match: matchExpr,
              attrHandle: {},
              find: {},
              relative: {
                ">": { dir: "parentNode", first: true },
                " ": { dir: "parentNode" },
                "+": { dir: "previousSibling", first: true },
                "~": { dir: "previousSibling" }
              },
              preFilter: {
                "ATTR": function(match) {
                  match[1] = match[1].replace(runescape, funescape);
                  match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                  if (match[2] === "~=") {
                    match[3] = " " + match[3] + " ";
                  }
                  return match.slice(0, 4);
                },
                "CHILD": function(match) {
                  match[1] = match[1].toLowerCase();
                  if (match[1].slice(0, 3) === "nth") {
                    if (!match[3]) {
                      Sizzle2.error(match[0]);
                    }
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                    match[5] = +(match[7] + match[8] || match[3] === "odd");
                  } else if (match[3]) {
                    Sizzle2.error(match[0]);
                  }
                  return match;
                },
                "PSEUDO": function(match) {
                  var excess, unquoted = !match[6] && match[2];
                  if (matchExpr["CHILD"].test(match[0])) {
                    return null;
                  }
                  if (match[3]) {
                    match[2] = match[4] || match[5] || "";
                  } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                  (excess = tokenize2(unquoted, true)) && // advance to the next closing parenthesis
                  (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                    match[0] = match[0].slice(0, excess);
                    match[2] = unquoted.slice(0, excess);
                  }
                  return match.slice(0, 3);
                }
              },
              filter: {
                "TAG": function(nodeNameSelector) {
                  var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                  return nodeNameSelector === "*" ? function() {
                    return true;
                  } : function(elem) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
                  };
                },
                "CLASS": function(className) {
                  var pattern = classCache[className + " "];
                  return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(
                    className,
                    function(elem) {
                      return pattern.test(
                        typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                      );
                    }
                  );
                },
                "ATTR": function(name2, operator, check) {
                  return function(elem) {
                    var result = Sizzle2.attr(elem, name2);
                    if (result == null) {
                      return operator === "!=";
                    }
                    if (!operator) {
                      return true;
                    }
                    result += "";
                    return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                  };
                },
                "CHILD": function(type, what, _argument, first, last) {
                  var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                  return first === 1 && last === 0 ? (
                    // Shortcut for :nth-*(n)
                    function(elem) {
                      return !!elem.parentNode;
                    }
                  ) : function(elem, _context, xml) {
                    var cache2, uniqueCache, outerCache, node, nodeIndex, start5, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                    if (parent) {
                      if (simple) {
                        while (dir2) {
                          node = elem;
                          while (node = node[dir2]) {
                            if (ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) {
                              return false;
                            }
                          }
                          start5 = dir2 = type === "only" && !start5 && "nextSibling";
                        }
                        return true;
                      }
                      start5 = [forward ? parent.firstChild : parent.lastChild];
                      if (forward && useCache) {
                        node = parent;
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        cache2 = uniqueCache[type] || [];
                        nodeIndex = cache2[0] === dirruns && cache2[1];
                        diff = nodeIndex && cache2[2];
                        node = nodeIndex && parent.childNodes[nodeIndex];
                        while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                        (diff = nodeIndex = 0) || start5.pop()) {
                          if (node.nodeType === 1 && ++diff && node === elem) {
                            uniqueCache[type] = [dirruns, nodeIndex, diff];
                            break;
                          }
                        }
                      } else {
                        if (useCache) {
                          node = elem;
                          outerCache = node[expando] || (node[expando] = {});
                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                          cache2 = uniqueCache[type] || [];
                          nodeIndex = cache2[0] === dirruns && cache2[1];
                          diff = nodeIndex;
                        }
                        if (diff === false) {
                          while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start5.pop()) {
                            if ((ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) && ++diff) {
                              if (useCache) {
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                uniqueCache[type] = [dirruns, diff];
                              }
                              if (node === elem) {
                                break;
                              }
                            }
                          }
                        }
                      }
                      diff -= last;
                      return diff === first || diff % first === 0 && diff / first >= 0;
                    }
                  };
                },
                "PSEUDO": function(pseudo, argument) {
                  var args, fn3 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
                  if (fn3[expando]) {
                    return fn3(argument);
                  }
                  if (fn3.length > 1) {
                    args = [pseudo, pseudo, "", argument];
                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                      var idx, matched = fn3(seed, argument), i4 = matched.length;
                      while (i4--) {
                        idx = indexOf2(seed, matched[i4]);
                        seed[idx] = !(matches2[idx] = matched[i4]);
                      }
                    }) : function(elem) {
                      return fn3(elem, 0, args);
                    };
                  }
                  return fn3;
                }
              },
              pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function(selector) {
                  var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
                  return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                    var elem, unmatched = matcher(seed, null, xml, []), i4 = seed.length;
                    while (i4--) {
                      if (elem = unmatched[i4]) {
                        seed[i4] = !(matches2[i4] = elem);
                      }
                    }
                  }) : function(elem, _context, xml) {
                    input[0] = elem;
                    matcher(input, null, xml, results);
                    input[0] = null;
                    return !results.pop();
                  };
                }),
                "has": markFunction(function(selector) {
                  return function(elem) {
                    return Sizzle2(selector, elem).length > 0;
                  };
                }),
                "contains": markFunction(function(text) {
                  text = text.replace(runescape, funescape);
                  return function(elem) {
                    return (elem.textContent || getText(elem)).indexOf(text) > -1;
                  };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function(lang) {
                  if (!ridentifier.test(lang || "")) {
                    Sizzle2.error("unsupported lang: " + lang);
                  }
                  lang = lang.replace(runescape, funescape).toLowerCase();
                  return function(elem) {
                    var elemLang;
                    do {
                      if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                        elemLang = elemLang.toLowerCase();
                        return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                      }
                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                    return false;
                  };
                }),
                // Miscellaneous
                "target": function(elem) {
                  var hash3 = window3.location && window3.location.hash;
                  return hash3 && hash3.slice(1) === elem.id;
                },
                "root": function(elem) {
                  return elem === docElem;
                },
                "focus": function(elem) {
                  return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                "enabled": createDisabledPseudo(false),
                "disabled": createDisabledPseudo(true),
                "checked": function(elem) {
                  var nodeName2 = elem.nodeName.toLowerCase();
                  return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
                },
                "selected": function(elem) {
                  if (elem.parentNode) {
                    elem.parentNode.selectedIndex;
                  }
                  return elem.selected === true;
                },
                // Contents
                "empty": function(elem) {
                  for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    if (elem.nodeType < 6) {
                      return false;
                    }
                  }
                  return true;
                },
                "parent": function(elem) {
                  return !Expr.pseudos["empty"](elem);
                },
                // Element/input types
                "header": function(elem) {
                  return rheader.test(elem.nodeName);
                },
                "input": function(elem) {
                  return rinputs.test(elem.nodeName);
                },
                "button": function(elem) {
                  var name2 = elem.nodeName.toLowerCase();
                  return name2 === "input" && elem.type === "button" || name2 === "button";
                },
                "text": function(elem) {
                  var attr;
                  return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE<8
                  // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                  ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                "first": createPositionalPseudo(function() {
                  return [0];
                }),
                "last": createPositionalPseudo(function(_matchIndexes, length) {
                  return [length - 1];
                }),
                "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
                  return [argument < 0 ? argument + length : argument];
                }),
                "even": createPositionalPseudo(function(matchIndexes, length) {
                  var i4 = 0;
                  for (; i4 < length; i4 += 2) {
                    matchIndexes.push(i4);
                  }
                  return matchIndexes;
                }),
                "odd": createPositionalPseudo(function(matchIndexes, length) {
                  var i4 = 1;
                  for (; i4 < length; i4 += 2) {
                    matchIndexes.push(i4);
                  }
                  return matchIndexes;
                }),
                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                  var i4 = argument < 0 ? argument + length : argument > length ? length : argument;
                  for (; --i4 >= 0; ) {
                    matchIndexes.push(i4);
                  }
                  return matchIndexes;
                }),
                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                  var i4 = argument < 0 ? argument + length : argument;
                  for (; ++i4 < length; ) {
                    matchIndexes.push(i4);
                  }
                  return matchIndexes;
                })
              }
            };
            Expr.pseudos["nth"] = Expr.pseudos["eq"];
            for (i3 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
              Expr.pseudos[i3] = createInputPseudo(i3);
            }
            for (i3 in { submit: true, reset: true }) {
              Expr.pseudos[i3] = createButtonPseudo(i3);
            }
            function setFilters() {
            }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();
            tokenize2 = Sizzle2.tokenize = function(selector, parseOnly) {
              var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
              if (cached) {
                return parseOnly ? 0 : cached.slice(0);
              }
              soFar = selector;
              groups = [];
              preFilters = Expr.preFilter;
              while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                  if (match) {
                    soFar = soFar.slice(match[0].length) || soFar;
                  }
                  groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    // Cast descendant combinators to space
                    type: match[0].replace(rtrim2, " ")
                  });
                  soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                  if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                    matched = match.shift();
                    tokens.push({
                      value: matched,
                      type,
                      matches: match
                    });
                    soFar = soFar.slice(matched.length);
                  }
                }
                if (!matched) {
                  break;
                }
              }
              return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : (
                // Cache the tokens
                tokenCache(selector, groups).slice(0)
              );
            };
            function toSelector(tokens) {
              var i4 = 0, len = tokens.length, selector = "";
              for (; i4 < len; i4++) {
                selector += tokens[i4].value;
              }
              return selector;
            }
            function addCombinator(matcher, combinator, base) {
              var dir2 = combinator.dir, skip2 = combinator.next, key = skip2 || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
              return combinator.first ? (
                // Check against closest ancestor/preceding element
                function(elem, context2, xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      return matcher(elem, context2, xml);
                    }
                  }
                  return false;
                }
              ) : (
                // Check against all ancestor/preceding elements
                function(elem, context2, xml) {
                  var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
                  if (xml) {
                    while (elem = elem[dir2]) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        if (matcher(elem, context2, xml)) {
                          return true;
                        }
                      }
                    }
                  } else {
                    while (elem = elem[dir2]) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                        if (skip2 && skip2 === elem.nodeName.toLowerCase()) {
                          elem = elem[dir2] || elem;
                        } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                          return newCache[2] = oldCache[2];
                        } else {
                          uniqueCache[key] = newCache;
                          if (newCache[2] = matcher(elem, context2, xml)) {
                            return true;
                          }
                        }
                      }
                    }
                  }
                  return false;
                }
              );
            }
            function elementMatcher(matchers) {
              return matchers.length > 1 ? function(elem, context2, xml) {
                var i4 = matchers.length;
                while (i4--) {
                  if (!matchers[i4](elem, context2, xml)) {
                    return false;
                  }
                }
                return true;
              } : matchers[0];
            }
            function multipleContexts(selector, contexts, results) {
              var i4 = 0, len = contexts.length;
              for (; i4 < len; i4++) {
                Sizzle2(selector, contexts[i4], results);
              }
              return results;
            }
            function condense(unmatched, map3, filter, context2, xml) {
              var elem, newUnmatched = [], i4 = 0, len = unmatched.length, mapped = map3 != null;
              for (; i4 < len; i4++) {
                if (elem = unmatched[i4]) {
                  if (!filter || filter(elem, context2, xml)) {
                    newUnmatched.push(elem);
                    if (mapped) {
                      map3.push(i4);
                    }
                  }
                }
              }
              return newUnmatched;
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
              if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
              }
              if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
              }
              return markFunction(function(seed, results, context2, xml) {
                var temp, i4, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                  selector || "*",
                  context2.nodeType ? [context2] : context2,
                  []
                ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context2, xml) : elems, matcherOut = matcher ? (
                  // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                  postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                    // ...intermediate processing is necessary
                    []
                  ) : (
                    // ...otherwise use results directly
                    results
                  )
                ) : matcherIn;
                if (matcher) {
                  matcher(matcherIn, matcherOut, context2, xml);
                }
                if (postFilter) {
                  temp = condense(matcherOut, postMap);
                  postFilter(temp, [], context2, xml);
                  i4 = temp.length;
                  while (i4--) {
                    if (elem = temp[i4]) {
                      matcherOut[postMap[i4]] = !(matcherIn[postMap[i4]] = elem);
                    }
                  }
                }
                if (seed) {
                  if (postFinder || preFilter) {
                    if (postFinder) {
                      temp = [];
                      i4 = matcherOut.length;
                      while (i4--) {
                        if (elem = matcherOut[i4]) {
                          temp.push(matcherIn[i4] = elem);
                        }
                      }
                      postFinder(null, matcherOut = [], temp, xml);
                    }
                    i4 = matcherOut.length;
                    while (i4--) {
                      if ((elem = matcherOut[i4]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i4]) > -1) {
                        seed[temp] = !(results[temp] = elem);
                      }
                    }
                  }
                } else {
                  matcherOut = condense(
                    matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                  );
                  if (postFinder) {
                    postFinder(null, results, matcherOut, xml);
                  } else {
                    push2.apply(results, matcherOut);
                  }
                }
              });
            }
            function matcherFromTokens(tokens) {
              var checkContext, matcher, j6, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i4 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
              }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf2(checkContext, elem) > -1;
              }, implicitRelative, true), matchers = [function(elem, context2, xml) {
                var ret = !leadingRelative && (xml || context2 !== outermostContext) || ((checkContext = context2).nodeType ? matchContext(elem, context2, xml) : matchAnyContext(elem, context2, xml));
                checkContext = null;
                return ret;
              }];
              for (; i4 < len; i4++) {
                if (matcher = Expr.relative[tokens[i4].type]) {
                  matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                  matcher = Expr.filter[tokens[i4].type].apply(null, tokens[i4].matches);
                  if (matcher[expando]) {
                    j6 = ++i4;
                    for (; j6 < len; j6++) {
                      if (Expr.relative[tokens[j6].type]) {
                        break;
                      }
                    }
                    return setMatcher(
                      i4 > 1 && elementMatcher(matchers),
                      i4 > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice(0, i4 - 1).concat({ value: tokens[i4 - 2].type === " " ? "*" : "" })
                      ).replace(rtrim2, "$1"),
                      matcher,
                      i4 < j6 && matcherFromTokens(tokens.slice(i4, j6)),
                      j6 < len && matcherFromTokens(tokens = tokens.slice(j6)),
                      j6 < len && toSelector(tokens)
                    );
                  }
                  matchers.push(matcher);
                }
              }
              return elementMatcher(matchers);
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
              var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context2, xml, results, outermost) {
                var elem, j6, matcher, matchedCount = 0, i4 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                if (outermost) {
                  outermostContext = context2 == document3 || context2 || outermost;
                }
                for (; i4 !== len && (elem = elems[i4]) != null; i4++) {
                  if (byElement && elem) {
                    j6 = 0;
                    if (!context2 && elem.ownerDocument != document3) {
                      setDocument(elem);
                      xml = !documentIsHTML;
                    }
                    while (matcher = elementMatchers[j6++]) {
                      if (matcher(elem, context2 || document3, xml)) {
                        results.push(elem);
                        break;
                      }
                    }
                    if (outermost) {
                      dirruns = dirrunsUnique;
                    }
                  }
                  if (bySet) {
                    if (elem = !matcher && elem) {
                      matchedCount--;
                    }
                    if (seed) {
                      unmatched.push(elem);
                    }
                  }
                }
                matchedCount += i4;
                if (bySet && i4 !== matchedCount) {
                  j6 = 0;
                  while (matcher = setMatchers[j6++]) {
                    matcher(unmatched, setMatched, context2, xml);
                  }
                  if (seed) {
                    if (matchedCount > 0) {
                      while (i4--) {
                        if (!(unmatched[i4] || setMatched[i4])) {
                          setMatched[i4] = pop.call(results);
                        }
                      }
                    }
                    setMatched = condense(setMatched);
                  }
                  push2.apply(results, setMatched);
                  if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                    Sizzle2.uniqueSort(results);
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                  outermostContext = contextBackup;
                }
                return unmatched;
              };
              return bySet ? markFunction(superMatcher) : superMatcher;
            }
            compile = Sizzle2.compile = function(selector, match) {
              var i4, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
              if (!cached) {
                if (!match) {
                  match = tokenize2(selector);
                }
                i4 = match.length;
                while (i4--) {
                  cached = matcherFromTokens(match[i4]);
                  if (cached[expando]) {
                    setMatchers.push(cached);
                  } else {
                    elementMatchers.push(cached);
                  }
                }
                cached = compilerCache(
                  selector,
                  matcherFromGroupMatchers(elementMatchers, setMatchers)
                );
                cached.selector = selector;
              }
              return cached;
            };
            select = Sizzle2.select = function(selector, context2, results, seed) {
              var i4, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize2(selector = compiled.selector || selector);
              results = results || [];
              if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context2.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                  context2 = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context2) || [])[0];
                  if (!context2) {
                    return results;
                  } else if (compiled) {
                    context2 = context2.parentNode;
                  }
                  selector = selector.slice(tokens.shift().value.length);
                }
                i4 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i4--) {
                  token = tokens[i4];
                  if (Expr.relative[type = token.type]) {
                    break;
                  }
                  if (find = Expr.find[type]) {
                    if (seed = find(
                      token.matches[0].replace(runescape, funescape),
                      rsibling.test(tokens[0].type) && testContext(context2.parentNode) || context2
                    )) {
                      tokens.splice(i4, 1);
                      selector = seed.length && toSelector(tokens);
                      if (!selector) {
                        push2.apply(results, seed);
                        return results;
                      }
                      break;
                    }
                  }
                }
              }
              (compiled || compile(selector, match))(
                seed,
                context2,
                !documentIsHTML,
                results,
                !context2 || rsibling.test(selector) && testContext(context2.parentNode) || context2
              );
              return results;
            };
            support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
            support2.detectDuplicates = !!hasDuplicate;
            setDocument();
            support2.sortDetached = assert(function(el) {
              return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
            });
            if (!assert(function(el) {
              el.innerHTML = "<a href='#'></a>";
              return el.firstChild.getAttribute("href") === "#";
            })) {
              addHandle("type|href|height|width", function(elem, name2, isXML2) {
                if (!isXML2) {
                  return elem.getAttribute(name2, name2.toLowerCase() === "type" ? 1 : 2);
                }
              });
            }
            if (!support2.attributes || !assert(function(el) {
              el.innerHTML = "<input/>";
              el.firstChild.setAttribute("value", "");
              return el.firstChild.getAttribute("value") === "";
            })) {
              addHandle("value", function(elem, _name, isXML2) {
                if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
                  return elem.defaultValue;
                }
              });
            }
            if (!assert(function(el) {
              return el.getAttribute("disabled") == null;
            })) {
              addHandle(booleans, function(elem, name2, isXML2) {
                var val;
                if (!isXML2) {
                  return elem[name2] === true ? name2.toLowerCase() : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
                }
              });
            }
            return Sizzle2;
          }(window2)
        );
        jQuery2.find = Sizzle;
        jQuery2.expr = Sizzle.selectors;
        jQuery2.expr[":"] = jQuery2.expr.pseudos;
        jQuery2.uniqueSort = jQuery2.unique = Sizzle.uniqueSort;
        jQuery2.text = Sizzle.getText;
        jQuery2.isXMLDoc = Sizzle.isXML;
        jQuery2.contains = Sizzle.contains;
        jQuery2.escapeSelector = Sizzle.escape;
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery2(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n3, elem) {
          var matched = [];
          for (; n3; n3 = n3.nextSibling) {
            if (n3.nodeType === 1 && n3 !== elem) {
              matched.push(n3);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery2.expr.match.needsContext;
        function nodeName(elem, name2) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name2.toLowerCase();
        }
        ;
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements2, qualifier, not) {
          if (isFunction2(qualifier)) {
            return jQuery2.grep(elements2, function(elem, i3) {
              return !!qualifier.call(elem, i3, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery2.grep(elements2, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery2.grep(elements2, function(elem) {
              return indexOf.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery2.filter(qualifier, elements2, not);
        }
        jQuery2.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery2.fn.extend({
          find: function(selector) {
            var i3, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery2(selector).filter(function() {
                for (i3 = 0; i3 < len; i3++) {
                  if (jQuery2.contains(self2[i3], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i3 = 0; i3 < len; i3++) {
              jQuery2.find(selector, self2[i3], ret);
            }
            return len > 1 ? jQuery2.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init2 = jQuery2.fn.init = function(selector, context2, root) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context2)) {
              if (match[1]) {
                context2 = context2 instanceof jQuery2 ? context2[0] : context2;
                jQuery2.merge(this, jQuery2.parseHTML(
                  match[1],
                  context2 && context2.nodeType ? context2.ownerDocument || context2 : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context2)) {
                  for (match in context2) {
                    if (isFunction2(this[match])) {
                      this[match](context2[match]);
                    } else {
                      this.attr(match, context2[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context2 || context2.jquery) {
              return (context2 || root).find(selector);
            } else {
              return this.constructor(context2).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction2(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : (
              // Execute immediately if ready is not present
              selector(jQuery2)
            );
          }
          return jQuery2.makeArray(selector, this);
        };
        init2.prototype = jQuery2.fn;
        rootjQuery = jQuery2(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery2.fn.extend({
          has: function(target) {
            var targets = jQuery2(target, this), l5 = targets.length;
            return this.filter(function() {
              var i3 = 0;
              for (; i3 < l5; i3++) {
                if (jQuery2.contains(this, targets[i3])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context2) {
            var cur, i3 = 0, l5 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i3 < l5; i3++) {
                for (cur = this[i3]; cur && cur !== context2; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                    // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
                  ))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
          },
          // Determine the position of an element within the set
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf.call(jQuery2(elem), this[0]);
            }
            return indexOf.call(
              this,
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context2) {
            return this.pushStack(
              jQuery2.uniqueSort(
                jQuery2.merge(this.get(), jQuery2(selector, context2))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery2.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i2, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i2, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i2, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery2.merge([], elem.childNodes);
          }
        }, function(name2, fn3) {
          jQuery2.fn[name2] = function(until, selector) {
            var matched = jQuery2.map(this, fn3, until);
            if (name2.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery2.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name2]) {
                jQuery2.uniqueSort(matched);
              }
              if (rparentsprev.test(name2)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options) {
          var object = {};
          jQuery2.each(options.match(rnothtmlwhite) || [], function(_26, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery2.Callbacks = function(options) {
          options = typeof options === "string" ? createOptions(options) : jQuery2.extend({}, options);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add3(args) {
                  jQuery2.each(args, function(_26, arg) {
                    if (isFunction2(arg)) {
                      if (!options.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add3(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            // Remove a callback from the list
            remove: function() {
              jQuery2.each(arguments, function(_26, arg) {
                var index2;
                while ((index2 = jQuery2.inArray(arg, list, index2)) > -1) {
                  list.splice(index2, 1);
                  if (index2 <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn3) {
              return fn3 ? jQuery2.inArray(fn3, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context2, args) {
              if (!locked) {
                args = args || [];
                args = [context2, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v4) {
          return v4;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve2, reject, noValue) {
          var method;
          try {
            if (value && isFunction2(method = value.promise)) {
              method.call(value).done(resolve2).fail(reject);
            } else if (value && isFunction2(method = value.then)) {
              method.call(value, resolve2, reject);
            } else {
              resolve2.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery2.extend({
          Deferred: function(func) {
            var tuples = [
              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [
                "notify",
                "progress",
                jQuery2.Callbacks("memory"),
                jQuery2.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery2.Callbacks("once memory"),
                jQuery2.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery2.Callbacks("once memory"),
                jQuery2.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn3) {
                return promise.then(null, fn3);
              },
              // Keep pipe for back-compat
              pipe: function() {
                var fns = arguments;
                return jQuery2.Deferred(function(newDefer) {
                  jQuery2.each(tuples, function(_i2, tuple) {
                    var fn3 = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn3 && fn3.apply(this, arguments);
                      if (returned && isFunction2(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn3 ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve2(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction2(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve2(maxDepth, deferred2, Identity, special),
                            resolve2(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve2(maxDepth, deferred2, Identity, special),
                            resolve2(maxDepth, deferred2, Thrower, special),
                            resolve2(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process2 = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e2) {
                        if (jQuery2.Deferred.exceptionHook) {
                          jQuery2.Deferred.exceptionHook(
                            e2,
                            process2.stackTrace
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e2];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process2();
                    } else {
                      if (jQuery2.Deferred.getStackHook) {
                        process2.stackTrace = jQuery2.Deferred.getStackHook();
                      }
                      window2.setTimeout(process2);
                    }
                  };
                }
                return jQuery2.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve2(
                      0,
                      newDefer,
                      isFunction2(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve2(
                      0,
                      newDefer,
                      isFunction2(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve2(
                      0,
                      newDefer,
                      isFunction2(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function(obj) {
                return obj != null ? jQuery2.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery2.each(tuples, function(i3, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  // rejected_callbacks.disable
                  // fulfilled_callbacks.disable
                  tuples[3 - i3][2].disable,
                  // rejected_handlers.disable
                  // fulfilled_handlers.disable
                  tuples[3 - i3][3].disable,
                  // progress_callbacks.lock
                  tuples[0][2].lock,
                  // progress_handlers.lock
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          // Deferred helper
          when: function(singleValue) {
            var remaining = arguments.length, i3 = remaining, resolveContexts = Array(i3), resolveValues = slice.call(arguments), master = jQuery2.Deferred(), updateFunc = function(i4) {
              return function(value) {
                resolveContexts[i4] = this;
                resolveValues[i4] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  master.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                master.done(updateFunc(i3)).resolve,
                master.reject,
                !remaining
              );
              if (master.state() === "pending" || isFunction2(resolveValues[i3] && resolveValues[i3].then)) {
                return master.then();
              }
            }
            while (i3--) {
              adoptValue(resolveValues[i3], updateFunc(i3), master.reject);
            }
            return master.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery2.Deferred.exceptionHook = function(error3, stack) {
          if (window2.console && window2.console.warn && error3 && rerrorNames.test(error3.name)) {
            window2.console.warn("jQuery.Deferred exception: " + error3.message, error3.stack, stack);
          }
        };
        jQuery2.readyException = function(error3) {
          window2.setTimeout(function() {
            throw error3;
          });
        };
        var readyList = jQuery2.Deferred();
        jQuery2.fn.ready = function(fn3) {
          readyList.then(fn3).catch(function(error3) {
            jQuery2.readyException(error3);
          });
          return this;
        };
        jQuery2.extend({
          // Is the DOM ready to be used? Set to true once it occurs.
          isReady: false,
          // A counter to track how many items to wait for before
          // the ready event fires. See #6781
          readyWait: 1,
          // Handle when the DOM is ready
          ready: function(wait3) {
            if (wait3 === true ? --jQuery2.readyWait : jQuery2.isReady) {
              return;
            }
            jQuery2.isReady = true;
            if (wait3 !== true && --jQuery2.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery2]);
          }
        });
        jQuery2.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery2.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery2.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn3, key, value, chainable, emptyGet, raw) {
          var i3 = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i3 in key) {
              access(elems, fn3, i3, key[i3], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction2(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn3.call(elems, value);
                fn3 = null;
              } else {
                bulk = fn3;
                fn3 = function(elem, _key, value2) {
                  return bulk.call(jQuery2(elem), value2);
                };
              }
            }
            if (fn3) {
              for (; i3 < len; i3++) {
                fn3(
                  elems[i3],
                  key,
                  raw ? value : value.call(elems[i3], i3, fn3(elems[i3], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn3.call(elems);
          }
          return len ? fn3(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery2.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache2 = this.cache(owner);
            if (typeof data === "string") {
              cache2[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache2[camelCase(prop)] = data[prop];
              }
            }
            return cache2;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : (
              // Always use camelCase key (gh-2257)
              owner[this.expando] && owner[this.expando][camelCase(key)]
            );
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i3, cache2 = owner[this.expando];
            if (cache2 === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
              }
              i3 = key.length;
              while (i3--) {
                delete cache2[key[i3]];
              }
            }
            if (key === void 0 || jQuery2.isEmptyObject(cache2)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache2 = owner[this.expando];
            return cache2 !== void 0 && !jQuery2.isEmptyObject(cache2);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name2;
          if (data === void 0 && elem.nodeType === 1) {
            name2 = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name2);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e2) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery2.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name2, data) {
            return dataUser.access(elem, name2, data);
          },
          removeData: function(elem, name2) {
            dataUser.remove(elem, name2);
          },
          // TODO: Now that all calls to _data and _removeData have been replaced
          // with direct calls to dataPriv methods, these can be deprecated.
          _data: function(elem, name2, data) {
            return dataPriv.access(elem, name2, data);
          },
          _removeData: function(elem, name2) {
            dataPriv.remove(elem, name2);
          }
        });
        jQuery2.fn.extend({
          data: function(key, value) {
            var i3, name2, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i3 = attrs.length;
                  while (i3--) {
                    if (attrs[i3]) {
                      name2 = attrs[i3].name;
                      if (name2.indexOf("data-") === 0) {
                        name2 = camelCase(name2.slice(5));
                        dataAttr(elem, name2, data[name2]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery2.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery2.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery2.queue(elem, type), startLength = queue.length, fn3 = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
              jQuery2.dequeue(elem, type);
            };
            if (fn3 === "inprogress") {
              fn3 = queue.shift();
              startLength--;
            }
            if (fn3) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn3.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          // Not public - generate a queueHooks object, or return the current one
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery2.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery2.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery2.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery2.queue(this, type, data);
              jQuery2._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery2.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery2.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          // Get a promise resolved when queues of a certain type
          // are emptied (fx is the type by default)
          promise: function(type, obj) {
            var tmp, count = 1, defer2 = jQuery2.Deferred(), elements2 = this, i3 = this.length, resolve2 = function() {
              if (!--count) {
                defer2.resolveWith(elements2, [elements2]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i3--) {
              tmp = dataPriv.get(elements2[i3], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve2);
              }
            }
            resolve2();
            return defer2.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery2.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
          // Support: Firefox <=43 - 45
          // Disconnected elements can have computed display: none, so first confirm that elem is
          // in the document.
          isAttached(elem) && jQuery2.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery2.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery2.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery2.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc2 = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc2.body.appendChild(doc2.createElement(nodeName2));
          display = jQuery2.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements2, show) {
          var display, elem, values = [], index2 = 0, length = elements2.length;
          for (; index2 < length; index2++) {
            elem = elements2[index2];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index2] = dataPriv.get(elem, "display") || null;
                if (!values[index2]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index2] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index2] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index2 = 0; index2 < length; index2++) {
            if (values[index2] != null) {
              elements2[index2].style.display = values[index2];
            }
          }
          return elements2;
        }
        jQuery2.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery2(this).show();
              } else {
                jQuery2(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div2 = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div2.appendChild(input);
          support.checkClone = div2.cloneNode(true).cloneNode(true).lastChild.checked;
          div2.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div2.cloneNode(true).lastChild.defaultValue;
          div2.innerHTML = "<option></option>";
          support.option = !!div2.lastChild;
        })();
        var wrapMap = {
          // XHTML parsers do not magically insert elements in the
          // same way that tag soup parsers do. So we cannot shorten
          // this by omitting <tbody> or other required elements.
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context2, tag) {
          var ret;
          if (typeof context2.getElementsByTagName !== "undefined") {
            ret = context2.getElementsByTagName(tag || "*");
          } else if (typeof context2.querySelectorAll !== "undefined") {
            ret = context2.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context2, tag)) {
            return jQuery2.merge([context2], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i3 = 0, l5 = elems.length;
          for (; i3 < l5; i3++) {
            dataPriv.set(
              elems[i3],
              "globalEval",
              !refElements || dataPriv.get(refElements[i3], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context2, scripts2, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j6, fragment = context2.createDocumentFragment(), nodes = [], i3 = 0, l5 = elems.length;
          for (; i3 < l5; i3++) {
            elem = elems[i3];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context2.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context2.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery2.htmlPrefilter(elem) + wrap[2];
                j6 = wrap[0];
                while (j6--) {
                  tmp = tmp.lastChild;
                }
                jQuery2.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i3 = 0;
          while (elem = nodes[i3++]) {
            if (selection && jQuery2.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts2) {
              j6 = 0;
              while (elem = tmp[j6++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts2.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function expectSync(elem, type) {
          return elem === safeActiveElement() === (type === "focus");
        }
        function safeActiveElement() {
          try {
            return document2.activeElement;
          } catch (err) {
          }
        }
        function on2(elem, types, selector, data, fn3, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on2(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn3 == null) {
            fn3 = selector;
            data = selector = void 0;
          } else if (fn3 == null) {
            if (typeof selector === "string") {
              fn3 = data;
              data = void 0;
            } else {
              fn3 = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn3 === false) {
            fn3 = returnFalse;
          } else if (!fn3) {
            return elem;
          }
          if (one === 1) {
            origFn = fn3;
            fn3 = function(event2) {
              jQuery2().off(event2);
              return origFn.apply(this, arguments);
            };
            fn3.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
          }
          return elem.each(function() {
            jQuery2.event.add(this, types, fn3, data, selector);
          });
        }
        jQuery2.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t4, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery2.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery2.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e2) {
                return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e2.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t4 = types.length;
            while (t4--) {
              tmp = rtypenamespace.exec(types[t4]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery2.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery2.event.special[type] || {};
              handleObj = jQuery2.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery2.event.global[type] = true;
            }
          },
          // Detach an event or set of events from an element
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j6, origCount, tmp, events, t4, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t4 = types.length;
            while (t4--) {
              tmp = rtypenamespace.exec(types[t4]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery2.event.remove(elem, type + types[t4], handler, selector, true);
                }
                continue;
              }
              special = jQuery2.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j6 = handlers.length;
              while (j6--) {
                handleObj = handlers[j6];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j6, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery2.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery2.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i3, j6, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event2 = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event2.type] || [], special = jQuery2.event.special[event2.type] || {};
            args[0] = event2;
            for (i3 = 1; i3 < arguments.length; i3++) {
              args[i3] = arguments[i3];
            }
            event2.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event2) === false) {
              return;
            }
            handlerQueue = jQuery2.event.handlers.call(this, event2, handlers);
            i3 = 0;
            while ((matched = handlerQueue[i3++]) && !event2.isPropagationStopped()) {
              event2.currentTarget = matched.elem;
              j6 = 0;
              while ((handleObj = matched.handlers[j6++]) && !event2.isImmediatePropagationStopped()) {
                if (!event2.rnamespace || handleObj.namespace === false || event2.rnamespace.test(handleObj.namespace)) {
                  event2.handleObj = handleObj;
                  event2.data = handleObj.data;
                  ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event2.result = ret) === false) {
                      event2.preventDefault();
                      event2.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event2);
            }
            return event2.result;
          },
          handlers: function(event2, handlers) {
            var i3, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event2.target;
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event2.type === "click" && event2.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event2.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i3 = 0; i3 < delegateCount; i3++) {
                    handleObj = handlers[i3];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name2, hook) {
            Object.defineProperty(jQuery2.Event.prototype, name2, {
              enumerable: true,
              configurable: true,
              get: isFunction2(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name2];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name2, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
          },
          special: {
            load: {
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
            },
            click: {
              // Utilize native event to ensure correct state for checkable inputs
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", returnTrue);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              // For cross-browser consistency, suppress native .click() on links
              // Also prevent it if we're currently inside a leveraged native-event stack
              _default: function(event2) {
                var target = event2.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event2) {
                if (event2.result !== void 0 && event2.originalEvent) {
                  event2.originalEvent.returnValue = event2.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, expectSync2) {
          if (!expectSync2) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery2.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery2.event.add(el, type, {
            namespace: false,
            handler: function(event2) {
              var notAsync, result, saved = dataPriv.get(this, type);
              if (event2.isTrigger & 1 && this[type]) {
                if (!saved.length) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  notAsync = expectSync2(this, type);
                  this[type]();
                  result = dataPriv.get(this, type);
                  if (saved !== result || notAsync) {
                    dataPriv.set(this, type, false);
                  } else {
                    result = {};
                  }
                  if (saved !== result) {
                    event2.stopImmediatePropagation();
                    event2.preventDefault();
                    return result.value;
                  }
                } else if ((jQuery2.event.special[type] || {}).delegateType) {
                  event2.stopPropagation();
                }
              } else if (saved.length) {
                dataPriv.set(this, type, {
                  value: jQuery2.event.trigger(
                    // Support: IE <=9 - 11+
                    // Extend with the prototype to reset the above stopImmediatePropagation()
                    jQuery2.extend(saved[0], jQuery2.Event.prototype),
                    saved.slice(1),
                    this
                  )
                });
                event2.stopImmediatePropagation();
              }
            }
          });
        }
        jQuery2.removeEvent = function(elem, type, handle2) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle2);
          }
        };
        jQuery2.Event = function(src, props) {
          if (!(this instanceof jQuery2.Event)) {
            return new jQuery2.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery2.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery2.expando] = true;
        };
        jQuery2.Event.prototype = {
          constructor: jQuery2.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e2 = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.preventDefault();
            }
          },
          stopPropagation: function() {
            var e2 = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e2 = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery2.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: function(event2) {
            var button = event2.button;
            if (event2.which == null && rkeyEvent.test(event2.type)) {
              return event2.charCode != null ? event2.charCode : event2.keyCode;
            }
            if (!event2.which && button !== void 0 && rmouseEvent.test(event2.type)) {
              if (button & 1) {
                return 1;
              }
              if (button & 2) {
                return 3;
              }
              if (button & 4) {
                return 2;
              }
              return 0;
            }
            return event2.which;
          }
        }, jQuery2.event.addProp);
        jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          jQuery2.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
              leverageNative(this, type, expectSync);
              return false;
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            delegateType
          };
        });
        jQuery2.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery2.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event2) {
              var ret, target = this, related = event2.relatedTarget, handleObj = event2.handleObj;
              if (!related || related !== target && !jQuery2.contains(target, related)) {
                event2.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event2.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery2.fn.extend({
          on: function(types, selector, data, fn3) {
            return on2(this, types, selector, data, fn3);
          },
          one: function(types, selector, data, fn3) {
            return on2(this, types, selector, data, fn3, 1);
          },
          off: function(types, selector, fn3) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery2(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn3 = selector;
              selector = void 0;
            }
            if (fn3 === false) {
              fn3 = returnFalse;
            }
            return this.each(function() {
              jQuery2.event.remove(this, types, fn3, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery2(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i3, l5, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i3 = 0, l5 = events[type].length; i3 < l5; i3++) {
                  jQuery2.event.add(dest, type, events[type][i3]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery2.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback2, ignored) {
          args = flat(args);
          var fragment, first, scripts2, hasScripts, node, doc2, i3 = 0, l5 = collection.length, iNoClone = l5 - 1, value = args[0], valueIsFunction = isFunction2(value);
          if (valueIsFunction || l5 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index2) {
              var self2 = collection.eq(index2);
              if (valueIsFunction) {
                args[0] = value.call(this, index2, self2.html());
              }
              domManip(self2, args, callback2, ignored);
            });
          }
          if (l5) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts2 = jQuery2.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts2.length;
              for (; i3 < l5; i3++) {
                node = fragment;
                if (i3 !== iNoClone) {
                  node = jQuery2.clone(node, true, true);
                  if (hasScripts) {
                    jQuery2.merge(scripts2, getAll(node, "script"));
                  }
                }
                callback2.call(collection[i3], node, i3);
              }
              if (hasScripts) {
                doc2 = scripts2[scripts2.length - 1].ownerDocument;
                jQuery2.map(scripts2, restoreScript);
                for (i3 = 0; i3 < hasScripts; i3++) {
                  node = scripts2[i3];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc2, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery2._evalUrl && !node.noModule) {
                        jQuery2._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc2);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc2);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove2(elem, selector, keepData) {
          var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i3 = 0;
          for (; (node = nodes[i3]) != null; i3++) {
            if (!keepData && node.nodeType === 1) {
              jQuery2.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery2.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i3, l5, srcElements, destElements, clone2 = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
              destElements = getAll(clone2);
              srcElements = getAll(elem);
              for (i3 = 0, l5 = srcElements.length; i3 < l5; i3++) {
                fixInput(srcElements[i3], destElements[i3]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone2);
                for (i3 = 0, l5 = srcElements.length; i3 < l5; i3++) {
                  cloneCopyEvent(srcElements[i3], destElements[i3]);
                }
              } else {
                cloneCopyEvent(elem, clone2);
              }
            }
            destElements = getAll(clone2, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone2;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery2.event.special, i3 = 0;
            for (; (elem = elems[i3]) !== void 0; i3++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery2.event.remove(elem, type);
                      } else {
                        jQuery2.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery2.fn.extend({
          detach: function(selector) {
            return remove2(this, selector, true);
          },
          remove: function(selector) {
            return remove2(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i3 = 0;
            for (; (elem = this[i3]) != null; i3++) {
              if (elem.nodeType === 1) {
                jQuery2.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i3 = 0, l5 = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery2.htmlPrefilter(value2);
                try {
                  for (; i3 < l5; i3++) {
                    elem = this[i3] || {};
                    if (elem.nodeType === 1) {
                      jQuery2.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e2) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery2.inArray(this, ignored) < 0) {
                jQuery2.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery2.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name2, original) {
          jQuery2.fn[name2] = function(selector) {
            var elems, ret = [], insert = jQuery2(selector), last = insert.length - 1, i3 = 0;
            for (; i3 <= last; i3++) {
              elems = i3 === last ? this : this.clone(true);
              jQuery2(insert[i3])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap2 = function(elem, options, callback2) {
          var ret, name2, old = {};
          for (name2 in options) {
            old[name2] = elem.style[name2];
            elem.style[name2] = options[name2];
          }
          ret = callback2.call(elem);
          for (name2 in options) {
            elem.style[name2] = old[name2];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div2) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div2.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div2);
            var divStyle = window2.getComputedStyle(div2);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div2.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div2.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div2.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div2 = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div2 = document2.createElement("div");
          if (!div2.style) {
            return;
          }
          div2.style.backgroundClip = "content-box";
          div2.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div2.style.backgroundClip === "content-box";
          jQuery2.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            reliableTrDimensions: function() {
              var table, tr2, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr2 = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px";
                tr2.style.height = "1px";
                trChild.style.height = "9px";
                documentElement.appendChild(table).appendChild(tr2).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr2);
                reliableTrDimensionsVal = parseInt(trStyle.height) > 3;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name2, computed) {
          var width, minWidth, maxWidth, ret, style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name2) || computed[name2];
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery2.style(elem, name2);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name2)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? (
            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + ""
          ) : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name2) {
          var capName = name2[0].toUpperCase() + name2.slice(1), i3 = cssPrefixes.length;
          while (i3--) {
            name2 = cssPrefixes[i3] + capName;
            if (name2 in emptyStyle) {
              return name2;
            }
          }
        }
        function finalPropName(name2) {
          var final = jQuery2.cssProps[name2] || vendorProps[name2];
          if (final) {
            return final;
          }
          if (name2 in emptyStyle) {
            return name2;
          }
          return vendorProps[name2] = vendorPropName(name2) || name2;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? (
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
          ) : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i3 = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i3 < 4; i3 += 2) {
            if (box === "margin") {
              delta += jQuery2.css(elem, box + cssExpand[i3], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery2.css(elem, "padding" + cssExpand[i3], true, styles);
              if (box !== "padding") {
                delta += jQuery2.css(elem, "border" + cssExpand[i3] + "Width", true, styles);
              } else {
                extra += jQuery2.css(elem, "border" + cssExpand[i3] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery2.css(elem, "padding" + cssExpand[i3], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery2.css(elem, "border" + cssExpand[i3] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
              // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
              // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
          }
          return delta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Interestingly, in some cases IE 9 doesn't suffer from this issue.
          !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
          // This happens for inline elements with no explicit setting (gh-3571)
          val === "auto" || // Support: Android <=4.1 - 4.3 only
          // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
          !parseFloat(val) && jQuery2.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
          elem.getClientRects().length) {
            isBorderBox = jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          ) + "px";
        }
        jQuery2.extend({
          // Add in style property hooks for overriding the default
          // behavior of getting and setting a style property
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          // Don't automatically add "px" to these possibly-unitless properties
          cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
          },
          // Add in properties whose names you wish to fix before
          // setting or getting the value
          cssProps: {},
          // Get and set the style property on a DOM Node
          style: function(elem, name2, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2), style = elem.style;
            if (!isCustomProp) {
              name2 = finalPropName(origName);
            }
            hooks = jQuery2.cssHooks[name2] || jQuery2.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name2, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name2.indexOf("background") === 0) {
                style[name2] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name2, value);
                } else {
                  style[name2] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name2];
            }
          },
          css: function(elem, name2, extra, styles) {
            var val, num, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2);
            if (!isCustomProp) {
              name2 = finalPropName(origName);
            }
            hooks = jQuery2.cssHooks[name2] || jQuery2.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name2, styles);
            }
            if (val === "normal" && name2 in cssNormalTransform) {
              val = cssNormalTransform[name2];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery2.each(["height", "width"], function(_i2, dimension) {
          jQuery2.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap2(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery2.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery2.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap2(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery2.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix2, suffix) {
          jQuery2.cssHooks[prefix2 + suffix] = {
            expand: function(value) {
              var i3 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i3 < 4; i3++) {
                expanded[prefix2 + cssExpand[i3] + suffix] = parts[i3] || parts[i3 - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix2 !== "margin") {
            jQuery2.cssHooks[prefix2 + suffix].set = setPositiveNumber;
          }
        });
        jQuery2.fn.extend({
          css: function(name2, value) {
            return access(this, function(elem, name3, value2) {
              var styles, len, map3 = {}, i3 = 0;
              if (Array.isArray(name3)) {
                styles = getStyles(elem);
                len = name3.length;
                for (; i3 < len; i3++) {
                  map3[name3[i3]] = jQuery2.css(elem, name3[i3], false, styles);
                }
                return map3;
              }
              return value2 !== void 0 ? jQuery2.style(elem, name3, value2) : jQuery2.css(elem, name3);
            }, name2, value, arguments.length > 1);
          }
        });
        function Tween(elem, options, prop, end2, easing) {
          return new Tween.prototype.init(elem, options, prop, end2, easing);
        }
        jQuery2.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options, prop, end2, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery2.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end2;
            this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery2.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery2.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery2.fx.step[tween.prop]) {
                jQuery2.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery2.easing = {
          linear: function(p4) {
            return p4;
          },
          swing: function(p4) {
            return 0.5 - Math.cos(p4 * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery2.fx = Tween.prototype.init;
        jQuery2.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery2.fx.interval);
            }
            jQuery2.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i3 = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i3 < 4; i3 += 2 - includeWidth) {
            which = cssExpand[i3];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation3.tweeners[prop] || []).concat(Animation3.tweeners["*"]), index2 = 0, length = collection.length;
          for (; index2 < length; index2++) {
            if (tween = collection[index2].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery2._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery2.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
            }
          }
          propTween = !jQuery2.isEmptyObject(props);
          if (!propTween && jQuery2.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery2.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery2.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery2.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery2.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index2, name2, easing, value, hooks;
          for (index2 in props) {
            name2 = camelCase(index2);
            easing = specialEasing[name2];
            value = props[index2];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index2] = value[0];
            }
            if (index2 !== name2) {
              props[name2] = value;
              delete props[index2];
            }
            hooks = jQuery2.cssHooks[name2];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name2];
              for (index2 in value) {
                if (!(index2 in props)) {
                  props[index2] = value[index2];
                  specialEasing[index2] = easing;
                }
              }
            } else {
              specialEasing[name2] = easing;
            }
          }
        }
        function Animation3(elem, properties, options) {
          var result, stopped, index2 = 0, length = Animation3.prefilters.length, deferred = jQuery2.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index3 = 0, length2 = animation.tweens.length;
            for (; index3 < length2; index3++) {
              animation.tweens[index3].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery2.extend({}, properties),
            opts: jQuery2.extend(true, {
              specialEasing: {},
              easing: jQuery2.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end2) {
              var tween = jQuery2.Tween(
                elem,
                animation.opts,
                prop,
                end2,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index3 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index3 < length2; index3++) {
                animation.tweens[index3].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index2 < length; index2++) {
            result = Animation3.prefilters[index2].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction2(result.stop)) {
                jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery2.map(props, createTween, animation);
          if (isFunction2(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery2.fx.timer(
            jQuery2.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery2.Animation = jQuery2.extend(Animation3, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback2) {
            if (isFunction2(props)) {
              callback2 = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index2 = 0, length = props.length;
            for (; index2 < length; index2++) {
              prop = props[index2];
              Animation3.tweeners[prop] = Animation3.tweeners[prop] || [];
              Animation3.tweeners[prop].unshift(callback2);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback2, prepend) {
            if (prepend) {
              Animation3.prefilters.unshift(callback2);
            } else {
              Animation3.prefilters.push(callback2);
            }
          }
        });
        jQuery2.speed = function(speed, easing, fn3) {
          var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
            complete: fn3 || !fn3 && easing || isFunction2(speed) && speed,
            duration: speed,
            easing: fn3 && easing || easing && !isFunction2(easing) && easing
          };
          if (jQuery2.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery2.fx.speeds) {
                opt.duration = jQuery2.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery2.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction2(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery2.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery2.fn.extend({
          fadeTo: function(speed, to3, easing, callback2) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to3 }, speed, easing, callback2);
          },
          animate: function(prop, speed, easing, callback2) {
            var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback2), doAnimation = function() {
              var anim = Animation3(this, jQuery2.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index2 = type != null && type + "queueHooks", timers = jQuery2.timers, data = dataPriv.get(this);
              if (index2) {
                if (data[index2] && data[index2].stop) {
                  stopQueue(data[index2]);
                }
              } else {
                for (index2 in data) {
                  if (data[index2] && data[index2].stop && rrun.test(index2)) {
                    stopQueue(data[index2]);
                  }
                }
              }
              for (index2 = timers.length; index2--; ) {
                if (timers[index2].elem === this && (type == null || timers[index2].queue === type)) {
                  timers[index2].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index2, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery2.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index2, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery2.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index2 = timers.length; index2--; ) {
                if (timers[index2].elem === this && timers[index2].queue === type) {
                  timers[index2].anim.stop(true);
                  timers.splice(index2, 1);
                }
              }
              for (index2 = 0; index2 < length; index2++) {
                if (queue[index2] && queue[index2].finish) {
                  queue[index2].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery2.each(["toggle", "show", "hide"], function(_i2, name2) {
          var cssFn = jQuery2.fn[name2];
          jQuery2.fn[name2] = function(speed, easing, callback2) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name2, true), speed, easing, callback2);
          };
        });
        jQuery2.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name2, props) {
          jQuery2.fn[name2] = function(speed, easing, callback2) {
            return this.animate(props, speed, easing, callback2);
          };
        });
        jQuery2.timers = [];
        jQuery2.fx.tick = function() {
          var timer, i3 = 0, timers = jQuery2.timers;
          fxNow = Date.now();
          for (; i3 < timers.length; i3++) {
            timer = timers[i3];
            if (!timer() && timers[i3] === timer) {
              timers.splice(i3--, 1);
            }
          }
          if (!timers.length) {
            jQuery2.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery2.fx.timer = function(timer) {
          jQuery2.timers.push(timer);
          jQuery2.fx.start();
        };
        jQuery2.fx.interval = 13;
        jQuery2.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery2.fx.stop = function() {
          inProgress = null;
        };
        jQuery2.fx.speeds = {
          slow: 600,
          fast: 200,
          // Default speed
          _default: 400
        };
        jQuery2.fn.delay = function(time, type) {
          time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery2.expr.attrHandle;
        jQuery2.fn.extend({
          attr: function(name2, value) {
            return access(this, jQuery2.attr, name2, value, arguments.length > 1);
          },
          removeAttr: function(name2) {
            return this.each(function() {
              jQuery2.removeAttr(this, name2);
            });
          }
        });
        jQuery2.extend({
          attr: function(elem, name2, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery2.prop(elem, name2, value);
            }
            if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
              hooks = jQuery2.attrHooks[name2.toLowerCase()] || (jQuery2.expr.match.bool.test(name2) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery2.removeAttr(elem, name2);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name2, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
              return ret;
            }
            ret = jQuery2.find.attr(elem, name2);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name2, i3 = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name2 = attrNames[i3++]) {
                elem.removeAttribute(name2);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name2) {
            if (value === false) {
              jQuery2.removeAttr(elem, name2);
            } else {
              elem.setAttribute(name2, name2);
            }
            return name2;
          }
        };
        jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i2, name2) {
          var getter = attrHandle[name2] || jQuery2.find.attr;
          attrHandle[name2] = function(elem, name3, isXML) {
            var ret, handle2, lowercaseName = name3.toLowerCase();
            if (!isXML) {
              handle2 = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name3, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle2;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery2.fn.extend({
          prop: function(name2, value) {
            return access(this, jQuery2.prop, name2, value, arguments.length > 1);
          },
          removeProp: function(name2) {
            return this.each(function() {
              delete this[jQuery2.propFix[name2] || name2];
            });
          }
        });
        jQuery2.extend({
          prop: function(elem, name2, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
              name2 = jQuery2.propFix[name2] || name2;
              hooks = jQuery2.propHooks[name2];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
                return ret;
              }
              return elem[name2] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
              return ret;
            }
            return elem[name2];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery2.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery2.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery2.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery2.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery2.fn.extend({
          addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j6, finalValue, i3 = 0;
            if (isFunction2(value)) {
              return this.each(function(j7) {
                jQuery2(this).addClass(value.call(this, j7, getClass(this)));
              });
            }
            classes = classesToArray(value);
            if (classes.length) {
              while (elem = this[i3++]) {
                curValue = getClass(elem);
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  j6 = 0;
                  while (clazz = classes[j6++]) {
                    if (cur.indexOf(" " + clazz + " ") < 0) {
                      cur += clazz + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    elem.setAttribute("class", finalValue);
                  }
                }
              }
            }
            return this;
          },
          removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j6, finalValue, i3 = 0;
            if (isFunction2(value)) {
              return this.each(function(j7) {
                jQuery2(this).removeClass(value.call(this, j7, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classes = classesToArray(value);
            if (classes.length) {
              while (elem = this[i3++]) {
                curValue = getClass(elem);
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  j6 = 0;
                  while (clazz = classes[j6++]) {
                    while (cur.indexOf(" " + clazz + " ") > -1) {
                      cur = cur.replace(" " + clazz + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    elem.setAttribute("class", finalValue);
                  }
                }
              }
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (isFunction2(value)) {
              return this.each(function(i3) {
                jQuery2(this).toggleClass(
                  value.call(this, i3, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            return this.each(function() {
              var className, i3, self2, classNames;
              if (isValidValue) {
                i3 = 0;
                self2 = jQuery2(this);
                classNames = classesToArray(value);
                while (className = classNames[i3++]) {
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i3 = 0;
            className = " " + selector + " ";
            while (elem = this[i3++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery2.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction2(value);
            return this.each(function(i3) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i3, jQuery2(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery2.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery2.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery2.find.attr(elem, "value");
                return val != null ? val : (
                  // Support: IE <=10 - 11 only
                  // option.text throws exceptions (#14686, #14858)
                  // Strip and collapse whitespace
                  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                  stripAndCollapse(jQuery2.text(elem))
                );
              }
            },
            select: {
              get: function(elem) {
                var value, option, i3, options = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max3 = one ? index2 + 1 : options.length;
                if (index2 < 0) {
                  i3 = max3;
                } else {
                  i3 = one ? index2 : 0;
                }
                for (; i3 < max3; i3++) {
                  option = options[i3];
                  if ((option.selected || i3 === index2) && // Don't return options that are disabled or in a disabled optgroup
                  !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery2(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options = elem.options, values = jQuery2.makeArray(value), i3 = options.length;
                while (i3--) {
                  option = options[i3];
                  if (option.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery2.each(["radio", "checkbox"], function() {
          jQuery2.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery2.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        support.focusin = "onfocusin" in window2;
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e2) {
          e2.stopPropagation();
        };
        jQuery2.extend(jQuery2.event, {
          trigger: function(event2, data, elem, onlyHandlers) {
            var i3, cur, tmp, bubbleType, ontype, handle2, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event2, "type") ? event2.type : event2, namespaces = hasOwn.call(event2, "namespace") ? event2.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery2.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event2 = event2[jQuery2.expando] ? event2 : new jQuery2.Event(type, typeof event2 === "object" && event2);
            event2.isTrigger = onlyHandlers ? 2 : 3;
            event2.namespace = namespaces.join(".");
            event2.rnamespace = event2.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event2.result = void 0;
            if (!event2.target) {
              event2.target = elem;
            }
            data = data == null ? [event2] : jQuery2.makeArray(data, [event2]);
            special = jQuery2.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i3 = 0;
            while ((cur = eventPath[i3++]) && !event2.isPropagationStopped()) {
              lastElement = cur;
              event2.type = i3 > 1 ? bubbleType : special.bindType || type;
              handle2 = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event2.type] && dataPriv.get(cur, "handle");
              if (handle2) {
                handle2.apply(cur, data);
              }
              handle2 = ontype && cur[ontype];
              if (handle2 && handle2.apply && acceptData(cur)) {
                event2.result = handle2.apply(cur, data);
                if (event2.result === false) {
                  event2.preventDefault();
                }
              }
            }
            event2.type = type;
            if (!onlyHandlers && !event2.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery2.event.triggered = type;
                  if (event2.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event2.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery2.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event2.result;
          },
          // Piggyback on a donor event to simulate a different one
          // Used only for `focus(in | out)` events
          simulate: function(type, elem, event2) {
            var e2 = jQuery2.extend(
              new jQuery2.Event(),
              event2,
              {
                type,
                isSimulated: true
              }
            );
            jQuery2.event.trigger(e2, null, elem);
          }
        });
        jQuery2.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery2.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery2.event.trigger(type, data, elem, true);
            }
          }
        });
        if (!support.focusin) {
          jQuery2.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
            var handler = function(event2) {
              jQuery2.event.simulate(fix, event2.target, jQuery2.event.fix(event2));
            };
            jQuery2.event.special[fix] = {
              setup: function() {
                var doc2 = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc2, fix);
                if (!attaches) {
                  doc2.addEventListener(orig, handler, true);
                }
                dataPriv.access(doc2, fix, (attaches || 0) + 1);
              },
              teardown: function() {
                var doc2 = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc2, fix) - 1;
                if (!attaches) {
                  doc2.removeEventListener(orig, handler, true);
                  dataPriv.remove(doc2, fix);
                } else {
                  dataPriv.access(doc2, fix, attaches);
                }
              }
            };
          });
        }
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery2.parseXML = function(data) {
          var xml;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e2) {
            xml = void 0;
          }
          if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery2.error("Invalid XML: " + data);
          }
          return xml;
        };
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix2, obj, traditional, add3) {
          var name2;
          if (Array.isArray(obj)) {
            jQuery2.each(obj, function(i3, v4) {
              if (traditional || rbracket.test(prefix2)) {
                add3(prefix2, v4);
              } else {
                buildParams(
                  prefix2 + "[" + (typeof v4 === "object" && v4 != null ? i3 : "") + "]",
                  v4,
                  traditional,
                  add3
                );
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name2 in obj) {
              buildParams(prefix2 + "[" + name2 + "]", obj[name2], traditional, add3);
            }
          } else {
            add3(prefix2, obj);
          }
        }
        jQuery2.param = function(a5, traditional) {
          var prefix2, s4 = [], add3 = function(key, valueOrFunction) {
            var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s4[s4.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a5 == null) {
            return "";
          }
          if (Array.isArray(a5) || a5.jquery && !jQuery2.isPlainObject(a5)) {
            jQuery2.each(a5, function() {
              add3(this.name, this.value);
            });
          } else {
            for (prefix2 in a5) {
              buildParams(prefix2, a5[prefix2], traditional, add3);
            }
          }
          return s4.join("&");
        };
        jQuery2.fn.extend({
          serialize: function() {
            return jQuery2.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements2 = jQuery2.prop(this, "elements");
              return elements2 ? jQuery2.makeArray(elements2) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i2, elem) {
              var val = jQuery2(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery2.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i3 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction2(func)) {
              while (dataType = dataTypes[i3++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery2.each(structure[dataType] || [], function(_26, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery2.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s4, jqXHR, responses) {
          var ct3, type, finalDataType, firstDataType, contents = s4.contents, dataTypes = s4.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct3 === void 0) {
              ct3 = s4.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct3) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct3)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s4.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s4, response2, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s4.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s4.converters) {
              converters[conv.toLowerCase()] = s4.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s4.responseFields[current]) {
              jqXHR[s4.responseFields[current]] = response2;
            }
            if (!prev && isSuccess && s4.dataFilter) {
              response2 = s4.dataFilter(response2, s4.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s4.throws) {
                    response2 = conv(response2);
                  } else {
                    try {
                      response2 = conv(response2);
                    } catch (e2) {
                      return {
                        state: "parsererror",
                        error: conv ? e2 : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response2 };
        }
        jQuery2.extend({
          // Counter for holding the number of active queries
          active: 0,
          // Last-Modified header cache for next request
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
              // Convert anything to text
              "* text": String,
              // Text to html (true = no transformation)
              "text html": true,
              // Evaluate text as a json expression
              "text json": JSON.parse,
              // Parse text as xml
              "text xml": jQuery2.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
              url: true,
              context: true
            }
          },
          // Creates a full fledged settings object into target
          // with both ajaxSettings and settings fields.
          // If target is omitted, writes into ajaxSettings.
          ajaxSetup: function(target, settings) {
            return settings ? (
              // Building a settings object
              ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings)
            ) : (
              // Extending ajaxSettings
              ajaxExtend(jQuery2.ajaxSettings, target)
            );
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          // Main method
          ajax: function(url, options) {
            if (typeof url === "object") {
              options = url;
              url = void 0;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i3, uncached, s4 = jQuery2.ajaxSetup({}, options), callbackContext = s4.context || s4, globalEventContext = s4.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s4.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              // Builds headers hashtable if needed
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              // Raw string
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              // Caches the header
              setRequestHeader: function(name2, value) {
                if (completed2 == null) {
                  name2 = requestHeadersNames[name2.toLowerCase()] = requestHeadersNames[name2.toLowerCase()] || name2;
                  requestHeaders[name2] = value;
                }
                return this;
              },
              // Overrides response content-type header
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s4.mimeType = type;
                }
                return this;
              },
              // Status-dependent callbacks
              statusCode: function(map3) {
                var code;
                if (map3) {
                  if (completed2) {
                    jqXHR.always(map3[jqXHR.status]);
                  } else {
                    for (code in map3) {
                      statusCode[code] = [statusCode[code], map3[code]];
                    }
                  }
                }
                return this;
              },
              // Cancel the request
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s4.url = ((url || s4.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s4.type = options.method || options.type || s4.method || s4.type;
            s4.dataTypes = (s4.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s4.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s4.url;
                urlAnchor.href = urlAnchor.href;
                s4.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e2) {
                s4.crossDomain = true;
              }
            }
            if (s4.data && s4.processData && typeof s4.data !== "string") {
              s4.data = jQuery2.param(s4.data, s4.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s4, options, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery2.event && s4.global;
            if (fireGlobals && jQuery2.active++ === 0) {
              jQuery2.event.trigger("ajaxStart");
            }
            s4.type = s4.type.toUpperCase();
            s4.hasContent = !rnoContent.test(s4.type);
            cacheURL = s4.url.replace(rhash, "");
            if (!s4.hasContent) {
              uncached = s4.url.slice(cacheURL.length);
              if (s4.data && (s4.processData || typeof s4.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s4.data;
                delete s4.data;
              }
              if (s4.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s4.url = cacheURL + uncached;
            } else if (s4.data && s4.processData && (s4.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s4.data = s4.data.replace(r20, "+");
            }
            if (s4.ifModified) {
              if (jQuery2.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
              }
              if (jQuery2.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
              }
            }
            if (s4.data && s4.hasContent && s4.contentType !== false || options.contentType) {
              jqXHR.setRequestHeader("Content-Type", s4.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s4.dataTypes[0] && s4.accepts[s4.dataTypes[0]] ? s4.accepts[s4.dataTypes[0]] + (s4.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s4.accepts["*"]
            );
            for (i3 in s4.headers) {
              jqXHR.setRequestHeader(i3, s4.headers[i3]);
            }
            if (s4.beforeSend && (s4.beforeSend.call(callbackContext, jqXHR, s4) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s4.complete);
            jqXHR.done(s4.success);
            jqXHR.fail(s4.error);
            transport = inspectPrefiltersOrTransports(transports, s4, options, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s4]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s4.async && s4.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s4.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e2) {
                if (completed2) {
                  throw e2;
                }
                done(-1, e2);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error3, response2, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response2 = ajaxHandleResponses(s4, jqXHR, responses);
              }
              if (!isSuccess && jQuery2.inArray("script", s4.dataTypes) > -1) {
                s4.converters["text script"] = function() {
                };
              }
              response2 = ajaxConvert(s4, response2, jqXHR, isSuccess);
              if (isSuccess) {
                if (s4.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery2.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery2.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s4.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response2.state;
                  success = response2.data;
                  error3 = response2.error;
                  isSuccess = !error3;
                }
              } else {
                error3 = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error3]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s4, isSuccess ? success : error3]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s4]);
                if (!--jQuery2.active) {
                  jQuery2.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback2) {
            return jQuery2.get(url, data, callback2, "json");
          },
          getScript: function(url, callback2) {
            return jQuery2.get(url, void 0, callback2, "script");
          }
        });
        jQuery2.each(["get", "post"], function(_i2, method) {
          jQuery2[method] = function(url, data, callback2, type) {
            if (isFunction2(data)) {
              type = type || callback2;
              callback2 = data;
              data = void 0;
            }
            return jQuery2.ajax(jQuery2.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback2
            }, jQuery2.isPlainObject(url) && url));
          };
        });
        jQuery2.ajaxPrefilter(function(s4) {
          var i3;
          for (i3 in s4.headers) {
            if (i3.toLowerCase() === "content-type") {
              s4.contentType = s4.headers[i3] || "";
            }
          }
        });
        jQuery2._evalUrl = function(url, options, doc2) {
          return jQuery2.ajax({
            url,
            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response2) {
              jQuery2.globalEval(response2, options, doc2);
            }
          });
        };
        jQuery2.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction2(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction2(html)) {
              return this.each(function(i3) {
                jQuery2(this).wrapInner(html.call(this, i3));
              });
            }
            return this.each(function() {
              var self2 = jQuery2(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction2(html);
            return this.each(function(i3) {
              jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i3) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery2(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery2.expr.pseudos.hidden = function(elem) {
          return !jQuery2.expr.pseudos.visible(elem);
        };
        jQuery2.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery2.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e2) {
          }
        };
        var xhrSuccessStatus = {
          // File protocol always yields status code 0, assume 200
          0: 200,
          // Support: IE <=9 only
          // #1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        }, xhrSupported = jQuery2.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery2.ajaxTransport(function(options) {
          var callback2, errorCallback;
          if (support.cors || xhrSupported && !options.crossDomain) {
            return {
              send: function(headers, complete) {
                var i3, xhr = options.xhr();
                xhr.open(
                  options.type,
                  options.url,
                  options.async,
                  options.username,
                  options.password
                );
                if (options.xhrFields) {
                  for (i3 in options.xhrFields) {
                    xhr[i3] = options.xhrFields[i3];
                  }
                }
                if (options.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options.mimeType);
                }
                if (!options.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i3 in headers) {
                  xhr.setRequestHeader(i3, headers[i3]);
                }
                callback2 = function(type) {
                  return function() {
                    if (callback2) {
                      callback2 = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            // File: protocol always yields status 0; see #8605, #14207
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          // Support: IE <=9 only
                          // IE9 has no XHR2 but throws on binary (trac-11426)
                          // For XHR2 non-text, let the caller handle it (gh-2498)
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback2();
                errorCallback = xhr.onerror = xhr.ontimeout = callback2("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback2) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback2 = callback2("abort");
                try {
                  xhr.send(options.hasContent && options.data || null);
                } catch (e2) {
                  if (callback2) {
                    throw e2;
                  }
                }
              },
              abort: function() {
                if (callback2) {
                  callback2();
                }
              }
            };
          }
        });
        jQuery2.ajaxPrefilter(function(s4) {
          if (s4.crossDomain) {
            s4.contents.script = false;
          }
        });
        jQuery2.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery2.globalEval(text);
              return text;
            }
          }
        });
        jQuery2.ajaxPrefilter("script", function(s4) {
          if (s4.cache === void 0) {
            s4.cache = false;
          }
          if (s4.crossDomain) {
            s4.type = "GET";
          }
        });
        jQuery2.ajaxTransport("script", function(s4) {
          if (s4.crossDomain || s4.scriptAttrs) {
            var script, callback2;
            return {
              send: function(_26, complete) {
                script = jQuery2("<script>").attr(s4.scriptAttrs || {}).prop({ charset: s4.scriptCharset, src: s4.url }).on("load error", callback2 = function(evt) {
                  script.remove();
                  callback2 = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback2) {
                  callback2();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery2.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback2 = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
            this[callback2] = true;
            return callback2;
          }
        });
        jQuery2.ajaxPrefilter("json jsonp", function(s4, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s4.jsonp !== false && (rjsonp.test(s4.url) ? "url" : typeof s4.data === "string" && (s4.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s4.data) && "data");
          if (jsonProp || s4.dataTypes[0] === "jsonp") {
            callbackName = s4.jsonpCallback = isFunction2(s4.jsonpCallback) ? s4.jsonpCallback() : s4.jsonpCallback;
            if (jsonProp) {
              s4[jsonProp] = s4[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s4.jsonp !== false) {
              s4.url += (rquery.test(s4.url) ? "&" : "?") + s4.jsonp + "=" + callbackName;
            }
            s4.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery2.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s4.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery2(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s4[callbackName]) {
                s4.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction2(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery2.parseHTML = function(data, context2, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context2 === "boolean") {
            keepScripts = context2;
            context2 = false;
          }
          var base, parsed, scripts2;
          if (!context2) {
            if (support.createHTMLDocument) {
              context2 = document2.implementation.createHTMLDocument("");
              base = context2.createElement("base");
              base.href = document2.location.href;
              context2.head.appendChild(base);
            } else {
              context2 = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts2 = !keepScripts && [];
          if (parsed) {
            return [context2.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context2, scripts2);
          if (scripts2 && scripts2.length) {
            jQuery2(scripts2).remove();
          }
          return jQuery2.merge([], parsed.childNodes);
        };
        jQuery2.fn.load = function(url, params, callback2) {
          var selector, type, response2, self2 = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction2(params)) {
            callback2 = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery2.ajax({
              url,
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response2 = arguments;
              self2.html(selector ? (
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
              ) : (
                // Otherwise use the full result
                responseText
              ));
            }).always(callback2 && function(jqXHR, status) {
              self2.each(function() {
                callback2.apply(this, response2 || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery2.expr.pseudos.animated = function(elem) {
          return jQuery2.grep(jQuery2.timers, function(fn3) {
            return elem === fn3.elem;
          }).length;
        };
        jQuery2.offset = {
          setOffset: function(elem, options, i3) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery2.css(elem, "top");
            curCSSLeft = jQuery2.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction2(options)) {
              options = options.call(elem, i3, jQuery2.extend({}, curOffset));
            }
            if (options.top != null) {
              props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
              props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
              options.using.call(elem, props);
            } else {
              if (typeof props.top === "number") {
                props.top += "px";
              }
              if (typeof props.left === "number") {
                props.left += "px";
              }
              curElem.css(props);
            }
          }
        };
        jQuery2.fn.extend({
          // offset() relates an element's border box to the document origin
          offset: function(options) {
            if (arguments.length) {
              return options === void 0 ? this : this.each(function(i3) {
                jQuery2.offset.setOffset(this, options, i3);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          // position() relates an element's margin box to its offset parent's padding box
          // This corresponds to the behavior of CSS absolute positioning
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset3, doc2, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery2.css(elem, "position") === "fixed") {
              offset3 = elem.getBoundingClientRect();
            } else {
              offset3 = this.offset();
              doc2 = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc2.documentElement;
              while (offsetParent && (offsetParent === doc2.body || offsetParent === doc2.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery2(offsetParent).offset();
                parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset3.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
              left: offset3.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
            };
          },
          // This method will return documentElement in the following cases:
          // 1) For the element inside the iframe without offsetParent, this method will return
          //    documentElement of the parent window
          // 2) For the hidden or detached element
          // 3) For body or html element, i.e. in case of the html node - it will return itself
          //
          // but those exceptions were never presented as a real life use-cases
          // and might be considered as more preferable results.
          //
          // This logic, however, is not guaranteed and can change at any point in the future
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top2 = "pageYOffset" === prop;
          jQuery2.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top2 ? val2 : win.pageXOffset,
                  top2 ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery2.each(["top", "left"], function(_i2, prop) {
          jQuery2.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery2.each({ Height: "height", Width: "width" }, function(name2, type) {
          jQuery2.each(
            { padding: "inner" + name2, content: type, "": "outer" + name2 },
            function(defaultExtra, funcName) {
              jQuery2.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type2, value2) {
                  var doc2;
                  if (isWindow(elem)) {
                    return funcName.indexOf("outer") === 0 ? elem["inner" + name2] : elem.document.documentElement["client" + name2];
                  }
                  if (elem.nodeType === 9) {
                    doc2 = elem.documentElement;
                    return Math.max(
                      elem.body["scroll" + name2],
                      doc2["scroll" + name2],
                      elem.body["offset" + name2],
                      doc2["offset" + name2],
                      doc2["client" + name2]
                    );
                  }
                  return value2 === void 0 ? (
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery2.css(elem, type2, extra)
                  ) : (
                    // Set width or height on the element
                    jQuery2.style(elem, type2, value2, extra)
                  );
                }, type, chainable ? margin : void 0, chainable);
              };
            }
          );
        });
        jQuery2.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i2, type) {
          jQuery2.fn[type] = function(fn3) {
            return this.on(type, fn3);
          };
        });
        jQuery2.fn.extend({
          bind: function(types, data, fn3) {
            return this.on(types, null, data, fn3);
          },
          unbind: function(types, fn3) {
            return this.off(types, null, fn3);
          },
          delegate: function(selector, types, data, fn3) {
            return this.on(types, selector, data, fn3);
          },
          undelegate: function(selector, types, fn3) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn3);
          },
          hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
          }
        });
        jQuery2.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i2, name2) {
            jQuery2.fn[name2] = function(data, fn3) {
              return arguments.length > 0 ? this.on(name2, null, data, fn3) : this.trigger(name2);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        jQuery2.proxy = function(fn3, context2) {
          var tmp, args, proxy;
          if (typeof context2 === "string") {
            tmp = fn3[context2];
            context2 = fn3;
            fn3 = tmp;
          }
          if (!isFunction2(fn3)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn3.apply(context2 || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn3.guid = fn3.guid || jQuery2.guid++;
          return proxy;
        };
        jQuery2.holdReady = function(hold) {
          if (hold) {
            jQuery2.readyWait++;
          } else {
            jQuery2.ready(true);
          }
        };
        jQuery2.isArray = Array.isArray;
        jQuery2.parseJSON = JSON.parse;
        jQuery2.nodeName = nodeName;
        jQuery2.isFunction = isFunction2;
        jQuery2.isWindow = isWindow;
        jQuery2.camelCase = camelCase;
        jQuery2.type = toType;
        jQuery2.now = Date.now;
        jQuery2.isNumeric = function(obj) {
          var type = jQuery2.type(obj);
          return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN(obj - parseFloat(obj));
        };
        jQuery2.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery2;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery2.noConflict = function(deep) {
          if (window2.$ === jQuery2) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery2) {
            window2.jQuery = _jQuery;
          }
          return jQuery2;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery2;
        }
        return jQuery2;
      });
    }
  });

  // app/javascript/jquery.js
  function defineJQuery(target) {
    if (typeof target !== "undefined" && target.$ === void 0) {
      target.$ = target.jQuery = target.jquery = import_jquery.default;
    }
  }
  var import_jquery;
  var init_jquery = __esm({
    "app/javascript/jquery.js"() {
      import_jquery = __toESM(require_jquery());
      if (typeof window !== "undefined") {
        defineJQuery(window);
      }
      if (typeof window !== "undefined") {
        defineJQuery(window);
      }
    }
  });

  // node_modules/@rails/ujs/lib/assets/compiled/rails-ujs.js
  var require_rails_ujs = __commonJS({
    "node_modules/@rails/ujs/lib/assets/compiled/rails-ujs.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function() {
        var context2 = this;
        (function() {
          (function() {
            this.Rails = {
              linkClickSelector: "a[data-confirm], a[data-method], a[data-remote]:not([disabled]), a[data-disable-with], a[data-disable]",
              buttonClickSelector: {
                selector: "button[data-remote]:not([form]), button[data-confirm]:not([form])",
                exclude: "form button"
              },
              inputChangeSelector: "select[data-remote], input[data-remote], textarea[data-remote]",
              formSubmitSelector: "form:not([data-turbo=true])",
              formInputClickSelector: "form:not([data-turbo=true]) input[type=submit], form:not([data-turbo=true]) input[type=image], form:not([data-turbo=true]) button[type=submit], form:not([data-turbo=true]) button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])",
              formDisableSelector: "input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled",
              formEnableSelector: "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled",
              fileInputSelector: "input[name][type=file]:not([disabled])",
              linkDisableSelector: "a[data-disable-with], a[data-disable]",
              buttonDisableSelector: "button[data-remote][data-disable-with], button[data-remote][data-disable]"
            };
          }).call(this);
        }).call(context2);
        var Rails3 = context2.Rails;
        (function() {
          (function() {
            var nonce;
            nonce = null;
            Rails3.loadCSPNonce = function() {
              var ref;
              return nonce = (ref = document.querySelector("meta[name=csp-nonce]")) != null ? ref.content : void 0;
            };
            Rails3.cspNonce = function() {
              return nonce != null ? nonce : Rails3.loadCSPNonce();
            };
          }).call(this);
          (function() {
            var expando, m4;
            m4 = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector;
            Rails3.matches = function(element, selector) {
              if (selector.exclude != null) {
                return m4.call(element, selector.selector) && !m4.call(element, selector.exclude);
              } else {
                return m4.call(element, selector);
              }
            };
            expando = "_ujsData";
            Rails3.getData = function(element, key) {
              var ref;
              return (ref = element[expando]) != null ? ref[key] : void 0;
            };
            Rails3.setData = function(element, key, value) {
              if (element[expando] == null) {
                element[expando] = {};
              }
              return element[expando][key] = value;
            };
            Rails3.$ = function(selector) {
              return Array.prototype.slice.call(document.querySelectorAll(selector));
            };
          }).call(this);
          (function() {
            var $7, csrfParam, csrfToken;
            $7 = Rails3.$;
            csrfToken = Rails3.csrfToken = function() {
              var meta;
              meta = document.querySelector("meta[name=csrf-token]");
              return meta && meta.content;
            };
            csrfParam = Rails3.csrfParam = function() {
              var meta;
              meta = document.querySelector("meta[name=csrf-param]");
              return meta && meta.content;
            };
            Rails3.CSRFProtection = function(xhr) {
              var token;
              token = csrfToken();
              if (token != null) {
                return xhr.setRequestHeader("X-CSRF-Token", token);
              }
            };
            Rails3.refreshCSRFTokens = function() {
              var param2, token;
              token = csrfToken();
              param2 = csrfParam();
              if (token != null && param2 != null) {
                return $7('form input[name="' + param2 + '"]').forEach(function(input) {
                  return input.value = token;
                });
              }
            };
          }).call(this);
          (function() {
            var CustomEvent2, fire, matches, preventDefault;
            matches = Rails3.matches;
            CustomEvent2 = window.CustomEvent;
            if (typeof CustomEvent2 !== "function") {
              CustomEvent2 = function(event2, params) {
                var evt;
                evt = document.createEvent("CustomEvent");
                evt.initCustomEvent(event2, params.bubbles, params.cancelable, params.detail);
                return evt;
              };
              CustomEvent2.prototype = window.Event.prototype;
              preventDefault = CustomEvent2.prototype.preventDefault;
              CustomEvent2.prototype.preventDefault = function() {
                var result;
                result = preventDefault.call(this);
                if (this.cancelable && !this.defaultPrevented) {
                  Object.defineProperty(this, "defaultPrevented", {
                    get: function() {
                      return true;
                    }
                  });
                }
                return result;
              };
            }
            fire = Rails3.fire = function(obj, name2, data) {
              var event2;
              event2 = new CustomEvent2(name2, {
                bubbles: true,
                cancelable: true,
                detail: data
              });
              obj.dispatchEvent(event2);
              return !event2.defaultPrevented;
            };
            Rails3.stopEverything = function(e2) {
              fire(e2.target, "ujs:everythingStopped");
              e2.preventDefault();
              e2.stopPropagation();
              return e2.stopImmediatePropagation();
            };
            Rails3.delegate = function(element, selector, eventType, handler) {
              return element.addEventListener(eventType, function(e2) {
                var target;
                target = e2.target;
                while (!(!(target instanceof Element) || matches(target, selector))) {
                  target = target.parentNode;
                }
                if (target instanceof Element && handler.call(target, e2) === false) {
                  e2.preventDefault();
                  return e2.stopPropagation();
                }
              });
            };
          }).call(this);
          (function() {
            var AcceptHeaders, CSRFProtection, createXHR, cspNonce, fire, prepareOptions, processResponse;
            cspNonce = Rails3.cspNonce, CSRFProtection = Rails3.CSRFProtection, fire = Rails3.fire;
            AcceptHeaders = {
              "*": "*/*",
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript",
              script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            };
            Rails3.ajax = function(options) {
              var xhr;
              options = prepareOptions(options);
              xhr = createXHR(options, function() {
                var ref, response2;
                response2 = processResponse((ref = xhr.response) != null ? ref : xhr.responseText, xhr.getResponseHeader("Content-Type"));
                if (Math.floor(xhr.status / 100) === 2) {
                  if (typeof options.success === "function") {
                    options.success(response2, xhr.statusText, xhr);
                  }
                } else {
                  if (typeof options.error === "function") {
                    options.error(response2, xhr.statusText, xhr);
                  }
                }
                return typeof options.complete === "function" ? options.complete(xhr, xhr.statusText) : void 0;
              });
              if (options.beforeSend != null && !options.beforeSend(xhr, options)) {
                return false;
              }
              if (xhr.readyState === XMLHttpRequest.OPENED) {
                return xhr.send(options.data);
              }
            };
            prepareOptions = function(options) {
              options.url = options.url || location.href;
              options.type = options.type.toUpperCase();
              if (options.type === "GET" && options.data) {
                if (options.url.indexOf("?") < 0) {
                  options.url += "?" + options.data;
                } else {
                  options.url += "&" + options.data;
                }
              }
              if (AcceptHeaders[options.dataType] == null) {
                options.dataType = "*";
              }
              options.accept = AcceptHeaders[options.dataType];
              if (options.dataType !== "*") {
                options.accept += ", */*; q=0.01";
              }
              return options;
            };
            createXHR = function(options, done) {
              var xhr;
              xhr = new XMLHttpRequest();
              xhr.open(options.type, options.url, true);
              xhr.setRequestHeader("Accept", options.accept);
              if (typeof options.data === "string") {
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
              }
              if (!options.crossDomain) {
                xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                CSRFProtection(xhr);
              }
              xhr.withCredentials = !!options.withCredentials;
              xhr.onreadystatechange = function() {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                  return done(xhr);
                }
              };
              return xhr;
            };
            processResponse = function(response2, type) {
              var parser, script;
              if (typeof response2 === "string" && typeof type === "string") {
                if (type.match(/\bjson\b/)) {
                  try {
                    response2 = JSON.parse(response2);
                  } catch (error3) {
                  }
                } else if (type.match(/\b(?:java|ecma)script\b/)) {
                  script = document.createElement("script");
                  script.setAttribute("nonce", cspNonce());
                  script.text = response2;
                  document.head.appendChild(script).parentNode.removeChild(script);
                } else if (type.match(/\b(xml|html|svg)\b/)) {
                  parser = new DOMParser();
                  type = type.replace(/;.+/, "");
                  try {
                    response2 = parser.parseFromString(response2, type);
                  } catch (error3) {
                  }
                }
              }
              return response2;
            };
            Rails3.href = function(element) {
              return element.href;
            };
            Rails3.isCrossDomain = function(url) {
              var e2, originAnchor, urlAnchor;
              originAnchor = document.createElement("a");
              originAnchor.href = location.href;
              urlAnchor = document.createElement("a");
              try {
                urlAnchor.href = url;
                return !((!urlAnchor.protocol || urlAnchor.protocol === ":") && !urlAnchor.host || originAnchor.protocol + "//" + originAnchor.host === urlAnchor.protocol + "//" + urlAnchor.host);
              } catch (error3) {
                e2 = error3;
                return true;
              }
            };
          }).call(this);
          (function() {
            var matches, toArray;
            matches = Rails3.matches;
            toArray = function(e2) {
              return Array.prototype.slice.call(e2);
            };
            Rails3.serializeElement = function(element, additionalParam) {
              var inputs, params;
              inputs = [element];
              if (matches(element, "form")) {
                inputs = toArray(element.elements);
              }
              params = [];
              inputs.forEach(function(input) {
                if (!input.name || input.disabled) {
                  return;
                }
                if (matches(input, "fieldset[disabled] *")) {
                  return;
                }
                if (matches(input, "select")) {
                  return toArray(input.options).forEach(function(option) {
                    if (option.selected) {
                      return params.push({
                        name: input.name,
                        value: option.value
                      });
                    }
                  });
                } else if (input.checked || ["radio", "checkbox", "submit"].indexOf(input.type) === -1) {
                  return params.push({
                    name: input.name,
                    value: input.value
                  });
                }
              });
              if (additionalParam) {
                params.push(additionalParam);
              }
              return params.map(function(param2) {
                if (param2.name != null) {
                  return encodeURIComponent(param2.name) + "=" + encodeURIComponent(param2.value);
                } else {
                  return param2;
                }
              }).join("&");
            };
            Rails3.formElements = function(form, selector) {
              if (matches(form, "form")) {
                return toArray(form.elements).filter(function(el) {
                  return matches(el, selector);
                });
              } else {
                return toArray(form.querySelectorAll(selector));
              }
            };
          }).call(this);
          (function() {
            var allowAction, fire, stopEverything;
            fire = Rails3.fire, stopEverything = Rails3.stopEverything;
            Rails3.handleConfirm = function(e2) {
              if (!allowAction(this)) {
                return stopEverything(e2);
              }
            };
            Rails3.confirm = function(message, element) {
              return confirm(message);
            };
            allowAction = function(element) {
              var answer, callback2, message;
              message = element.getAttribute("data-confirm");
              if (!message) {
                return true;
              }
              answer = false;
              if (fire(element, "confirm")) {
                try {
                  answer = Rails3.confirm(message, element);
                } catch (error3) {
                }
                callback2 = fire(element, "confirm:complete", [answer]);
              }
              return answer && callback2;
            };
          }).call(this);
          (function() {
            var disableFormElement, disableFormElements, disableLinkElement, enableFormElement, enableFormElements, enableLinkElement, formElements, getData, isXhrRedirect, matches, setData, stopEverything;
            matches = Rails3.matches, getData = Rails3.getData, setData = Rails3.setData, stopEverything = Rails3.stopEverything, formElements = Rails3.formElements;
            Rails3.handleDisabledElement = function(e2) {
              var element;
              element = this;
              if (element.disabled) {
                return stopEverything(e2);
              }
            };
            Rails3.enableElement = function(e2) {
              var element;
              if (e2 instanceof Event) {
                if (isXhrRedirect(e2)) {
                  return;
                }
                element = e2.target;
              } else {
                element = e2;
              }
              if (matches(element, Rails3.linkDisableSelector)) {
                return enableLinkElement(element);
              } else if (matches(element, Rails3.buttonDisableSelector) || matches(element, Rails3.formEnableSelector)) {
                return enableFormElement(element);
              } else if (matches(element, Rails3.formSubmitSelector)) {
                return enableFormElements(element);
              }
            };
            Rails3.disableElement = function(e2) {
              var element;
              element = e2 instanceof Event ? e2.target : e2;
              if (matches(element, Rails3.linkDisableSelector)) {
                return disableLinkElement(element);
              } else if (matches(element, Rails3.buttonDisableSelector) || matches(element, Rails3.formDisableSelector)) {
                return disableFormElement(element);
              } else if (matches(element, Rails3.formSubmitSelector)) {
                return disableFormElements(element);
              }
            };
            disableLinkElement = function(element) {
              var replacement;
              if (getData(element, "ujs:disabled")) {
                return;
              }
              replacement = element.getAttribute("data-disable-with");
              if (replacement != null) {
                setData(element, "ujs:enable-with", element.innerHTML);
                element.innerHTML = replacement;
              }
              element.addEventListener("click", stopEverything);
              return setData(element, "ujs:disabled", true);
            };
            enableLinkElement = function(element) {
              var originalText;
              originalText = getData(element, "ujs:enable-with");
              if (originalText != null) {
                element.innerHTML = originalText;
                setData(element, "ujs:enable-with", null);
              }
              element.removeEventListener("click", stopEverything);
              return setData(element, "ujs:disabled", null);
            };
            disableFormElements = function(form) {
              return formElements(form, Rails3.formDisableSelector).forEach(disableFormElement);
            };
            disableFormElement = function(element) {
              var replacement;
              if (getData(element, "ujs:disabled")) {
                return;
              }
              replacement = element.getAttribute("data-disable-with");
              if (replacement != null) {
                if (matches(element, "button")) {
                  setData(element, "ujs:enable-with", element.innerHTML);
                  element.innerHTML = replacement;
                } else {
                  setData(element, "ujs:enable-with", element.value);
                  element.value = replacement;
                }
              }
              element.disabled = true;
              return setData(element, "ujs:disabled", true);
            };
            enableFormElements = function(form) {
              return formElements(form, Rails3.formEnableSelector).forEach(enableFormElement);
            };
            enableFormElement = function(element) {
              var originalText;
              originalText = getData(element, "ujs:enable-with");
              if (originalText != null) {
                if (matches(element, "button")) {
                  element.innerHTML = originalText;
                } else {
                  element.value = originalText;
                }
                setData(element, "ujs:enable-with", null);
              }
              element.disabled = false;
              return setData(element, "ujs:disabled", null);
            };
            isXhrRedirect = function(event2) {
              var ref, xhr;
              xhr = (ref = event2.detail) != null ? ref[0] : void 0;
              return (xhr != null ? xhr.getResponseHeader("X-Xhr-Redirect") : void 0) != null;
            };
          }).call(this);
          (function() {
            var stopEverything;
            stopEverything = Rails3.stopEverything;
            Rails3.handleMethod = function(e2) {
              var csrfParam, csrfToken, form, formContent, href, link, method;
              link = this;
              method = link.getAttribute("data-method");
              if (!method) {
                return;
              }
              href = Rails3.href(link);
              csrfToken = Rails3.csrfToken();
              csrfParam = Rails3.csrfParam();
              form = document.createElement("form");
              formContent = "<input name='_method' value='" + method + "' type='hidden' />";
              if (csrfParam != null && csrfToken != null && !Rails3.isCrossDomain(href)) {
                formContent += "<input name='" + csrfParam + "' value='" + csrfToken + "' type='hidden' />";
              }
              formContent += '<input type="submit" />';
              form.method = "post";
              form.action = href;
              form.target = link.target;
              form.innerHTML = formContent;
              form.style.display = "none";
              document.body.appendChild(form);
              form.querySelector('[type="submit"]').click();
              return stopEverything(e2);
            };
          }).call(this);
          (function() {
            var ajax, fire, getData, isCrossDomain, isRemote, matches, serializeElement, setData, stopEverything, slice = [].slice;
            matches = Rails3.matches, getData = Rails3.getData, setData = Rails3.setData, fire = Rails3.fire, stopEverything = Rails3.stopEverything, ajax = Rails3.ajax, isCrossDomain = Rails3.isCrossDomain, serializeElement = Rails3.serializeElement;
            isRemote = function(element) {
              var value;
              value = element.getAttribute("data-remote");
              return value != null && value !== "false";
            };
            Rails3.handleRemote = function(e2) {
              var button, data, dataType, element, method, url, withCredentials;
              element = this;
              if (!isRemote(element)) {
                return true;
              }
              if (!fire(element, "ajax:before")) {
                fire(element, "ajax:stopped");
                return false;
              }
              withCredentials = element.getAttribute("data-with-credentials");
              dataType = element.getAttribute("data-type") || "script";
              if (matches(element, Rails3.formSubmitSelector)) {
                button = getData(element, "ujs:submit-button");
                method = getData(element, "ujs:submit-button-formmethod") || element.method;
                url = getData(element, "ujs:submit-button-formaction") || element.getAttribute("action") || location.href;
                if (method.toUpperCase() === "GET") {
                  url = url.replace(/\?.*$/, "");
                }
                if (element.enctype === "multipart/form-data") {
                  data = new FormData(element);
                  if (button != null) {
                    data.append(button.name, button.value);
                  }
                } else {
                  data = serializeElement(element, button);
                }
                setData(element, "ujs:submit-button", null);
                setData(element, "ujs:submit-button-formmethod", null);
                setData(element, "ujs:submit-button-formaction", null);
              } else if (matches(element, Rails3.buttonClickSelector) || matches(element, Rails3.inputChangeSelector)) {
                method = element.getAttribute("data-method");
                url = element.getAttribute("data-url");
                data = serializeElement(element, element.getAttribute("data-params"));
              } else {
                method = element.getAttribute("data-method");
                url = Rails3.href(element);
                data = element.getAttribute("data-params");
              }
              ajax({
                type: method || "GET",
                url,
                data,
                dataType,
                beforeSend: function(xhr, options) {
                  if (fire(element, "ajax:beforeSend", [xhr, options])) {
                    return fire(element, "ajax:send", [xhr]);
                  } else {
                    fire(element, "ajax:stopped");
                    return false;
                  }
                },
                success: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:success", args);
                },
                error: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:error", args);
                },
                complete: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:complete", args);
                },
                crossDomain: isCrossDomain(url),
                withCredentials: withCredentials != null && withCredentials !== "false"
              });
              return stopEverything(e2);
            };
            Rails3.formSubmitButtonClick = function(e2) {
              var button, form;
              button = this;
              form = button.form;
              if (!form) {
                return;
              }
              if (button.name) {
                setData(form, "ujs:submit-button", {
                  name: button.name,
                  value: button.value
                });
              }
              setData(form, "ujs:formnovalidate-button", button.formNoValidate);
              setData(form, "ujs:submit-button-formaction", button.getAttribute("formaction"));
              return setData(form, "ujs:submit-button-formmethod", button.getAttribute("formmethod"));
            };
            Rails3.preventInsignificantClick = function(e2) {
              var data, insignificantMetaClick, link, metaClick, method, nonPrimaryMouseClick;
              link = this;
              method = (link.getAttribute("data-method") || "GET").toUpperCase();
              data = link.getAttribute("data-params");
              metaClick = e2.metaKey || e2.ctrlKey;
              insignificantMetaClick = metaClick && method === "GET" && !data;
              nonPrimaryMouseClick = e2.button != null && e2.button !== 0;
              if (nonPrimaryMouseClick || insignificantMetaClick) {
                return e2.stopImmediatePropagation();
              }
            };
          }).call(this);
          (function() {
            var $7, CSRFProtection, delegate, disableElement, enableElement, fire, formSubmitButtonClick, getData, handleConfirm, handleDisabledElement, handleMethod, handleRemote, loadCSPNonce, preventInsignificantClick, refreshCSRFTokens;
            fire = Rails3.fire, delegate = Rails3.delegate, getData = Rails3.getData, $7 = Rails3.$, refreshCSRFTokens = Rails3.refreshCSRFTokens, CSRFProtection = Rails3.CSRFProtection, loadCSPNonce = Rails3.loadCSPNonce, enableElement = Rails3.enableElement, disableElement = Rails3.disableElement, handleDisabledElement = Rails3.handleDisabledElement, handleConfirm = Rails3.handleConfirm, preventInsignificantClick = Rails3.preventInsignificantClick, handleRemote = Rails3.handleRemote, formSubmitButtonClick = Rails3.formSubmitButtonClick, handleMethod = Rails3.handleMethod;
            if (typeof jQuery !== "undefined" && jQuery !== null && jQuery.ajax != null) {
              if (jQuery.rails) {
                throw new Error("If you load both jquery_ujs and rails-ujs, use rails-ujs only.");
              }
              jQuery.rails = Rails3;
              jQuery.ajaxPrefilter(function(options, originalOptions, xhr) {
                if (!options.crossDomain) {
                  return CSRFProtection(xhr);
                }
              });
            }
            Rails3.start = function() {
              if (window._rails_loaded) {
                throw new Error("rails-ujs has already been loaded!");
              }
              window.addEventListener("pageshow", function() {
                $7(Rails3.formEnableSelector).forEach(function(el) {
                  if (getData(el, "ujs:disabled")) {
                    return enableElement(el);
                  }
                });
                return $7(Rails3.linkDisableSelector).forEach(function(el) {
                  if (getData(el, "ujs:disabled")) {
                    return enableElement(el);
                  }
                });
              });
              delegate(document, Rails3.linkDisableSelector, "ajax:complete", enableElement);
              delegate(document, Rails3.linkDisableSelector, "ajax:stopped", enableElement);
              delegate(document, Rails3.buttonDisableSelector, "ajax:complete", enableElement);
              delegate(document, Rails3.buttonDisableSelector, "ajax:stopped", enableElement);
              delegate(document, Rails3.linkClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails3.linkClickSelector, "click", handleDisabledElement);
              delegate(document, Rails3.linkClickSelector, "click", handleConfirm);
              delegate(document, Rails3.linkClickSelector, "click", disableElement);
              delegate(document, Rails3.linkClickSelector, "click", handleRemote);
              delegate(document, Rails3.linkClickSelector, "click", handleMethod);
              delegate(document, Rails3.buttonClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails3.buttonClickSelector, "click", handleDisabledElement);
              delegate(document, Rails3.buttonClickSelector, "click", handleConfirm);
              delegate(document, Rails3.buttonClickSelector, "click", disableElement);
              delegate(document, Rails3.buttonClickSelector, "click", handleRemote);
              delegate(document, Rails3.inputChangeSelector, "change", handleDisabledElement);
              delegate(document, Rails3.inputChangeSelector, "change", handleConfirm);
              delegate(document, Rails3.inputChangeSelector, "change", handleRemote);
              delegate(document, Rails3.formSubmitSelector, "submit", handleDisabledElement);
              delegate(document, Rails3.formSubmitSelector, "submit", handleConfirm);
              delegate(document, Rails3.formSubmitSelector, "submit", handleRemote);
              delegate(document, Rails3.formSubmitSelector, "submit", function(e2) {
                return setTimeout(function() {
                  return disableElement(e2);
                }, 13);
              });
              delegate(document, Rails3.formSubmitSelector, "ajax:send", disableElement);
              delegate(document, Rails3.formSubmitSelector, "ajax:complete", enableElement);
              delegate(document, Rails3.formInputClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails3.formInputClickSelector, "click", handleDisabledElement);
              delegate(document, Rails3.formInputClickSelector, "click", handleConfirm);
              delegate(document, Rails3.formInputClickSelector, "click", formSubmitButtonClick);
              document.addEventListener("DOMContentLoaded", refreshCSRFTokens);
              document.addEventListener("DOMContentLoaded", loadCSPNonce);
              return window._rails_loaded = true;
            };
            if (window.Rails === Rails3 && fire(document, "rails:attachBindings")) {
              Rails3.start();
            }
          }).call(this);
        }).call(this);
        if (typeof module2 === "object" && module2.exports) {
          module2.exports = Rails3;
        } else if (typeof define === "function" && define.amd) {
          define(Rails3);
        }
      }).call(exports);
    }
  });

  // node_modules/@rails/activestorage/app/assets/javascripts/activestorage.js
  var require_activestorage = __commonJS({
    "node_modules/@rails/activestorage/app/assets/javascripts/activestorage.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function(global3, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global3.ActiveStorage = {});
      })(exports, function(exports2) {
        "use strict";
        function createCommonjsModule(fn3, module3) {
          return module3 = {
            exports: {}
          }, fn3(module3, module3.exports), module3.exports;
        }
        var sparkMd5 = createCommonjsModule(function(module3, exports3) {
          (function(factory) {
            {
              module3.exports = factory();
            }
          })(function(undefined2) {
            var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
            function md5cycle(x4, k4) {
              var a5 = x4[0], b5 = x4[1], c4 = x4[2], d5 = x4[3];
              a5 += (b5 & c4 | ~b5 & d5) + k4[0] - 680876936 | 0;
              a5 = (a5 << 7 | a5 >>> 25) + b5 | 0;
              d5 += (a5 & b5 | ~a5 & c4) + k4[1] - 389564586 | 0;
              d5 = (d5 << 12 | d5 >>> 20) + a5 | 0;
              c4 += (d5 & a5 | ~d5 & b5) + k4[2] + 606105819 | 0;
              c4 = (c4 << 17 | c4 >>> 15) + d5 | 0;
              b5 += (c4 & d5 | ~c4 & a5) + k4[3] - 1044525330 | 0;
              b5 = (b5 << 22 | b5 >>> 10) + c4 | 0;
              a5 += (b5 & c4 | ~b5 & d5) + k4[4] - 176418897 | 0;
              a5 = (a5 << 7 | a5 >>> 25) + b5 | 0;
              d5 += (a5 & b5 | ~a5 & c4) + k4[5] + 1200080426 | 0;
              d5 = (d5 << 12 | d5 >>> 20) + a5 | 0;
              c4 += (d5 & a5 | ~d5 & b5) + k4[6] - 1473231341 | 0;
              c4 = (c4 << 17 | c4 >>> 15) + d5 | 0;
              b5 += (c4 & d5 | ~c4 & a5) + k4[7] - 45705983 | 0;
              b5 = (b5 << 22 | b5 >>> 10) + c4 | 0;
              a5 += (b5 & c4 | ~b5 & d5) + k4[8] + 1770035416 | 0;
              a5 = (a5 << 7 | a5 >>> 25) + b5 | 0;
              d5 += (a5 & b5 | ~a5 & c4) + k4[9] - 1958414417 | 0;
              d5 = (d5 << 12 | d5 >>> 20) + a5 | 0;
              c4 += (d5 & a5 | ~d5 & b5) + k4[10] - 42063 | 0;
              c4 = (c4 << 17 | c4 >>> 15) + d5 | 0;
              b5 += (c4 & d5 | ~c4 & a5) + k4[11] - 1990404162 | 0;
              b5 = (b5 << 22 | b5 >>> 10) + c4 | 0;
              a5 += (b5 & c4 | ~b5 & d5) + k4[12] + 1804603682 | 0;
              a5 = (a5 << 7 | a5 >>> 25) + b5 | 0;
              d5 += (a5 & b5 | ~a5 & c4) + k4[13] - 40341101 | 0;
              d5 = (d5 << 12 | d5 >>> 20) + a5 | 0;
              c4 += (d5 & a5 | ~d5 & b5) + k4[14] - 1502002290 | 0;
              c4 = (c4 << 17 | c4 >>> 15) + d5 | 0;
              b5 += (c4 & d5 | ~c4 & a5) + k4[15] + 1236535329 | 0;
              b5 = (b5 << 22 | b5 >>> 10) + c4 | 0;
              a5 += (b5 & d5 | c4 & ~d5) + k4[1] - 165796510 | 0;
              a5 = (a5 << 5 | a5 >>> 27) + b5 | 0;
              d5 += (a5 & c4 | b5 & ~c4) + k4[6] - 1069501632 | 0;
              d5 = (d5 << 9 | d5 >>> 23) + a5 | 0;
              c4 += (d5 & b5 | a5 & ~b5) + k4[11] + 643717713 | 0;
              c4 = (c4 << 14 | c4 >>> 18) + d5 | 0;
              b5 += (c4 & a5 | d5 & ~a5) + k4[0] - 373897302 | 0;
              b5 = (b5 << 20 | b5 >>> 12) + c4 | 0;
              a5 += (b5 & d5 | c4 & ~d5) + k4[5] - 701558691 | 0;
              a5 = (a5 << 5 | a5 >>> 27) + b5 | 0;
              d5 += (a5 & c4 | b5 & ~c4) + k4[10] + 38016083 | 0;
              d5 = (d5 << 9 | d5 >>> 23) + a5 | 0;
              c4 += (d5 & b5 | a5 & ~b5) + k4[15] - 660478335 | 0;
              c4 = (c4 << 14 | c4 >>> 18) + d5 | 0;
              b5 += (c4 & a5 | d5 & ~a5) + k4[4] - 405537848 | 0;
              b5 = (b5 << 20 | b5 >>> 12) + c4 | 0;
              a5 += (b5 & d5 | c4 & ~d5) + k4[9] + 568446438 | 0;
              a5 = (a5 << 5 | a5 >>> 27) + b5 | 0;
              d5 += (a5 & c4 | b5 & ~c4) + k4[14] - 1019803690 | 0;
              d5 = (d5 << 9 | d5 >>> 23) + a5 | 0;
              c4 += (d5 & b5 | a5 & ~b5) + k4[3] - 187363961 | 0;
              c4 = (c4 << 14 | c4 >>> 18) + d5 | 0;
              b5 += (c4 & a5 | d5 & ~a5) + k4[8] + 1163531501 | 0;
              b5 = (b5 << 20 | b5 >>> 12) + c4 | 0;
              a5 += (b5 & d5 | c4 & ~d5) + k4[13] - 1444681467 | 0;
              a5 = (a5 << 5 | a5 >>> 27) + b5 | 0;
              d5 += (a5 & c4 | b5 & ~c4) + k4[2] - 51403784 | 0;
              d5 = (d5 << 9 | d5 >>> 23) + a5 | 0;
              c4 += (d5 & b5 | a5 & ~b5) + k4[7] + 1735328473 | 0;
              c4 = (c4 << 14 | c4 >>> 18) + d5 | 0;
              b5 += (c4 & a5 | d5 & ~a5) + k4[12] - 1926607734 | 0;
              b5 = (b5 << 20 | b5 >>> 12) + c4 | 0;
              a5 += (b5 ^ c4 ^ d5) + k4[5] - 378558 | 0;
              a5 = (a5 << 4 | a5 >>> 28) + b5 | 0;
              d5 += (a5 ^ b5 ^ c4) + k4[8] - 2022574463 | 0;
              d5 = (d5 << 11 | d5 >>> 21) + a5 | 0;
              c4 += (d5 ^ a5 ^ b5) + k4[11] + 1839030562 | 0;
              c4 = (c4 << 16 | c4 >>> 16) + d5 | 0;
              b5 += (c4 ^ d5 ^ a5) + k4[14] - 35309556 | 0;
              b5 = (b5 << 23 | b5 >>> 9) + c4 | 0;
              a5 += (b5 ^ c4 ^ d5) + k4[1] - 1530992060 | 0;
              a5 = (a5 << 4 | a5 >>> 28) + b5 | 0;
              d5 += (a5 ^ b5 ^ c4) + k4[4] + 1272893353 | 0;
              d5 = (d5 << 11 | d5 >>> 21) + a5 | 0;
              c4 += (d5 ^ a5 ^ b5) + k4[7] - 155497632 | 0;
              c4 = (c4 << 16 | c4 >>> 16) + d5 | 0;
              b5 += (c4 ^ d5 ^ a5) + k4[10] - 1094730640 | 0;
              b5 = (b5 << 23 | b5 >>> 9) + c4 | 0;
              a5 += (b5 ^ c4 ^ d5) + k4[13] + 681279174 | 0;
              a5 = (a5 << 4 | a5 >>> 28) + b5 | 0;
              d5 += (a5 ^ b5 ^ c4) + k4[0] - 358537222 | 0;
              d5 = (d5 << 11 | d5 >>> 21) + a5 | 0;
              c4 += (d5 ^ a5 ^ b5) + k4[3] - 722521979 | 0;
              c4 = (c4 << 16 | c4 >>> 16) + d5 | 0;
              b5 += (c4 ^ d5 ^ a5) + k4[6] + 76029189 | 0;
              b5 = (b5 << 23 | b5 >>> 9) + c4 | 0;
              a5 += (b5 ^ c4 ^ d5) + k4[9] - 640364487 | 0;
              a5 = (a5 << 4 | a5 >>> 28) + b5 | 0;
              d5 += (a5 ^ b5 ^ c4) + k4[12] - 421815835 | 0;
              d5 = (d5 << 11 | d5 >>> 21) + a5 | 0;
              c4 += (d5 ^ a5 ^ b5) + k4[15] + 530742520 | 0;
              c4 = (c4 << 16 | c4 >>> 16) + d5 | 0;
              b5 += (c4 ^ d5 ^ a5) + k4[2] - 995338651 | 0;
              b5 = (b5 << 23 | b5 >>> 9) + c4 | 0;
              a5 += (c4 ^ (b5 | ~d5)) + k4[0] - 198630844 | 0;
              a5 = (a5 << 6 | a5 >>> 26) + b5 | 0;
              d5 += (b5 ^ (a5 | ~c4)) + k4[7] + 1126891415 | 0;
              d5 = (d5 << 10 | d5 >>> 22) + a5 | 0;
              c4 += (a5 ^ (d5 | ~b5)) + k4[14] - 1416354905 | 0;
              c4 = (c4 << 15 | c4 >>> 17) + d5 | 0;
              b5 += (d5 ^ (c4 | ~a5)) + k4[5] - 57434055 | 0;
              b5 = (b5 << 21 | b5 >>> 11) + c4 | 0;
              a5 += (c4 ^ (b5 | ~d5)) + k4[12] + 1700485571 | 0;
              a5 = (a5 << 6 | a5 >>> 26) + b5 | 0;
              d5 += (b5 ^ (a5 | ~c4)) + k4[3] - 1894986606 | 0;
              d5 = (d5 << 10 | d5 >>> 22) + a5 | 0;
              c4 += (a5 ^ (d5 | ~b5)) + k4[10] - 1051523 | 0;
              c4 = (c4 << 15 | c4 >>> 17) + d5 | 0;
              b5 += (d5 ^ (c4 | ~a5)) + k4[1] - 2054922799 | 0;
              b5 = (b5 << 21 | b5 >>> 11) + c4 | 0;
              a5 += (c4 ^ (b5 | ~d5)) + k4[8] + 1873313359 | 0;
              a5 = (a5 << 6 | a5 >>> 26) + b5 | 0;
              d5 += (b5 ^ (a5 | ~c4)) + k4[15] - 30611744 | 0;
              d5 = (d5 << 10 | d5 >>> 22) + a5 | 0;
              c4 += (a5 ^ (d5 | ~b5)) + k4[6] - 1560198380 | 0;
              c4 = (c4 << 15 | c4 >>> 17) + d5 | 0;
              b5 += (d5 ^ (c4 | ~a5)) + k4[13] + 1309151649 | 0;
              b5 = (b5 << 21 | b5 >>> 11) + c4 | 0;
              a5 += (c4 ^ (b5 | ~d5)) + k4[4] - 145523070 | 0;
              a5 = (a5 << 6 | a5 >>> 26) + b5 | 0;
              d5 += (b5 ^ (a5 | ~c4)) + k4[11] - 1120210379 | 0;
              d5 = (d5 << 10 | d5 >>> 22) + a5 | 0;
              c4 += (a5 ^ (d5 | ~b5)) + k4[2] + 718787259 | 0;
              c4 = (c4 << 15 | c4 >>> 17) + d5 | 0;
              b5 += (d5 ^ (c4 | ~a5)) + k4[9] - 343485551 | 0;
              b5 = (b5 << 21 | b5 >>> 11) + c4 | 0;
              x4[0] = a5 + x4[0] | 0;
              x4[1] = b5 + x4[1] | 0;
              x4[2] = c4 + x4[2] | 0;
              x4[3] = d5 + x4[3] | 0;
            }
            function md5blk(s4) {
              var md5blks = [], i3;
              for (i3 = 0; i3 < 64; i3 += 4) {
                md5blks[i3 >> 2] = s4.charCodeAt(i3) + (s4.charCodeAt(i3 + 1) << 8) + (s4.charCodeAt(i3 + 2) << 16) + (s4.charCodeAt(i3 + 3) << 24);
              }
              return md5blks;
            }
            function md5blk_array(a5) {
              var md5blks = [], i3;
              for (i3 = 0; i3 < 64; i3 += 4) {
                md5blks[i3 >> 2] = a5[i3] + (a5[i3 + 1] << 8) + (a5[i3 + 2] << 16) + (a5[i3 + 3] << 24);
              }
              return md5blks;
            }
            function md51(s4) {
              var n3 = s4.length, state = [1732584193, -271733879, -1732584194, 271733878], i3, length, tail, tmp, lo, hi2;
              for (i3 = 64; i3 <= n3; i3 += 64) {
                md5cycle(state, md5blk(s4.substring(i3 - 64, i3)));
              }
              s4 = s4.substring(i3 - 64);
              length = s4.length;
              tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              for (i3 = 0; i3 < length; i3 += 1) {
                tail[i3 >> 2] |= s4.charCodeAt(i3) << (i3 % 4 << 3);
              }
              tail[i3 >> 2] |= 128 << (i3 % 4 << 3);
              if (i3 > 55) {
                md5cycle(state, tail);
                for (i3 = 0; i3 < 16; i3 += 1) {
                  tail[i3] = 0;
                }
              }
              tmp = n3 * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi2 = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi2;
              md5cycle(state, tail);
              return state;
            }
            function md51_array(a5) {
              var n3 = a5.length, state = [1732584193, -271733879, -1732584194, 271733878], i3, length, tail, tmp, lo, hi2;
              for (i3 = 64; i3 <= n3; i3 += 64) {
                md5cycle(state, md5blk_array(a5.subarray(i3 - 64, i3)));
              }
              a5 = i3 - 64 < n3 ? a5.subarray(i3 - 64) : new Uint8Array(0);
              length = a5.length;
              tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              for (i3 = 0; i3 < length; i3 += 1) {
                tail[i3 >> 2] |= a5[i3] << (i3 % 4 << 3);
              }
              tail[i3 >> 2] |= 128 << (i3 % 4 << 3);
              if (i3 > 55) {
                md5cycle(state, tail);
                for (i3 = 0; i3 < 16; i3 += 1) {
                  tail[i3] = 0;
                }
              }
              tmp = n3 * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi2 = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi2;
              md5cycle(state, tail);
              return state;
            }
            function rhex(n3) {
              var s4 = "", j6;
              for (j6 = 0; j6 < 4; j6 += 1) {
                s4 += hex_chr[n3 >> j6 * 8 + 4 & 15] + hex_chr[n3 >> j6 * 8 & 15];
              }
              return s4;
            }
            function hex2(x4) {
              var i3;
              for (i3 = 0; i3 < x4.length; i3 += 1) {
                x4[i3] = rhex(x4[i3]);
              }
              return x4.join("");
            }
            if (hex2(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") ;
            if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
              (function() {
                function clamp2(val, length) {
                  val = val | 0 || 0;
                  if (val < 0) {
                    return Math.max(val + length, 0);
                  }
                  return Math.min(val, length);
                }
                ArrayBuffer.prototype.slice = function(from2, to3) {
                  var length = this.byteLength, begin = clamp2(from2, length), end2 = length, num, target, targetArray, sourceArray;
                  if (to3 !== undefined2) {
                    end2 = clamp2(to3, length);
                  }
                  if (begin > end2) {
                    return new ArrayBuffer(0);
                  }
                  num = end2 - begin;
                  target = new ArrayBuffer(num);
                  targetArray = new Uint8Array(target);
                  sourceArray = new Uint8Array(this, begin, num);
                  targetArray.set(sourceArray);
                  return target;
                };
              })();
            }
            function toUtf8(str) {
              if (/[\u0080-\uFFFF]/.test(str)) {
                str = unescape(encodeURIComponent(str));
              }
              return str;
            }
            function utf8Str2ArrayBuffer(str, returnUInt8Array) {
              var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i3;
              for (i3 = 0; i3 < length; i3 += 1) {
                arr[i3] = str.charCodeAt(i3);
              }
              return returnUInt8Array ? arr : buff;
            }
            function arrayBuffer2Utf8Str(buff) {
              return String.fromCharCode.apply(null, new Uint8Array(buff));
            }
            function concatenateArrayBuffers(first, second, returnUInt8Array) {
              var result = new Uint8Array(first.byteLength + second.byteLength);
              result.set(new Uint8Array(first));
              result.set(new Uint8Array(second), first.byteLength);
              return returnUInt8Array ? result : result.buffer;
            }
            function hexToBinaryString(hex3) {
              var bytes = [], length = hex3.length, x4;
              for (x4 = 0; x4 < length - 1; x4 += 2) {
                bytes.push(parseInt(hex3.substr(x4, 2), 16));
              }
              return String.fromCharCode.apply(String, bytes);
            }
            function SparkMD5() {
              this.reset();
            }
            SparkMD5.prototype.append = function(str) {
              this.appendBinary(toUtf8(str));
              return this;
            };
            SparkMD5.prototype.appendBinary = function(contents) {
              this._buff += contents;
              this._length += contents.length;
              var length = this._buff.length, i3;
              for (i3 = 64; i3 <= length; i3 += 64) {
                md5cycle(this._hash, md5blk(this._buff.substring(i3 - 64, i3)));
              }
              this._buff = this._buff.substring(i3 - 64);
              return this;
            };
            SparkMD5.prototype.end = function(raw) {
              var buff = this._buff, length = buff.length, i3, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
              for (i3 = 0; i3 < length; i3 += 1) {
                tail[i3 >> 2] |= buff.charCodeAt(i3) << (i3 % 4 << 3);
              }
              this._finish(tail, length);
              ret = hex2(this._hash);
              if (raw) {
                ret = hexToBinaryString(ret);
              }
              this.reset();
              return ret;
            };
            SparkMD5.prototype.reset = function() {
              this._buff = "";
              this._length = 0;
              this._hash = [1732584193, -271733879, -1732584194, 271733878];
              return this;
            };
            SparkMD5.prototype.getState = function() {
              return {
                buff: this._buff,
                length: this._length,
                hash: this._hash
              };
            };
            SparkMD5.prototype.setState = function(state) {
              this._buff = state.buff;
              this._length = state.length;
              this._hash = state.hash;
              return this;
            };
            SparkMD5.prototype.destroy = function() {
              delete this._hash;
              delete this._buff;
              delete this._length;
            };
            SparkMD5.prototype._finish = function(tail, length) {
              var i3 = length, tmp, lo, hi2;
              tail[i3 >> 2] |= 128 << (i3 % 4 << 3);
              if (i3 > 55) {
                md5cycle(this._hash, tail);
                for (i3 = 0; i3 < 16; i3 += 1) {
                  tail[i3] = 0;
                }
              }
              tmp = this._length * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi2 = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi2;
              md5cycle(this._hash, tail);
            };
            SparkMD5.hash = function(str, raw) {
              return SparkMD5.hashBinary(toUtf8(str), raw);
            };
            SparkMD5.hashBinary = function(content, raw) {
              var hash3 = md51(content), ret = hex2(hash3);
              return raw ? hexToBinaryString(ret) : ret;
            };
            SparkMD5.ArrayBuffer = function() {
              this.reset();
            };
            SparkMD5.ArrayBuffer.prototype.append = function(arr) {
              var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i3;
              this._length += arr.byteLength;
              for (i3 = 64; i3 <= length; i3 += 64) {
                md5cycle(this._hash, md5blk_array(buff.subarray(i3 - 64, i3)));
              }
              this._buff = i3 - 64 < length ? new Uint8Array(buff.buffer.slice(i3 - 64)) : new Uint8Array(0);
              return this;
            };
            SparkMD5.ArrayBuffer.prototype.end = function(raw) {
              var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i3, ret;
              for (i3 = 0; i3 < length; i3 += 1) {
                tail[i3 >> 2] |= buff[i3] << (i3 % 4 << 3);
              }
              this._finish(tail, length);
              ret = hex2(this._hash);
              if (raw) {
                ret = hexToBinaryString(ret);
              }
              this.reset();
              return ret;
            };
            SparkMD5.ArrayBuffer.prototype.reset = function() {
              this._buff = new Uint8Array(0);
              this._length = 0;
              this._hash = [1732584193, -271733879, -1732584194, 271733878];
              return this;
            };
            SparkMD5.ArrayBuffer.prototype.getState = function() {
              var state = SparkMD5.prototype.getState.call(this);
              state.buff = arrayBuffer2Utf8Str(state.buff);
              return state;
            };
            SparkMD5.ArrayBuffer.prototype.setState = function(state) {
              state.buff = utf8Str2ArrayBuffer(state.buff, true);
              return SparkMD5.prototype.setState.call(this, state);
            };
            SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
            SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
            SparkMD5.ArrayBuffer.hash = function(arr, raw) {
              var hash3 = md51_array(new Uint8Array(arr)), ret = hex2(hash3);
              return raw ? hexToBinaryString(ret) : ret;
            };
            return SparkMD5;
          });
        });
        var classCallCheck = function(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        };
        var createClass = /* @__PURE__ */ function() {
          function defineProperties(target, props) {
            for (var i3 = 0; i3 < props.length; i3++) {
              var descriptor = props[i3];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
        var FileChecksum = function() {
          createClass(FileChecksum2, null, [{
            key: "create",
            value: function create(file, callback2) {
              var instance = new FileChecksum2(file);
              instance.create(callback2);
            }
          }]);
          function FileChecksum2(file) {
            classCallCheck(this, FileChecksum2);
            this.file = file;
            this.chunkSize = 2097152;
            this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
            this.chunkIndex = 0;
          }
          createClass(FileChecksum2, [{
            key: "create",
            value: function create(callback2) {
              var _this = this;
              this.callback = callback2;
              this.md5Buffer = new sparkMd5.ArrayBuffer();
              this.fileReader = new FileReader();
              this.fileReader.addEventListener("load", function(event2) {
                return _this.fileReaderDidLoad(event2);
              });
              this.fileReader.addEventListener("error", function(event2) {
                return _this.fileReaderDidError(event2);
              });
              this.readNextChunk();
            }
          }, {
            key: "fileReaderDidLoad",
            value: function fileReaderDidLoad(event2) {
              this.md5Buffer.append(event2.target.result);
              if (!this.readNextChunk()) {
                var binaryDigest = this.md5Buffer.end(true);
                var base64digest = btoa(binaryDigest);
                this.callback(null, base64digest);
              }
            }
          }, {
            key: "fileReaderDidError",
            value: function fileReaderDidError(event2) {
              this.callback("Error reading " + this.file.name);
            }
          }, {
            key: "readNextChunk",
            value: function readNextChunk() {
              if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
                var start6 = this.chunkIndex * this.chunkSize;
                var end2 = Math.min(start6 + this.chunkSize, this.file.size);
                var bytes = fileSlice.call(this.file, start6, end2);
                this.fileReader.readAsArrayBuffer(bytes);
                this.chunkIndex++;
                return true;
              } else {
                return false;
              }
            }
          }]);
          return FileChecksum2;
        }();
        function getMetaValue(name2) {
          var element = findElement(document.head, 'meta[name="' + name2 + '"]');
          if (element) {
            return element.getAttribute("content");
          }
        }
        function findElements(root, selector) {
          if (typeof root == "string") {
            selector = root;
            root = document;
          }
          var elements2 = root.querySelectorAll(selector);
          return toArray$1(elements2);
        }
        function findElement(root, selector) {
          if (typeof root == "string") {
            selector = root;
            root = document;
          }
          return root.querySelector(selector);
        }
        function dispatchEvent2(element, type) {
          var eventInit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var disabled = element.disabled;
          var bubbles = eventInit.bubbles, cancelable = eventInit.cancelable, detail = eventInit.detail;
          var event2 = document.createEvent("Event");
          event2.initEvent(type, bubbles || true, cancelable || true);
          event2.detail = detail || {};
          try {
            element.disabled = false;
            element.dispatchEvent(event2);
          } finally {
            element.disabled = disabled;
          }
          return event2;
        }
        function toArray$1(value) {
          if (Array.isArray(value)) {
            return value;
          } else if (Array.from) {
            return Array.from(value);
          } else {
            return [].slice.call(value);
          }
        }
        var BlobRecord = function() {
          function BlobRecord2(file, checksum, url) {
            var _this = this;
            classCallCheck(this, BlobRecord2);
            this.file = file;
            this.attributes = {
              filename: file.name,
              content_type: file.type || "application/octet-stream",
              byte_size: file.size,
              checksum
            };
            this.xhr = new XMLHttpRequest();
            this.xhr.open("POST", url, true);
            this.xhr.responseType = "json";
            this.xhr.setRequestHeader("Content-Type", "application/json");
            this.xhr.setRequestHeader("Accept", "application/json");
            this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            var csrfToken = getMetaValue("csrf-token");
            if (csrfToken != void 0) {
              this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
            }
            this.xhr.addEventListener("load", function(event2) {
              return _this.requestDidLoad(event2);
            });
            this.xhr.addEventListener("error", function(event2) {
              return _this.requestDidError(event2);
            });
          }
          createClass(BlobRecord2, [{
            key: "create",
            value: function create(callback2) {
              this.callback = callback2;
              this.xhr.send(JSON.stringify({
                blob: this.attributes
              }));
            }
          }, {
            key: "requestDidLoad",
            value: function requestDidLoad(event2) {
              if (this.status >= 200 && this.status < 300) {
                var response2 = this.response;
                var direct_upload = response2.direct_upload;
                delete response2.direct_upload;
                this.attributes = response2;
                this.directUploadData = direct_upload;
                this.callback(null, this.toJSON());
              } else {
                this.requestDidError(event2);
              }
            }
          }, {
            key: "requestDidError",
            value: function requestDidError(event2) {
              this.callback('Error creating Blob for "' + this.file.name + '". Status: ' + this.status);
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var result = {};
              for (var key in this.attributes) {
                result[key] = this.attributes[key];
              }
              return result;
            }
          }, {
            key: "status",
            get: function get$$1() {
              return this.xhr.status;
            }
          }, {
            key: "response",
            get: function get$$1() {
              var _xhr = this.xhr, responseType = _xhr.responseType, response2 = _xhr.response;
              if (responseType == "json") {
                return response2;
              } else {
                return JSON.parse(response2);
              }
            }
          }]);
          return BlobRecord2;
        }();
        var BlobUpload = function() {
          function BlobUpload2(blob) {
            var _this = this;
            classCallCheck(this, BlobUpload2);
            this.blob = blob;
            this.file = blob.file;
            var _blob$directUploadDat = blob.directUploadData, url = _blob$directUploadDat.url, headers = _blob$directUploadDat.headers;
            this.xhr = new XMLHttpRequest();
            this.xhr.open("PUT", url, true);
            this.xhr.responseType = "text";
            for (var key in headers) {
              this.xhr.setRequestHeader(key, headers[key]);
            }
            this.xhr.addEventListener("load", function(event2) {
              return _this.requestDidLoad(event2);
            });
            this.xhr.addEventListener("error", function(event2) {
              return _this.requestDidError(event2);
            });
          }
          createClass(BlobUpload2, [{
            key: "create",
            value: function create(callback2) {
              this.callback = callback2;
              this.xhr.send(this.file.slice());
            }
          }, {
            key: "requestDidLoad",
            value: function requestDidLoad(event2) {
              var _xhr = this.xhr, status = _xhr.status, response2 = _xhr.response;
              if (status >= 200 && status < 300) {
                this.callback(null, response2);
              } else {
                this.requestDidError(event2);
              }
            }
          }, {
            key: "requestDidError",
            value: function requestDidError(event2) {
              this.callback('Error storing "' + this.file.name + '". Status: ' + this.xhr.status);
            }
          }]);
          return BlobUpload2;
        }();
        var id = 0;
        var DirectUpload3 = function() {
          function DirectUpload4(file, url, delegate) {
            classCallCheck(this, DirectUpload4);
            this.id = ++id;
            this.file = file;
            this.url = url;
            this.delegate = delegate;
          }
          createClass(DirectUpload4, [{
            key: "create",
            value: function create(callback2) {
              var _this = this;
              FileChecksum.create(this.file, function(error3, checksum) {
                if (error3) {
                  callback2(error3);
                  return;
                }
                var blob = new BlobRecord(_this.file, checksum, _this.url);
                notify(_this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
                blob.create(function(error4) {
                  if (error4) {
                    callback2(error4);
                  } else {
                    var upload = new BlobUpload(blob);
                    notify(_this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
                    upload.create(function(error5) {
                      if (error5) {
                        callback2(error5);
                      } else {
                        callback2(null, blob.toJSON());
                      }
                    });
                  }
                });
              });
            }
          }]);
          return DirectUpload4;
        }();
        function notify(object, methodName) {
          if (object && typeof object[methodName] == "function") {
            for (var _len = arguments.length, messages = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              messages[_key - 2] = arguments[_key];
            }
            return object[methodName].apply(object, messages);
          }
        }
        var DirectUploadController = function() {
          function DirectUploadController2(input, file) {
            classCallCheck(this, DirectUploadController2);
            this.input = input;
            this.file = file;
            this.directUpload = new DirectUpload3(this.file, this.url, this);
            this.dispatch("initialize");
          }
          createClass(DirectUploadController2, [{
            key: "start",
            value: function start6(callback2) {
              var _this = this;
              var hiddenInput = document.createElement("input");
              hiddenInput.type = "hidden";
              hiddenInput.name = this.input.name;
              this.input.insertAdjacentElement("beforebegin", hiddenInput);
              this.dispatch("start");
              this.directUpload.create(function(error3, attributes) {
                if (error3) {
                  hiddenInput.parentNode.removeChild(hiddenInput);
                  _this.dispatchError(error3);
                } else {
                  hiddenInput.value = attributes.signed_id;
                }
                _this.dispatch("end");
                callback2(error3);
              });
            }
          }, {
            key: "uploadRequestDidProgress",
            value: function uploadRequestDidProgress(event2) {
              var progress = event2.loaded / event2.total * 100;
              if (progress) {
                this.dispatch("progress", {
                  progress
                });
              }
            }
          }, {
            key: "dispatch",
            value: function dispatch4(name2) {
              var detail = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              detail.file = this.file;
              detail.id = this.directUpload.id;
              return dispatchEvent2(this.input, "direct-upload:" + name2, {
                detail
              });
            }
          }, {
            key: "dispatchError",
            value: function dispatchError(error3) {
              var event2 = this.dispatch("error", {
                error: error3
              });
              if (!event2.defaultPrevented) {
                alert(error3);
              }
            }
          }, {
            key: "directUploadWillCreateBlobWithXHR",
            value: function directUploadWillCreateBlobWithXHR(xhr) {
              this.dispatch("before-blob-request", {
                xhr
              });
            }
          }, {
            key: "directUploadWillStoreFileWithXHR",
            value: function directUploadWillStoreFileWithXHR(xhr) {
              var _this2 = this;
              this.dispatch("before-storage-request", {
                xhr
              });
              xhr.upload.addEventListener("progress", function(event2) {
                return _this2.uploadRequestDidProgress(event2);
              });
            }
          }, {
            key: "url",
            get: function get$$1() {
              return this.input.getAttribute("data-direct-upload-url");
            }
          }]);
          return DirectUploadController2;
        }();
        var inputSelector = "input[type=file][data-direct-upload-url]:not([disabled])";
        var DirectUploadsController = function() {
          function DirectUploadsController2(form) {
            classCallCheck(this, DirectUploadsController2);
            this.form = form;
            this.inputs = findElements(form, inputSelector).filter(function(input) {
              return input.files.length;
            });
          }
          createClass(DirectUploadsController2, [{
            key: "start",
            value: function start6(callback2) {
              var _this = this;
              var controllers2 = this.createDirectUploadControllers();
              var startNextController = function startNextController2() {
                var controller = controllers2.shift();
                if (controller) {
                  controller.start(function(error3) {
                    if (error3) {
                      callback2(error3);
                      _this.dispatch("end");
                    } else {
                      startNextController2();
                    }
                  });
                } else {
                  callback2();
                  _this.dispatch("end");
                }
              };
              this.dispatch("start");
              startNextController();
            }
          }, {
            key: "createDirectUploadControllers",
            value: function createDirectUploadControllers() {
              var controllers2 = [];
              this.inputs.forEach(function(input) {
                toArray$1(input.files).forEach(function(file) {
                  var controller = new DirectUploadController(input, file);
                  controllers2.push(controller);
                });
              });
              return controllers2;
            }
          }, {
            key: "dispatch",
            value: function dispatch4(name2) {
              var detail = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return dispatchEvent2(this.form, "direct-uploads:" + name2, {
                detail
              });
            }
          }]);
          return DirectUploadsController2;
        }();
        var processingAttribute = "data-direct-uploads-processing";
        var submitButtonsByForm = /* @__PURE__ */ new WeakMap();
        var started = false;
        function start5() {
          if (!started) {
            started = true;
            document.addEventListener("click", didClick, true);
            document.addEventListener("submit", didSubmitForm);
            document.addEventListener("ajax:before", didSubmitRemoteElement);
          }
        }
        function didClick(event2) {
          var target = event2.target;
          if ((target.tagName == "INPUT" || target.tagName == "BUTTON") && target.type == "submit" && target.form) {
            submitButtonsByForm.set(target.form, target);
          }
        }
        function didSubmitForm(event2) {
          handleFormSubmissionEvent(event2);
        }
        function didSubmitRemoteElement(event2) {
          if (event2.target.tagName == "FORM") {
            handleFormSubmissionEvent(event2);
          }
        }
        function handleFormSubmissionEvent(event2) {
          var form = event2.target;
          if (form.hasAttribute(processingAttribute)) {
            event2.preventDefault();
            return;
          }
          var controller = new DirectUploadsController(form);
          var inputs = controller.inputs;
          if (inputs.length) {
            event2.preventDefault();
            form.setAttribute(processingAttribute, "");
            inputs.forEach(disable);
            controller.start(function(error3) {
              form.removeAttribute(processingAttribute);
              if (error3) {
                inputs.forEach(enable);
              } else {
                submitForm(form);
              }
            });
          }
        }
        function submitForm(form) {
          var button = submitButtonsByForm.get(form) || findElement(form, "input[type=submit], button[type=submit]");
          if (button) {
            var _button = button, disabled = _button.disabled;
            button.disabled = false;
            button.focus();
            button.click();
            button.disabled = disabled;
          } else {
            button = document.createElement("input");
            button.type = "submit";
            button.style.display = "none";
            form.appendChild(button);
            button.click();
            form.removeChild(button);
          }
          submitButtonsByForm.delete(form);
        }
        function disable(input) {
          input.disabled = true;
        }
        function enable(input) {
          input.disabled = false;
        }
        function autostart() {
          if (window.ActiveStorage) {
            start5();
          }
        }
        setTimeout(autostart, 1);
        exports2.start = start5;
        exports2.DirectUpload = DirectUpload3;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
      });
    }
  });

  // node_modules/intl-tel-input/build/js/intlTelInput.js
  var require_intlTelInput = __commonJS({
    "node_modules/intl-tel-input/build/js/intlTelInput.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function(factory) {
        if (typeof module2 === "object" && module2.exports) module2.exports = factory();
        else window.intlTelInput = factory();
      })(function(undefined2) {
        "use strict";
        return function() {
          var allCountries = [["Afghanistan (\u202B\u0627\u0641\u063A\u0627\u0646\u0633\u062A\u0627\u0646\u202C\u200E)", "af", "93"], ["Albania (Shqip\xEBri)", "al", "355"], ["Algeria (\u202B\u0627\u0644\u062C\u0632\u0627\u0626\u0631\u202C\u200E)", "dz", "213"], ["American Samoa", "as", "1", 5, ["684"]], ["Andorra", "ad", "376"], ["Angola", "ao", "244"], ["Anguilla", "ai", "1", 6, ["264"]], ["Antigua and Barbuda", "ag", "1", 7, ["268"]], ["Argentina", "ar", "54"], ["Armenia (\u0540\u0561\u0575\u0561\u057D\u057F\u0561\u0576)", "am", "374"], ["Aruba", "aw", "297"], ["Australia", "au", "61", 0], ["Austria (\xD6sterreich)", "at", "43"], ["Azerbaijan (Az\u0259rbaycan)", "az", "994"], ["Bahamas", "bs", "1", 8, ["242"]], ["Bahrain (\u202B\u0627\u0644\u0628\u062D\u0631\u064A\u0646\u202C\u200E)", "bh", "973"], ["Bangladesh (\u09AC\u09BE\u0982\u09B2\u09BE\u09A6\u09C7\u09B6)", "bd", "880"], ["Barbados", "bb", "1", 9, ["246"]], ["Belarus (\u0411\u0435\u043B\u0430\u0440\u0443\u0441\u044C)", "by", "375"], ["Belgium (Belgi\xEB)", "be", "32"], ["Belize", "bz", "501"], ["Benin (B\xE9nin)", "bj", "229"], ["Bermuda", "bm", "1", 10, ["441"]], ["Bhutan (\u0F60\u0F56\u0FB2\u0F74\u0F42)", "bt", "975"], ["Bolivia", "bo", "591"], ["Bosnia and Herzegovina (\u0411\u043E\u0441\u043D\u0430 \u0438 \u0425\u0435\u0440\u0446\u0435\u0433\u043E\u0432\u0438\u043D\u0430)", "ba", "387"], ["Botswana", "bw", "267"], ["Brazil (Brasil)", "br", "55"], ["British Indian Ocean Territory", "io", "246"], ["British Virgin Islands", "vg", "1", 11, ["284"]], ["Brunei", "bn", "673"], ["Bulgaria (\u0411\u044A\u043B\u0433\u0430\u0440\u0438\u044F)", "bg", "359"], ["Burkina Faso", "bf", "226"], ["Burundi (Uburundi)", "bi", "257"], ["Cambodia (\u1780\u1798\u17D2\u1796\u17BB\u1787\u17B6)", "kh", "855"], ["Cameroon (Cameroun)", "cm", "237"], ["Canada", "ca", "1", 1, ["204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905"]], ["Cape Verde (Kabu Verdi)", "cv", "238"], ["Caribbean Netherlands", "bq", "599", 1, ["3", "4", "7"]], ["Cayman Islands", "ky", "1", 12, ["345"]], ["Central African Republic (R\xE9publique centrafricaine)", "cf", "236"], ["Chad (Tchad)", "td", "235"], ["Chile", "cl", "56"], ["China (\u4E2D\u56FD)", "cn", "86"], ["Christmas Island", "cx", "61", 2, ["89164"]], ["Cocos (Keeling) Islands", "cc", "61", 1, ["89162"]], ["Colombia", "co", "57"], ["Comoros (\u202B\u062C\u0632\u0631 \u0627\u0644\u0642\u0645\u0631\u202C\u200E)", "km", "269"], ["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)", "cd", "243"], ["Congo (Republic) (Congo-Brazzaville)", "cg", "242"], ["Cook Islands", "ck", "682"], ["Costa Rica", "cr", "506"], ["C\xF4te d\u2019Ivoire", "ci", "225"], ["Croatia (Hrvatska)", "hr", "385"], ["Cuba", "cu", "53"], ["Cura\xE7ao", "cw", "599", 0], ["Cyprus (\u039A\u03CD\u03C0\u03C1\u03BF\u03C2)", "cy", "357"], ["Czech Republic (\u010Cesk\xE1 republika)", "cz", "420"], ["Denmark (Danmark)", "dk", "45"], ["Djibouti", "dj", "253"], ["Dominica", "dm", "1", 13, ["767"]], ["Dominican Republic (Rep\xFAblica Dominicana)", "do", "1", 2, ["809", "829", "849"]], ["Ecuador", "ec", "593"], ["Egypt (\u202B\u0645\u0635\u0631\u202C\u200E)", "eg", "20"], ["El Salvador", "sv", "503"], ["Equatorial Guinea (Guinea Ecuatorial)", "gq", "240"], ["Eritrea", "er", "291"], ["Estonia (Eesti)", "ee", "372"], ["Ethiopia", "et", "251"], ["Falkland Islands (Islas Malvinas)", "fk", "500"], ["Faroe Islands (F\xF8royar)", "fo", "298"], ["Fiji", "fj", "679"], ["Finland (Suomi)", "fi", "358", 0], ["France", "fr", "33"], ["French Guiana (Guyane fran\xE7aise)", "gf", "594"], ["French Polynesia (Polyn\xE9sie fran\xE7aise)", "pf", "689"], ["Gabon", "ga", "241"], ["Gambia", "gm", "220"], ["Georgia (\u10E1\u10D0\u10E5\u10D0\u10E0\u10D7\u10D5\u10D4\u10DA\u10DD)", "ge", "995"], ["Germany (Deutschland)", "de", "49"], ["Ghana (Gaana)", "gh", "233"], ["Gibraltar", "gi", "350"], ["Greece (\u0395\u03BB\u03BB\u03AC\u03B4\u03B1)", "gr", "30"], ["Greenland (Kalaallit Nunaat)", "gl", "299"], ["Grenada", "gd", "1", 14, ["473"]], ["Guadeloupe", "gp", "590", 0], ["Guam", "gu", "1", 15, ["671"]], ["Guatemala", "gt", "502"], ["Guernsey", "gg", "44", 1, ["1481", "7781", "7839", "7911"]], ["Guinea (Guin\xE9e)", "gn", "224"], ["Guinea-Bissau (Guin\xE9 Bissau)", "gw", "245"], ["Guyana", "gy", "592"], ["Haiti", "ht", "509"], ["Honduras", "hn", "504"], ["Hong Kong (\u9999\u6E2F)", "hk", "852"], ["Hungary (Magyarorsz\xE1g)", "hu", "36"], ["Iceland (\xCDsland)", "is", "354"], ["India (\u092D\u093E\u0930\u0924)", "in", "91"], ["Indonesia", "id", "62"], ["Iran (\u202B\u0627\u06CC\u0631\u0627\u0646\u202C\u200E)", "ir", "98"], ["Iraq (\u202B\u0627\u0644\u0639\u0631\u0627\u0642\u202C\u200E)", "iq", "964"], ["Ireland", "ie", "353"], ["Isle of Man", "im", "44", 2, ["1624", "74576", "7524", "7924", "7624"]], ["Israel (\u202B\u05D9\u05E9\u05E8\u05D0\u05DC\u202C\u200E)", "il", "972"], ["Italy (Italia)", "it", "39", 0], ["Jamaica", "jm", "1", 4, ["876", "658"]], ["Japan (\u65E5\u672C)", "jp", "81"], ["Jersey", "je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"]], ["Jordan (\u202B\u0627\u0644\u0623\u0631\u062F\u0646\u202C\u200E)", "jo", "962"], ["Kazakhstan (\u041A\u0430\u0437\u0430\u0445\u0441\u0442\u0430\u043D)", "kz", "7", 1, ["33", "7"]], ["Kenya", "ke", "254"], ["Kiribati", "ki", "686"], ["Kosovo", "xk", "383"], ["Kuwait (\u202B\u0627\u0644\u0643\u0648\u064A\u062A\u202C\u200E)", "kw", "965"], ["Kyrgyzstan (\u041A\u044B\u0440\u0433\u044B\u0437\u0441\u0442\u0430\u043D)", "kg", "996"], ["Laos (\u0EA5\u0EB2\u0EA7)", "la", "856"], ["Latvia (Latvija)", "lv", "371"], ["Lebanon (\u202B\u0644\u0628\u0646\u0627\u0646\u202C\u200E)", "lb", "961"], ["Lesotho", "ls", "266"], ["Liberia", "lr", "231"], ["Libya (\u202B\u0644\u064A\u0628\u064A\u0627\u202C\u200E)", "ly", "218"], ["Liechtenstein", "li", "423"], ["Lithuania (Lietuva)", "lt", "370"], ["Luxembourg", "lu", "352"], ["Macau (\u6FB3\u9580)", "mo", "853"], ["Macedonia (FYROM) (\u041C\u0430\u043A\u0435\u0434\u043E\u043D\u0438\u0458\u0430)", "mk", "389"], ["Madagascar (Madagasikara)", "mg", "261"], ["Malawi", "mw", "265"], ["Malaysia", "my", "60"], ["Maldives", "mv", "960"], ["Mali", "ml", "223"], ["Malta", "mt", "356"], ["Marshall Islands", "mh", "692"], ["Martinique", "mq", "596"], ["Mauritania (\u202B\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627\u202C\u200E)", "mr", "222"], ["Mauritius (Moris)", "mu", "230"], ["Mayotte", "yt", "262", 1, ["269", "639"]], ["Mexico (M\xE9xico)", "mx", "52"], ["Micronesia", "fm", "691"], ["Moldova (Republica Moldova)", "md", "373"], ["Monaco", "mc", "377"], ["Mongolia (\u041C\u043E\u043D\u0433\u043E\u043B)", "mn", "976"], ["Montenegro (Crna Gora)", "me", "382"], ["Montserrat", "ms", "1", 16, ["664"]], ["Morocco (\u202B\u0627\u0644\u0645\u063A\u0631\u0628\u202C\u200E)", "ma", "212", 0], ["Mozambique (Mo\xE7ambique)", "mz", "258"], ["Myanmar (Burma) (\u1019\u103C\u1014\u103A\u1019\u102C)", "mm", "95"], ["Namibia (Namibi\xEB)", "na", "264"], ["Nauru", "nr", "674"], ["Nepal (\u0928\u0947\u092A\u093E\u0932)", "np", "977"], ["Netherlands (Nederland)", "nl", "31"], ["New Caledonia (Nouvelle-Cal\xE9donie)", "nc", "687"], ["New Zealand", "nz", "64"], ["Nicaragua", "ni", "505"], ["Niger (Nijar)", "ne", "227"], ["Nigeria", "ng", "234"], ["Niue", "nu", "683"], ["Norfolk Island", "nf", "672"], ["North Korea (\uC870\uC120 \uBBFC\uC8FC\uC8FC\uC758 \uC778\uBBFC \uACF5\uD654\uAD6D)", "kp", "850"], ["Northern Mariana Islands", "mp", "1", 17, ["670"]], ["Norway (Norge)", "no", "47", 0], ["Oman (\u202B\u0639\u064F\u0645\u0627\u0646\u202C\u200E)", "om", "968"], ["Pakistan (\u202B\u067E\u0627\u06A9\u0633\u062A\u0627\u0646\u202C\u200E)", "pk", "92"], ["Palau", "pw", "680"], ["Palestine (\u202B\u0641\u0644\u0633\u0637\u064A\u0646\u202C\u200E)", "ps", "970"], ["Panama (Panam\xE1)", "pa", "507"], ["Papua New Guinea", "pg", "675"], ["Paraguay", "py", "595"], ["Peru (Per\xFA)", "pe", "51"], ["Philippines", "ph", "63"], ["Poland (Polska)", "pl", "48"], ["Portugal", "pt", "351"], ["Puerto Rico", "pr", "1", 3, ["787", "939"]], ["Qatar (\u202B\u0642\u0637\u0631\u202C\u200E)", "qa", "974"], ["R\xE9union (La R\xE9union)", "re", "262", 0], ["Romania (Rom\xE2nia)", "ro", "40"], ["Russia (\u0420\u043E\u0441\u0441\u0438\u044F)", "ru", "7", 0], ["Rwanda", "rw", "250"], ["Saint Barth\xE9lemy", "bl", "590", 1], ["Saint Helena", "sh", "290"], ["Saint Kitts and Nevis", "kn", "1", 18, ["869"]], ["Saint Lucia", "lc", "1", 19, ["758"]], ["Saint Martin (Saint-Martin (partie fran\xE7aise))", "mf", "590", 2], ["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)", "pm", "508"], ["Saint Vincent and the Grenadines", "vc", "1", 20, ["784"]], ["Samoa", "ws", "685"], ["San Marino", "sm", "378"], ["S\xE3o Tom\xE9 and Pr\xEDncipe (S\xE3o Tom\xE9 e Pr\xEDncipe)", "st", "239"], ["Saudi Arabia (\u202B\u0627\u0644\u0645\u0645\u0644\u0643\u0629 \u0627\u0644\u0639\u0631\u0628\u064A\u0629 \u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629\u202C\u200E)", "sa", "966"], ["Senegal (S\xE9n\xE9gal)", "sn", "221"], ["Serbia (\u0421\u0440\u0431\u0438\u0458\u0430)", "rs", "381"], ["Seychelles", "sc", "248"], ["Sierra Leone", "sl", "232"], ["Singapore", "sg", "65"], ["Sint Maarten", "sx", "1", 21, ["721"]], ["Slovakia (Slovensko)", "sk", "421"], ["Slovenia (Slovenija)", "si", "386"], ["Solomon Islands", "sb", "677"], ["Somalia (Soomaaliya)", "so", "252"], ["South Africa", "za", "27"], ["South Korea (\uB300\uD55C\uBBFC\uAD6D)", "kr", "82"], ["South Sudan (\u202B\u062C\u0646\u0648\u0628 \u0627\u0644\u0633\u0648\u062F\u0627\u0646\u202C\u200E)", "ss", "211"], ["Spain (Espa\xF1a)", "es", "34"], ["Sri Lanka (\u0DC1\u0DCA\u200D\u0DBB\u0DD3 \u0DBD\u0D82\u0D9A\u0DCF\u0DC0)", "lk", "94"], ["Sudan (\u202B\u0627\u0644\u0633\u0648\u062F\u0627\u0646\u202C\u200E)", "sd", "249"], ["Suriname", "sr", "597"], ["Svalbard and Jan Mayen", "sj", "47", 1, ["79"]], ["Swaziland", "sz", "268"], ["Sweden (Sverige)", "se", "46"], ["Switzerland (Schweiz)", "ch", "41"], ["Syria (\u202B\u0633\u0648\u0631\u064A\u0627\u202C\u200E)", "sy", "963"], ["Taiwan (\u53F0\u7063)", "tw", "886"], ["Tajikistan", "tj", "992"], ["Tanzania", "tz", "255"], ["Thailand (\u0E44\u0E17\u0E22)", "th", "66"], ["Timor-Leste", "tl", "670"], ["Togo", "tg", "228"], ["Tokelau", "tk", "690"], ["Tonga", "to", "676"], ["Trinidad and Tobago", "tt", "1", 22, ["868"]], ["Tunisia (\u202B\u062A\u0648\u0646\u0633\u202C\u200E)", "tn", "216"], ["Turkey (T\xFCrkiye)", "tr", "90"], ["Turkmenistan", "tm", "993"], ["Turks and Caicos Islands", "tc", "1", 23, ["649"]], ["Tuvalu", "tv", "688"], ["U.S. Virgin Islands", "vi", "1", 24, ["340"]], ["Uganda", "ug", "256"], ["Ukraine (\u0423\u043A\u0440\u0430\u0457\u043D\u0430)", "ua", "380"], ["United Arab Emirates (\u202B\u0627\u0644\u0625\u0645\u0627\u0631\u0627\u062A \u0627\u0644\u0639\u0631\u0628\u064A\u0629 \u0627\u0644\u0645\u062A\u062D\u062F\u0629\u202C\u200E)", "ae", "971"], ["United Kingdom", "gb", "44", 0], ["United States", "us", "1", 0], ["Uruguay", "uy", "598"], ["Uzbekistan (O\u02BBzbekiston)", "uz", "998"], ["Vanuatu", "vu", "678"], ["Vatican City (Citt\xE0 del Vaticano)", "va", "39", 1, ["06698"]], ["Venezuela", "ve", "58"], ["Vietnam (Vi\u1EC7t Nam)", "vn", "84"], ["Wallis and Futuna (Wallis-et-Futuna)", "wf", "681"], ["Western Sahara (\u202B\u0627\u0644\u0635\u062D\u0631\u0627\u0621 \u0627\u0644\u063A\u0631\u0628\u064A\u0629\u202C\u200E)", "eh", "212", 1, ["5288", "5289"]], ["Yemen (\u202B\u0627\u0644\u064A\u0645\u0646\u202C\u200E)", "ye", "967"], ["Zambia", "zm", "260"], ["Zimbabwe", "zw", "263"], ["\xC5land Islands", "ax", "358", 1, ["18"]]];
          for (var i3 = 0; i3 < allCountries.length; i3++) {
            var c4 = allCountries[i3];
            allCountries[i3] = {
              name: c4[0],
              iso2: c4[1],
              dialCode: c4[2],
              priority: c4[3] || 0,
              areaCodes: c4[4] || null
            };
          }
          "use strict";
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties2(target, props) {
            for (var i4 = 0; i4 < props.length; i4++) {
              var descriptor = props[i4];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass2(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties2(Constructor, staticProps);
            return Constructor;
          }
          var intlTelInputGlobals = {
            getInstance: function getInstance(input) {
              var id2 = input.getAttribute("data-intl-tel-input-id");
              return window.intlTelInputGlobals.instances[id2];
            },
            instances: {},
            // using a global like this allows us to mock it in the tests
            documentReady: function documentReady() {
              return document.readyState === "complete";
            }
          };
          if (typeof window === "object") window.intlTelInputGlobals = intlTelInputGlobals;
          var id = 0;
          var defaults3 = {
            // whether or not to allow the dropdown
            allowDropdown: true,
            // if there is just a dial code in the input: remove it on blur
            autoHideDialCode: true,
            // add a placeholder in the input with an example number for the selected country
            autoPlaceholder: "polite",
            // modify the parentClass
            customContainer: "",
            // modify the auto placeholder
            customPlaceholder: null,
            // append menu to specified element
            dropdownContainer: null,
            // don't display these countries
            excludeCountries: [],
            // format the input value during initialisation and on setNumber
            formatOnDisplay: true,
            // geoIp lookup function
            geoIpLookup: null,
            // inject a hidden input with this name, and on submit, populate it with the result of getNumber
            hiddenInput: "",
            // initial country
            initialCountry: "",
            // localized country names e.g. { 'de': 'Deutschland' }
            localizedCountries: null,
            // don't insert international dial codes
            nationalMode: true,
            // display only these countries
            onlyCountries: [],
            // number type to use for placeholders
            placeholderNumberType: "MOBILE",
            // the countries at the top of the list. defaults to united states and united kingdom
            preferredCountries: ["us", "gb"],
            // display the country dial code next to the selected flag so it's not part of the typed number
            separateDialCode: false,
            // specify the path to the libphonenumber script to enable validation/formatting
            utilsScript: ""
          };
          var regionlessNanpNumbers = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"];
          var forEachProp = function forEachProp2(obj, callback2) {
            var keys = Object.keys(obj);
            for (var i4 = 0; i4 < keys.length; i4++) {
              callback2(keys[i4], obj[keys[i4]]);
            }
          };
          var forEachInstance = function forEachInstance2(method) {
            forEachProp(window.intlTelInputGlobals.instances, function(key) {
              window.intlTelInputGlobals.instances[key][method]();
            });
          };
          var Iti = /* @__PURE__ */ function() {
            function Iti2(input, options) {
              var _this = this;
              _classCallCheck2(this, Iti2);
              this.id = id++;
              this.telInput = input;
              this.activeItem = null;
              this.highlightedItem = null;
              var customOptions = options || {};
              this.options = {};
              forEachProp(defaults3, function(key, value) {
                _this.options[key] = customOptions.hasOwnProperty(key) ? customOptions[key] : value;
              });
              this.hadInitialPlaceholder = Boolean(input.getAttribute("placeholder"));
            }
            _createClass2(Iti2, [{
              key: "_init",
              value: function _init() {
                var _this2 = this;
                if (this.options.nationalMode) this.options.autoHideDialCode = false;
                if (this.options.separateDialCode) {
                  this.options.autoHideDialCode = this.options.nationalMode = false;
                }
                this.isMobile = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (this.isMobile) {
                  document.body.classList.add("iti-mobile");
                  if (!this.options.dropdownContainer) this.options.dropdownContainer = document.body;
                }
                if (typeof Promise !== "undefined") {
                  var autoCountryPromise = new Promise(function(resolve2, reject) {
                    _this2.resolveAutoCountryPromise = resolve2;
                    _this2.rejectAutoCountryPromise = reject;
                  });
                  var utilsScriptPromise = new Promise(function(resolve2, reject) {
                    _this2.resolveUtilsScriptPromise = resolve2;
                    _this2.rejectUtilsScriptPromise = reject;
                  });
                  this.promise = Promise.all([autoCountryPromise, utilsScriptPromise]);
                } else {
                  this.resolveAutoCountryPromise = this.rejectAutoCountryPromise = function() {
                  };
                  this.resolveUtilsScriptPromise = this.rejectUtilsScriptPromise = function() {
                  };
                }
                this.selectedCountryData = {};
                this._processCountryData();
                this._generateMarkup();
                this._setInitialState();
                this._initListeners();
                this._initRequests();
              }
            }, {
              key: "_processCountryData",
              value: function _processCountryData() {
                this._processAllCountries();
                this._processCountryCodes();
                this._processPreferredCountries();
                if (this.options.localizedCountries) this._translateCountriesByLocale();
                if (this.options.onlyCountries.length || this.options.localizedCountries) {
                  this.countries.sort(this._countryNameSort);
                }
              }
            }, {
              key: "_addCountryCode",
              value: function _addCountryCode(iso2, countryCode, priority) {
                if (countryCode.length > this.countryCodeMaxLen) {
                  this.countryCodeMaxLen = countryCode.length;
                }
                if (!this.countryCodes.hasOwnProperty(countryCode)) {
                  this.countryCodes[countryCode] = [];
                }
                for (var i4 = 0; i4 < this.countryCodes[countryCode].length; i4++) {
                  if (this.countryCodes[countryCode][i4] === iso2) return;
                }
                var index2 = priority !== undefined2 ? priority : this.countryCodes[countryCode].length;
                this.countryCodes[countryCode][index2] = iso2;
              }
            }, {
              key: "_processAllCountries",
              value: function _processAllCountries() {
                if (this.options.onlyCountries.length) {
                  var lowerCaseOnlyCountries = this.options.onlyCountries.map(function(country) {
                    return country.toLowerCase();
                  });
                  this.countries = allCountries.filter(function(country) {
                    return lowerCaseOnlyCountries.indexOf(country.iso2) > -1;
                  });
                } else if (this.options.excludeCountries.length) {
                  var lowerCaseExcludeCountries = this.options.excludeCountries.map(function(country) {
                    return country.toLowerCase();
                  });
                  this.countries = allCountries.filter(function(country) {
                    return lowerCaseExcludeCountries.indexOf(country.iso2) === -1;
                  });
                } else {
                  this.countries = allCountries;
                }
              }
            }, {
              key: "_translateCountriesByLocale",
              value: function _translateCountriesByLocale() {
                for (var i4 = 0; i4 < this.countries.length; i4++) {
                  var iso = this.countries[i4].iso2.toLowerCase();
                  if (this.options.localizedCountries.hasOwnProperty(iso)) {
                    this.countries[i4].name = this.options.localizedCountries[iso];
                  }
                }
              }
            }, {
              key: "_countryNameSort",
              value: function _countryNameSort(a5, b5) {
                return a5.name.localeCompare(b5.name);
              }
            }, {
              key: "_processCountryCodes",
              value: function _processCountryCodes() {
                this.countryCodeMaxLen = 0;
                this.dialCodes = {};
                this.countryCodes = {};
                for (var i4 = 0; i4 < this.countries.length; i4++) {
                  var c5 = this.countries[i4];
                  if (!this.dialCodes[c5.dialCode]) this.dialCodes[c5.dialCode] = true;
                  this._addCountryCode(c5.iso2, c5.dialCode, c5.priority);
                }
                for (var _i2 = 0; _i2 < this.countries.length; _i2++) {
                  var _c = this.countries[_i2];
                  if (_c.areaCodes) {
                    var rootCountryCode = this.countryCodes[_c.dialCode][0];
                    for (var j6 = 0; j6 < _c.areaCodes.length; j6++) {
                      var areaCode = _c.areaCodes[j6];
                      for (var k4 = 1; k4 < areaCode.length; k4++) {
                        var partialDialCode = _c.dialCode + areaCode.substr(0, k4);
                        this._addCountryCode(rootCountryCode, partialDialCode);
                        this._addCountryCode(_c.iso2, partialDialCode);
                      }
                      this._addCountryCode(_c.iso2, _c.dialCode + areaCode);
                    }
                  }
                }
              }
            }, {
              key: "_processPreferredCountries",
              value: function _processPreferredCountries() {
                this.preferredCountries = [];
                for (var i4 = 0; i4 < this.options.preferredCountries.length; i4++) {
                  var countryCode = this.options.preferredCountries[i4].toLowerCase();
                  var countryData = this._getCountryData(countryCode, false, true);
                  if (countryData) this.preferredCountries.push(countryData);
                }
              }
            }, {
              key: "_createEl",
              value: function _createEl(name2, attrs, container) {
                var el = document.createElement(name2);
                if (attrs) forEachProp(attrs, function(key, value) {
                  return el.setAttribute(key, value);
                });
                if (container) container.appendChild(el);
                return el;
              }
            }, {
              key: "_generateMarkup",
              value: function _generateMarkup() {
                if (!this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete"))) {
                  this.telInput.setAttribute("autocomplete", "off");
                }
                var parentClass = "iti";
                if (this.options.allowDropdown) parentClass += " iti--allow-dropdown";
                if (this.options.separateDialCode) parentClass += " iti--separate-dial-code";
                if (this.options.customContainer) {
                  parentClass += " ";
                  parentClass += this.options.customContainer;
                }
                var wrapper = this._createEl("div", {
                  "class": parentClass
                });
                this.telInput.parentNode.insertBefore(wrapper, this.telInput);
                this.flagsContainer = this._createEl("div", {
                  "class": "iti__flag-container"
                }, wrapper);
                wrapper.appendChild(this.telInput);
                this.selectedFlag = this._createEl("div", {
                  "class": "iti__selected-flag",
                  role: "combobox",
                  "aria-controls": "iti-".concat(this.id, "__country-listbox"),
                  "aria-owns": "iti-".concat(this.id, "__country-listbox"),
                  "aria-expanded": "false"
                }, this.flagsContainer);
                this.selectedFlagInner = this._createEl("div", {
                  "class": "iti__flag"
                }, this.selectedFlag);
                if (this.options.separateDialCode) {
                  this.selectedDialCode = this._createEl("div", {
                    "class": "iti__selected-dial-code"
                  }, this.selectedFlag);
                }
                if (this.options.allowDropdown) {
                  this.selectedFlag.setAttribute("tabindex", "0");
                  this.dropdownArrow = this._createEl("div", {
                    "class": "iti__arrow"
                  }, this.selectedFlag);
                  this.countryList = this._createEl("ul", {
                    "class": "iti__country-list iti__hide",
                    id: "iti-".concat(this.id, "__country-listbox"),
                    role: "listbox",
                    "aria-label": "List of countries"
                  });
                  if (this.preferredCountries.length) {
                    this._appendListItems(this.preferredCountries, "iti__preferred", true);
                    this._createEl("li", {
                      "class": "iti__divider",
                      role: "separator",
                      "aria-disabled": "true"
                    }, this.countryList);
                  }
                  this._appendListItems(this.countries, "iti__standard");
                  if (this.options.dropdownContainer) {
                    this.dropdown = this._createEl("div", {
                      "class": "iti iti--container"
                    });
                    this.dropdown.appendChild(this.countryList);
                  } else {
                    this.flagsContainer.appendChild(this.countryList);
                  }
                }
                if (this.options.hiddenInput) {
                  var hiddenInputName = this.options.hiddenInput;
                  var name2 = this.telInput.getAttribute("name");
                  if (name2) {
                    var i4 = name2.lastIndexOf("[");
                    if (i4 !== -1) hiddenInputName = "".concat(name2.substr(0, i4), "[").concat(hiddenInputName, "]");
                  }
                  this.hiddenInput = this._createEl("input", {
                    type: "hidden",
                    name: hiddenInputName
                  });
                  wrapper.appendChild(this.hiddenInput);
                }
              }
            }, {
              key: "_appendListItems",
              value: function _appendListItems(countries, className, preferred) {
                var tmp = "";
                for (var i4 = 0; i4 < countries.length; i4++) {
                  var c5 = countries[i4];
                  var idSuffix = preferred ? "-preferred" : "";
                  tmp += "<li class='iti__country ".concat(className, "' tabIndex='-1' id='iti-").concat(this.id, "__item-").concat(c5.iso2).concat(idSuffix, "' role='option' data-dial-code='").concat(c5.dialCode, "' data-country-code='").concat(c5.iso2, "' aria-selected='false'>");
                  tmp += "<div class='iti__flag-box'><div class='iti__flag iti__".concat(c5.iso2, "'></div></div>");
                  tmp += "<span class='iti__country-name'>".concat(c5.name, "</span>");
                  tmp += "<span class='iti__dial-code'>+".concat(c5.dialCode, "</span>");
                  tmp += "</li>";
                }
                this.countryList.insertAdjacentHTML("beforeend", tmp);
              }
            }, {
              key: "_setInitialState",
              value: function _setInitialState() {
                var val = this.telInput.value;
                var dialCode = this._getDialCode(val);
                var isRegionlessNanp = this._isRegionlessNanp(val);
                var _this$options = this.options, initialCountry = _this$options.initialCountry, nationalMode = _this$options.nationalMode, autoHideDialCode = _this$options.autoHideDialCode, separateDialCode = _this$options.separateDialCode;
                if (dialCode && !isRegionlessNanp) {
                  this._updateFlagFromNumber(val);
                } else if (initialCountry !== "auto") {
                  if (initialCountry) {
                    this._setFlag(initialCountry.toLowerCase());
                  } else {
                    if (dialCode && isRegionlessNanp) {
                      this._setFlag("us");
                    } else {
                      this.defaultCountry = this.preferredCountries.length ? this.preferredCountries[0].iso2 : this.countries[0].iso2;
                      if (!val) {
                        this._setFlag(this.defaultCountry);
                      }
                    }
                  }
                  if (!val && !nationalMode && !autoHideDialCode && !separateDialCode) {
                    this.telInput.value = "+".concat(this.selectedCountryData.dialCode);
                  }
                }
                if (val) this._updateValFromNumber(val);
              }
            }, {
              key: "_initListeners",
              value: function _initListeners() {
                this._initKeyListeners();
                if (this.options.autoHideDialCode) this._initBlurListeners();
                if (this.options.allowDropdown) this._initDropdownListeners();
                if (this.hiddenInput) this._initHiddenInputListener();
              }
            }, {
              key: "_initHiddenInputListener",
              value: function _initHiddenInputListener() {
                var _this3 = this;
                this._handleHiddenInputSubmit = function() {
                  _this3.hiddenInput.value = _this3.getNumber();
                };
                if (this.telInput.form) this.telInput.form.addEventListener("submit", this._handleHiddenInputSubmit);
              }
            }, {
              key: "_getClosestLabel",
              value: function _getClosestLabel() {
                var el = this.telInput;
                while (el && el.tagName !== "LABEL") {
                  el = el.parentNode;
                }
                return el;
              }
            }, {
              key: "_initDropdownListeners",
              value: function _initDropdownListeners() {
                var _this4 = this;
                this._handleLabelClick = function(e2) {
                  if (_this4.countryList.classList.contains("iti__hide")) _this4.telInput.focus();
                  else e2.preventDefault();
                };
                var label = this._getClosestLabel();
                if (label) label.addEventListener("click", this._handleLabelClick);
                this._handleClickSelectedFlag = function() {
                  if (_this4.countryList.classList.contains("iti__hide") && !_this4.telInput.disabled && !_this4.telInput.readOnly) {
                    _this4._showDropdown();
                  }
                };
                this.selectedFlag.addEventListener("click", this._handleClickSelectedFlag);
                this._handleFlagsContainerKeydown = function(e2) {
                  var isDropdownHidden = _this4.countryList.classList.contains("iti__hide");
                  if (isDropdownHidden && ["ArrowUp", "Up", "ArrowDown", "Down", " ", "Enter"].indexOf(e2.key) !== -1) {
                    e2.preventDefault();
                    e2.stopPropagation();
                    _this4._showDropdown();
                  }
                  if (e2.key === "Tab") _this4._closeDropdown();
                };
                this.flagsContainer.addEventListener("keydown", this._handleFlagsContainerKeydown);
              }
            }, {
              key: "_initRequests",
              value: function _initRequests() {
                var _this5 = this;
                if (this.options.utilsScript && !window.intlTelInputUtils) {
                  if (window.intlTelInputGlobals.documentReady()) {
                    window.intlTelInputGlobals.loadUtils(this.options.utilsScript);
                  } else {
                    window.addEventListener("load", function() {
                      window.intlTelInputGlobals.loadUtils(_this5.options.utilsScript);
                    });
                  }
                } else this.resolveUtilsScriptPromise();
                if (this.options.initialCountry === "auto") this._loadAutoCountry();
                else this.resolveAutoCountryPromise();
              }
            }, {
              key: "_loadAutoCountry",
              value: function _loadAutoCountry() {
                if (window.intlTelInputGlobals.autoCountry) {
                  this.handleAutoCountry();
                } else if (!window.intlTelInputGlobals.startedLoadingAutoCountry) {
                  window.intlTelInputGlobals.startedLoadingAutoCountry = true;
                  if (typeof this.options.geoIpLookup === "function") {
                    this.options.geoIpLookup(function(countryCode) {
                      window.intlTelInputGlobals.autoCountry = countryCode.toLowerCase();
                      setTimeout(function() {
                        return forEachInstance("handleAutoCountry");
                      });
                    }, function() {
                      return forEachInstance("rejectAutoCountryPromise");
                    });
                  }
                }
              }
            }, {
              key: "_initKeyListeners",
              value: function _initKeyListeners() {
                var _this6 = this;
                this._handleKeyupEvent = function() {
                  if (_this6._updateFlagFromNumber(_this6.telInput.value)) {
                    _this6._triggerCountryChange();
                  }
                };
                this.telInput.addEventListener("keyup", this._handleKeyupEvent);
                this._handleClipboardEvent = function() {
                  setTimeout(_this6._handleKeyupEvent);
                };
                this.telInput.addEventListener("cut", this._handleClipboardEvent);
                this.telInput.addEventListener("paste", this._handleClipboardEvent);
              }
            }, {
              key: "_cap",
              value: function _cap(number) {
                var max3 = this.telInput.getAttribute("maxlength");
                return max3 && number.length > max3 ? number.substr(0, max3) : number;
              }
            }, {
              key: "_initBlurListeners",
              value: function _initBlurListeners() {
                var _this7 = this;
                this._handleSubmitOrBlurEvent = function() {
                  _this7._removeEmptyDialCode();
                };
                if (this.telInput.form) this.telInput.form.addEventListener("submit", this._handleSubmitOrBlurEvent);
                this.telInput.addEventListener("blur", this._handleSubmitOrBlurEvent);
              }
            }, {
              key: "_removeEmptyDialCode",
              value: function _removeEmptyDialCode() {
                if (this.telInput.value.charAt(0) === "+") {
                  var numeric = this._getNumeric(this.telInput.value);
                  if (!numeric || this.selectedCountryData.dialCode === numeric) {
                    this.telInput.value = "";
                  }
                }
              }
            }, {
              key: "_getNumeric",
              value: function _getNumeric(s4) {
                return s4.replace(/\D/g, "");
              }
            }, {
              key: "_trigger",
              value: function _trigger(name2) {
                var e2 = document.createEvent("Event");
                e2.initEvent(name2, true, true);
                this.telInput.dispatchEvent(e2);
              }
            }, {
              key: "_showDropdown",
              value: function _showDropdown() {
                this.countryList.classList.remove("iti__hide");
                this.selectedFlag.setAttribute("aria-expanded", "true");
                this._setDropdownPosition();
                if (this.activeItem) {
                  this._highlightListItem(this.activeItem, false);
                  this._scrollTo(this.activeItem, true);
                }
                this._bindDropdownListeners();
                this.dropdownArrow.classList.add("iti__arrow--up");
                this._trigger("open:countrydropdown");
              }
            }, {
              key: "_toggleClass",
              value: function _toggleClass(el, className, shouldHaveClass) {
                if (shouldHaveClass && !el.classList.contains(className)) el.classList.add(className);
                else if (!shouldHaveClass && el.classList.contains(className)) el.classList.remove(className);
              }
            }, {
              key: "_setDropdownPosition",
              value: function _setDropdownPosition() {
                var _this8 = this;
                if (this.options.dropdownContainer) {
                  this.options.dropdownContainer.appendChild(this.dropdown);
                }
                if (!this.isMobile) {
                  var pos = this.telInput.getBoundingClientRect();
                  var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                  var inputTop = pos.top + windowTop;
                  var dropdownHeight = this.countryList.offsetHeight;
                  var dropdownFitsBelow = inputTop + this.telInput.offsetHeight + dropdownHeight < windowTop + window.innerHeight;
                  var dropdownFitsAbove = inputTop - dropdownHeight > windowTop;
                  this._toggleClass(this.countryList, "iti__country-list--dropup", !dropdownFitsBelow && dropdownFitsAbove);
                  if (this.options.dropdownContainer) {
                    var extraTop = !dropdownFitsBelow && dropdownFitsAbove ? 0 : this.telInput.offsetHeight;
                    this.dropdown.style.top = "".concat(inputTop + extraTop, "px");
                    this.dropdown.style.left = "".concat(pos.left + document.body.scrollLeft, "px");
                    this._handleWindowScroll = function() {
                      return _this8._closeDropdown();
                    };
                    window.addEventListener("scroll", this._handleWindowScroll);
                  }
                }
              }
            }, {
              key: "_getClosestListItem",
              value: function _getClosestListItem(target) {
                var el = target;
                while (el && el !== this.countryList && !el.classList.contains("iti__country")) {
                  el = el.parentNode;
                }
                return el === this.countryList ? null : el;
              }
            }, {
              key: "_bindDropdownListeners",
              value: function _bindDropdownListeners() {
                var _this9 = this;
                this._handleMouseoverCountryList = function(e2) {
                  var listItem = _this9._getClosestListItem(e2.target);
                  if (listItem) _this9._highlightListItem(listItem, false);
                };
                this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList);
                this._handleClickCountryList = function(e2) {
                  var listItem = _this9._getClosestListItem(e2.target);
                  if (listItem) _this9._selectListItem(listItem);
                };
                this.countryList.addEventListener("click", this._handleClickCountryList);
                var isOpening = true;
                this._handleClickOffToClose = function() {
                  if (!isOpening) _this9._closeDropdown();
                  isOpening = false;
                };
                document.documentElement.addEventListener("click", this._handleClickOffToClose);
                var query = "";
                var queryTimer = null;
                this._handleKeydownOnDropdown = function(e2) {
                  e2.preventDefault();
                  if (e2.key === "ArrowUp" || e2.key === "Up" || e2.key === "ArrowDown" || e2.key === "Down") _this9._handleUpDownKey(e2.key);
                  else if (e2.key === "Enter") _this9._handleEnterKey();
                  else if (e2.key === "Escape") _this9._closeDropdown();
                  else if (/^[a-zA-Z--- ]$/.test(e2.key)) {
                    if (queryTimer) clearTimeout(queryTimer);
                    query += e2.key.toLowerCase();
                    _this9._searchForCountry(query);
                    queryTimer = setTimeout(function() {
                      query = "";
                    }, 1e3);
                  }
                };
                document.addEventListener("keydown", this._handleKeydownOnDropdown);
              }
            }, {
              key: "_handleUpDownKey",
              value: function _handleUpDownKey(key) {
                var next = key === "ArrowUp" || key === "Up" ? this.highlightedItem.previousElementSibling : this.highlightedItem.nextElementSibling;
                if (next) {
                  if (next.classList.contains("iti__divider")) {
                    next = key === "ArrowUp" || key === "Up" ? next.previousElementSibling : next.nextElementSibling;
                  }
                  this._highlightListItem(next, true);
                }
              }
            }, {
              key: "_handleEnterKey",
              value: function _handleEnterKey() {
                if (this.highlightedItem) this._selectListItem(this.highlightedItem);
              }
            }, {
              key: "_searchForCountry",
              value: function _searchForCountry(query) {
                for (var i4 = 0; i4 < this.countries.length; i4++) {
                  if (this._startsWith(this.countries[i4].name, query)) {
                    var listItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(this.countries[i4].iso2));
                    this._highlightListItem(listItem, false);
                    this._scrollTo(listItem, true);
                    break;
                  }
                }
              }
            }, {
              key: "_startsWith",
              value: function _startsWith(a5, b5) {
                return a5.substr(0, b5.length).toLowerCase() === b5;
              }
            }, {
              key: "_updateValFromNumber",
              value: function _updateValFromNumber(originalNumber) {
                var number = originalNumber;
                if (this.options.formatOnDisplay && window.intlTelInputUtils && this.selectedCountryData) {
                  var useNational = !this.options.separateDialCode && (this.options.nationalMode || number.charAt(0) !== "+");
                  var _intlTelInputUtils$nu = intlTelInputUtils.numberFormat, NATIONAL = _intlTelInputUtils$nu.NATIONAL, INTERNATIONAL = _intlTelInputUtils$nu.INTERNATIONAL;
                  var format2 = useNational ? NATIONAL : INTERNATIONAL;
                  number = intlTelInputUtils.formatNumber(number, this.selectedCountryData.iso2, format2);
                }
                number = this._beforeSetNumber(number);
                this.telInput.value = number;
              }
            }, {
              key: "_updateFlagFromNumber",
              value: function _updateFlagFromNumber(originalNumber) {
                var number = originalNumber;
                var selectedDialCode = this.selectedCountryData.dialCode;
                var isNanp = selectedDialCode === "1";
                if (number && this.options.nationalMode && isNanp && number.charAt(0) !== "+") {
                  if (number.charAt(0) !== "1") number = "1".concat(number);
                  number = "+".concat(number);
                }
                if (this.options.separateDialCode && selectedDialCode && number.charAt(0) !== "+") {
                  number = "+".concat(selectedDialCode).concat(number);
                }
                var dialCode = this._getDialCode(number, true);
                var numeric = this._getNumeric(number);
                var countryCode = null;
                if (dialCode) {
                  var countryCodes = this.countryCodes[this._getNumeric(dialCode)];
                  var alreadySelected = countryCodes.indexOf(this.selectedCountryData.iso2) !== -1 && numeric.length <= dialCode.length - 1;
                  var isRegionlessNanpNumber = selectedDialCode === "1" && this._isRegionlessNanp(numeric);
                  if (!isRegionlessNanpNumber && !alreadySelected) {
                    for (var j6 = 0; j6 < countryCodes.length; j6++) {
                      if (countryCodes[j6]) {
                        countryCode = countryCodes[j6];
                        break;
                      }
                    }
                  }
                } else if (number.charAt(0) === "+" && numeric.length) {
                  countryCode = "";
                } else if (!number || number === "+") {
                  countryCode = this.defaultCountry;
                }
                if (countryCode !== null) {
                  return this._setFlag(countryCode);
                }
                return false;
              }
            }, {
              key: "_isRegionlessNanp",
              value: function _isRegionlessNanp(number) {
                var numeric = this._getNumeric(number);
                if (numeric.charAt(0) === "1") {
                  var areaCode = numeric.substr(1, 3);
                  return regionlessNanpNumbers.indexOf(areaCode) !== -1;
                }
                return false;
              }
            }, {
              key: "_highlightListItem",
              value: function _highlightListItem(listItem, shouldFocus) {
                var prevItem = this.highlightedItem;
                if (prevItem) prevItem.classList.remove("iti__highlight");
                this.highlightedItem = listItem;
                this.highlightedItem.classList.add("iti__highlight");
                if (shouldFocus) this.highlightedItem.focus();
              }
            }, {
              key: "_getCountryData",
              value: function _getCountryData(countryCode, ignoreOnlyCountriesOption, allowFail) {
                var countryList = ignoreOnlyCountriesOption ? allCountries : this.countries;
                for (var i4 = 0; i4 < countryList.length; i4++) {
                  if (countryList[i4].iso2 === countryCode) {
                    return countryList[i4];
                  }
                }
                if (allowFail) {
                  return null;
                }
                throw new Error("No country data for '".concat(countryCode, "'"));
              }
            }, {
              key: "_setFlag",
              value: function _setFlag(countryCode) {
                var prevCountry = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
                this.selectedCountryData = countryCode ? this._getCountryData(countryCode, false, false) : {};
                if (this.selectedCountryData.iso2) {
                  this.defaultCountry = this.selectedCountryData.iso2;
                }
                this.selectedFlagInner.setAttribute("class", "iti__flag iti__".concat(countryCode));
                var title = countryCode ? "".concat(this.selectedCountryData.name, ": +").concat(this.selectedCountryData.dialCode) : "Unknown";
                this.selectedFlag.setAttribute("title", title);
                if (this.options.separateDialCode) {
                  var dialCode = this.selectedCountryData.dialCode ? "+".concat(this.selectedCountryData.dialCode) : "";
                  this.selectedDialCode.innerHTML = dialCode;
                  var selectedFlagWidth = this.selectedFlag.offsetWidth || this._getHiddenSelectedFlagWidth();
                  this.telInput.style.paddingLeft = "".concat(selectedFlagWidth + 6, "px");
                }
                this._updatePlaceholder();
                if (this.options.allowDropdown) {
                  var prevItem = this.activeItem;
                  if (prevItem) {
                    prevItem.classList.remove("iti__active");
                    prevItem.setAttribute("aria-selected", "false");
                  }
                  if (countryCode) {
                    var nextItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode, "-preferred")) || this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode));
                    nextItem.setAttribute("aria-selected", "true");
                    nextItem.classList.add("iti__active");
                    this.activeItem = nextItem;
                    this.selectedFlag.setAttribute("aria-activedescendant", nextItem.getAttribute("id"));
                  }
                }
                return prevCountry.iso2 !== countryCode;
              }
            }, {
              key: "_getHiddenSelectedFlagWidth",
              value: function _getHiddenSelectedFlagWidth() {
                var containerClone = this.telInput.parentNode.cloneNode();
                containerClone.style.visibility = "hidden";
                document.body.appendChild(containerClone);
                var flagsContainerClone = this.flagsContainer.cloneNode();
                containerClone.appendChild(flagsContainerClone);
                var selectedFlagClone = this.selectedFlag.cloneNode(true);
                flagsContainerClone.appendChild(selectedFlagClone);
                var width = selectedFlagClone.offsetWidth;
                containerClone.parentNode.removeChild(containerClone);
                return width;
              }
            }, {
              key: "_updatePlaceholder",
              value: function _updatePlaceholder() {
                var shouldSetPlaceholder = this.options.autoPlaceholder === "aggressive" || !this.hadInitialPlaceholder && this.options.autoPlaceholder === "polite";
                if (window.intlTelInputUtils && shouldSetPlaceholder) {
                  var numberType = intlTelInputUtils.numberType[this.options.placeholderNumberType];
                  var placeholder = this.selectedCountryData.iso2 ? intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, this.options.nationalMode, numberType) : "";
                  placeholder = this._beforeSetNumber(placeholder);
                  if (typeof this.options.customPlaceholder === "function") {
                    placeholder = this.options.customPlaceholder(placeholder, this.selectedCountryData);
                  }
                  this.telInput.setAttribute("placeholder", placeholder);
                }
              }
            }, {
              key: "_selectListItem",
              value: function _selectListItem(listItem) {
                var flagChanged = this._setFlag(listItem.getAttribute("data-country-code"));
                this._closeDropdown();
                this._updateDialCode(listItem.getAttribute("data-dial-code"), true);
                this.telInput.focus();
                var len = this.telInput.value.length;
                this.telInput.setSelectionRange(len, len);
                if (flagChanged) {
                  this._triggerCountryChange();
                }
              }
            }, {
              key: "_closeDropdown",
              value: function _closeDropdown() {
                this.countryList.classList.add("iti__hide");
                this.selectedFlag.setAttribute("aria-expanded", "false");
                this.dropdownArrow.classList.remove("iti__arrow--up");
                document.removeEventListener("keydown", this._handleKeydownOnDropdown);
                document.documentElement.removeEventListener("click", this._handleClickOffToClose);
                this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList);
                this.countryList.removeEventListener("click", this._handleClickCountryList);
                if (this.options.dropdownContainer) {
                  if (!this.isMobile) window.removeEventListener("scroll", this._handleWindowScroll);
                  if (this.dropdown.parentNode) this.dropdown.parentNode.removeChild(this.dropdown);
                }
                this._trigger("close:countrydropdown");
              }
            }, {
              key: "_scrollTo",
              value: function _scrollTo(element, middle) {
                var container = this.countryList;
                var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                var containerHeight = container.offsetHeight;
                var containerTop = container.getBoundingClientRect().top + windowTop;
                var containerBottom = containerTop + containerHeight;
                var elementHeight = element.offsetHeight;
                var elementTop = element.getBoundingClientRect().top + windowTop;
                var elementBottom = elementTop + elementHeight;
                var newScrollTop = elementTop - containerTop + container.scrollTop;
                var middleOffset = containerHeight / 2 - elementHeight / 2;
                if (elementTop < containerTop) {
                  if (middle) newScrollTop -= middleOffset;
                  container.scrollTop = newScrollTop;
                } else if (elementBottom > containerBottom) {
                  if (middle) newScrollTop += middleOffset;
                  var heightDifference = containerHeight - elementHeight;
                  container.scrollTop = newScrollTop - heightDifference;
                }
              }
            }, {
              key: "_updateDialCode",
              value: function _updateDialCode(newDialCodeBare, hasSelectedListItem) {
                var inputVal = this.telInput.value;
                var newDialCode = "+".concat(newDialCodeBare);
                var newNumber;
                if (inputVal.charAt(0) === "+") {
                  var prevDialCode = this._getDialCode(inputVal);
                  if (prevDialCode) {
                    newNumber = inputVal.replace(prevDialCode, newDialCode);
                  } else {
                    newNumber = newDialCode;
                  }
                } else if (this.options.nationalMode || this.options.separateDialCode) {
                  return;
                } else {
                  if (inputVal) {
                    newNumber = newDialCode + inputVal;
                  } else if (hasSelectedListItem || !this.options.autoHideDialCode) {
                    newNumber = newDialCode;
                  } else {
                    return;
                  }
                }
                this.telInput.value = newNumber;
              }
            }, {
              key: "_getDialCode",
              value: function _getDialCode(number, includeAreaCode) {
                var dialCode = "";
                if (number.charAt(0) === "+") {
                  var numericChars = "";
                  for (var i4 = 0; i4 < number.length; i4++) {
                    var c5 = number.charAt(i4);
                    if (!isNaN(parseInt(c5, 10))) {
                      numericChars += c5;
                      if (includeAreaCode) {
                        if (this.countryCodes[numericChars]) {
                          dialCode = number.substr(0, i4 + 1);
                        }
                      } else {
                        if (this.dialCodes[numericChars]) {
                          dialCode = number.substr(0, i4 + 1);
                          break;
                        }
                      }
                      if (numericChars.length === this.countryCodeMaxLen) {
                        break;
                      }
                    }
                  }
                }
                return dialCode;
              }
            }, {
              key: "_getFullNumber",
              value: function _getFullNumber() {
                var val = this.telInput.value.trim();
                var dialCode = this.selectedCountryData.dialCode;
                var prefix2;
                var numericVal = this._getNumeric(val);
                if (this.options.separateDialCode && val.charAt(0) !== "+" && dialCode && numericVal) {
                  prefix2 = "+".concat(dialCode);
                } else {
                  prefix2 = "";
                }
                return prefix2 + val;
              }
            }, {
              key: "_beforeSetNumber",
              value: function _beforeSetNumber(originalNumber) {
                var number = originalNumber;
                if (this.options.separateDialCode) {
                  var dialCode = this._getDialCode(number);
                  if (dialCode) {
                    dialCode = "+".concat(this.selectedCountryData.dialCode);
                    var start5 = number[dialCode.length] === " " || number[dialCode.length] === "-" ? dialCode.length + 1 : dialCode.length;
                    number = number.substr(start5);
                  }
                }
                return this._cap(number);
              }
            }, {
              key: "_triggerCountryChange",
              value: function _triggerCountryChange() {
                this._trigger("countrychange");
              }
            }, {
              key: "handleAutoCountry",
              value: function handleAutoCountry() {
                if (this.options.initialCountry === "auto") {
                  this.defaultCountry = window.intlTelInputGlobals.autoCountry;
                  if (!this.telInput.value) {
                    this.setCountry(this.defaultCountry);
                  }
                  this.resolveAutoCountryPromise();
                }
              }
            }, {
              key: "handleUtils",
              value: function handleUtils() {
                if (window.intlTelInputUtils) {
                  if (this.telInput.value) {
                    this._updateValFromNumber(this.telInput.value);
                  }
                  this._updatePlaceholder();
                }
                this.resolveUtilsScriptPromise();
              }
            }, {
              key: "destroy",
              value: function destroy2() {
                var form = this.telInput.form;
                if (this.options.allowDropdown) {
                  this._closeDropdown();
                  this.selectedFlag.removeEventListener("click", this._handleClickSelectedFlag);
                  this.flagsContainer.removeEventListener("keydown", this._handleFlagsContainerKeydown);
                  var label = this._getClosestLabel();
                  if (label) label.removeEventListener("click", this._handleLabelClick);
                }
                if (this.hiddenInput && form) form.removeEventListener("submit", this._handleHiddenInputSubmit);
                if (this.options.autoHideDialCode) {
                  if (form) form.removeEventListener("submit", this._handleSubmitOrBlurEvent);
                  this.telInput.removeEventListener("blur", this._handleSubmitOrBlurEvent);
                }
                this.telInput.removeEventListener("keyup", this._handleKeyupEvent);
                this.telInput.removeEventListener("cut", this._handleClipboardEvent);
                this.telInput.removeEventListener("paste", this._handleClipboardEvent);
                this.telInput.removeAttribute("data-intl-tel-input-id");
                var wrapper = this.telInput.parentNode;
                wrapper.parentNode.insertBefore(this.telInput, wrapper);
                wrapper.parentNode.removeChild(wrapper);
                delete window.intlTelInputGlobals.instances[this.id];
              }
            }, {
              key: "getExtension",
              value: function getExtension2() {
                if (window.intlTelInputUtils) {
                  return intlTelInputUtils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2);
                }
                return "";
              }
            }, {
              key: "getNumber",
              value: function getNumber(format2) {
                if (window.intlTelInputUtils) {
                  var iso2 = this.selectedCountryData.iso2;
                  return intlTelInputUtils.formatNumber(this._getFullNumber(), iso2, format2);
                }
                return "";
              }
            }, {
              key: "getNumberType",
              value: function getNumberType() {
                if (window.intlTelInputUtils) {
                  return intlTelInputUtils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2);
                }
                return -99;
              }
            }, {
              key: "getSelectedCountryData",
              value: function getSelectedCountryData() {
                return this.selectedCountryData;
              }
            }, {
              key: "getValidationError",
              value: function getValidationError() {
                if (window.intlTelInputUtils) {
                  var iso2 = this.selectedCountryData.iso2;
                  return intlTelInputUtils.getValidationError(this._getFullNumber(), iso2);
                }
                return -99;
              }
            }, {
              key: "isValidNumber",
              value: function isValidNumber() {
                var val = this._getFullNumber().trim();
                var countryCode = this.options.nationalMode ? this.selectedCountryData.iso2 : "";
                return window.intlTelInputUtils ? intlTelInputUtils.isValidNumber(val, countryCode) : null;
              }
            }, {
              key: "setCountry",
              value: function setCountry(originalCountryCode) {
                var countryCode = originalCountryCode.toLowerCase();
                if (!this.selectedFlagInner.classList.contains("iti__".concat(countryCode))) {
                  this._setFlag(countryCode);
                  this._updateDialCode(this.selectedCountryData.dialCode, false);
                  this._triggerCountryChange();
                }
              }
            }, {
              key: "setNumber",
              value: function setNumber(number) {
                var flagChanged = this._updateFlagFromNumber(number);
                this._updateValFromNumber(number);
                if (flagChanged) {
                  this._triggerCountryChange();
                }
              }
            }, {
              key: "setPlaceholderNumberType",
              value: function setPlaceholderNumberType(type) {
                this.options.placeholderNumberType = type;
                this._updatePlaceholder();
              }
            }]);
            return Iti2;
          }();
          intlTelInputGlobals.getCountryData = function() {
            return allCountries;
          };
          var injectScript = function injectScript2(path, handleSuccess, handleFailure) {
            var script = document.createElement("script");
            script.onload = function() {
              forEachInstance("handleUtils");
              if (handleSuccess) handleSuccess();
            };
            script.onerror = function() {
              forEachInstance("rejectUtilsScriptPromise");
              if (handleFailure) handleFailure();
            };
            script.className = "iti-load-utils";
            script.async = true;
            script.src = path;
            document.body.appendChild(script);
          };
          intlTelInputGlobals.loadUtils = function(path) {
            if (!window.intlTelInputUtils && !window.intlTelInputGlobals.startedLoadingUtilsScript) {
              window.intlTelInputGlobals.startedLoadingUtilsScript = true;
              if (typeof Promise !== "undefined") {
                return new Promise(function(resolve2, reject) {
                  return injectScript(path, resolve2, reject);
                });
              }
              injectScript(path);
            }
            return null;
          };
          intlTelInputGlobals.defaults = defaults3;
          intlTelInputGlobals.version = "17.0.8";
          return function(input, options) {
            var iti = new Iti(input, options);
            iti._init();
            input.setAttribute("data-intl-tel-input-id", iti.id);
            window.intlTelInputGlobals.instances[iti.id] = iti;
            return iti;
          };
        }();
      });
    }
  });

  // node_modules/intl-tel-input/index.js
  var require_intl_tel_input = __commonJS({
    "node_modules/intl-tel-input/index.js"(exports, module2) {
      init_define_process();
      init_jquery();
      module2.exports = require_intlTelInput();
    }
  });

  // node_modules/select2/dist/js/select2.js
  var require_select2 = __commonJS({
    "node_modules/select2/dist/js/select2.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function(factory) {
        if (typeof define === "function" && define.amd) {
          define(["jquery"], factory);
        } else if (typeof module2 === "object" && module2.exports) {
          module2.exports = function(root, jQuery2) {
            if (jQuery2 === void 0) {
              if (typeof window !== "undefined") {
                jQuery2 = require_jquery();
              } else {
                jQuery2 = require_jquery()(root);
              }
            }
            factory(jQuery2);
            return jQuery2;
          };
        } else {
          factory(jQuery);
        }
      })(function(jQuery2) {
        var S22 = function() {
          if (jQuery2 && jQuery2.fn && jQuery2.fn.select2 && jQuery2.fn.select2.amd) {
            var S23 = jQuery2.fn.select2.amd;
          }
          var S23;
          (function() {
            if (!S23 || !S23.requirejs) {
              if (!S23) {
                S23 = {};
              } else {
                require2 = S23;
              }
              var requirejs, require2, define2;
              (function(undef) {
                var main3, req, makeMap, handlers, defined2 = {}, waiting = {}, config = {}, defining = {}, hasOwn = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
                function hasProp(obj, prop) {
                  return hasOwn.call(obj, prop);
                }
                function normalize(name2, baseName) {
                  var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i3, j6, part, normalizedBaseParts, baseParts = baseName && baseName.split("/"), map3 = config.map, starMap = map3 && map3["*"] || {};
                  if (name2) {
                    name2 = name2.split("/");
                    lastIndex = name2.length - 1;
                    if (config.nodeIdCompat && jsSuffixRegExp.test(name2[lastIndex])) {
                      name2[lastIndex] = name2[lastIndex].replace(jsSuffixRegExp, "");
                    }
                    if (name2[0].charAt(0) === "." && baseParts) {
                      normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                      name2 = normalizedBaseParts.concat(name2);
                    }
                    for (i3 = 0; i3 < name2.length; i3++) {
                      part = name2[i3];
                      if (part === ".") {
                        name2.splice(i3, 1);
                        i3 -= 1;
                      } else if (part === "..") {
                        if (i3 === 0 || i3 === 1 && name2[2] === ".." || name2[i3 - 1] === "..") {
                          continue;
                        } else if (i3 > 0) {
                          name2.splice(i3 - 1, 2);
                          i3 -= 2;
                        }
                      }
                    }
                    name2 = name2.join("/");
                  }
                  if ((baseParts || starMap) && map3) {
                    nameParts = name2.split("/");
                    for (i3 = nameParts.length; i3 > 0; i3 -= 1) {
                      nameSegment = nameParts.slice(0, i3).join("/");
                      if (baseParts) {
                        for (j6 = baseParts.length; j6 > 0; j6 -= 1) {
                          mapValue = map3[baseParts.slice(0, j6).join("/")];
                          if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                              foundMap = mapValue;
                              foundI = i3;
                              break;
                            }
                          }
                        }
                      }
                      if (foundMap) {
                        break;
                      }
                      if (!foundStarMap && starMap && starMap[nameSegment]) {
                        foundStarMap = starMap[nameSegment];
                        starI = i3;
                      }
                    }
                    if (!foundMap && foundStarMap) {
                      foundMap = foundStarMap;
                      foundI = starI;
                    }
                    if (foundMap) {
                      nameParts.splice(0, foundI, foundMap);
                      name2 = nameParts.join("/");
                    }
                  }
                  return name2;
                }
                function makeRequire(relName, forceSync) {
                  return function() {
                    var args = aps.call(arguments, 0);
                    if (typeof args[0] !== "string" && args.length === 1) {
                      args.push(null);
                    }
                    return req.apply(undef, args.concat([relName, forceSync]));
                  };
                }
                function makeNormalize(relName) {
                  return function(name2) {
                    return normalize(name2, relName);
                  };
                }
                function makeLoad(depName) {
                  return function(value) {
                    defined2[depName] = value;
                  };
                }
                function callDep(name2) {
                  if (hasProp(waiting, name2)) {
                    var args = waiting[name2];
                    delete waiting[name2];
                    defining[name2] = true;
                    main3.apply(undef, args);
                  }
                  if (!hasProp(defined2, name2) && !hasProp(defining, name2)) {
                    throw new Error("No " + name2);
                  }
                  return defined2[name2];
                }
                function splitPrefix(name2) {
                  var prefix2, index2 = name2 ? name2.indexOf("!") : -1;
                  if (index2 > -1) {
                    prefix2 = name2.substring(0, index2);
                    name2 = name2.substring(index2 + 1, name2.length);
                  }
                  return [prefix2, name2];
                }
                function makeRelParts(relName) {
                  return relName ? splitPrefix(relName) : [];
                }
                makeMap = function(name2, relParts) {
                  var plugin, parts = splitPrefix(name2), prefix2 = parts[0], relResourceName = relParts[1];
                  name2 = parts[1];
                  if (prefix2) {
                    prefix2 = normalize(prefix2, relResourceName);
                    plugin = callDep(prefix2);
                  }
                  if (prefix2) {
                    if (plugin && plugin.normalize) {
                      name2 = plugin.normalize(name2, makeNormalize(relResourceName));
                    } else {
                      name2 = normalize(name2, relResourceName);
                    }
                  } else {
                    name2 = normalize(name2, relResourceName);
                    parts = splitPrefix(name2);
                    prefix2 = parts[0];
                    name2 = parts[1];
                    if (prefix2) {
                      plugin = callDep(prefix2);
                    }
                  }
                  return {
                    f: prefix2 ? prefix2 + "!" + name2 : name2,
                    //fullName
                    n: name2,
                    pr: prefix2,
                    p: plugin
                  };
                };
                function makeConfig(name2) {
                  return function() {
                    return config && config.config && config.config[name2] || {};
                  };
                }
                handlers = {
                  require: function(name2) {
                    return makeRequire(name2);
                  },
                  exports: function(name2) {
                    var e2 = defined2[name2];
                    if (typeof e2 !== "undefined") {
                      return e2;
                    } else {
                      return defined2[name2] = {};
                    }
                  },
                  module: function(name2) {
                    return {
                      id: name2,
                      uri: "",
                      exports: defined2[name2],
                      config: makeConfig(name2)
                    };
                  }
                };
                main3 = function(name2, deps, callback2, relName) {
                  var cjsModule, depName, ret, map3, i3, relParts, args = [], callbackType = typeof callback2, usingExports;
                  relName = relName || name2;
                  relParts = makeRelParts(relName);
                  if (callbackType === "undefined" || callbackType === "function") {
                    deps = !deps.length && callback2.length ? ["require", "exports", "module"] : deps;
                    for (i3 = 0; i3 < deps.length; i3 += 1) {
                      map3 = makeMap(deps[i3], relParts);
                      depName = map3.f;
                      if (depName === "require") {
                        args[i3] = handlers.require(name2);
                      } else if (depName === "exports") {
                        args[i3] = handlers.exports(name2);
                        usingExports = true;
                      } else if (depName === "module") {
                        cjsModule = args[i3] = handlers.module(name2);
                      } else if (hasProp(defined2, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                        args[i3] = callDep(depName);
                      } else if (map3.p) {
                        map3.p.load(map3.n, makeRequire(relName, true), makeLoad(depName), {});
                        args[i3] = defined2[depName];
                      } else {
                        throw new Error(name2 + " missing " + depName);
                      }
                    }
                    ret = callback2 ? callback2.apply(defined2[name2], args) : void 0;
                    if (name2) {
                      if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined2[name2]) {
                        defined2[name2] = cjsModule.exports;
                      } else if (ret !== undef || !usingExports) {
                        defined2[name2] = ret;
                      }
                    }
                  } else if (name2) {
                    defined2[name2] = callback2;
                  }
                };
                requirejs = require2 = req = function(deps, callback2, relName, forceSync, alt) {
                  if (typeof deps === "string") {
                    if (handlers[deps]) {
                      return handlers[deps](callback2);
                    }
                    return callDep(makeMap(deps, makeRelParts(callback2)).f);
                  } else if (!deps.splice) {
                    config = deps;
                    if (config.deps) {
                      req(config.deps, config.callback);
                    }
                    if (!callback2) {
                      return;
                    }
                    if (callback2.splice) {
                      deps = callback2;
                      callback2 = relName;
                      relName = null;
                    } else {
                      deps = undef;
                    }
                  }
                  callback2 = callback2 || function() {
                  };
                  if (typeof relName === "function") {
                    relName = forceSync;
                    forceSync = alt;
                  }
                  if (forceSync) {
                    main3(undef, deps, callback2, relName);
                  } else {
                    setTimeout(function() {
                      main3(undef, deps, callback2, relName);
                    }, 4);
                  }
                  return req;
                };
                req.config = function(cfg) {
                  return req(cfg);
                };
                requirejs._defined = defined2;
                define2 = function(name2, deps, callback2) {
                  if (typeof name2 !== "string") {
                    throw new Error("See almond README: incorrect module build, no module name");
                  }
                  if (!deps.splice) {
                    callback2 = deps;
                    deps = [];
                  }
                  if (!hasProp(defined2, name2) && !hasProp(waiting, name2)) {
                    waiting[name2] = [name2, deps, callback2];
                  }
                };
                define2.amd = {
                  jQuery: true
                };
              })();
              S23.requirejs = requirejs;
              S23.require = require2;
              S23.define = define2;
            }
          })();
          S23.define("almond", function() {
          });
          S23.define("jquery", [], function() {
            var _$ = jQuery2 || $;
            if (_$ == null && console && console.error) {
              console.error(
                "Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."
              );
            }
            return _$;
          });
          S23.define("select2/utils", [
            "jquery"
          ], function($7) {
            var Utils = {};
            Utils.Extend = function(ChildClass, SuperClass) {
              var __hasProp = {}.hasOwnProperty;
              function BaseConstructor() {
                this.constructor = ChildClass;
              }
              for (var key in SuperClass) {
                if (__hasProp.call(SuperClass, key)) {
                  ChildClass[key] = SuperClass[key];
                }
              }
              BaseConstructor.prototype = SuperClass.prototype;
              ChildClass.prototype = new BaseConstructor();
              ChildClass.__super__ = SuperClass.prototype;
              return ChildClass;
            };
            function getMethods(theClass) {
              var proto = theClass.prototype;
              var methods = [];
              for (var methodName in proto) {
                var m4 = proto[methodName];
                if (typeof m4 !== "function") {
                  continue;
                }
                if (methodName === "constructor") {
                  continue;
                }
                methods.push(methodName);
              }
              return methods;
            }
            Utils.Decorate = function(SuperClass, DecoratorClass) {
              var decoratedMethods = getMethods(DecoratorClass);
              var superMethods = getMethods(SuperClass);
              function DecoratedClass() {
                var unshift = Array.prototype.unshift;
                var argCount = DecoratorClass.prototype.constructor.length;
                var calledConstructor = SuperClass.prototype.constructor;
                if (argCount > 0) {
                  unshift.call(arguments, SuperClass.prototype.constructor);
                  calledConstructor = DecoratorClass.prototype.constructor;
                }
                calledConstructor.apply(this, arguments);
              }
              DecoratorClass.displayName = SuperClass.displayName;
              function ctr() {
                this.constructor = DecoratedClass;
              }
              DecoratedClass.prototype = new ctr();
              for (var m4 = 0; m4 < superMethods.length; m4++) {
                var superMethod = superMethods[m4];
                DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
              }
              var calledMethod = function(methodName) {
                var originalMethod = function() {
                };
                if (methodName in DecoratedClass.prototype) {
                  originalMethod = DecoratedClass.prototype[methodName];
                }
                var decoratedMethod2 = DecoratorClass.prototype[methodName];
                return function() {
                  var unshift = Array.prototype.unshift;
                  unshift.call(arguments, originalMethod);
                  return decoratedMethod2.apply(this, arguments);
                };
              };
              for (var d5 = 0; d5 < decoratedMethods.length; d5++) {
                var decoratedMethod = decoratedMethods[d5];
                DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
              }
              return DecoratedClass;
            };
            var Observable = function() {
              this.listeners = {};
            };
            Observable.prototype.on = function(event2, callback2) {
              this.listeners = this.listeners || {};
              if (event2 in this.listeners) {
                this.listeners[event2].push(callback2);
              } else {
                this.listeners[event2] = [callback2];
              }
            };
            Observable.prototype.trigger = function(event2) {
              var slice = Array.prototype.slice;
              var params = slice.call(arguments, 1);
              this.listeners = this.listeners || {};
              if (params == null) {
                params = [];
              }
              if (params.length === 0) {
                params.push({});
              }
              params[0]._type = event2;
              if (event2 in this.listeners) {
                this.invoke(this.listeners[event2], slice.call(arguments, 1));
              }
              if ("*" in this.listeners) {
                this.invoke(this.listeners["*"], arguments);
              }
            };
            Observable.prototype.invoke = function(listeners, params) {
              for (var i3 = 0, len = listeners.length; i3 < len; i3++) {
                listeners[i3].apply(this, params);
              }
            };
            Utils.Observable = Observable;
            Utils.generateChars = function(length) {
              var chars = "";
              for (var i3 = 0; i3 < length; i3++) {
                var randomChar = Math.floor(Math.random() * 36);
                chars += randomChar.toString(36);
              }
              return chars;
            };
            Utils.bind = function(func, context2) {
              return function() {
                func.apply(context2, arguments);
              };
            };
            Utils._convertData = function(data) {
              for (var originalKey in data) {
                var keys = originalKey.split("-");
                var dataLevel = data;
                if (keys.length === 1) {
                  continue;
                }
                for (var k4 = 0; k4 < keys.length; k4++) {
                  var key = keys[k4];
                  key = key.substring(0, 1).toLowerCase() + key.substring(1);
                  if (!(key in dataLevel)) {
                    dataLevel[key] = {};
                  }
                  if (k4 == keys.length - 1) {
                    dataLevel[key] = data[originalKey];
                  }
                  dataLevel = dataLevel[key];
                }
                delete data[originalKey];
              }
              return data;
            };
            Utils.hasScroll = function(index2, el) {
              var $el = $7(el);
              var overflowX = el.style.overflowX;
              var overflowY = el.style.overflowY;
              if (overflowX === overflowY && (overflowY === "hidden" || overflowY === "visible")) {
                return false;
              }
              if (overflowX === "scroll" || overflowY === "scroll") {
                return true;
              }
              return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
            };
            Utils.escapeMarkup = function(markup) {
              var replaceMap = {
                "\\": "&#92;",
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
                "/": "&#47;"
              };
              if (typeof markup !== "string") {
                return markup;
              }
              return String(markup).replace(/[&<>"'\/\\]/g, function(match) {
                return replaceMap[match];
              });
            };
            Utils.appendMany = function($element, $nodes) {
              if ($7.fn.jquery.substr(0, 3) === "1.7") {
                var $jqNodes = $7();
                $7.map($nodes, function(node) {
                  $jqNodes = $jqNodes.add(node);
                });
                $nodes = $jqNodes;
              }
              $element.append($nodes);
            };
            Utils.__cache = {};
            var id = 0;
            Utils.GetUniqueElementId = function(element) {
              var select2Id = element.getAttribute("data-select2-id");
              if (select2Id == null) {
                if (element.id) {
                  select2Id = element.id;
                  element.setAttribute("data-select2-id", select2Id);
                } else {
                  element.setAttribute("data-select2-id", ++id);
                  select2Id = id.toString();
                }
              }
              return select2Id;
            };
            Utils.StoreData = function(element, name2, value) {
              var id2 = Utils.GetUniqueElementId(element);
              if (!Utils.__cache[id2]) {
                Utils.__cache[id2] = {};
              }
              Utils.__cache[id2][name2] = value;
            };
            Utils.GetData = function(element, name2) {
              var id2 = Utils.GetUniqueElementId(element);
              if (name2) {
                if (Utils.__cache[id2]) {
                  if (Utils.__cache[id2][name2] != null) {
                    return Utils.__cache[id2][name2];
                  }
                  return $7(element).data(name2);
                }
                return $7(element).data(name2);
              } else {
                return Utils.__cache[id2];
              }
            };
            Utils.RemoveData = function(element) {
              var id2 = Utils.GetUniqueElementId(element);
              if (Utils.__cache[id2] != null) {
                delete Utils.__cache[id2];
              }
              element.removeAttribute("data-select2-id");
            };
            return Utils;
          });
          S23.define("select2/results", [
            "jquery",
            "./utils"
          ], function($7, Utils) {
            function Results($element, options, dataAdapter) {
              this.$element = $element;
              this.data = dataAdapter;
              this.options = options;
              Results.__super__.constructor.call(this);
            }
            Utils.Extend(Results, Utils.Observable);
            Results.prototype.render = function() {
              var $results = $7(
                '<ul class="select2-results__options" role="listbox"></ul>'
              );
              if (this.options.get("multiple")) {
                $results.attr("aria-multiselectable", "true");
              }
              this.$results = $results;
              return $results;
            };
            Results.prototype.clear = function() {
              this.$results.empty();
            };
            Results.prototype.displayMessage = function(params) {
              var escapeMarkup = this.options.get("escapeMarkup");
              this.clear();
              this.hideLoading();
              var $message = $7(
                '<li role="alert" aria-live="assertive" class="select2-results__option"></li>'
              );
              var message = this.options.get("translations").get(params.message);
              $message.append(
                escapeMarkup(
                  message(params.args)
                )
              );
              $message[0].className += " select2-results__message";
              this.$results.append($message);
            };
            Results.prototype.hideMessages = function() {
              this.$results.find(".select2-results__message").remove();
            };
            Results.prototype.append = function(data) {
              this.hideLoading();
              var $options = [];
              if (data.results == null || data.results.length === 0) {
                if (this.$results.children().length === 0) {
                  this.trigger("results:message", {
                    message: "noResults"
                  });
                }
                return;
              }
              data.results = this.sort(data.results);
              for (var d5 = 0; d5 < data.results.length; d5++) {
                var item = data.results[d5];
                var $option = this.option(item);
                $options.push($option);
              }
              this.$results.append($options);
            };
            Results.prototype.position = function($results, $dropdown) {
              var $resultsContainer = $dropdown.find(".select2-results");
              $resultsContainer.append($results);
            };
            Results.prototype.sort = function(data) {
              var sorter2 = this.options.get("sorter");
              return sorter2(data);
            };
            Results.prototype.highlightFirstItem = function() {
              var $options = this.$results.find(".select2-results__option[aria-selected]");
              var $selected = $options.filter("[aria-selected=true]");
              if ($selected.length > 0) {
                $selected.first().trigger("mouseenter");
              } else {
                $options.first().trigger("mouseenter");
              }
              this.ensureHighlightVisible();
            };
            Results.prototype.setClasses = function() {
              var self2 = this;
              this.data.current(function(selected) {
                var selectedIds = $7.map(selected, function(s4) {
                  return s4.id.toString();
                });
                var $options = self2.$results.find(".select2-results__option[aria-selected]");
                $options.each(function() {
                  var $option = $7(this);
                  var item = Utils.GetData(this, "data");
                  var id = "" + item.id;
                  if (item.element != null && item.element.selected || item.element == null && $7.inArray(id, selectedIds) > -1) {
                    $option.attr("aria-selected", "true");
                  } else {
                    $option.attr("aria-selected", "false");
                  }
                });
              });
            };
            Results.prototype.showLoading = function(params) {
              this.hideLoading();
              var loadingMore = this.options.get("translations").get("searching");
              var loading = {
                disabled: true,
                loading: true,
                text: loadingMore(params)
              };
              var $loading = this.option(loading);
              $loading.className += " loading-results";
              this.$results.prepend($loading);
            };
            Results.prototype.hideLoading = function() {
              this.$results.find(".loading-results").remove();
            };
            Results.prototype.option = function(data) {
              var option = document.createElement("li");
              option.className = "select2-results__option";
              var attrs = {
                "role": "option",
                "aria-selected": "false"
              };
              var matches = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;
              if (data.element != null && matches.call(data.element, ":disabled") || data.element == null && data.disabled) {
                delete attrs["aria-selected"];
                attrs["aria-disabled"] = "true";
              }
              if (data.id == null) {
                delete attrs["aria-selected"];
              }
              if (data._resultId != null) {
                option.id = data._resultId;
              }
              if (data.title) {
                option.title = data.title;
              }
              if (data.children) {
                attrs.role = "group";
                attrs["aria-label"] = data.text;
                delete attrs["aria-selected"];
              }
              for (var attr in attrs) {
                var val = attrs[attr];
                option.setAttribute(attr, val);
              }
              if (data.children) {
                var $option = $7(option);
                var label = document.createElement("strong");
                label.className = "select2-results__group";
                var $label = $7(label);
                this.template(data, label);
                var $children = [];
                for (var c4 = 0; c4 < data.children.length; c4++) {
                  var child = data.children[c4];
                  var $child = this.option(child);
                  $children.push($child);
                }
                var $childrenContainer = $7("<ul></ul>", {
                  "class": "select2-results__options select2-results__options--nested"
                });
                $childrenContainer.append($children);
                $option.append(label);
                $option.append($childrenContainer);
              } else {
                this.template(data, option);
              }
              Utils.StoreData(option, "data", data);
              return option;
            };
            Results.prototype.bind = function(container, $container) {
              var self2 = this;
              var id = container.id + "-results";
              this.$results.attr("id", id);
              container.on("results:all", function(params) {
                self2.clear();
                self2.append(params.data);
                if (container.isOpen()) {
                  self2.setClasses();
                  self2.highlightFirstItem();
                }
              });
              container.on("results:append", function(params) {
                self2.append(params.data);
                if (container.isOpen()) {
                  self2.setClasses();
                }
              });
              container.on("query", function(params) {
                self2.hideMessages();
                self2.showLoading(params);
              });
              container.on("select", function() {
                if (!container.isOpen()) {
                  return;
                }
                self2.setClasses();
                if (self2.options.get("scrollAfterSelect")) {
                  self2.highlightFirstItem();
                }
              });
              container.on("unselect", function() {
                if (!container.isOpen()) {
                  return;
                }
                self2.setClasses();
                if (self2.options.get("scrollAfterSelect")) {
                  self2.highlightFirstItem();
                }
              });
              container.on("open", function() {
                self2.$results.attr("aria-expanded", "true");
                self2.$results.attr("aria-hidden", "false");
                self2.setClasses();
                self2.ensureHighlightVisible();
              });
              container.on("close", function() {
                self2.$results.attr("aria-expanded", "false");
                self2.$results.attr("aria-hidden", "true");
                self2.$results.removeAttr("aria-activedescendant");
              });
              container.on("results:toggle", function() {
                var $highlighted = self2.getHighlightedResults();
                if ($highlighted.length === 0) {
                  return;
                }
                $highlighted.trigger("mouseup");
              });
              container.on("results:select", function() {
                var $highlighted = self2.getHighlightedResults();
                if ($highlighted.length === 0) {
                  return;
                }
                var data = Utils.GetData($highlighted[0], "data");
                if ($highlighted.attr("aria-selected") == "true") {
                  self2.trigger("close", {});
                } else {
                  self2.trigger("select", {
                    data
                  });
                }
              });
              container.on("results:previous", function() {
                var $highlighted = self2.getHighlightedResults();
                var $options = self2.$results.find("[aria-selected]");
                var currentIndex = $options.index($highlighted);
                if (currentIndex <= 0) {
                  return;
                }
                var nextIndex = currentIndex - 1;
                if ($highlighted.length === 0) {
                  nextIndex = 0;
                }
                var $next = $options.eq(nextIndex);
                $next.trigger("mouseenter");
                var currentOffset = self2.$results.offset().top;
                var nextTop = $next.offset().top;
                var nextOffset = self2.$results.scrollTop() + (nextTop - currentOffset);
                if (nextIndex === 0) {
                  self2.$results.scrollTop(0);
                } else if (nextTop - currentOffset < 0) {
                  self2.$results.scrollTop(nextOffset);
                }
              });
              container.on("results:next", function() {
                var $highlighted = self2.getHighlightedResults();
                var $options = self2.$results.find("[aria-selected]");
                var currentIndex = $options.index($highlighted);
                var nextIndex = currentIndex + 1;
                if (nextIndex >= $options.length) {
                  return;
                }
                var $next = $options.eq(nextIndex);
                $next.trigger("mouseenter");
                var currentOffset = self2.$results.offset().top + self2.$results.outerHeight(false);
                var nextBottom = $next.offset().top + $next.outerHeight(false);
                var nextOffset = self2.$results.scrollTop() + nextBottom - currentOffset;
                if (nextIndex === 0) {
                  self2.$results.scrollTop(0);
                } else if (nextBottom > currentOffset) {
                  self2.$results.scrollTop(nextOffset);
                }
              });
              container.on("results:focus", function(params) {
                params.element.addClass("select2-results__option--highlighted");
              });
              container.on("results:message", function(params) {
                self2.displayMessage(params);
              });
              if ($7.fn.mousewheel) {
                this.$results.on("mousewheel", function(e2) {
                  var top2 = self2.$results.scrollTop();
                  var bottom2 = self2.$results.get(0).scrollHeight - top2 + e2.deltaY;
                  var isAtTop = e2.deltaY > 0 && top2 - e2.deltaY <= 0;
                  var isAtBottom = e2.deltaY < 0 && bottom2 <= self2.$results.height();
                  if (isAtTop) {
                    self2.$results.scrollTop(0);
                    e2.preventDefault();
                    e2.stopPropagation();
                  } else if (isAtBottom) {
                    self2.$results.scrollTop(
                      self2.$results.get(0).scrollHeight - self2.$results.height()
                    );
                    e2.preventDefault();
                    e2.stopPropagation();
                  }
                });
              }
              this.$results.on(
                "mouseup",
                ".select2-results__option[aria-selected]",
                function(evt) {
                  var $this = $7(this);
                  var data = Utils.GetData(this, "data");
                  if ($this.attr("aria-selected") === "true") {
                    if (self2.options.get("multiple")) {
                      self2.trigger("unselect", {
                        originalEvent: evt,
                        data
                      });
                    } else {
                      self2.trigger("close", {});
                    }
                    return;
                  }
                  self2.trigger("select", {
                    originalEvent: evt,
                    data
                  });
                }
              );
              this.$results.on(
                "mouseenter",
                ".select2-results__option[aria-selected]",
                function(evt) {
                  var data = Utils.GetData(this, "data");
                  self2.getHighlightedResults().removeClass("select2-results__option--highlighted");
                  self2.trigger("results:focus", {
                    data,
                    element: $7(this)
                  });
                }
              );
            };
            Results.prototype.getHighlightedResults = function() {
              var $highlighted = this.$results.find(".select2-results__option--highlighted");
              return $highlighted;
            };
            Results.prototype.destroy = function() {
              this.$results.remove();
            };
            Results.prototype.ensureHighlightVisible = function() {
              var $highlighted = this.getHighlightedResults();
              if ($highlighted.length === 0) {
                return;
              }
              var $options = this.$results.find("[aria-selected]");
              var currentIndex = $options.index($highlighted);
              var currentOffset = this.$results.offset().top;
              var nextTop = $highlighted.offset().top;
              var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
              var offsetDelta = nextTop - currentOffset;
              nextOffset -= $highlighted.outerHeight(false) * 2;
              if (currentIndex <= 2) {
                this.$results.scrollTop(0);
              } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
                this.$results.scrollTop(nextOffset);
              }
            };
            Results.prototype.template = function(result, container) {
              var template2 = this.options.get("templateResult");
              var escapeMarkup = this.options.get("escapeMarkup");
              var content = template2(result, container);
              if (content == null) {
                container.style.display = "none";
              } else if (typeof content === "string") {
                container.innerHTML = escapeMarkup(content);
              } else {
                $7(container).append(content);
              }
            };
            return Results;
          });
          S23.define("select2/keys", [], function() {
            var KEYS = {
              BACKSPACE: 8,
              TAB: 9,
              ENTER: 13,
              SHIFT: 16,
              CTRL: 17,
              ALT: 18,
              ESC: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT: 37,
              UP: 38,
              RIGHT: 39,
              DOWN: 40,
              DELETE: 46
            };
            return KEYS;
          });
          S23.define("select2/selection/base", [
            "jquery",
            "../utils",
            "../keys"
          ], function($7, Utils, KEYS) {
            function BaseSelection($element, options) {
              this.$element = $element;
              this.options = options;
              BaseSelection.__super__.constructor.call(this);
            }
            Utils.Extend(BaseSelection, Utils.Observable);
            BaseSelection.prototype.render = function() {
              var $selection = $7(
                '<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>'
              );
              this._tabindex = 0;
              if (Utils.GetData(this.$element[0], "old-tabindex") != null) {
                this._tabindex = Utils.GetData(this.$element[0], "old-tabindex");
              } else if (this.$element.attr("tabindex") != null) {
                this._tabindex = this.$element.attr("tabindex");
              }
              $selection.attr("title", this.$element.attr("title"));
              $selection.attr("tabindex", this._tabindex);
              $selection.attr("aria-disabled", "false");
              this.$selection = $selection;
              return $selection;
            };
            BaseSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              this.container = container;
              this.$selection.on("focus", function(evt) {
                self2.trigger("focus", evt);
              });
              this.$selection.on("blur", function(evt) {
                self2._handleBlur(evt);
              });
              this.$selection.on("keydown", function(evt) {
                self2.trigger("keypress", evt);
                if (evt.which === KEYS.SPACE) {
                  evt.preventDefault();
                }
              });
              container.on("results:focus", function(params) {
                self2.$selection.attr("aria-activedescendant", params.data._resultId);
              });
              container.on("selection:update", function(params) {
                self2.update(params.data);
              });
              container.on("open", function() {
                self2.$selection.attr("aria-expanded", "true");
                self2.$selection.attr("aria-owns", resultsId);
                self2._attachCloseHandler(container);
              });
              container.on("close", function() {
                self2.$selection.attr("aria-expanded", "false");
                self2.$selection.removeAttr("aria-activedescendant");
                self2.$selection.removeAttr("aria-owns");
                self2.$selection.trigger("focus");
                self2._detachCloseHandler(container);
              });
              container.on("enable", function() {
                self2.$selection.attr("tabindex", self2._tabindex);
                self2.$selection.attr("aria-disabled", "false");
              });
              container.on("disable", function() {
                self2.$selection.attr("tabindex", "-1");
                self2.$selection.attr("aria-disabled", "true");
              });
            };
            BaseSelection.prototype._handleBlur = function(evt) {
              var self2 = this;
              window.setTimeout(function() {
                if (document.activeElement == self2.$selection[0] || $7.contains(self2.$selection[0], document.activeElement)) {
                  return;
                }
                self2.trigger("blur", evt);
              }, 1);
            };
            BaseSelection.prototype._attachCloseHandler = function(container) {
              $7(document.body).on("mousedown.select2." + container.id, function(e2) {
                var $target = $7(e2.target);
                var $select = $target.closest(".select2");
                var $all = $7(".select2.select2-container--open");
                $all.each(function() {
                  if (this == $select[0]) {
                    return;
                  }
                  var $element = Utils.GetData(this, "element");
                  $element.select2("close");
                });
              });
            };
            BaseSelection.prototype._detachCloseHandler = function(container) {
              $7(document.body).off("mousedown.select2." + container.id);
            };
            BaseSelection.prototype.position = function($selection, $container) {
              var $selectionContainer = $container.find(".selection");
              $selectionContainer.append($selection);
            };
            BaseSelection.prototype.destroy = function() {
              this._detachCloseHandler(this.container);
            };
            BaseSelection.prototype.update = function(data) {
              throw new Error("The `update` method must be defined in child classes.");
            };
            BaseSelection.prototype.isEnabled = function() {
              return !this.isDisabled();
            };
            BaseSelection.prototype.isDisabled = function() {
              return this.options.get("disabled");
            };
            return BaseSelection;
          });
          S23.define("select2/selection/single", [
            "jquery",
            "./base",
            "../utils",
            "../keys"
          ], function($7, BaseSelection, Utils, KEYS) {
            function SingleSelection() {
              SingleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(SingleSelection, BaseSelection);
            SingleSelection.prototype.render = function() {
              var $selection = SingleSelection.__super__.render.call(this);
              $selection.addClass("select2-selection--single");
              $selection.html(
                '<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'
              );
              return $selection;
            };
            SingleSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              SingleSelection.__super__.bind.apply(this, arguments);
              var id = container.id + "-container";
              this.$selection.find(".select2-selection__rendered").attr("id", id).attr("role", "textbox").attr("aria-readonly", "true");
              this.$selection.attr("aria-labelledby", id);
              this.$selection.on("mousedown", function(evt) {
                if (evt.which !== 1) {
                  return;
                }
                self2.trigger("toggle", {
                  originalEvent: evt
                });
              });
              this.$selection.on("focus", function(evt) {
              });
              this.$selection.on("blur", function(evt) {
              });
              container.on("focus", function(evt) {
                if (!container.isOpen()) {
                  self2.$selection.trigger("focus");
                }
              });
            };
            SingleSelection.prototype.clear = function() {
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.empty();
              $rendered.removeAttr("title");
            };
            SingleSelection.prototype.display = function(data, container) {
              var template2 = this.options.get("templateSelection");
              var escapeMarkup = this.options.get("escapeMarkup");
              return escapeMarkup(template2(data, container));
            };
            SingleSelection.prototype.selectionContainer = function() {
              return $7("<span></span>");
            };
            SingleSelection.prototype.update = function(data) {
              if (data.length === 0) {
                this.clear();
                return;
              }
              var selection = data[0];
              var $rendered = this.$selection.find(".select2-selection__rendered");
              var formatted = this.display(selection, $rendered);
              $rendered.empty().append(formatted);
              var title = selection.title || selection.text;
              if (title) {
                $rendered.attr("title", title);
              } else {
                $rendered.removeAttr("title");
              }
            };
            return SingleSelection;
          });
          S23.define("select2/selection/multiple", [
            "jquery",
            "./base",
            "../utils"
          ], function($7, BaseSelection, Utils) {
            function MultipleSelection($element, options) {
              MultipleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(MultipleSelection, BaseSelection);
            MultipleSelection.prototype.render = function() {
              var $selection = MultipleSelection.__super__.render.call(this);
              $selection.addClass("select2-selection--multiple");
              $selection.html(
                '<ul class="select2-selection__rendered"></ul>'
              );
              return $selection;
            };
            MultipleSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              MultipleSelection.__super__.bind.apply(this, arguments);
              this.$selection.on("click", function(evt) {
                self2.trigger("toggle", {
                  originalEvent: evt
                });
              });
              this.$selection.on(
                "click",
                ".select2-selection__choice__remove",
                function(evt) {
                  if (self2.isDisabled()) {
                    return;
                  }
                  var $remove = $7(this);
                  var $selection = $remove.parent();
                  var data = Utils.GetData($selection[0], "data");
                  self2.trigger("unselect", {
                    originalEvent: evt,
                    data
                  });
                }
              );
            };
            MultipleSelection.prototype.clear = function() {
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.empty();
              $rendered.removeAttr("title");
            };
            MultipleSelection.prototype.display = function(data, container) {
              var template2 = this.options.get("templateSelection");
              var escapeMarkup = this.options.get("escapeMarkup");
              return escapeMarkup(template2(data, container));
            };
            MultipleSelection.prototype.selectionContainer = function() {
              var $container = $7(
                '<li class="select2-selection__choice"><span class="select2-selection__choice__remove" role="presentation">&times;</span></li>'
              );
              return $container;
            };
            MultipleSelection.prototype.update = function(data) {
              this.clear();
              if (data.length === 0) {
                return;
              }
              var $selections = [];
              for (var d5 = 0; d5 < data.length; d5++) {
                var selection = data[d5];
                var $selection = this.selectionContainer();
                var formatted = this.display(selection, $selection);
                $selection.append(formatted);
                var title = selection.title || selection.text;
                if (title) {
                  $selection.attr("title", title);
                }
                Utils.StoreData($selection[0], "data", selection);
                $selections.push($selection);
              }
              var $rendered = this.$selection.find(".select2-selection__rendered");
              Utils.appendMany($rendered, $selections);
            };
            return MultipleSelection;
          });
          S23.define("select2/selection/placeholder", [
            "../utils"
          ], function(Utils) {
            function Placeholder(decorated, $element, options) {
              this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
              decorated.call(this, $element, options);
            }
            Placeholder.prototype.normalizePlaceholder = function(_26, placeholder) {
              if (typeof placeholder === "string") {
                placeholder = {
                  id: "",
                  text: placeholder
                };
              }
              return placeholder;
            };
            Placeholder.prototype.createPlaceholder = function(decorated, placeholder) {
              var $placeholder = this.selectionContainer();
              $placeholder.html(this.display(placeholder));
              $placeholder.addClass("select2-selection__placeholder").removeClass("select2-selection__choice");
              return $placeholder;
            };
            Placeholder.prototype.update = function(decorated, data) {
              var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
              var multipleSelections = data.length > 1;
              if (multipleSelections || singlePlaceholder) {
                return decorated.call(this, data);
              }
              this.clear();
              var $placeholder = this.createPlaceholder(this.placeholder);
              this.$selection.find(".select2-selection__rendered").append($placeholder);
            };
            return Placeholder;
          });
          S23.define("select2/selection/allowClear", [
            "jquery",
            "../keys",
            "../utils"
          ], function($7, KEYS, Utils) {
            function AllowClear() {
            }
            AllowClear.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              if (this.placeholder == null) {
                if (this.options.get("debug") && window.console && console.error) {
                  console.error(
                    "Select2: The `allowClear` option should be used in combination with the `placeholder` option."
                  );
                }
              }
              this.$selection.on(
                "mousedown",
                ".select2-selection__clear",
                function(evt) {
                  self2._handleClear(evt);
                }
              );
              container.on("keypress", function(evt) {
                self2._handleKeyboardClear(evt, container);
              });
            };
            AllowClear.prototype._handleClear = function(_26, evt) {
              if (this.isDisabled()) {
                return;
              }
              var $clear = this.$selection.find(".select2-selection__clear");
              if ($clear.length === 0) {
                return;
              }
              evt.stopPropagation();
              var data = Utils.GetData($clear[0], "data");
              var previousVal = this.$element.val();
              this.$element.val(this.placeholder.id);
              var unselectData = {
                data
              };
              this.trigger("clear", unselectData);
              if (unselectData.prevented) {
                this.$element.val(previousVal);
                return;
              }
              for (var d5 = 0; d5 < data.length; d5++) {
                unselectData = {
                  data: data[d5]
                };
                this.trigger("unselect", unselectData);
                if (unselectData.prevented) {
                  this.$element.val(previousVal);
                  return;
                }
              }
              this.$element.trigger("input").trigger("change");
              this.trigger("toggle", {});
            };
            AllowClear.prototype._handleKeyboardClear = function(_26, evt, container) {
              if (container.isOpen()) {
                return;
              }
              if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
                this._handleClear(evt);
              }
            };
            AllowClear.prototype.update = function(decorated, data) {
              decorated.call(this, data);
              if (this.$selection.find(".select2-selection__placeholder").length > 0 || data.length === 0) {
                return;
              }
              var removeAll = this.options.get("translations").get("removeAllItems");
              var $remove = $7(
                '<span class="select2-selection__clear" title="' + removeAll() + '">&times;</span>'
              );
              Utils.StoreData($remove[0], "data", data);
              this.$selection.find(".select2-selection__rendered").prepend($remove);
            };
            return AllowClear;
          });
          S23.define("select2/selection/search", [
            "jquery",
            "../utils",
            "../keys"
          ], function($7, Utils, KEYS) {
            function Search(decorated, $element, options) {
              decorated.call(this, $element, options);
            }
            Search.prototype.render = function(decorated) {
              var $search = $7(
                '<li class="select2-search select2-search--inline"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" /></li>'
              );
              this.$searchContainer = $search;
              this.$search = $search.find("input");
              var $rendered = decorated.call(this);
              this._transferTabIndex();
              return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              decorated.call(this, container, $container);
              container.on("open", function() {
                self2.$search.attr("aria-controls", resultsId);
                self2.$search.trigger("focus");
              });
              container.on("close", function() {
                self2.$search.val("");
                self2.$search.removeAttr("aria-controls");
                self2.$search.removeAttr("aria-activedescendant");
                self2.$search.trigger("focus");
              });
              container.on("enable", function() {
                self2.$search.prop("disabled", false);
                self2._transferTabIndex();
              });
              container.on("disable", function() {
                self2.$search.prop("disabled", true);
              });
              container.on("focus", function(evt) {
                self2.$search.trigger("focus");
              });
              container.on("results:focus", function(params) {
                if (params.data._resultId) {
                  self2.$search.attr("aria-activedescendant", params.data._resultId);
                } else {
                  self2.$search.removeAttr("aria-activedescendant");
                }
              });
              this.$selection.on("focusin", ".select2-search--inline", function(evt) {
                self2.trigger("focus", evt);
              });
              this.$selection.on("focusout", ".select2-search--inline", function(evt) {
                self2._handleBlur(evt);
              });
              this.$selection.on("keydown", ".select2-search--inline", function(evt) {
                evt.stopPropagation();
                self2.trigger("keypress", evt);
                self2._keyUpPrevented = evt.isDefaultPrevented();
                var key = evt.which;
                if (key === KEYS.BACKSPACE && self2.$search.val() === "") {
                  var $previousChoice = self2.$searchContainer.prev(".select2-selection__choice");
                  if ($previousChoice.length > 0) {
                    var item = Utils.GetData($previousChoice[0], "data");
                    self2.searchRemoveChoice(item);
                    evt.preventDefault();
                  }
                }
              });
              this.$selection.on("click", ".select2-search--inline", function(evt) {
                if (self2.$search.val()) {
                  evt.stopPropagation();
                }
              });
              var msie = document.documentMode;
              var disableInputEvents = msie && msie <= 11;
              this.$selection.on(
                "input.searchcheck",
                ".select2-search--inline",
                function(evt) {
                  if (disableInputEvents) {
                    self2.$selection.off("input.search input.searchcheck");
                    return;
                  }
                  self2.$selection.off("keyup.search");
                }
              );
              this.$selection.on(
                "keyup.search input.search",
                ".select2-search--inline",
                function(evt) {
                  if (disableInputEvents && evt.type === "input") {
                    self2.$selection.off("input.search input.searchcheck");
                    return;
                  }
                  var key = evt.which;
                  if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                    return;
                  }
                  if (key == KEYS.TAB) {
                    return;
                  }
                  self2.handleSearch(evt);
                }
              );
            };
            Search.prototype._transferTabIndex = function(decorated) {
              this.$search.attr("tabindex", this.$selection.attr("tabindex"));
              this.$selection.attr("tabindex", "-1");
            };
            Search.prototype.createPlaceholder = function(decorated, placeholder) {
              this.$search.attr("placeholder", placeholder.text);
            };
            Search.prototype.update = function(decorated, data) {
              var searchHadFocus = this.$search[0] == document.activeElement;
              this.$search.attr("placeholder", "");
              decorated.call(this, data);
              this.$selection.find(".select2-selection__rendered").append(this.$searchContainer);
              this.resizeSearch();
              if (searchHadFocus) {
                this.$search.trigger("focus");
              }
            };
            Search.prototype.handleSearch = function() {
              this.resizeSearch();
              if (!this._keyUpPrevented) {
                var input = this.$search.val();
                this.trigger("query", {
                  term: input
                });
              }
              this._keyUpPrevented = false;
            };
            Search.prototype.searchRemoveChoice = function(decorated, item) {
              this.trigger("unselect", {
                data: item
              });
              this.$search.val(item.text);
              this.handleSearch();
            };
            Search.prototype.resizeSearch = function() {
              this.$search.css("width", "25px");
              var width = "";
              if (this.$search.attr("placeholder") !== "") {
                width = this.$selection.find(".select2-selection__rendered").width();
              } else {
                var minimumWidth = this.$search.val().length + 1;
                width = minimumWidth * 0.75 + "em";
              }
              this.$search.css("width", width);
            };
            return Search;
          });
          S23.define("select2/selection/eventRelay", [
            "jquery"
          ], function($7) {
            function EventRelay() {
            }
            EventRelay.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var relayEvents = [
                "open",
                "opening",
                "close",
                "closing",
                "select",
                "selecting",
                "unselect",
                "unselecting",
                "clear",
                "clearing"
              ];
              var preventableEvents = [
                "opening",
                "closing",
                "selecting",
                "unselecting",
                "clearing"
              ];
              decorated.call(this, container, $container);
              container.on("*", function(name2, params) {
                if ($7.inArray(name2, relayEvents) === -1) {
                  return;
                }
                params = params || {};
                var evt = $7.Event("select2:" + name2, {
                  params
                });
                self2.$element.trigger(evt);
                if ($7.inArray(name2, preventableEvents) === -1) {
                  return;
                }
                params.prevented = evt.isDefaultPrevented();
              });
            };
            return EventRelay;
          });
          S23.define("select2/translation", [
            "jquery",
            "require"
          ], function($7, require2) {
            function Translation(dict) {
              this.dict = dict || {};
            }
            Translation.prototype.all = function() {
              return this.dict;
            };
            Translation.prototype.get = function(key) {
              return this.dict[key];
            };
            Translation.prototype.extend = function(translation) {
              this.dict = $7.extend({}, translation.all(), this.dict);
            };
            Translation._cache = {};
            Translation.loadPath = function(path) {
              if (!(path in Translation._cache)) {
                var translations = require2(path);
                Translation._cache[path] = translations;
              }
              return new Translation(Translation._cache[path]);
            };
            return Translation;
          });
          S23.define("select2/diacritics", [], function() {
            var diacritics = {
              "\u24B6": "A",
              "\uFF21": "A",
              "\xC0": "A",
              "\xC1": "A",
              "\xC2": "A",
              "\u1EA6": "A",
              "\u1EA4": "A",
              "\u1EAA": "A",
              "\u1EA8": "A",
              "\xC3": "A",
              "\u0100": "A",
              "\u0102": "A",
              "\u1EB0": "A",
              "\u1EAE": "A",
              "\u1EB4": "A",
              "\u1EB2": "A",
              "\u0226": "A",
              "\u01E0": "A",
              "\xC4": "A",
              "\u01DE": "A",
              "\u1EA2": "A",
              "\xC5": "A",
              "\u01FA": "A",
              "\u01CD": "A",
              "\u0200": "A",
              "\u0202": "A",
              "\u1EA0": "A",
              "\u1EAC": "A",
              "\u1EB6": "A",
              "\u1E00": "A",
              "\u0104": "A",
              "\u023A": "A",
              "\u2C6F": "A",
              "\uA732": "AA",
              "\xC6": "AE",
              "\u01FC": "AE",
              "\u01E2": "AE",
              "\uA734": "AO",
              "\uA736": "AU",
              "\uA738": "AV",
              "\uA73A": "AV",
              "\uA73C": "AY",
              "\u24B7": "B",
              "\uFF22": "B",
              "\u1E02": "B",
              "\u1E04": "B",
              "\u1E06": "B",
              "\u0243": "B",
              "\u0182": "B",
              "\u0181": "B",
              "\u24B8": "C",
              "\uFF23": "C",
              "\u0106": "C",
              "\u0108": "C",
              "\u010A": "C",
              "\u010C": "C",
              "\xC7": "C",
              "\u1E08": "C",
              "\u0187": "C",
              "\u023B": "C",
              "\uA73E": "C",
              "\u24B9": "D",
              "\uFF24": "D",
              "\u1E0A": "D",
              "\u010E": "D",
              "\u1E0C": "D",
              "\u1E10": "D",
              "\u1E12": "D",
              "\u1E0E": "D",
              "\u0110": "D",
              "\u018B": "D",
              "\u018A": "D",
              "\u0189": "D",
              "\uA779": "D",
              "\u01F1": "DZ",
              "\u01C4": "DZ",
              "\u01F2": "Dz",
              "\u01C5": "Dz",
              "\u24BA": "E",
              "\uFF25": "E",
              "\xC8": "E",
              "\xC9": "E",
              "\xCA": "E",
              "\u1EC0": "E",
              "\u1EBE": "E",
              "\u1EC4": "E",
              "\u1EC2": "E",
              "\u1EBC": "E",
              "\u0112": "E",
              "\u1E14": "E",
              "\u1E16": "E",
              "\u0114": "E",
              "\u0116": "E",
              "\xCB": "E",
              "\u1EBA": "E",
              "\u011A": "E",
              "\u0204": "E",
              "\u0206": "E",
              "\u1EB8": "E",
              "\u1EC6": "E",
              "\u0228": "E",
              "\u1E1C": "E",
              "\u0118": "E",
              "\u1E18": "E",
              "\u1E1A": "E",
              "\u0190": "E",
              "\u018E": "E",
              "\u24BB": "F",
              "\uFF26": "F",
              "\u1E1E": "F",
              "\u0191": "F",
              "\uA77B": "F",
              "\u24BC": "G",
              "\uFF27": "G",
              "\u01F4": "G",
              "\u011C": "G",
              "\u1E20": "G",
              "\u011E": "G",
              "\u0120": "G",
              "\u01E6": "G",
              "\u0122": "G",
              "\u01E4": "G",
              "\u0193": "G",
              "\uA7A0": "G",
              "\uA77D": "G",
              "\uA77E": "G",
              "\u24BD": "H",
              "\uFF28": "H",
              "\u0124": "H",
              "\u1E22": "H",
              "\u1E26": "H",
              "\u021E": "H",
              "\u1E24": "H",
              "\u1E28": "H",
              "\u1E2A": "H",
              "\u0126": "H",
              "\u2C67": "H",
              "\u2C75": "H",
              "\uA78D": "H",
              "\u24BE": "I",
              "\uFF29": "I",
              "\xCC": "I",
              "\xCD": "I",
              "\xCE": "I",
              "\u0128": "I",
              "\u012A": "I",
              "\u012C": "I",
              "\u0130": "I",
              "\xCF": "I",
              "\u1E2E": "I",
              "\u1EC8": "I",
              "\u01CF": "I",
              "\u0208": "I",
              "\u020A": "I",
              "\u1ECA": "I",
              "\u012E": "I",
              "\u1E2C": "I",
              "\u0197": "I",
              "\u24BF": "J",
              "\uFF2A": "J",
              "\u0134": "J",
              "\u0248": "J",
              "\u24C0": "K",
              "\uFF2B": "K",
              "\u1E30": "K",
              "\u01E8": "K",
              "\u1E32": "K",
              "\u0136": "K",
              "\u1E34": "K",
              "\u0198": "K",
              "\u2C69": "K",
              "\uA740": "K",
              "\uA742": "K",
              "\uA744": "K",
              "\uA7A2": "K",
              "\u24C1": "L",
              "\uFF2C": "L",
              "\u013F": "L",
              "\u0139": "L",
              "\u013D": "L",
              "\u1E36": "L",
              "\u1E38": "L",
              "\u013B": "L",
              "\u1E3C": "L",
              "\u1E3A": "L",
              "\u0141": "L",
              "\u023D": "L",
              "\u2C62": "L",
              "\u2C60": "L",
              "\uA748": "L",
              "\uA746": "L",
              "\uA780": "L",
              "\u01C7": "LJ",
              "\u01C8": "Lj",
              "\u24C2": "M",
              "\uFF2D": "M",
              "\u1E3E": "M",
              "\u1E40": "M",
              "\u1E42": "M",
              "\u2C6E": "M",
              "\u019C": "M",
              "\u24C3": "N",
              "\uFF2E": "N",
              "\u01F8": "N",
              "\u0143": "N",
              "\xD1": "N",
              "\u1E44": "N",
              "\u0147": "N",
              "\u1E46": "N",
              "\u0145": "N",
              "\u1E4A": "N",
              "\u1E48": "N",
              "\u0220": "N",
              "\u019D": "N",
              "\uA790": "N",
              "\uA7A4": "N",
              "\u01CA": "NJ",
              "\u01CB": "Nj",
              "\u24C4": "O",
              "\uFF2F": "O",
              "\xD2": "O",
              "\xD3": "O",
              "\xD4": "O",
              "\u1ED2": "O",
              "\u1ED0": "O",
              "\u1ED6": "O",
              "\u1ED4": "O",
              "\xD5": "O",
              "\u1E4C": "O",
              "\u022C": "O",
              "\u1E4E": "O",
              "\u014C": "O",
              "\u1E50": "O",
              "\u1E52": "O",
              "\u014E": "O",
              "\u022E": "O",
              "\u0230": "O",
              "\xD6": "O",
              "\u022A": "O",
              "\u1ECE": "O",
              "\u0150": "O",
              "\u01D1": "O",
              "\u020C": "O",
              "\u020E": "O",
              "\u01A0": "O",
              "\u1EDC": "O",
              "\u1EDA": "O",
              "\u1EE0": "O",
              "\u1EDE": "O",
              "\u1EE2": "O",
              "\u1ECC": "O",
              "\u1ED8": "O",
              "\u01EA": "O",
              "\u01EC": "O",
              "\xD8": "O",
              "\u01FE": "O",
              "\u0186": "O",
              "\u019F": "O",
              "\uA74A": "O",
              "\uA74C": "O",
              "\u0152": "OE",
              "\u01A2": "OI",
              "\uA74E": "OO",
              "\u0222": "OU",
              "\u24C5": "P",
              "\uFF30": "P",
              "\u1E54": "P",
              "\u1E56": "P",
              "\u01A4": "P",
              "\u2C63": "P",
              "\uA750": "P",
              "\uA752": "P",
              "\uA754": "P",
              "\u24C6": "Q",
              "\uFF31": "Q",
              "\uA756": "Q",
              "\uA758": "Q",
              "\u024A": "Q",
              "\u24C7": "R",
              "\uFF32": "R",
              "\u0154": "R",
              "\u1E58": "R",
              "\u0158": "R",
              "\u0210": "R",
              "\u0212": "R",
              "\u1E5A": "R",
              "\u1E5C": "R",
              "\u0156": "R",
              "\u1E5E": "R",
              "\u024C": "R",
              "\u2C64": "R",
              "\uA75A": "R",
              "\uA7A6": "R",
              "\uA782": "R",
              "\u24C8": "S",
              "\uFF33": "S",
              "\u1E9E": "S",
              "\u015A": "S",
              "\u1E64": "S",
              "\u015C": "S",
              "\u1E60": "S",
              "\u0160": "S",
              "\u1E66": "S",
              "\u1E62": "S",
              "\u1E68": "S",
              "\u0218": "S",
              "\u015E": "S",
              "\u2C7E": "S",
              "\uA7A8": "S",
              "\uA784": "S",
              "\u24C9": "T",
              "\uFF34": "T",
              "\u1E6A": "T",
              "\u0164": "T",
              "\u1E6C": "T",
              "\u021A": "T",
              "\u0162": "T",
              "\u1E70": "T",
              "\u1E6E": "T",
              "\u0166": "T",
              "\u01AC": "T",
              "\u01AE": "T",
              "\u023E": "T",
              "\uA786": "T",
              "\uA728": "TZ",
              "\u24CA": "U",
              "\uFF35": "U",
              "\xD9": "U",
              "\xDA": "U",
              "\xDB": "U",
              "\u0168": "U",
              "\u1E78": "U",
              "\u016A": "U",
              "\u1E7A": "U",
              "\u016C": "U",
              "\xDC": "U",
              "\u01DB": "U",
              "\u01D7": "U",
              "\u01D5": "U",
              "\u01D9": "U",
              "\u1EE6": "U",
              "\u016E": "U",
              "\u0170": "U",
              "\u01D3": "U",
              "\u0214": "U",
              "\u0216": "U",
              "\u01AF": "U",
              "\u1EEA": "U",
              "\u1EE8": "U",
              "\u1EEE": "U",
              "\u1EEC": "U",
              "\u1EF0": "U",
              "\u1EE4": "U",
              "\u1E72": "U",
              "\u0172": "U",
              "\u1E76": "U",
              "\u1E74": "U",
              "\u0244": "U",
              "\u24CB": "V",
              "\uFF36": "V",
              "\u1E7C": "V",
              "\u1E7E": "V",
              "\u01B2": "V",
              "\uA75E": "V",
              "\u0245": "V",
              "\uA760": "VY",
              "\u24CC": "W",
              "\uFF37": "W",
              "\u1E80": "W",
              "\u1E82": "W",
              "\u0174": "W",
              "\u1E86": "W",
              "\u1E84": "W",
              "\u1E88": "W",
              "\u2C72": "W",
              "\u24CD": "X",
              "\uFF38": "X",
              "\u1E8A": "X",
              "\u1E8C": "X",
              "\u24CE": "Y",
              "\uFF39": "Y",
              "\u1EF2": "Y",
              "\xDD": "Y",
              "\u0176": "Y",
              "\u1EF8": "Y",
              "\u0232": "Y",
              "\u1E8E": "Y",
              "\u0178": "Y",
              "\u1EF6": "Y",
              "\u1EF4": "Y",
              "\u01B3": "Y",
              "\u024E": "Y",
              "\u1EFE": "Y",
              "\u24CF": "Z",
              "\uFF3A": "Z",
              "\u0179": "Z",
              "\u1E90": "Z",
              "\u017B": "Z",
              "\u017D": "Z",
              "\u1E92": "Z",
              "\u1E94": "Z",
              "\u01B5": "Z",
              "\u0224": "Z",
              "\u2C7F": "Z",
              "\u2C6B": "Z",
              "\uA762": "Z",
              "\u24D0": "a",
              "\uFF41": "a",
              "\u1E9A": "a",
              "\xE0": "a",
              "\xE1": "a",
              "\xE2": "a",
              "\u1EA7": "a",
              "\u1EA5": "a",
              "\u1EAB": "a",
              "\u1EA9": "a",
              "\xE3": "a",
              "\u0101": "a",
              "\u0103": "a",
              "\u1EB1": "a",
              "\u1EAF": "a",
              "\u1EB5": "a",
              "\u1EB3": "a",
              "\u0227": "a",
              "\u01E1": "a",
              "\xE4": "a",
              "\u01DF": "a",
              "\u1EA3": "a",
              "\xE5": "a",
              "\u01FB": "a",
              "\u01CE": "a",
              "\u0201": "a",
              "\u0203": "a",
              "\u1EA1": "a",
              "\u1EAD": "a",
              "\u1EB7": "a",
              "\u1E01": "a",
              "\u0105": "a",
              "\u2C65": "a",
              "\u0250": "a",
              "\uA733": "aa",
              "\xE6": "ae",
              "\u01FD": "ae",
              "\u01E3": "ae",
              "\uA735": "ao",
              "\uA737": "au",
              "\uA739": "av",
              "\uA73B": "av",
              "\uA73D": "ay",
              "\u24D1": "b",
              "\uFF42": "b",
              "\u1E03": "b",
              "\u1E05": "b",
              "\u1E07": "b",
              "\u0180": "b",
              "\u0183": "b",
              "\u0253": "b",
              "\u24D2": "c",
              "\uFF43": "c",
              "\u0107": "c",
              "\u0109": "c",
              "\u010B": "c",
              "\u010D": "c",
              "\xE7": "c",
              "\u1E09": "c",
              "\u0188": "c",
              "\u023C": "c",
              "\uA73F": "c",
              "\u2184": "c",
              "\u24D3": "d",
              "\uFF44": "d",
              "\u1E0B": "d",
              "\u010F": "d",
              "\u1E0D": "d",
              "\u1E11": "d",
              "\u1E13": "d",
              "\u1E0F": "d",
              "\u0111": "d",
              "\u018C": "d",
              "\u0256": "d",
              "\u0257": "d",
              "\uA77A": "d",
              "\u01F3": "dz",
              "\u01C6": "dz",
              "\u24D4": "e",
              "\uFF45": "e",
              "\xE8": "e",
              "\xE9": "e",
              "\xEA": "e",
              "\u1EC1": "e",
              "\u1EBF": "e",
              "\u1EC5": "e",
              "\u1EC3": "e",
              "\u1EBD": "e",
              "\u0113": "e",
              "\u1E15": "e",
              "\u1E17": "e",
              "\u0115": "e",
              "\u0117": "e",
              "\xEB": "e",
              "\u1EBB": "e",
              "\u011B": "e",
              "\u0205": "e",
              "\u0207": "e",
              "\u1EB9": "e",
              "\u1EC7": "e",
              "\u0229": "e",
              "\u1E1D": "e",
              "\u0119": "e",
              "\u1E19": "e",
              "\u1E1B": "e",
              "\u0247": "e",
              "\u025B": "e",
              "\u01DD": "e",
              "\u24D5": "f",
              "\uFF46": "f",
              "\u1E1F": "f",
              "\u0192": "f",
              "\uA77C": "f",
              "\u24D6": "g",
              "\uFF47": "g",
              "\u01F5": "g",
              "\u011D": "g",
              "\u1E21": "g",
              "\u011F": "g",
              "\u0121": "g",
              "\u01E7": "g",
              "\u0123": "g",
              "\u01E5": "g",
              "\u0260": "g",
              "\uA7A1": "g",
              "\u1D79": "g",
              "\uA77F": "g",
              "\u24D7": "h",
              "\uFF48": "h",
              "\u0125": "h",
              "\u1E23": "h",
              "\u1E27": "h",
              "\u021F": "h",
              "\u1E25": "h",
              "\u1E29": "h",
              "\u1E2B": "h",
              "\u1E96": "h",
              "\u0127": "h",
              "\u2C68": "h",
              "\u2C76": "h",
              "\u0265": "h",
              "\u0195": "hv",
              "\u24D8": "i",
              "\uFF49": "i",
              "\xEC": "i",
              "\xED": "i",
              "\xEE": "i",
              "\u0129": "i",
              "\u012B": "i",
              "\u012D": "i",
              "\xEF": "i",
              "\u1E2F": "i",
              "\u1EC9": "i",
              "\u01D0": "i",
              "\u0209": "i",
              "\u020B": "i",
              "\u1ECB": "i",
              "\u012F": "i",
              "\u1E2D": "i",
              "\u0268": "i",
              "\u0131": "i",
              "\u24D9": "j",
              "\uFF4A": "j",
              "\u0135": "j",
              "\u01F0": "j",
              "\u0249": "j",
              "\u24DA": "k",
              "\uFF4B": "k",
              "\u1E31": "k",
              "\u01E9": "k",
              "\u1E33": "k",
              "\u0137": "k",
              "\u1E35": "k",
              "\u0199": "k",
              "\u2C6A": "k",
              "\uA741": "k",
              "\uA743": "k",
              "\uA745": "k",
              "\uA7A3": "k",
              "\u24DB": "l",
              "\uFF4C": "l",
              "\u0140": "l",
              "\u013A": "l",
              "\u013E": "l",
              "\u1E37": "l",
              "\u1E39": "l",
              "\u013C": "l",
              "\u1E3D": "l",
              "\u1E3B": "l",
              "\u017F": "l",
              "\u0142": "l",
              "\u019A": "l",
              "\u026B": "l",
              "\u2C61": "l",
              "\uA749": "l",
              "\uA781": "l",
              "\uA747": "l",
              "\u01C9": "lj",
              "\u24DC": "m",
              "\uFF4D": "m",
              "\u1E3F": "m",
              "\u1E41": "m",
              "\u1E43": "m",
              "\u0271": "m",
              "\u026F": "m",
              "\u24DD": "n",
              "\uFF4E": "n",
              "\u01F9": "n",
              "\u0144": "n",
              "\xF1": "n",
              "\u1E45": "n",
              "\u0148": "n",
              "\u1E47": "n",
              "\u0146": "n",
              "\u1E4B": "n",
              "\u1E49": "n",
              "\u019E": "n",
              "\u0272": "n",
              "\u0149": "n",
              "\uA791": "n",
              "\uA7A5": "n",
              "\u01CC": "nj",
              "\u24DE": "o",
              "\uFF4F": "o",
              "\xF2": "o",
              "\xF3": "o",
              "\xF4": "o",
              "\u1ED3": "o",
              "\u1ED1": "o",
              "\u1ED7": "o",
              "\u1ED5": "o",
              "\xF5": "o",
              "\u1E4D": "o",
              "\u022D": "o",
              "\u1E4F": "o",
              "\u014D": "o",
              "\u1E51": "o",
              "\u1E53": "o",
              "\u014F": "o",
              "\u022F": "o",
              "\u0231": "o",
              "\xF6": "o",
              "\u022B": "o",
              "\u1ECF": "o",
              "\u0151": "o",
              "\u01D2": "o",
              "\u020D": "o",
              "\u020F": "o",
              "\u01A1": "o",
              "\u1EDD": "o",
              "\u1EDB": "o",
              "\u1EE1": "o",
              "\u1EDF": "o",
              "\u1EE3": "o",
              "\u1ECD": "o",
              "\u1ED9": "o",
              "\u01EB": "o",
              "\u01ED": "o",
              "\xF8": "o",
              "\u01FF": "o",
              "\u0254": "o",
              "\uA74B": "o",
              "\uA74D": "o",
              "\u0275": "o",
              "\u0153": "oe",
              "\u01A3": "oi",
              "\u0223": "ou",
              "\uA74F": "oo",
              "\u24DF": "p",
              "\uFF50": "p",
              "\u1E55": "p",
              "\u1E57": "p",
              "\u01A5": "p",
              "\u1D7D": "p",
              "\uA751": "p",
              "\uA753": "p",
              "\uA755": "p",
              "\u24E0": "q",
              "\uFF51": "q",
              "\u024B": "q",
              "\uA757": "q",
              "\uA759": "q",
              "\u24E1": "r",
              "\uFF52": "r",
              "\u0155": "r",
              "\u1E59": "r",
              "\u0159": "r",
              "\u0211": "r",
              "\u0213": "r",
              "\u1E5B": "r",
              "\u1E5D": "r",
              "\u0157": "r",
              "\u1E5F": "r",
              "\u024D": "r",
              "\u027D": "r",
              "\uA75B": "r",
              "\uA7A7": "r",
              "\uA783": "r",
              "\u24E2": "s",
              "\uFF53": "s",
              "\xDF": "s",
              "\u015B": "s",
              "\u1E65": "s",
              "\u015D": "s",
              "\u1E61": "s",
              "\u0161": "s",
              "\u1E67": "s",
              "\u1E63": "s",
              "\u1E69": "s",
              "\u0219": "s",
              "\u015F": "s",
              "\u023F": "s",
              "\uA7A9": "s",
              "\uA785": "s",
              "\u1E9B": "s",
              "\u24E3": "t",
              "\uFF54": "t",
              "\u1E6B": "t",
              "\u1E97": "t",
              "\u0165": "t",
              "\u1E6D": "t",
              "\u021B": "t",
              "\u0163": "t",
              "\u1E71": "t",
              "\u1E6F": "t",
              "\u0167": "t",
              "\u01AD": "t",
              "\u0288": "t",
              "\u2C66": "t",
              "\uA787": "t",
              "\uA729": "tz",
              "\u24E4": "u",
              "\uFF55": "u",
              "\xF9": "u",
              "\xFA": "u",
              "\xFB": "u",
              "\u0169": "u",
              "\u1E79": "u",
              "\u016B": "u",
              "\u1E7B": "u",
              "\u016D": "u",
              "\xFC": "u",
              "\u01DC": "u",
              "\u01D8": "u",
              "\u01D6": "u",
              "\u01DA": "u",
              "\u1EE7": "u",
              "\u016F": "u",
              "\u0171": "u",
              "\u01D4": "u",
              "\u0215": "u",
              "\u0217": "u",
              "\u01B0": "u",
              "\u1EEB": "u",
              "\u1EE9": "u",
              "\u1EEF": "u",
              "\u1EED": "u",
              "\u1EF1": "u",
              "\u1EE5": "u",
              "\u1E73": "u",
              "\u0173": "u",
              "\u1E77": "u",
              "\u1E75": "u",
              "\u0289": "u",
              "\u24E5": "v",
              "\uFF56": "v",
              "\u1E7D": "v",
              "\u1E7F": "v",
              "\u028B": "v",
              "\uA75F": "v",
              "\u028C": "v",
              "\uA761": "vy",
              "\u24E6": "w",
              "\uFF57": "w",
              "\u1E81": "w",
              "\u1E83": "w",
              "\u0175": "w",
              "\u1E87": "w",
              "\u1E85": "w",
              "\u1E98": "w",
              "\u1E89": "w",
              "\u2C73": "w",
              "\u24E7": "x",
              "\uFF58": "x",
              "\u1E8B": "x",
              "\u1E8D": "x",
              "\u24E8": "y",
              "\uFF59": "y",
              "\u1EF3": "y",
              "\xFD": "y",
              "\u0177": "y",
              "\u1EF9": "y",
              "\u0233": "y",
              "\u1E8F": "y",
              "\xFF": "y",
              "\u1EF7": "y",
              "\u1E99": "y",
              "\u1EF5": "y",
              "\u01B4": "y",
              "\u024F": "y",
              "\u1EFF": "y",
              "\u24E9": "z",
              "\uFF5A": "z",
              "\u017A": "z",
              "\u1E91": "z",
              "\u017C": "z",
              "\u017E": "z",
              "\u1E93": "z",
              "\u1E95": "z",
              "\u01B6": "z",
              "\u0225": "z",
              "\u0240": "z",
              "\u2C6C": "z",
              "\uA763": "z",
              "\u0386": "\u0391",
              "\u0388": "\u0395",
              "\u0389": "\u0397",
              "\u038A": "\u0399",
              "\u03AA": "\u0399",
              "\u038C": "\u039F",
              "\u038E": "\u03A5",
              "\u03AB": "\u03A5",
              "\u038F": "\u03A9",
              "\u03AC": "\u03B1",
              "\u03AD": "\u03B5",
              "\u03AE": "\u03B7",
              "\u03AF": "\u03B9",
              "\u03CA": "\u03B9",
              "\u0390": "\u03B9",
              "\u03CC": "\u03BF",
              "\u03CD": "\u03C5",
              "\u03CB": "\u03C5",
              "\u03B0": "\u03C5",
              "\u03CE": "\u03C9",
              "\u03C2": "\u03C3",
              "\u2019": "'"
            };
            return diacritics;
          });
          S23.define("select2/data/base", [
            "../utils"
          ], function(Utils) {
            function BaseAdapter($element, options) {
              BaseAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(BaseAdapter, Utils.Observable);
            BaseAdapter.prototype.current = function(callback2) {
              throw new Error("The `current` method must be defined in child classes.");
            };
            BaseAdapter.prototype.query = function(params, callback2) {
              throw new Error("The `query` method must be defined in child classes.");
            };
            BaseAdapter.prototype.bind = function(container, $container) {
            };
            BaseAdapter.prototype.destroy = function() {
            };
            BaseAdapter.prototype.generateResultId = function(container, data) {
              var id = container.id + "-result-";
              id += Utils.generateChars(4);
              if (data.id != null) {
                id += "-" + data.id.toString();
              } else {
                id += "-" + Utils.generateChars(4);
              }
              return id;
            };
            return BaseAdapter;
          });
          S23.define("select2/data/select", [
            "./base",
            "../utils",
            "jquery"
          ], function(BaseAdapter, Utils, $7) {
            function SelectAdapter($element, options) {
              this.$element = $element;
              this.options = options;
              SelectAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(SelectAdapter, BaseAdapter);
            SelectAdapter.prototype.current = function(callback2) {
              var data = [];
              var self2 = this;
              this.$element.find(":selected").each(function() {
                var $option = $7(this);
                var option = self2.item($option);
                data.push(option);
              });
              callback2(data);
            };
            SelectAdapter.prototype.select = function(data) {
              var self2 = this;
              data.selected = true;
              if ($7(data.element).is("option")) {
                data.element.selected = true;
                this.$element.trigger("input").trigger("change");
                return;
              }
              if (this.$element.prop("multiple")) {
                this.current(function(currentData) {
                  var val2 = [];
                  data = [data];
                  data.push.apply(data, currentData);
                  for (var d5 = 0; d5 < data.length; d5++) {
                    var id = data[d5].id;
                    if ($7.inArray(id, val2) === -1) {
                      val2.push(id);
                    }
                  }
                  self2.$element.val(val2);
                  self2.$element.trigger("input").trigger("change");
                });
              } else {
                var val = data.id;
                this.$element.val(val);
                this.$element.trigger("input").trigger("change");
              }
            };
            SelectAdapter.prototype.unselect = function(data) {
              var self2 = this;
              if (!this.$element.prop("multiple")) {
                return;
              }
              data.selected = false;
              if ($7(data.element).is("option")) {
                data.element.selected = false;
                this.$element.trigger("input").trigger("change");
                return;
              }
              this.current(function(currentData) {
                var val = [];
                for (var d5 = 0; d5 < currentData.length; d5++) {
                  var id = currentData[d5].id;
                  if (id !== data.id && $7.inArray(id, val) === -1) {
                    val.push(id);
                  }
                }
                self2.$element.val(val);
                self2.$element.trigger("input").trigger("change");
              });
            };
            SelectAdapter.prototype.bind = function(container, $container) {
              var self2 = this;
              this.container = container;
              container.on("select", function(params) {
                self2.select(params.data);
              });
              container.on("unselect", function(params) {
                self2.unselect(params.data);
              });
            };
            SelectAdapter.prototype.destroy = function() {
              this.$element.find("*").each(function() {
                Utils.RemoveData(this);
              });
            };
            SelectAdapter.prototype.query = function(params, callback2) {
              var data = [];
              var self2 = this;
              var $options = this.$element.children();
              $options.each(function() {
                var $option = $7(this);
                if (!$option.is("option") && !$option.is("optgroup")) {
                  return;
                }
                var option = self2.item($option);
                var matches = self2.matches(params, option);
                if (matches !== null) {
                  data.push(matches);
                }
              });
              callback2({
                results: data
              });
            };
            SelectAdapter.prototype.addOptions = function($options) {
              Utils.appendMany(this.$element, $options);
            };
            SelectAdapter.prototype.option = function(data) {
              var option;
              if (data.children) {
                option = document.createElement("optgroup");
                option.label = data.text;
              } else {
                option = document.createElement("option");
                if (option.textContent !== void 0) {
                  option.textContent = data.text;
                } else {
                  option.innerText = data.text;
                }
              }
              if (data.id !== void 0) {
                option.value = data.id;
              }
              if (data.disabled) {
                option.disabled = true;
              }
              if (data.selected) {
                option.selected = true;
              }
              if (data.title) {
                option.title = data.title;
              }
              var $option = $7(option);
              var normalizedData = this._normalizeItem(data);
              normalizedData.element = option;
              Utils.StoreData(option, "data", normalizedData);
              return $option;
            };
            SelectAdapter.prototype.item = function($option) {
              var data = {};
              data = Utils.GetData($option[0], "data");
              if (data != null) {
                return data;
              }
              if ($option.is("option")) {
                data = {
                  id: $option.val(),
                  text: $option.text(),
                  disabled: $option.prop("disabled"),
                  selected: $option.prop("selected"),
                  title: $option.prop("title")
                };
              } else if ($option.is("optgroup")) {
                data = {
                  text: $option.prop("label"),
                  children: [],
                  title: $option.prop("title")
                };
                var $children = $option.children("option");
                var children = [];
                for (var c4 = 0; c4 < $children.length; c4++) {
                  var $child = $7($children[c4]);
                  var child = this.item($child);
                  children.push(child);
                }
                data.children = children;
              }
              data = this._normalizeItem(data);
              data.element = $option[0];
              Utils.StoreData($option[0], "data", data);
              return data;
            };
            SelectAdapter.prototype._normalizeItem = function(item) {
              if (item !== Object(item)) {
                item = {
                  id: item,
                  text: item
                };
              }
              item = $7.extend({}, {
                text: ""
              }, item);
              var defaults3 = {
                selected: false,
                disabled: false
              };
              if (item.id != null) {
                item.id = item.id.toString();
              }
              if (item.text != null) {
                item.text = item.text.toString();
              }
              if (item._resultId == null && item.id && this.container != null) {
                item._resultId = this.generateResultId(this.container, item);
              }
              return $7.extend({}, defaults3, item);
            };
            SelectAdapter.prototype.matches = function(params, data) {
              var matcher = this.options.get("matcher");
              return matcher(params, data);
            };
            return SelectAdapter;
          });
          S23.define("select2/data/array", [
            "./select",
            "../utils",
            "jquery"
          ], function(SelectAdapter, Utils, $7) {
            function ArrayAdapter($element, options) {
              this._dataToConvert = options.get("data") || [];
              ArrayAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(ArrayAdapter, SelectAdapter);
            ArrayAdapter.prototype.bind = function(container, $container) {
              ArrayAdapter.__super__.bind.call(this, container, $container);
              this.addOptions(this.convertToOptions(this._dataToConvert));
            };
            ArrayAdapter.prototype.select = function(data) {
              var $option = this.$element.find("option").filter(function(i3, elm) {
                return elm.value == data.id.toString();
              });
              if ($option.length === 0) {
                $option = this.option(data);
                this.addOptions($option);
              }
              ArrayAdapter.__super__.select.call(this, data);
            };
            ArrayAdapter.prototype.convertToOptions = function(data) {
              var self2 = this;
              var $existing = this.$element.find("option");
              var existingIds = $existing.map(function() {
                return self2.item($7(this)).id;
              }).get();
              var $options = [];
              function onlyItem(item2) {
                return function() {
                  return $7(this).val() == item2.id;
                };
              }
              for (var d5 = 0; d5 < data.length; d5++) {
                var item = this._normalizeItem(data[d5]);
                if ($7.inArray(item.id, existingIds) >= 0) {
                  var $existingOption = $existing.filter(onlyItem(item));
                  var existingData = this.item($existingOption);
                  var newData = $7.extend(true, {}, item, existingData);
                  var $newOption = this.option(newData);
                  $existingOption.replaceWith($newOption);
                  continue;
                }
                var $option = this.option(item);
                if (item.children) {
                  var $children = this.convertToOptions(item.children);
                  Utils.appendMany($option, $children);
                }
                $options.push($option);
              }
              return $options;
            };
            return ArrayAdapter;
          });
          S23.define("select2/data/ajax", [
            "./array",
            "../utils",
            "jquery"
          ], function(ArrayAdapter, Utils, $7) {
            function AjaxAdapter($element, options) {
              this.ajaxOptions = this._applyDefaults(options.get("ajax"));
              if (this.ajaxOptions.processResults != null) {
                this.processResults = this.ajaxOptions.processResults;
              }
              AjaxAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(AjaxAdapter, ArrayAdapter);
            AjaxAdapter.prototype._applyDefaults = function(options) {
              var defaults3 = {
                data: function(params) {
                  return $7.extend({}, params, {
                    q: params.term
                  });
                },
                transport: function(params, success, failure) {
                  var $request = $7.ajax(params);
                  $request.then(success);
                  $request.fail(failure);
                  return $request;
                }
              };
              return $7.extend({}, defaults3, options, true);
            };
            AjaxAdapter.prototype.processResults = function(results) {
              return results;
            };
            AjaxAdapter.prototype.query = function(params, callback2) {
              var matches = [];
              var self2 = this;
              if (this._request != null) {
                if ($7.isFunction(this._request.abort)) {
                  this._request.abort();
                }
                this._request = null;
              }
              var options = $7.extend({
                type: "GET"
              }, this.ajaxOptions);
              if (typeof options.url === "function") {
                options.url = options.url.call(this.$element, params);
              }
              if (typeof options.data === "function") {
                options.data = options.data.call(this.$element, params);
              }
              function request2() {
                var $request = options.transport(options, function(data) {
                  var results = self2.processResults(data, params);
                  if (self2.options.get("debug") && window.console && console.error) {
                    if (!results || !results.results || !$7.isArray(results.results)) {
                      console.error(
                        "Select2: The AJAX results did not return an array in the `results` key of the response."
                      );
                    }
                  }
                  callback2(results);
                }, function() {
                  if ("status" in $request && ($request.status === 0 || $request.status === "0")) {
                    return;
                  }
                  self2.trigger("results:message", {
                    message: "errorLoading"
                  });
                });
                self2._request = $request;
              }
              if (this.ajaxOptions.delay && params.term != null) {
                if (this._queryTimeout) {
                  window.clearTimeout(this._queryTimeout);
                }
                this._queryTimeout = window.setTimeout(request2, this.ajaxOptions.delay);
              } else {
                request2();
              }
            };
            return AjaxAdapter;
          });
          S23.define("select2/data/tags", [
            "jquery"
          ], function($7) {
            function Tags(decorated, $element, options) {
              var tags = options.get("tags");
              var createTag = options.get("createTag");
              if (createTag !== void 0) {
                this.createTag = createTag;
              }
              var insertTag = options.get("insertTag");
              if (insertTag !== void 0) {
                this.insertTag = insertTag;
              }
              decorated.call(this, $element, options);
              if ($7.isArray(tags)) {
                for (var t4 = 0; t4 < tags.length; t4++) {
                  var tag = tags[t4];
                  var item = this._normalizeItem(tag);
                  var $option = this.option(item);
                  this.$element.append($option);
                }
              }
            }
            Tags.prototype.query = function(decorated, params, callback2) {
              var self2 = this;
              this._removeOldTags();
              if (params.term == null || params.page != null) {
                decorated.call(this, params, callback2);
                return;
              }
              function wrapper(obj, child) {
                var data = obj.results;
                for (var i3 = 0; i3 < data.length; i3++) {
                  var option = data[i3];
                  var checkChildren = option.children != null && !wrapper({
                    results: option.children
                  }, true);
                  var optionText = (option.text || "").toUpperCase();
                  var paramsTerm = (params.term || "").toUpperCase();
                  var checkText = optionText === paramsTerm;
                  if (checkText || checkChildren) {
                    if (child) {
                      return false;
                    }
                    obj.data = data;
                    callback2(obj);
                    return;
                  }
                }
                if (child) {
                  return true;
                }
                var tag = self2.createTag(params);
                if (tag != null) {
                  var $option = self2.option(tag);
                  $option.attr("data-select2-tag", true);
                  self2.addOptions([$option]);
                  self2.insertTag(data, tag);
                }
                obj.results = data;
                callback2(obj);
              }
              decorated.call(this, params, wrapper);
            };
            Tags.prototype.createTag = function(decorated, params) {
              var term = $7.trim(params.term);
              if (term === "") {
                return null;
              }
              return {
                id: term,
                text: term
              };
            };
            Tags.prototype.insertTag = function(_26, data, tag) {
              data.unshift(tag);
            };
            Tags.prototype._removeOldTags = function(_26) {
              var $options = this.$element.find("option[data-select2-tag]");
              $options.each(function() {
                if (this.selected) {
                  return;
                }
                $7(this).remove();
              });
            };
            return Tags;
          });
          S23.define("select2/data/tokenizer", [
            "jquery"
          ], function($7) {
            function Tokenizer(decorated, $element, options) {
              var tokenizer = options.get("tokenizer");
              if (tokenizer !== void 0) {
                this.tokenizer = tokenizer;
              }
              decorated.call(this, $element, options);
            }
            Tokenizer.prototype.bind = function(decorated, container, $container) {
              decorated.call(this, container, $container);
              this.$search = container.dropdown.$search || container.selection.$search || $container.find(".select2-search__field");
            };
            Tokenizer.prototype.query = function(decorated, params, callback2) {
              var self2 = this;
              function createAndSelect(data) {
                var item = self2._normalizeItem(data);
                var $existingOptions = self2.$element.find("option").filter(function() {
                  return $7(this).val() === item.id;
                });
                if (!$existingOptions.length) {
                  var $option = self2.option(item);
                  $option.attr("data-select2-tag", true);
                  self2._removeOldTags();
                  self2.addOptions([$option]);
                }
                select(item);
              }
              function select(data) {
                self2.trigger("select", {
                  data
                });
              }
              params.term = params.term || "";
              var tokenData = this.tokenizer(params, this.options, createAndSelect);
              if (tokenData.term !== params.term) {
                if (this.$search.length) {
                  this.$search.val(tokenData.term);
                  this.$search.trigger("focus");
                }
                params.term = tokenData.term;
              }
              decorated.call(this, params, callback2);
            };
            Tokenizer.prototype.tokenizer = function(_26, params, options, callback2) {
              var separators = options.get("tokenSeparators") || [];
              var term = params.term;
              var i3 = 0;
              var createTag = this.createTag || function(params2) {
                return {
                  id: params2.term,
                  text: params2.term
                };
              };
              while (i3 < term.length) {
                var termChar = term[i3];
                if ($7.inArray(termChar, separators) === -1) {
                  i3++;
                  continue;
                }
                var part = term.substr(0, i3);
                var partParams = $7.extend({}, params, {
                  term: part
                });
                var data = createTag(partParams);
                if (data == null) {
                  i3++;
                  continue;
                }
                callback2(data);
                term = term.substr(i3 + 1) || "";
                i3 = 0;
              }
              return {
                term
              };
            };
            return Tokenizer;
          });
          S23.define("select2/data/minimumInputLength", [], function() {
            function MinimumInputLength(decorated, $e2, options) {
              this.minimumInputLength = options.get("minimumInputLength");
              decorated.call(this, $e2, options);
            }
            MinimumInputLength.prototype.query = function(decorated, params, callback2) {
              params.term = params.term || "";
              if (params.term.length < this.minimumInputLength) {
                this.trigger("results:message", {
                  message: "inputTooShort",
                  args: {
                    minimum: this.minimumInputLength,
                    input: params.term,
                    params
                  }
                });
                return;
              }
              decorated.call(this, params, callback2);
            };
            return MinimumInputLength;
          });
          S23.define("select2/data/maximumInputLength", [], function() {
            function MaximumInputLength(decorated, $e2, options) {
              this.maximumInputLength = options.get("maximumInputLength");
              decorated.call(this, $e2, options);
            }
            MaximumInputLength.prototype.query = function(decorated, params, callback2) {
              params.term = params.term || "";
              if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
                this.trigger("results:message", {
                  message: "inputTooLong",
                  args: {
                    maximum: this.maximumInputLength,
                    input: params.term,
                    params
                  }
                });
                return;
              }
              decorated.call(this, params, callback2);
            };
            return MaximumInputLength;
          });
          S23.define("select2/data/maximumSelectionLength", [], function() {
            function MaximumSelectionLength(decorated, $e2, options) {
              this.maximumSelectionLength = options.get("maximumSelectionLength");
              decorated.call(this, $e2, options);
            }
            MaximumSelectionLength.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("select", function() {
                self2._checkIfMaximumSelected();
              });
            };
            MaximumSelectionLength.prototype.query = function(decorated, params, callback2) {
              var self2 = this;
              this._checkIfMaximumSelected(function() {
                decorated.call(self2, params, callback2);
              });
            };
            MaximumSelectionLength.prototype._checkIfMaximumSelected = function(_26, successCallback) {
              var self2 = this;
              this.current(function(currentData) {
                var count = currentData != null ? currentData.length : 0;
                if (self2.maximumSelectionLength > 0 && count >= self2.maximumSelectionLength) {
                  self2.trigger("results:message", {
                    message: "maximumSelected",
                    args: {
                      maximum: self2.maximumSelectionLength
                    }
                  });
                  return;
                }
                if (successCallback) {
                  successCallback();
                }
              });
            };
            return MaximumSelectionLength;
          });
          S23.define("select2/dropdown", [
            "jquery",
            "./utils"
          ], function($7, Utils) {
            function Dropdown($element, options) {
              this.$element = $element;
              this.options = options;
              Dropdown.__super__.constructor.call(this);
            }
            Utils.Extend(Dropdown, Utils.Observable);
            Dropdown.prototype.render = function() {
              var $dropdown = $7(
                '<span class="select2-dropdown"><span class="select2-results"></span></span>'
              );
              $dropdown.attr("dir", this.options.get("dir"));
              this.$dropdown = $dropdown;
              return $dropdown;
            };
            Dropdown.prototype.bind = function() {
            };
            Dropdown.prototype.position = function($dropdown, $container) {
            };
            Dropdown.prototype.destroy = function() {
              this.$dropdown.remove();
            };
            return Dropdown;
          });
          S23.define("select2/dropdown/search", [
            "jquery",
            "../utils"
          ], function($7, Utils) {
            function Search() {
            }
            Search.prototype.render = function(decorated) {
              var $rendered = decorated.call(this);
              var $search = $7(
                '<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" /></span>'
              );
              this.$searchContainer = $search;
              this.$search = $search.find("input");
              $rendered.prepend($search);
              return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              decorated.call(this, container, $container);
              this.$search.on("keydown", function(evt) {
                self2.trigger("keypress", evt);
                self2._keyUpPrevented = evt.isDefaultPrevented();
              });
              this.$search.on("input", function(evt) {
                $7(this).off("keyup");
              });
              this.$search.on("keyup input", function(evt) {
                self2.handleSearch(evt);
              });
              container.on("open", function() {
                self2.$search.attr("tabindex", 0);
                self2.$search.attr("aria-controls", resultsId);
                self2.$search.trigger("focus");
                window.setTimeout(function() {
                  self2.$search.trigger("focus");
                }, 0);
              });
              container.on("close", function() {
                self2.$search.attr("tabindex", -1);
                self2.$search.removeAttr("aria-controls");
                self2.$search.removeAttr("aria-activedescendant");
                self2.$search.val("");
                self2.$search.trigger("blur");
              });
              container.on("focus", function() {
                if (!container.isOpen()) {
                  self2.$search.trigger("focus");
                }
              });
              container.on("results:all", function(params) {
                if (params.query.term == null || params.query.term === "") {
                  var showSearch = self2.showSearch(params);
                  if (showSearch) {
                    self2.$searchContainer.removeClass("select2-search--hide");
                  } else {
                    self2.$searchContainer.addClass("select2-search--hide");
                  }
                }
              });
              container.on("results:focus", function(params) {
                if (params.data._resultId) {
                  self2.$search.attr("aria-activedescendant", params.data._resultId);
                } else {
                  self2.$search.removeAttr("aria-activedescendant");
                }
              });
            };
            Search.prototype.handleSearch = function(evt) {
              if (!this._keyUpPrevented) {
                var input = this.$search.val();
                this.trigger("query", {
                  term: input
                });
              }
              this._keyUpPrevented = false;
            };
            Search.prototype.showSearch = function(_26, params) {
              return true;
            };
            return Search;
          });
          S23.define("select2/dropdown/hidePlaceholder", [], function() {
            function HidePlaceholder(decorated, $element, options, dataAdapter) {
              this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
              decorated.call(this, $element, options, dataAdapter);
            }
            HidePlaceholder.prototype.append = function(decorated, data) {
              data.results = this.removePlaceholder(data.results);
              decorated.call(this, data);
            };
            HidePlaceholder.prototype.normalizePlaceholder = function(_26, placeholder) {
              if (typeof placeholder === "string") {
                placeholder = {
                  id: "",
                  text: placeholder
                };
              }
              return placeholder;
            };
            HidePlaceholder.prototype.removePlaceholder = function(_26, data) {
              var modifiedData = data.slice(0);
              for (var d5 = data.length - 1; d5 >= 0; d5--) {
                var item = data[d5];
                if (this.placeholder.id === item.id) {
                  modifiedData.splice(d5, 1);
                }
              }
              return modifiedData;
            };
            return HidePlaceholder;
          });
          S23.define("select2/dropdown/infiniteScroll", [
            "jquery"
          ], function($7) {
            function InfiniteScroll(decorated, $element, options, dataAdapter) {
              this.lastParams = {};
              decorated.call(this, $element, options, dataAdapter);
              this.$loadingMore = this.createLoadingMore();
              this.loading = false;
            }
            InfiniteScroll.prototype.append = function(decorated, data) {
              this.$loadingMore.remove();
              this.loading = false;
              decorated.call(this, data);
              if (this.showLoadingMore(data)) {
                this.$results.append(this.$loadingMore);
                this.loadMoreIfNeeded();
              }
            };
            InfiniteScroll.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("query", function(params) {
                self2.lastParams = params;
                self2.loading = true;
              });
              container.on("query:append", function(params) {
                self2.lastParams = params;
                self2.loading = true;
              });
              this.$results.on("scroll", this.loadMoreIfNeeded.bind(this));
            };
            InfiniteScroll.prototype.loadMoreIfNeeded = function() {
              var isLoadMoreVisible = $7.contains(
                document.documentElement,
                this.$loadingMore[0]
              );
              if (this.loading || !isLoadMoreVisible) {
                return;
              }
              var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
              var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);
              if (currentOffset + 50 >= loadingMoreOffset) {
                this.loadMore();
              }
            };
            InfiniteScroll.prototype.loadMore = function() {
              this.loading = true;
              var params = $7.extend({}, { page: 1 }, this.lastParams);
              params.page++;
              this.trigger("query:append", params);
            };
            InfiniteScroll.prototype.showLoadingMore = function(_26, data) {
              return data.pagination && data.pagination.more;
            };
            InfiniteScroll.prototype.createLoadingMore = function() {
              var $option = $7(
                '<li class="select2-results__option select2-results__option--load-more"role="option" aria-disabled="true"></li>'
              );
              var message = this.options.get("translations").get("loadingMore");
              $option.html(message(this.lastParams));
              return $option;
            };
            return InfiniteScroll;
          });
          S23.define("select2/dropdown/attachBody", [
            "jquery",
            "../utils"
          ], function($7, Utils) {
            function AttachBody(decorated, $element, options) {
              this.$dropdownParent = $7(options.get("dropdownParent") || document.body);
              decorated.call(this, $element, options);
            }
            AttachBody.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("open", function() {
                self2._showDropdown();
                self2._attachPositioningHandler(container);
                self2._bindContainerResultHandlers(container);
              });
              container.on("close", function() {
                self2._hideDropdown();
                self2._detachPositioningHandler(container);
              });
              this.$dropdownContainer.on("mousedown", function(evt) {
                evt.stopPropagation();
              });
            };
            AttachBody.prototype.destroy = function(decorated) {
              decorated.call(this);
              this.$dropdownContainer.remove();
            };
            AttachBody.prototype.position = function(decorated, $dropdown, $container) {
              $dropdown.attr("class", $container.attr("class"));
              $dropdown.removeClass("select2");
              $dropdown.addClass("select2-container--open");
              $dropdown.css({
                position: "absolute",
                top: -999999
              });
              this.$container = $container;
            };
            AttachBody.prototype.render = function(decorated) {
              var $container = $7("<span></span>");
              var $dropdown = decorated.call(this);
              $container.append($dropdown);
              this.$dropdownContainer = $container;
              return $container;
            };
            AttachBody.prototype._hideDropdown = function(decorated) {
              this.$dropdownContainer.detach();
            };
            AttachBody.prototype._bindContainerResultHandlers = function(decorated, container) {
              if (this._containerResultsHandlersBound) {
                return;
              }
              var self2 = this;
              container.on("results:all", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("results:append", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("results:message", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("select", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("unselect", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              this._containerResultsHandlersBound = true;
            };
            AttachBody.prototype._attachPositioningHandler = function(decorated, container) {
              var self2 = this;
              var scrollEvent = "scroll.select2." + container.id;
              var resizeEvent = "resize.select2." + container.id;
              var orientationEvent = "orientationchange.select2." + container.id;
              var $watchers = this.$container.parents().filter(Utils.hasScroll);
              $watchers.each(function() {
                Utils.StoreData(this, "select2-scroll-position", {
                  x: $7(this).scrollLeft(),
                  y: $7(this).scrollTop()
                });
              });
              $watchers.on(scrollEvent, function(ev) {
                var position = Utils.GetData(this, "select2-scroll-position");
                $7(this).scrollTop(position.y);
              });
              $7(window).on(
                scrollEvent + " " + resizeEvent + " " + orientationEvent,
                function(e2) {
                  self2._positionDropdown();
                  self2._resizeDropdown();
                }
              );
            };
            AttachBody.prototype._detachPositioningHandler = function(decorated, container) {
              var scrollEvent = "scroll.select2." + container.id;
              var resizeEvent = "resize.select2." + container.id;
              var orientationEvent = "orientationchange.select2." + container.id;
              var $watchers = this.$container.parents().filter(Utils.hasScroll);
              $watchers.off(scrollEvent);
              $7(window).off(scrollEvent + " " + resizeEvent + " " + orientationEvent);
            };
            AttachBody.prototype._positionDropdown = function() {
              var $window = $7(window);
              var isCurrentlyAbove = this.$dropdown.hasClass("select2-dropdown--above");
              var isCurrentlyBelow = this.$dropdown.hasClass("select2-dropdown--below");
              var newDirection = null;
              var offset3 = this.$container.offset();
              offset3.bottom = offset3.top + this.$container.outerHeight(false);
              var container = {
                height: this.$container.outerHeight(false)
              };
              container.top = offset3.top;
              container.bottom = offset3.top + container.height;
              var dropdown = {
                height: this.$dropdown.outerHeight(false)
              };
              var viewport2 = {
                top: $window.scrollTop(),
                bottom: $window.scrollTop() + $window.height()
              };
              var enoughRoomAbove = viewport2.top < offset3.top - dropdown.height;
              var enoughRoomBelow = viewport2.bottom > offset3.bottom + dropdown.height;
              var css = {
                left: offset3.left,
                top: container.bottom
              };
              var $offsetParent = this.$dropdownParent;
              if ($offsetParent.css("position") === "static") {
                $offsetParent = $offsetParent.offsetParent();
              }
              var parentOffset = {
                top: 0,
                left: 0
              };
              if ($7.contains(document.body, $offsetParent[0]) || $offsetParent[0].isConnected) {
                parentOffset = $offsetParent.offset();
              }
              css.top -= parentOffset.top;
              css.left -= parentOffset.left;
              if (!isCurrentlyAbove && !isCurrentlyBelow) {
                newDirection = "below";
              }
              if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
                newDirection = "above";
              } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
                newDirection = "below";
              }
              if (newDirection == "above" || isCurrentlyAbove && newDirection !== "below") {
                css.top = container.top - parentOffset.top - dropdown.height;
              }
              if (newDirection != null) {
                this.$dropdown.removeClass("select2-dropdown--below select2-dropdown--above").addClass("select2-dropdown--" + newDirection);
                this.$container.removeClass("select2-container--below select2-container--above").addClass("select2-container--" + newDirection);
              }
              this.$dropdownContainer.css(css);
            };
            AttachBody.prototype._resizeDropdown = function() {
              var css = {
                width: this.$container.outerWidth(false) + "px"
              };
              if (this.options.get("dropdownAutoWidth")) {
                css.minWidth = css.width;
                css.position = "relative";
                css.width = "auto";
              }
              this.$dropdown.css(css);
            };
            AttachBody.prototype._showDropdown = function(decorated) {
              this.$dropdownContainer.appendTo(this.$dropdownParent);
              this._positionDropdown();
              this._resizeDropdown();
            };
            return AttachBody;
          });
          S23.define("select2/dropdown/minimumResultsForSearch", [], function() {
            function countResults(data) {
              var count = 0;
              for (var d5 = 0; d5 < data.length; d5++) {
                var item = data[d5];
                if (item.children) {
                  count += countResults(item.children);
                } else {
                  count++;
                }
              }
              return count;
            }
            function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
              this.minimumResultsForSearch = options.get("minimumResultsForSearch");
              if (this.minimumResultsForSearch < 0) {
                this.minimumResultsForSearch = Infinity;
              }
              decorated.call(this, $element, options, dataAdapter);
            }
            MinimumResultsForSearch.prototype.showSearch = function(decorated, params) {
              if (countResults(params.data.results) < this.minimumResultsForSearch) {
                return false;
              }
              return decorated.call(this, params);
            };
            return MinimumResultsForSearch;
          });
          S23.define("select2/dropdown/selectOnClose", [
            "../utils"
          ], function(Utils) {
            function SelectOnClose() {
            }
            SelectOnClose.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("close", function(params) {
                self2._handleSelectOnClose(params);
              });
            };
            SelectOnClose.prototype._handleSelectOnClose = function(_26, params) {
              if (params && params.originalSelect2Event != null) {
                var event2 = params.originalSelect2Event;
                if (event2._type === "select" || event2._type === "unselect") {
                  return;
                }
              }
              var $highlightedResults = this.getHighlightedResults();
              if ($highlightedResults.length < 1) {
                return;
              }
              var data = Utils.GetData($highlightedResults[0], "data");
              if (data.element != null && data.element.selected || data.element == null && data.selected) {
                return;
              }
              this.trigger("select", {
                data
              });
            };
            return SelectOnClose;
          });
          S23.define("select2/dropdown/closeOnSelect", [], function() {
            function CloseOnSelect() {
            }
            CloseOnSelect.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("select", function(evt) {
                self2._selectTriggered(evt);
              });
              container.on("unselect", function(evt) {
                self2._selectTriggered(evt);
              });
            };
            CloseOnSelect.prototype._selectTriggered = function(_26, evt) {
              var originalEvent = evt.originalEvent;
              if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
                return;
              }
              this.trigger("close", {
                originalEvent,
                originalSelect2Event: evt
              });
            };
            return CloseOnSelect;
          });
          S23.define("select2/i18n/en", [], function() {
            return {
              errorLoading: function() {
                return "The results could not be loaded.";
              },
              inputTooLong: function(args) {
                var overChars = args.input.length - args.maximum;
                var message = "Please delete " + overChars + " character";
                if (overChars != 1) {
                  message += "s";
                }
                return message;
              },
              inputTooShort: function(args) {
                var remainingChars = args.minimum - args.input.length;
                var message = "Please enter " + remainingChars + " or more characters";
                return message;
              },
              loadingMore: function() {
                return "Loading more results\u2026";
              },
              maximumSelected: function(args) {
                var message = "You can only select " + args.maximum + " item";
                if (args.maximum != 1) {
                  message += "s";
                }
                return message;
              },
              noResults: function() {
                return "No results found";
              },
              searching: function() {
                return "Searching\u2026";
              },
              removeAllItems: function() {
                return "Remove all items";
              }
            };
          });
          S23.define("select2/defaults", [
            "jquery",
            "require",
            "./results",
            "./selection/single",
            "./selection/multiple",
            "./selection/placeholder",
            "./selection/allowClear",
            "./selection/search",
            "./selection/eventRelay",
            "./utils",
            "./translation",
            "./diacritics",
            "./data/select",
            "./data/array",
            "./data/ajax",
            "./data/tags",
            "./data/tokenizer",
            "./data/minimumInputLength",
            "./data/maximumInputLength",
            "./data/maximumSelectionLength",
            "./dropdown",
            "./dropdown/search",
            "./dropdown/hidePlaceholder",
            "./dropdown/infiniteScroll",
            "./dropdown/attachBody",
            "./dropdown/minimumResultsForSearch",
            "./dropdown/selectOnClose",
            "./dropdown/closeOnSelect",
            "./i18n/en"
          ], function($7, require2, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, EnglishTranslation) {
            function Defaults2() {
              this.reset();
            }
            Defaults2.prototype.apply = function(options) {
              options = $7.extend(true, {}, this.defaults, options);
              if (options.dataAdapter == null) {
                if (options.ajax != null) {
                  options.dataAdapter = AjaxData;
                } else if (options.data != null) {
                  options.dataAdapter = ArrayData;
                } else {
                  options.dataAdapter = SelectData;
                }
                if (options.minimumInputLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MinimumInputLength
                  );
                }
                if (options.maximumInputLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MaximumInputLength
                  );
                }
                if (options.maximumSelectionLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MaximumSelectionLength
                  );
                }
                if (options.tags) {
                  options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
                }
                if (options.tokenSeparators != null || options.tokenizer != null) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    Tokenizer
                  );
                }
                if (options.query != null) {
                  var Query = require2(options.amdBase + "compat/query");
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    Query
                  );
                }
                if (options.initSelection != null) {
                  var InitSelection = require2(options.amdBase + "compat/initSelection");
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    InitSelection
                  );
                }
              }
              if (options.resultsAdapter == null) {
                options.resultsAdapter = ResultsList;
                if (options.ajax != null) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    InfiniteScroll
                  );
                }
                if (options.placeholder != null) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    HidePlaceholder
                  );
                }
                if (options.selectOnClose) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    SelectOnClose
                  );
                }
              }
              if (options.dropdownAdapter == null) {
                if (options.multiple) {
                  options.dropdownAdapter = Dropdown;
                } else {
                  var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
                  options.dropdownAdapter = SearchableDropdown;
                }
                if (options.minimumResultsForSearch !== 0) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    MinimumResultsForSearch
                  );
                }
                if (options.closeOnSelect) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    CloseOnSelect
                  );
                }
                if (options.dropdownCssClass != null || options.dropdownCss != null || options.adaptDropdownCssClass != null) {
                  var DropdownCSS = require2(options.amdBase + "compat/dropdownCss");
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    DropdownCSS
                  );
                }
                options.dropdownAdapter = Utils.Decorate(
                  options.dropdownAdapter,
                  AttachBody
                );
              }
              if (options.selectionAdapter == null) {
                if (options.multiple) {
                  options.selectionAdapter = MultipleSelection;
                } else {
                  options.selectionAdapter = SingleSelection;
                }
                if (options.placeholder != null) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    Placeholder
                  );
                }
                if (options.allowClear) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    AllowClear
                  );
                }
                if (options.multiple) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    SelectionSearch
                  );
                }
                if (options.containerCssClass != null || options.containerCss != null || options.adaptContainerCssClass != null) {
                  var ContainerCSS = require2(options.amdBase + "compat/containerCss");
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    ContainerCSS
                  );
                }
                options.selectionAdapter = Utils.Decorate(
                  options.selectionAdapter,
                  EventRelay
                );
              }
              options.language = this._resolveLanguage(options.language);
              options.language.push("en");
              var uniqueLanguages = [];
              for (var l5 = 0; l5 < options.language.length; l5++) {
                var language = options.language[l5];
                if (uniqueLanguages.indexOf(language) === -1) {
                  uniqueLanguages.push(language);
                }
              }
              options.language = uniqueLanguages;
              options.translations = this._processTranslations(
                options.language,
                options.debug
              );
              return options;
            };
            Defaults2.prototype.reset = function() {
              function stripDiacritics(text) {
                function match(a5) {
                  return DIACRITICS[a5] || a5;
                }
                return text.replace(/[^\u0000-\u007E]/g, match);
              }
              function matcher(params, data) {
                if ($7.trim(params.term) === "") {
                  return data;
                }
                if (data.children && data.children.length > 0) {
                  var match = $7.extend(true, {}, data);
                  for (var c4 = data.children.length - 1; c4 >= 0; c4--) {
                    var child = data.children[c4];
                    var matches = matcher(params, child);
                    if (matches == null) {
                      match.children.splice(c4, 1);
                    }
                  }
                  if (match.children.length > 0) {
                    return match;
                  }
                  return matcher(params, match);
                }
                var original = stripDiacritics(data.text).toUpperCase();
                var term = stripDiacritics(params.term).toUpperCase();
                if (original.indexOf(term) > -1) {
                  return data;
                }
                return null;
              }
              this.defaults = {
                amdBase: "./",
                amdLanguageBase: "./i18n/",
                closeOnSelect: true,
                debug: false,
                dropdownAutoWidth: false,
                escapeMarkup: Utils.escapeMarkup,
                language: {},
                matcher,
                minimumInputLength: 0,
                maximumInputLength: 0,
                maximumSelectionLength: 0,
                minimumResultsForSearch: 0,
                selectOnClose: false,
                scrollAfterSelect: false,
                sorter: function(data) {
                  return data;
                },
                templateResult: function(result) {
                  return result.text;
                },
                templateSelection: function(selection) {
                  return selection.text;
                },
                theme: "default",
                width: "resolve"
              };
            };
            Defaults2.prototype.applyFromElement = function(options, $element) {
              var optionLanguage = options.language;
              var defaultLanguage = this.defaults.language;
              var elementLanguage = $element.prop("lang");
              var parentLanguage = $element.closest("[lang]").prop("lang");
              var languages = Array.prototype.concat.call(
                this._resolveLanguage(elementLanguage),
                this._resolveLanguage(optionLanguage),
                this._resolveLanguage(defaultLanguage),
                this._resolveLanguage(parentLanguage)
              );
              options.language = languages;
              return options;
            };
            Defaults2.prototype._resolveLanguage = function(language) {
              if (!language) {
                return [];
              }
              if ($7.isEmptyObject(language)) {
                return [];
              }
              if ($7.isPlainObject(language)) {
                return [language];
              }
              var languages;
              if (!$7.isArray(language)) {
                languages = [language];
              } else {
                languages = language;
              }
              var resolvedLanguages = [];
              for (var l5 = 0; l5 < languages.length; l5++) {
                resolvedLanguages.push(languages[l5]);
                if (typeof languages[l5] === "string" && languages[l5].indexOf("-") > 0) {
                  var languageParts = languages[l5].split("-");
                  var baseLanguage = languageParts[0];
                  resolvedLanguages.push(baseLanguage);
                }
              }
              return resolvedLanguages;
            };
            Defaults2.prototype._processTranslations = function(languages, debug) {
              var translations = new Translation();
              for (var l5 = 0; l5 < languages.length; l5++) {
                var languageData = new Translation();
                var language = languages[l5];
                if (typeof language === "string") {
                  try {
                    languageData = Translation.loadPath(language);
                  } catch (e2) {
                    try {
                      language = this.defaults.amdLanguageBase + language;
                      languageData = Translation.loadPath(language);
                    } catch (ex) {
                      if (debug && window.console && console.warn) {
                        console.warn(
                          'Select2: The language file for "' + language + '" could not be automatically loaded. A fallback will be used instead.'
                        );
                      }
                    }
                  }
                } else if ($7.isPlainObject(language)) {
                  languageData = new Translation(language);
                } else {
                  languageData = language;
                }
                translations.extend(languageData);
              }
              return translations;
            };
            Defaults2.prototype.set = function(key, value) {
              var camelKey = $7.camelCase(key);
              var data = {};
              data[camelKey] = value;
              var convertedData = Utils._convertData(data);
              $7.extend(true, this.defaults, convertedData);
            };
            var defaults3 = new Defaults2();
            return defaults3;
          });
          S23.define("select2/options", [
            "require",
            "jquery",
            "./defaults",
            "./utils"
          ], function(require2, $7, Defaults2, Utils) {
            function Options(options, $element) {
              this.options = options;
              if ($element != null) {
                this.fromElement($element);
              }
              if ($element != null) {
                this.options = Defaults2.applyFromElement(this.options, $element);
              }
              this.options = Defaults2.apply(this.options);
              if ($element && $element.is("input")) {
                var InputCompat = require2(this.get("amdBase") + "compat/inputData");
                this.options.dataAdapter = Utils.Decorate(
                  this.options.dataAdapter,
                  InputCompat
                );
              }
            }
            Options.prototype.fromElement = function($e2) {
              var excludedData = ["select2"];
              if (this.options.multiple == null) {
                this.options.multiple = $e2.prop("multiple");
              }
              if (this.options.disabled == null) {
                this.options.disabled = $e2.prop("disabled");
              }
              if (this.options.dir == null) {
                if ($e2.prop("dir")) {
                  this.options.dir = $e2.prop("dir");
                } else if ($e2.closest("[dir]").prop("dir")) {
                  this.options.dir = $e2.closest("[dir]").prop("dir");
                } else {
                  this.options.dir = "ltr";
                }
              }
              $e2.prop("disabled", this.options.disabled);
              $e2.prop("multiple", this.options.multiple);
              if (Utils.GetData($e2[0], "select2Tags")) {
                if (this.options.debug && window.console && console.warn) {
                  console.warn(
                    'Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'
                  );
                }
                Utils.StoreData($e2[0], "data", Utils.GetData($e2[0], "select2Tags"));
                Utils.StoreData($e2[0], "tags", true);
              }
              if (Utils.GetData($e2[0], "ajaxUrl")) {
                if (this.options.debug && window.console && console.warn) {
                  console.warn(
                    "Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."
                  );
                }
                $e2.attr("ajax--url", Utils.GetData($e2[0], "ajaxUrl"));
                Utils.StoreData($e2[0], "ajax-Url", Utils.GetData($e2[0], "ajaxUrl"));
              }
              var dataset = {};
              function upperCaseLetter(_26, letter) {
                return letter.toUpperCase();
              }
              for (var attr = 0; attr < $e2[0].attributes.length; attr++) {
                var attributeName = $e2[0].attributes[attr].name;
                var prefix2 = "data-";
                if (attributeName.substr(0, prefix2.length) == prefix2) {
                  var dataName = attributeName.substring(prefix2.length);
                  var dataValue = Utils.GetData($e2[0], dataName);
                  var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);
                  dataset[camelDataName] = dataValue;
                }
              }
              if ($7.fn.jquery && $7.fn.jquery.substr(0, 2) == "1." && $e2[0].dataset) {
                dataset = $7.extend(true, {}, $e2[0].dataset, dataset);
              }
              var data = $7.extend(true, {}, Utils.GetData($e2[0]), dataset);
              data = Utils._convertData(data);
              for (var key in data) {
                if ($7.inArray(key, excludedData) > -1) {
                  continue;
                }
                if ($7.isPlainObject(this.options[key])) {
                  $7.extend(this.options[key], data[key]);
                } else {
                  this.options[key] = data[key];
                }
              }
              return this;
            };
            Options.prototype.get = function(key) {
              return this.options[key];
            };
            Options.prototype.set = function(key, val) {
              this.options[key] = val;
            };
            return Options;
          });
          S23.define("select2/core", [
            "jquery",
            "./options",
            "./utils",
            "./keys"
          ], function($7, Options, Utils, KEYS) {
            var Select2 = function($element, options) {
              if (Utils.GetData($element[0], "select2") != null) {
                Utils.GetData($element[0], "select2").destroy();
              }
              this.$element = $element;
              this.id = this._generateId($element);
              options = options || {};
              this.options = new Options(options, $element);
              Select2.__super__.constructor.call(this);
              var tabindex = $element.attr("tabindex") || 0;
              Utils.StoreData($element[0], "old-tabindex", tabindex);
              $element.attr("tabindex", "-1");
              var DataAdapter = this.options.get("dataAdapter");
              this.dataAdapter = new DataAdapter($element, this.options);
              var $container = this.render();
              this._placeContainer($container);
              var SelectionAdapter = this.options.get("selectionAdapter");
              this.selection = new SelectionAdapter($element, this.options);
              this.$selection = this.selection.render();
              this.selection.position(this.$selection, $container);
              var DropdownAdapter = this.options.get("dropdownAdapter");
              this.dropdown = new DropdownAdapter($element, this.options);
              this.$dropdown = this.dropdown.render();
              this.dropdown.position(this.$dropdown, $container);
              var ResultsAdapter = this.options.get("resultsAdapter");
              this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
              this.$results = this.results.render();
              this.results.position(this.$results, this.$dropdown);
              var self2 = this;
              this._bindAdapters();
              this._registerDomEvents();
              this._registerDataEvents();
              this._registerSelectionEvents();
              this._registerDropdownEvents();
              this._registerResultsEvents();
              this._registerEvents();
              this.dataAdapter.current(function(initialData) {
                self2.trigger("selection:update", {
                  data: initialData
                });
              });
              $element.addClass("select2-hidden-accessible");
              $element.attr("aria-hidden", "true");
              this._syncAttributes();
              Utils.StoreData($element[0], "select2", this);
              $element.data("select2", this);
            };
            Utils.Extend(Select2, Utils.Observable);
            Select2.prototype._generateId = function($element) {
              var id = "";
              if ($element.attr("id") != null) {
                id = $element.attr("id");
              } else if ($element.attr("name") != null) {
                id = $element.attr("name") + "-" + Utils.generateChars(2);
              } else {
                id = Utils.generateChars(4);
              }
              id = id.replace(/(:|\.|\[|\]|,)/g, "");
              id = "select2-" + id;
              return id;
            };
            Select2.prototype._placeContainer = function($container) {
              $container.insertAfter(this.$element);
              var width = this._resolveWidth(this.$element, this.options.get("width"));
              if (width != null) {
                $container.css("width", width);
              }
            };
            Select2.prototype._resolveWidth = function($element, method) {
              var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
              if (method == "resolve") {
                var styleWidth = this._resolveWidth($element, "style");
                if (styleWidth != null) {
                  return styleWidth;
                }
                return this._resolveWidth($element, "element");
              }
              if (method == "element") {
                var elementWidth = $element.outerWidth(false);
                if (elementWidth <= 0) {
                  return "auto";
                }
                return elementWidth + "px";
              }
              if (method == "style") {
                var style = $element.attr("style");
                if (typeof style !== "string") {
                  return null;
                }
                var attrs = style.split(";");
                for (var i3 = 0, l5 = attrs.length; i3 < l5; i3 = i3 + 1) {
                  var attr = attrs[i3].replace(/\s/g, "");
                  var matches = attr.match(WIDTH);
                  if (matches !== null && matches.length >= 1) {
                    return matches[1];
                  }
                }
                return null;
              }
              if (method == "computedstyle") {
                var computedStyle = window.getComputedStyle($element[0]);
                return computedStyle.width;
              }
              return method;
            };
            Select2.prototype._bindAdapters = function() {
              this.dataAdapter.bind(this, this.$container);
              this.selection.bind(this, this.$container);
              this.dropdown.bind(this, this.$container);
              this.results.bind(this, this.$container);
            };
            Select2.prototype._registerDomEvents = function() {
              var self2 = this;
              this.$element.on("change.select2", function() {
                self2.dataAdapter.current(function(data) {
                  self2.trigger("selection:update", {
                    data
                  });
                });
              });
              this.$element.on("focus.select2", function(evt) {
                self2.trigger("focus", evt);
              });
              this._syncA = Utils.bind(this._syncAttributes, this);
              this._syncS = Utils.bind(this._syncSubtree, this);
              if (this.$element[0].attachEvent) {
                this.$element[0].attachEvent("onpropertychange", this._syncA);
              }
              var observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
              if (observer != null) {
                this._observer = new observer(function(mutations) {
                  self2._syncA();
                  self2._syncS(null, mutations);
                });
                this._observer.observe(this.$element[0], {
                  attributes: true,
                  childList: true,
                  subtree: false
                });
              } else if (this.$element[0].addEventListener) {
                this.$element[0].addEventListener(
                  "DOMAttrModified",
                  self2._syncA,
                  false
                );
                this.$element[0].addEventListener(
                  "DOMNodeInserted",
                  self2._syncS,
                  false
                );
                this.$element[0].addEventListener(
                  "DOMNodeRemoved",
                  self2._syncS,
                  false
                );
              }
            };
            Select2.prototype._registerDataEvents = function() {
              var self2 = this;
              this.dataAdapter.on("*", function(name2, params) {
                self2.trigger(name2, params);
              });
            };
            Select2.prototype._registerSelectionEvents = function() {
              var self2 = this;
              var nonRelayEvents = ["toggle", "focus"];
              this.selection.on("toggle", function() {
                self2.toggleDropdown();
              });
              this.selection.on("focus", function(params) {
                self2.focus(params);
              });
              this.selection.on("*", function(name2, params) {
                if ($7.inArray(name2, nonRelayEvents) !== -1) {
                  return;
                }
                self2.trigger(name2, params);
              });
            };
            Select2.prototype._registerDropdownEvents = function() {
              var self2 = this;
              this.dropdown.on("*", function(name2, params) {
                self2.trigger(name2, params);
              });
            };
            Select2.prototype._registerResultsEvents = function() {
              var self2 = this;
              this.results.on("*", function(name2, params) {
                self2.trigger(name2, params);
              });
            };
            Select2.prototype._registerEvents = function() {
              var self2 = this;
              this.on("open", function() {
                self2.$container.addClass("select2-container--open");
              });
              this.on("close", function() {
                self2.$container.removeClass("select2-container--open");
              });
              this.on("enable", function() {
                self2.$container.removeClass("select2-container--disabled");
              });
              this.on("disable", function() {
                self2.$container.addClass("select2-container--disabled");
              });
              this.on("blur", function() {
                self2.$container.removeClass("select2-container--focus");
              });
              this.on("query", function(params) {
                if (!self2.isOpen()) {
                  self2.trigger("open", {});
                }
                this.dataAdapter.query(params, function(data) {
                  self2.trigger("results:all", {
                    data,
                    query: params
                  });
                });
              });
              this.on("query:append", function(params) {
                this.dataAdapter.query(params, function(data) {
                  self2.trigger("results:append", {
                    data,
                    query: params
                  });
                });
              });
              this.on("keypress", function(evt) {
                var key = evt.which;
                if (self2.isOpen()) {
                  if (key === KEYS.ESC || key === KEYS.TAB || key === KEYS.UP && evt.altKey) {
                    self2.close(evt);
                    evt.preventDefault();
                  } else if (key === KEYS.ENTER) {
                    self2.trigger("results:select", {});
                    evt.preventDefault();
                  } else if (key === KEYS.SPACE && evt.ctrlKey) {
                    self2.trigger("results:toggle", {});
                    evt.preventDefault();
                  } else if (key === KEYS.UP) {
                    self2.trigger("results:previous", {});
                    evt.preventDefault();
                  } else if (key === KEYS.DOWN) {
                    self2.trigger("results:next", {});
                    evt.preventDefault();
                  }
                } else {
                  if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
                    self2.open();
                    evt.preventDefault();
                  }
                }
              });
            };
            Select2.prototype._syncAttributes = function() {
              this.options.set("disabled", this.$element.prop("disabled"));
              if (this.isDisabled()) {
                if (this.isOpen()) {
                  this.close();
                }
                this.trigger("disable", {});
              } else {
                this.trigger("enable", {});
              }
            };
            Select2.prototype._isChangeMutation = function(evt, mutations) {
              var changed = false;
              var self2 = this;
              if (evt && evt.target && (evt.target.nodeName !== "OPTION" && evt.target.nodeName !== "OPTGROUP")) {
                return;
              }
              if (!mutations) {
                changed = true;
              } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
                for (var n3 = 0; n3 < mutations.addedNodes.length; n3++) {
                  var node = mutations.addedNodes[n3];
                  if (node.selected) {
                    changed = true;
                  }
                }
              } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
                changed = true;
              } else if ($7.isArray(mutations)) {
                $7.each(mutations, function(evt2, mutation) {
                  if (self2._isChangeMutation(evt2, mutation)) {
                    changed = true;
                    return false;
                  }
                });
              }
              return changed;
            };
            Select2.prototype._syncSubtree = function(evt, mutations) {
              var changed = this._isChangeMutation(evt, mutations);
              var self2 = this;
              if (changed) {
                this.dataAdapter.current(function(currentData) {
                  self2.trigger("selection:update", {
                    data: currentData
                  });
                });
              }
            };
            Select2.prototype.trigger = function(name2, args) {
              var actualTrigger = Select2.__super__.trigger;
              var preTriggerMap = {
                "open": "opening",
                "close": "closing",
                "select": "selecting",
                "unselect": "unselecting",
                "clear": "clearing"
              };
              if (args === void 0) {
                args = {};
              }
              if (name2 in preTriggerMap) {
                var preTriggerName = preTriggerMap[name2];
                var preTriggerArgs = {
                  prevented: false,
                  name: name2,
                  args
                };
                actualTrigger.call(this, preTriggerName, preTriggerArgs);
                if (preTriggerArgs.prevented) {
                  args.prevented = true;
                  return;
                }
              }
              actualTrigger.call(this, name2, args);
            };
            Select2.prototype.toggleDropdown = function() {
              if (this.isDisabled()) {
                return;
              }
              if (this.isOpen()) {
                this.close();
              } else {
                this.open();
              }
            };
            Select2.prototype.open = function() {
              if (this.isOpen()) {
                return;
              }
              if (this.isDisabled()) {
                return;
              }
              this.trigger("query", {});
            };
            Select2.prototype.close = function(evt) {
              if (!this.isOpen()) {
                return;
              }
              this.trigger("close", { originalEvent: evt });
            };
            Select2.prototype.isEnabled = function() {
              return !this.isDisabled();
            };
            Select2.prototype.isDisabled = function() {
              return this.options.get("disabled");
            };
            Select2.prototype.isOpen = function() {
              return this.$container.hasClass("select2-container--open");
            };
            Select2.prototype.hasFocus = function() {
              return this.$container.hasClass("select2-container--focus");
            };
            Select2.prototype.focus = function(data) {
              if (this.hasFocus()) {
                return;
              }
              this.$container.addClass("select2-container--focus");
              this.trigger("focus", {});
            };
            Select2.prototype.enable = function(args) {
              if (this.options.get("debug") && window.console && console.warn) {
                console.warn(
                  'Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'
                );
              }
              if (args == null || args.length === 0) {
                args = [true];
              }
              var disabled = !args[0];
              this.$element.prop("disabled", disabled);
            };
            Select2.prototype.data = function() {
              if (this.options.get("debug") && arguments.length > 0 && window.console && console.warn) {
                console.warn(
                  'Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.'
                );
              }
              var data = [];
              this.dataAdapter.current(function(currentData) {
                data = currentData;
              });
              return data;
            };
            Select2.prototype.val = function(args) {
              if (this.options.get("debug") && window.console && console.warn) {
                console.warn(
                  'Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'
                );
              }
              if (args == null || args.length === 0) {
                return this.$element.val();
              }
              var newVal = args[0];
              if ($7.isArray(newVal)) {
                newVal = $7.map(newVal, function(obj) {
                  return obj.toString();
                });
              }
              this.$element.val(newVal).trigger("input").trigger("change");
            };
            Select2.prototype.destroy = function() {
              this.$container.remove();
              if (this.$element[0].detachEvent) {
                this.$element[0].detachEvent("onpropertychange", this._syncA);
              }
              if (this._observer != null) {
                this._observer.disconnect();
                this._observer = null;
              } else if (this.$element[0].removeEventListener) {
                this.$element[0].removeEventListener("DOMAttrModified", this._syncA, false);
                this.$element[0].removeEventListener("DOMNodeInserted", this._syncS, false);
                this.$element[0].removeEventListener("DOMNodeRemoved", this._syncS, false);
              }
              this._syncA = null;
              this._syncS = null;
              this.$element.off(".select2");
              this.$element.attr(
                "tabindex",
                Utils.GetData(this.$element[0], "old-tabindex")
              );
              this.$element.removeClass("select2-hidden-accessible");
              this.$element.attr("aria-hidden", "false");
              Utils.RemoveData(this.$element[0]);
              this.$element.removeData("select2");
              this.dataAdapter.destroy();
              this.selection.destroy();
              this.dropdown.destroy();
              this.results.destroy();
              this.dataAdapter = null;
              this.selection = null;
              this.dropdown = null;
              this.results = null;
            };
            Select2.prototype.render = function() {
              var $container = $7(
                '<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>'
              );
              $container.attr("dir", this.options.get("dir"));
              this.$container = $container;
              this.$container.addClass("select2-container--" + this.options.get("theme"));
              Utils.StoreData($container[0], "element", this.$element);
              return $container;
            };
            return Select2;
          });
          S23.define("jquery-mousewheel", [
            "jquery"
          ], function($7) {
            return $7;
          });
          S23.define("jquery.select2", [
            "jquery",
            "jquery-mousewheel",
            "./select2/core",
            "./select2/defaults",
            "./select2/utils"
          ], function($7, _26, Select2, Defaults2, Utils) {
            if ($7.fn.select2 == null) {
              var thisMethods = ["open", "close", "destroy"];
              $7.fn.select2 = function(options) {
                options = options || {};
                if (typeof options === "object") {
                  this.each(function() {
                    var instanceOptions = $7.extend(true, {}, options);
                    var instance = new Select2($7(this), instanceOptions);
                  });
                  return this;
                } else if (typeof options === "string") {
                  var ret;
                  var args = Array.prototype.slice.call(arguments, 1);
                  this.each(function() {
                    var instance = Utils.GetData(this, "select2");
                    if (instance == null && window.console && console.error) {
                      console.error(
                        "The select2('" + options + "') method was called on an element that is not using Select2."
                      );
                    }
                    ret = instance[options].apply(instance, args);
                  });
                  if ($7.inArray(options, thisMethods) > -1) {
                    return this;
                  }
                  return ret;
                } else {
                  throw new Error("Invalid arguments for Select2: " + options);
                }
              };
            }
            if ($7.fn.select2.defaults == null) {
              $7.fn.select2.defaults = Defaults2;
            }
            return Select2;
          });
          return {
            define: S23.define,
            require: S23.require
          };
        }();
        var select2 = S22.require("jquery.select2");
        jQuery2.fn.select2.amd = S22;
        return select2;
      });
    }
  });

  // node_modules/select2/dist/js/i18n/en.js
  var require_en = __commonJS({
    "node_modules/select2/dist/js/i18n/en.js"() {
      init_define_process();
      init_jquery();
      !function() {
        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) var e2 = jQuery.fn.select2.amd;
        e2.define("select2/i18n/en", [], function() {
          return { errorLoading: function() {
            return "The results could not be loaded.";
          }, inputTooLong: function(e3) {
            var n3 = e3.input.length - e3.maximum, r3 = "Please delete " + n3 + " character";
            return 1 != n3 && (r3 += "s"), r3;
          }, inputTooShort: function(e3) {
            return "Please enter " + (e3.minimum - e3.input.length) + " or more characters";
          }, loadingMore: function() {
            return "Loading more results\u2026";
          }, maximumSelected: function(e3) {
            var n3 = "You can only select " + e3.maximum + " item";
            return 1 != e3.maximum && (n3 += "s"), n3;
          }, noResults: function() {
            return "No results found";
          }, searching: function() {
            return "Searching\u2026";
          }, removeAllItems: function() {
            return "Remove all items";
          } };
        }), e2.define, e2.require;
      }();
    }
  });

  // node_modules/select2/dist/js/i18n/es.js
  var require_es = __commonJS({
    "node_modules/select2/dist/js/i18n/es.js"() {
      init_define_process();
      init_jquery();
      !function() {
        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) var e2 = jQuery.fn.select2.amd;
        e2.define("select2/i18n/es", [], function() {
          return { errorLoading: function() {
            return "No se pudieron cargar los resultados";
          }, inputTooLong: function(e3) {
            var n3 = e3.input.length - e3.maximum, r3 = "Por favor, elimine " + n3 + " car";
            return r3 += 1 == n3 ? "\xE1cter" : "acteres";
          }, inputTooShort: function(e3) {
            var n3 = e3.minimum - e3.input.length, r3 = "Por favor, introduzca " + n3 + " car";
            return r3 += 1 == n3 ? "\xE1cter" : "acteres";
          }, loadingMore: function() {
            return "Cargando m\xE1s resultados\u2026";
          }, maximumSelected: function(e3) {
            var n3 = "S\xF3lo puede seleccionar " + e3.maximum + " elemento";
            return 1 != e3.maximum && (n3 += "s"), n3;
          }, noResults: function() {
            return "No se encontraron resultados";
          }, searching: function() {
            return "Buscando\u2026";
          }, removeAllItems: function() {
            return "Eliminar todos los elementos";
          } };
        }), e2.define, e2.require;
      }();
    }
  });

  // node_modules/select2/dist/js/i18n/pt.js
  var require_pt = __commonJS({
    "node_modules/select2/dist/js/i18n/pt.js"() {
      init_define_process();
      init_jquery();
      !function() {
        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) var e2 = jQuery.fn.select2.amd;
        e2.define("select2/i18n/pt", [], function() {
          return { errorLoading: function() {
            return "Os resultados n\xE3o puderam ser carregados.";
          }, inputTooLong: function(e3) {
            var r3 = e3.input.length - e3.maximum, n3 = "Por favor apague " + r3 + " ";
            return n3 += 1 != r3 ? "caracteres" : "caractere";
          }, inputTooShort: function(e3) {
            return "Introduza " + (e3.minimum - e3.input.length) + " ou mais caracteres";
          }, loadingMore: function() {
            return "A carregar mais resultados\u2026";
          }, maximumSelected: function(e3) {
            var r3 = "Apenas pode seleccionar " + e3.maximum + " ";
            return r3 += 1 != e3.maximum ? "itens" : "item";
          }, noResults: function() {
            return "Sem resultados";
          }, searching: function() {
            return "A procurar\u2026";
          }, removeAllItems: function() {
            return "Remover todos os itens";
          } };
        }), e2.define, e2.require;
      }();
    }
  });

  // node_modules/select2/dist/js/i18n/ja.js
  var require_ja = __commonJS({
    "node_modules/select2/dist/js/i18n/ja.js"() {
      init_define_process();
      init_jquery();
      !function() {
        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) var n3 = jQuery.fn.select2.amd;
        n3.define("select2/i18n/ja", [], function() {
          return { errorLoading: function() {
            return "\u7D50\u679C\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u307E\u305B\u3093\u3067\u3057\u305F";
          }, inputTooLong: function(n4) {
            return n4.input.length - n4.maximum + " \u6587\u5B57\u3092\u524A\u9664\u3057\u3066\u304F\u3060\u3055\u3044";
          }, inputTooShort: function(n4) {
            return "\u5C11\u306A\u304F\u3068\u3082 " + (n4.minimum - n4.input.length) + " \u6587\u5B57\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044";
          }, loadingMore: function() {
            return "\u8AAD\u307F\u8FBC\u307F\u4E2D\u2026";
          }, maximumSelected: function(n4) {
            return n4.maximum + " \u4EF6\u3057\u304B\u9078\u629E\u3067\u304D\u307E\u305B\u3093";
          }, noResults: function() {
            return "\u5BFE\u8C61\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093";
          }, searching: function() {
            return "\u691C\u7D22\u3057\u3066\u3044\u307E\u3059\u2026";
          }, removeAllItems: function() {
            return "\u3059\u3079\u3066\u306E\u30A2\u30A4\u30C6\u30E0\u3092\u524A\u9664";
          } };
        }), n3.define, n3.require;
      }();
    }
  });

  // node_modules/tom-select/dist/js/tom-select.complete.js
  var require_tom_select_complete = __commonJS({
    "node_modules/tom-select/dist/js/tom-select.complete.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function(global3, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global3 = typeof globalThis !== "undefined" ? globalThis : global3 || self, global3.TomSelect = factory());
      })(exports, function() {
        "use strict";
        function forEvents(events, callback2) {
          events.split(/\s+/).forEach((event2) => {
            callback2(event2);
          });
        }
        class MicroEvent {
          constructor() {
            this._events = void 0;
            this._events = {};
          }
          on(events, fct) {
            forEvents(events, (event2) => {
              const event_array = this._events[event2] || [];
              event_array.push(fct);
              this._events[event2] = event_array;
            });
          }
          off(events, fct) {
            var n3 = arguments.length;
            if (n3 === 0) {
              this._events = {};
              return;
            }
            forEvents(events, (event2) => {
              if (n3 === 1) {
                delete this._events[event2];
                return;
              }
              const event_array = this._events[event2];
              if (event_array === void 0) return;
              event_array.splice(event_array.indexOf(fct), 1);
              this._events[event2] = event_array;
            });
          }
          trigger(events, ...args) {
            var self2 = this;
            forEvents(events, (event2) => {
              const event_array = self2._events[event2];
              if (event_array === void 0) return;
              event_array.forEach((fct) => {
                fct.apply(self2, args);
              });
            });
          }
        }
        function MicroPlugin(Interface) {
          Interface.plugins = {};
          return class extends Interface {
            constructor(...args) {
              super(...args);
              this.plugins = {
                names: [],
                settings: {},
                requested: {},
                loaded: {}
              };
            }
            /**
             * Registers a plugin.
             *
             * @param {function} fn
             */
            static define(name2, fn3) {
              Interface.plugins[name2] = {
                "name": name2,
                "fn": fn3
              };
            }
            /**
             * Initializes the listed plugins (with options).
             * Acceptable formats:
             *
             * List (without options):
             *   ['a', 'b', 'c']
             *
             * List (with options):
             *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
             *
             * Hash (with options):
             *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
             *
             * @param {array|object} plugins
             */
            initializePlugins(plugins2) {
              var key, name2;
              const self2 = this;
              const queue = [];
              if (Array.isArray(plugins2)) {
                plugins2.forEach((plugin) => {
                  if (typeof plugin === "string") {
                    queue.push(plugin);
                  } else {
                    self2.plugins.settings[plugin.name] = plugin.options;
                    queue.push(plugin.name);
                  }
                });
              } else if (plugins2) {
                for (key in plugins2) {
                  if (plugins2.hasOwnProperty(key)) {
                    self2.plugins.settings[key] = plugins2[key];
                    queue.push(key);
                  }
                }
              }
              while (name2 = queue.shift()) {
                self2.require(name2);
              }
            }
            loadPlugin(name2) {
              var self2 = this;
              var plugins2 = self2.plugins;
              var plugin = Interface.plugins[name2];
              if (!Interface.plugins.hasOwnProperty(name2)) {
                throw new Error('Unable to find "' + name2 + '" plugin');
              }
              plugins2.requested[name2] = true;
              plugins2.loaded[name2] = plugin.fn.apply(self2, [self2.plugins.settings[name2] || {}]);
              plugins2.names.push(name2);
            }
            /**
             * Initializes a plugin.
             *
             */
            require(name2) {
              var self2 = this;
              var plugins2 = self2.plugins;
              if (!self2.plugins.loaded.hasOwnProperty(name2)) {
                if (plugins2.requested[name2]) {
                  throw new Error('Plugin has circular dependency ("' + name2 + '")');
                }
                self2.loadPlugin(name2);
              }
              return plugins2.loaded[name2];
            }
          };
        }
        const arrayToPattern = (chars) => {
          chars = chars.filter(Boolean);
          if (chars.length < 2) {
            return chars[0] || "";
          }
          return maxValueLength(chars) == 1 ? "[" + chars.join("") + "]" : "(?:" + chars.join("|") + ")";
        };
        const sequencePattern = (array) => {
          if (!hasDuplicates(array)) {
            return array.join("");
          }
          let pattern = "";
          let prev_char_count = 0;
          const prev_pattern = () => {
            if (prev_char_count > 1) {
              pattern += "{" + prev_char_count + "}";
            }
          };
          array.forEach((char, i3) => {
            if (char === array[i3 - 1]) {
              prev_char_count++;
              return;
            }
            prev_pattern();
            pattern += char;
            prev_char_count = 1;
          });
          prev_pattern();
          return pattern;
        };
        const setToPattern = (chars) => {
          let array = toArray(chars);
          return arrayToPattern(array);
        };
        const hasDuplicates = (array) => {
          return new Set(array).size !== array.length;
        };
        const escape_regex = (str) => {
          return (str + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1");
        };
        const maxValueLength = (array) => {
          return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
        };
        const unicodeLength = (str) => {
          return toArray(str).length;
        };
        const toArray = (p4) => Array.from(p4);
        const allSubstrings = (input) => {
          if (input.length === 1) return [[input]];
          let result = [];
          const start5 = input.substring(1);
          const suba = allSubstrings(start5);
          suba.forEach(function(subresult) {
            let tmp = subresult.slice(0);
            tmp[0] = input.charAt(0) + tmp[0];
            result.push(tmp);
            tmp = subresult.slice(0);
            tmp.unshift(input.charAt(0));
            result.push(tmp);
          });
          return result;
        };
        const code_points = [[0, 65535]];
        const accent_pat = "[\u0300-\u036F\xB7\u02BE\u02BC]";
        let unicode_map;
        let multi_char_reg;
        const max_char_length = 3;
        const latin_convert = {};
        const latin_condensed = {
          "/": "\u2044\u2215",
          "0": "\u07C0",
          "a": "\u2C65\u0250\u0251",
          "aa": "\uA733",
          "ae": "\xE6\u01FD\u01E3",
          "ao": "\uA735",
          "au": "\uA737",
          "av": "\uA739\uA73B",
          "ay": "\uA73D",
          "b": "\u0180\u0253\u0183",
          "c": "\uA73F\u0188\u023C\u2184",
          "d": "\u0111\u0257\u0256\u1D05\u018C\uABB7\u0501\u0266",
          "e": "\u025B\u01DD\u1D07\u0247",
          "f": "\uA77C\u0192",
          "g": "\u01E5\u0260\uA7A1\u1D79\uA77F\u0262",
          "h": "\u0127\u2C68\u2C76\u0265",
          "i": "\u0268\u0131",
          "j": "\u0249\u0237",
          "k": "\u0199\u2C6A\uA741\uA743\uA745\uA7A3",
          "l": "\u0142\u019A\u026B\u2C61\uA749\uA747\uA781\u026D",
          "m": "\u0271\u026F\u03FB",
          "n": "\uA7A5\u019E\u0272\uA791\u1D0E\u043B\u0509",
          "o": "\xF8\u01FF\u0254\u0275\uA74B\uA74D\u1D11",
          "oe": "\u0153",
          "oi": "\u01A3",
          "oo": "\uA74F",
          "ou": "\u0223",
          "p": "\u01A5\u1D7D\uA751\uA753\uA755\u03C1",
          "q": "\uA757\uA759\u024B",
          "r": "\u024D\u027D\uA75B\uA7A7\uA783",
          "s": "\xDF\u023F\uA7A9\uA785\u0282",
          "t": "\u0167\u01AD\u0288\u2C66\uA787",
          "th": "\xFE",
          "tz": "\uA729",
          "u": "\u0289",
          "v": "\u028B\uA75F\u028C",
          "vy": "\uA761",
          "w": "\u2C73",
          "y": "\u01B4\u024F\u1EFF",
          "z": "\u01B6\u0225\u0240\u2C6C\uA763",
          "hv": "\u0195"
        };
        for (let latin in latin_condensed) {
          let unicode = latin_condensed[latin] || "";
          for (let i3 = 0; i3 < unicode.length; i3++) {
            let char = unicode.substring(i3, i3 + 1);
            latin_convert[char] = latin;
          }
        }
        const convert_pat = new RegExp(Object.keys(latin_convert).join("|") + "|" + accent_pat, "gu");
        const initialize3 = (_code_points) => {
          if (unicode_map !== void 0) return;
          unicode_map = generateMap(_code_points || code_points);
        };
        const normalize = (str, form = "NFKD") => str.normalize(form);
        const asciifold = (str) => {
          return toArray(str).reduce(
            /**
             * @param {string} result
             * @param {string} char
             */
            (result, char) => {
              return result + _asciifold(char);
            },
            ""
          );
        };
        const _asciifold = (str) => {
          str = normalize(str).toLowerCase().replace(convert_pat, (char) => {
            return latin_convert[char] || "";
          });
          return normalize(str, "NFC");
        };
        function* generator(code_points2) {
          for (const [code_point_min, code_point_max] of code_points2) {
            for (let i3 = code_point_min; i3 <= code_point_max; i3++) {
              let composed = String.fromCharCode(i3);
              let folded = asciifold(composed);
              if (folded == composed.toLowerCase()) {
                continue;
              }
              if (folded.length > max_char_length) {
                continue;
              }
              if (folded.length == 0) {
                continue;
              }
              yield {
                folded,
                composed,
                code_point: i3
              };
            }
          }
        }
        const generateSets = (code_points2) => {
          const unicode_sets = {};
          const addMatching = (folded, to_add) => {
            const folded_set = unicode_sets[folded] || /* @__PURE__ */ new Set();
            const patt = new RegExp("^" + setToPattern(folded_set) + "$", "iu");
            if (to_add.match(patt)) {
              return;
            }
            folded_set.add(escape_regex(to_add));
            unicode_sets[folded] = folded_set;
          };
          for (let value of generator(code_points2)) {
            addMatching(value.folded, value.folded);
            addMatching(value.folded, value.composed);
          }
          return unicode_sets;
        };
        const generateMap = (code_points2) => {
          const unicode_sets = generateSets(code_points2);
          const unicode_map2 = {};
          let multi_char = [];
          for (let folded in unicode_sets) {
            let set2 = unicode_sets[folded];
            if (set2) {
              unicode_map2[folded] = setToPattern(set2);
            }
            if (folded.length > 1) {
              multi_char.push(escape_regex(folded));
            }
          }
          multi_char.sort((a5, b5) => b5.length - a5.length);
          const multi_char_patt = arrayToPattern(multi_char);
          multi_char_reg = new RegExp("^" + multi_char_patt, "u");
          return unicode_map2;
        };
        const mapSequence = (strings, min_replacement = 1) => {
          let chars_replaced = 0;
          strings = strings.map((str) => {
            if (unicode_map[str]) {
              chars_replaced += str.length;
            }
            return unicode_map[str] || str;
          });
          if (chars_replaced >= min_replacement) {
            return sequencePattern(strings);
          }
          return "";
        };
        const substringsToPattern = (str, min_replacement = 1) => {
          min_replacement = Math.max(min_replacement, str.length - 1);
          return arrayToPattern(allSubstrings(str).map((sub_pat) => {
            return mapSequence(sub_pat, min_replacement);
          }));
        };
        const sequencesToPattern = (sequences, all = true) => {
          let min_replacement = sequences.length > 1 ? 1 : 0;
          return arrayToPattern(sequences.map((sequence) => {
            let seq = [];
            const len = all ? sequence.length() : sequence.length() - 1;
            for (let j6 = 0; j6 < len; j6++) {
              seq.push(substringsToPattern(sequence.substrs[j6] || "", min_replacement));
            }
            return sequencePattern(seq);
          }));
        };
        const inSequences = (needle_seq, sequences) => {
          for (const seq of sequences) {
            if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
              continue;
            }
            if (seq.substrs.join("") !== needle_seq.substrs.join("")) {
              continue;
            }
            let needle_parts = needle_seq.parts;
            const filter = (part) => {
              for (const needle_part of needle_parts) {
                if (needle_part.start === part.start && needle_part.substr === part.substr) {
                  return false;
                }
                if (part.length == 1 || needle_part.length == 1) {
                  continue;
                }
                if (part.start < needle_part.start && part.end > needle_part.start) {
                  return true;
                }
                if (needle_part.start < part.start && needle_part.end > part.start) {
                  return true;
                }
              }
              return false;
            };
            let filtered = seq.parts.filter(filter);
            if (filtered.length > 0) {
              continue;
            }
            return true;
          }
          return false;
        };
        class Sequence {
          constructor() {
            this.parts = [];
            this.substrs = [];
            this.start = 0;
            this.end = 0;
          }
          /**
           * @param {TSequencePart|undefined} part
           */
          add(part) {
            if (part) {
              this.parts.push(part);
              this.substrs.push(part.substr);
              this.start = Math.min(part.start, this.start);
              this.end = Math.max(part.end, this.end);
            }
          }
          last() {
            return this.parts[this.parts.length - 1];
          }
          length() {
            return this.parts.length;
          }
          /**
           * @param {number} position
           * @param {TSequencePart} last_piece
           */
          clone(position, last_piece) {
            let clone2 = new Sequence();
            let parts = JSON.parse(JSON.stringify(this.parts));
            let last_part = parts.pop();
            for (const part of parts) {
              clone2.add(part);
            }
            let last_substr = last_piece.substr.substring(0, position - last_part.start);
            let clone_last_len = last_substr.length;
            clone2.add({
              start: last_part.start,
              end: last_part.start + clone_last_len,
              length: clone_last_len,
              substr: last_substr
            });
            return clone2;
          }
        }
        const getPattern = (str) => {
          initialize3();
          str = asciifold(str);
          let pattern = "";
          let sequences = [new Sequence()];
          for (let i3 = 0; i3 < str.length; i3++) {
            let substr = str.substring(i3);
            let match = substr.match(multi_char_reg);
            const char = str.substring(i3, i3 + 1);
            const match_str = match ? match[0] : null;
            let overlapping = [];
            let added_types = /* @__PURE__ */ new Set();
            for (const sequence of sequences) {
              const last_piece = sequence.last();
              if (!last_piece || last_piece.length == 1 || last_piece.end <= i3) {
                if (match_str) {
                  const len = match_str.length;
                  sequence.add({
                    start: i3,
                    end: i3 + len,
                    length: len,
                    substr: match_str
                  });
                  added_types.add("1");
                } else {
                  sequence.add({
                    start: i3,
                    end: i3 + 1,
                    length: 1,
                    substr: char
                  });
                  added_types.add("2");
                }
              } else if (match_str) {
                let clone2 = sequence.clone(i3, last_piece);
                const len = match_str.length;
                clone2.add({
                  start: i3,
                  end: i3 + len,
                  length: len,
                  substr: match_str
                });
                overlapping.push(clone2);
              } else {
                added_types.add("3");
              }
            }
            if (overlapping.length > 0) {
              overlapping = overlapping.sort((a5, b5) => {
                return a5.length() - b5.length();
              });
              for (let clone2 of overlapping) {
                if (inSequences(clone2, sequences)) {
                  continue;
                }
                sequences.push(clone2);
              }
              continue;
            }
            if (i3 > 0 && added_types.size == 1 && !added_types.has("3")) {
              pattern += sequencesToPattern(sequences, false);
              let new_seq = new Sequence();
              const old_seq = sequences[0];
              if (old_seq) {
                new_seq.add(old_seq.last());
              }
              sequences = [new_seq];
            }
          }
          pattern += sequencesToPattern(sequences, true);
          return pattern;
        };
        const getAttr = (obj, name2) => {
          if (!obj) return;
          return obj[name2];
        };
        const getAttrNesting = (obj, name2) => {
          if (!obj) return;
          var part, names2 = name2.split(".");
          while ((part = names2.shift()) && (obj = obj[part])) ;
          return obj;
        };
        const scoreValue = (value, token, weight) => {
          var score, pos;
          if (!value) return 0;
          value = value + "";
          if (token.regex == null) return 0;
          pos = value.search(token.regex);
          if (pos === -1) return 0;
          score = token.string.length / value.length;
          if (pos === 0) score += 0.5;
          return score * weight;
        };
        const propToArray = (obj, key) => {
          var value = obj[key];
          if (typeof value == "function") return value;
          if (value && !Array.isArray(value)) {
            obj[key] = [value];
          }
        };
        const iterate$1 = (object, callback2) => {
          if (Array.isArray(object)) {
            object.forEach(callback2);
          } else {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                callback2(object[key], key);
              }
            }
          }
        };
        const cmp = (a5, b5) => {
          if (typeof a5 === "number" && typeof b5 === "number") {
            return a5 > b5 ? 1 : a5 < b5 ? -1 : 0;
          }
          a5 = asciifold(a5 + "").toLowerCase();
          b5 = asciifold(b5 + "").toLowerCase();
          if (a5 > b5) return 1;
          if (b5 > a5) return -1;
          return 0;
        };
        class Sifter {
          // []|{};
          /**
           * Textually searches arrays and hashes of objects
           * by property (or multiple properties). Designed
           * specifically for autocomplete.
           *
           */
          constructor(items, settings) {
            this.items = void 0;
            this.settings = void 0;
            this.items = items;
            this.settings = settings || {
              diacritics: true
            };
          }
          /**
           * Splits a search string into an array of individual
           * regexps to be used to match results.
           *
           */
          tokenize(query, respect_word_boundaries, weights) {
            if (!query || !query.length) return [];
            const tokens = [];
            const words2 = query.split(/\s+/);
            var field_regex;
            if (weights) {
              field_regex = new RegExp("^(" + Object.keys(weights).map(escape_regex).join("|") + "):(.*)$");
            }
            words2.forEach((word) => {
              let field_match;
              let field = null;
              let regex = null;
              if (field_regex && (field_match = word.match(field_regex))) {
                field = field_match[1];
                word = field_match[2];
              }
              if (word.length > 0) {
                if (this.settings.diacritics) {
                  regex = getPattern(word) || null;
                } else {
                  regex = escape_regex(word);
                }
                if (regex && respect_word_boundaries) regex = "\\b" + regex;
              }
              tokens.push({
                string: word,
                regex: regex ? new RegExp(regex, "iu") : null,
                field
              });
            });
            return tokens;
          }
          /**
           * Returns a function to be used to score individual results.
           *
           * Good matches will have a higher score than poor matches.
           * If an item is not a match, 0 will be returned by the function.
           *
           * @returns {T.ScoreFn}
           */
          getScoreFunction(query, options) {
            var search = this.prepareSearch(query, options);
            return this._getScoreFunction(search);
          }
          /**
           * @returns {T.ScoreFn}
           *
           */
          _getScoreFunction(search) {
            const tokens = search.tokens, token_count = tokens.length;
            if (!token_count) {
              return function() {
                return 0;
              };
            }
            const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
            if (!field_count) {
              return function() {
                return 1;
              };
            }
            const scoreObject = function() {
              if (field_count === 1) {
                return function(token, data) {
                  const field = fields[0].field;
                  return scoreValue(getAttrFn(data, field), token, weights[field] || 1);
                };
              }
              return function(token, data) {
                var sum = 0;
                if (token.field) {
                  const value = getAttrFn(data, token.field);
                  if (!token.regex && value) {
                    sum += 1 / field_count;
                  } else {
                    sum += scoreValue(value, token, 1);
                  }
                } else {
                  iterate$1(weights, (weight, field) => {
                    sum += scoreValue(getAttrFn(data, field), token, weight);
                  });
                }
                return sum / field_count;
              };
            }();
            if (token_count === 1) {
              return function(data) {
                return scoreObject(tokens[0], data);
              };
            }
            if (search.options.conjunction === "and") {
              return function(data) {
                var score, sum = 0;
                for (let token of tokens) {
                  score = scoreObject(token, data);
                  if (score <= 0) return 0;
                  sum += score;
                }
                return sum / token_count;
              };
            } else {
              return function(data) {
                var sum = 0;
                iterate$1(tokens, (token) => {
                  sum += scoreObject(token, data);
                });
                return sum / token_count;
              };
            }
          }
          /**
           * Returns a function that can be used to compare two
           * results, for sorting purposes. If no sorting should
           * be performed, `null` will be returned.
           *
           * @return function(a,b)
           */
          getSortFunction(query, options) {
            var search = this.prepareSearch(query, options);
            return this._getSortFunction(search);
          }
          _getSortFunction(search) {
            var implicit_score, sort_flds = [];
            const self2 = this, options = search.options, sort = !search.query && options.sort_empty ? options.sort_empty : options.sort;
            if (typeof sort == "function") {
              return sort.bind(this);
            }
            const get_field = function get_field2(name2, result) {
              if (name2 === "$score") return result.score;
              return search.getAttrFn(self2.items[result.id], name2);
            };
            if (sort) {
              for (let s4 of sort) {
                if (search.query || s4.field !== "$score") {
                  sort_flds.push(s4);
                }
              }
            }
            if (search.query) {
              implicit_score = true;
              for (let fld of sort_flds) {
                if (fld.field === "$score") {
                  implicit_score = false;
                  break;
                }
              }
              if (implicit_score) {
                sort_flds.unshift({
                  field: "$score",
                  direction: "desc"
                });
              }
            } else {
              sort_flds = sort_flds.filter((fld) => fld.field !== "$score");
            }
            const sort_flds_count = sort_flds.length;
            if (!sort_flds_count) {
              return null;
            }
            return function(a5, b5) {
              var result, field;
              for (let sort_fld of sort_flds) {
                field = sort_fld.field;
                let multiplier = sort_fld.direction === "desc" ? -1 : 1;
                result = multiplier * cmp(get_field(field, a5), get_field(field, b5));
                if (result) return result;
              }
              return 0;
            };
          }
          /**
           * Parses a search query and returns an object
           * with tokens and fields ready to be populated
           * with results.
           *
           */
          prepareSearch(query, optsUser) {
            const weights = {};
            var options = Object.assign({}, optsUser);
            propToArray(options, "sort");
            propToArray(options, "sort_empty");
            if (options.fields) {
              propToArray(options, "fields");
              const fields = [];
              options.fields.forEach((field) => {
                if (typeof field == "string") {
                  field = {
                    field,
                    weight: 1
                  };
                }
                fields.push(field);
                weights[field.field] = "weight" in field ? field.weight : 1;
              });
              options.fields = fields;
            }
            return {
              options,
              query: query.toLowerCase().trim(),
              tokens: this.tokenize(query, options.respect_word_boundaries, weights),
              total: 0,
              items: [],
              weights,
              getAttrFn: options.nesting ? getAttrNesting : getAttr
            };
          }
          /**
           * Searches through all items and returns a sorted array of matches.
           *
           */
          search(query, options) {
            var self2 = this, score, search;
            search = this.prepareSearch(query, options);
            options = search.options;
            query = search.query;
            const fn_score = options.score || self2._getScoreFunction(search);
            if (query.length) {
              iterate$1(self2.items, (item, id) => {
                score = fn_score(item);
                if (options.filter === false || score > 0) {
                  search.items.push({
                    "score": score,
                    "id": id
                  });
                }
              });
            } else {
              iterate$1(self2.items, (_26, id) => {
                search.items.push({
                  "score": 1,
                  "id": id
                });
              });
            }
            const fn_sort = self2._getSortFunction(search);
            if (fn_sort) search.items.sort(fn_sort);
            search.total = search.items.length;
            if (typeof options.limit === "number") {
              search.items = search.items.slice(0, options.limit);
            }
            return search;
          }
        }
        const iterate = (object, callback2) => {
          if (Array.isArray(object)) {
            object.forEach(callback2);
          } else {
            for (var key in object) {
              if (object.hasOwnProperty(key)) {
                callback2(object[key], key);
              }
            }
          }
        };
        const getDom = (query) => {
          if (query.jquery) {
            return query[0];
          }
          if (query instanceof HTMLElement) {
            return query;
          }
          if (isHtmlString(query)) {
            var tpl = document.createElement("template");
            tpl.innerHTML = query.trim();
            return tpl.content.firstChild;
          }
          return document.querySelector(query);
        };
        const isHtmlString = (arg) => {
          if (typeof arg === "string" && arg.indexOf("<") > -1) {
            return true;
          }
          return false;
        };
        const escapeQuery = (query) => {
          return query.replace(/['"\\]/g, "\\$&");
        };
        const triggerEvent = (dom_el, event_name) => {
          var event2 = document.createEvent("HTMLEvents");
          event2.initEvent(event_name, true, false);
          dom_el.dispatchEvent(event2);
        };
        const applyCSS = (dom_el, css) => {
          Object.assign(dom_el.style, css);
        };
        const addClasses = (elmts, ...classes) => {
          var norm_classes = classesArray(classes);
          elmts = castAsArray(elmts);
          elmts.map((el) => {
            norm_classes.map((cls) => {
              el.classList.add(cls);
            });
          });
        };
        const removeClasses = (elmts, ...classes) => {
          var norm_classes = classesArray(classes);
          elmts = castAsArray(elmts);
          elmts.map((el) => {
            norm_classes.map((cls) => {
              el.classList.remove(cls);
            });
          });
        };
        const classesArray = (args) => {
          var classes = [];
          iterate(args, (_classes) => {
            if (typeof _classes === "string") {
              _classes = _classes.trim().split(/[\11\12\14\15\40]/);
            }
            if (Array.isArray(_classes)) {
              classes = classes.concat(_classes);
            }
          });
          return classes.filter(Boolean);
        };
        const castAsArray = (arg) => {
          if (!Array.isArray(arg)) {
            arg = [arg];
          }
          return arg;
        };
        const parentMatch = (target, selector, wrapper) => {
          if (wrapper && !wrapper.contains(target)) {
            return;
          }
          while (target && target.matches) {
            if (target.matches(selector)) {
              return target;
            }
            target = target.parentNode;
          }
        };
        const getTail = (list, direction = 0) => {
          if (direction > 0) {
            return list[list.length - 1];
          }
          return list[0];
        };
        const isEmptyObject = (obj) => {
          return Object.keys(obj).length === 0;
        };
        const nodeIndex = (el, amongst) => {
          if (!el) return -1;
          amongst = amongst || el.nodeName;
          var i3 = 0;
          while (el = el.previousElementSibling) {
            if (el.matches(amongst)) {
              i3++;
            }
          }
          return i3;
        };
        const setAttr = (el, attrs) => {
          iterate(attrs, (val, attr) => {
            if (val == null) {
              el.removeAttribute(attr);
            } else {
              el.setAttribute(attr, "" + val);
            }
          });
        };
        const replaceNode = (existing, replacement) => {
          if (existing.parentNode) existing.parentNode.replaceChild(replacement, existing);
        };
        const highlight = (element, regex) => {
          if (regex === null) return;
          if (typeof regex === "string") {
            if (!regex.length) return;
            regex = new RegExp(regex, "i");
          }
          const highlightText = (node) => {
            var match = node.data.match(regex);
            if (match && node.data.length > 0) {
              var spannode = document.createElement("span");
              spannode.className = "highlight";
              var middlebit = node.splitText(match.index);
              middlebit.splitText(match[0].length);
              var middleclone = middlebit.cloneNode(true);
              spannode.appendChild(middleclone);
              replaceNode(middlebit, spannode);
              return 1;
            }
            return 0;
          };
          const highlightChildren = (node) => {
            if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
              Array.from(node.childNodes).forEach((element2) => {
                highlightRecursive(element2);
              });
            }
          };
          const highlightRecursive = (node) => {
            if (node.nodeType === 3) {
              return highlightText(node);
            }
            highlightChildren(node);
            return 0;
          };
          highlightRecursive(element);
        };
        const removeHighlight = (el) => {
          var elements2 = el.querySelectorAll("span.highlight");
          Array.prototype.forEach.call(elements2, function(el2) {
            var parent = el2.parentNode;
            parent.replaceChild(el2.firstChild, el2);
            parent.normalize();
          });
        };
        const KEY_A = 65;
        const KEY_RETURN = 13;
        const KEY_ESC = 27;
        const KEY_LEFT = 37;
        const KEY_UP = 38;
        const KEY_RIGHT = 39;
        const KEY_DOWN = 40;
        const KEY_BACKSPACE = 8;
        const KEY_DELETE = 46;
        const KEY_TAB = 9;
        const IS_MAC = typeof navigator === "undefined" ? false : /Mac/.test(navigator.userAgent);
        const KEY_SHORTCUT = IS_MAC ? "metaKey" : "ctrlKey";
        var defaults3 = {
          options: [],
          optgroups: [],
          plugins: [],
          delimiter: ",",
          splitOn: null,
          // regexp or string for splitting up values from a paste command
          persist: true,
          diacritics: true,
          create: null,
          createOnBlur: false,
          createFilter: null,
          highlight: true,
          openOnFocus: true,
          shouldOpen: null,
          maxOptions: 50,
          maxItems: null,
          hideSelected: null,
          duplicates: false,
          addPrecedence: false,
          selectOnTab: false,
          preload: null,
          allowEmptyOption: false,
          //closeAfterSelect: false,
          refreshThrottle: 300,
          loadThrottle: 300,
          loadingClass: "loading",
          dataAttr: null,
          //'data-data',
          optgroupField: "optgroup",
          valueField: "value",
          labelField: "text",
          disabledField: "disabled",
          optgroupLabelField: "label",
          optgroupValueField: "value",
          lockOptgroupOrder: false,
          sortField: "$order",
          searchField: ["text"],
          searchConjunction: "and",
          mode: null,
          wrapperClass: "ts-wrapper",
          controlClass: "ts-control",
          dropdownClass: "ts-dropdown",
          dropdownContentClass: "ts-dropdown-content",
          itemClass: "item",
          optionClass: "option",
          dropdownParent: null,
          controlInput: '<input type="text" autocomplete="off" size="1" />',
          copyClassesToDropdown: false,
          placeholder: null,
          hidePlaceholder: null,
          shouldLoad: function(query) {
            return query.length > 0;
          },
          /*
          load                 : null, // function(query, callback) { ... }
          score                : null, // function(search) { ... }
          onInitialize         : null, // function() { ... }
          onChange             : null, // function(value) { ... }
          onItemAdd            : null, // function(value, $item) { ... }
          onItemRemove         : null, // function(value) { ... }
          onClear              : null, // function() { ... }
          onOptionAdd          : null, // function(value, data) { ... }
          onOptionRemove       : null, // function(value) { ... }
          onOptionClear        : null, // function() { ... }
          onOptionGroupAdd     : null, // function(id, data) { ... }
          onOptionGroupRemove  : null, // function(id) { ... }
          onOptionGroupClear   : null, // function() { ... }
          onDropdownOpen       : null, // function(dropdown) { ... }
          onDropdownClose      : null, // function(dropdown) { ... }
          onType               : null, // function(str) { ... }
          onDelete             : null, // function(values) { ... }
          */
          render: {
            /*
            item: null,
            optgroup: null,
            optgroup_header: null,
            option: null,
            option_create: null
            */
          }
        };
        const hash_key = (value) => {
          if (typeof value === "undefined" || value === null) return null;
          return get_hash(value);
        };
        const get_hash = (value) => {
          if (typeof value === "boolean") return value ? "1" : "0";
          return value + "";
        };
        const escape_html = (str) => {
          return (str + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        };
        const timeout = (fn3, timeout2) => {
          if (timeout2 > 0) {
            return setTimeout(fn3, timeout2);
          }
          fn3.call(null);
          return null;
        };
        const loadDebounce = (fn3, delay) => {
          var timeout2;
          return function(value, callback2) {
            var self2 = this;
            if (timeout2) {
              self2.loading = Math.max(self2.loading - 1, 0);
              clearTimeout(timeout2);
            }
            timeout2 = setTimeout(function() {
              timeout2 = null;
              self2.loadedSearches[value] = true;
              fn3.call(self2, value, callback2);
            }, delay);
          };
        };
        const debounce_events = (self2, types, fn3) => {
          var type;
          var trigger = self2.trigger;
          var event_args = {};
          self2.trigger = function() {
            var type2 = arguments[0];
            if (types.indexOf(type2) !== -1) {
              event_args[type2] = arguments;
            } else {
              return trigger.apply(self2, arguments);
            }
          };
          fn3.apply(self2, []);
          self2.trigger = trigger;
          for (type of types) {
            if (type in event_args) {
              trigger.apply(self2, event_args[type]);
            }
          }
        };
        const getSelection2 = (input) => {
          return {
            start: input.selectionStart || 0,
            length: (input.selectionEnd || 0) - (input.selectionStart || 0)
          };
        };
        const preventDefault = (evt, stop = false) => {
          if (evt) {
            evt.preventDefault();
            if (stop) {
              evt.stopPropagation();
            }
          }
        };
        const addEvent = (target, type, callback2, options) => {
          target.addEventListener(type, callback2, options);
        };
        const isKeyDown = (key_name, evt) => {
          if (!evt) {
            return false;
          }
          if (!evt[key_name]) {
            return false;
          }
          var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
          if (count === 1) {
            return true;
          }
          return false;
        };
        const getId = (el, id) => {
          const existing_id = el.getAttribute("id");
          if (existing_id) {
            return existing_id;
          }
          el.setAttribute("id", id);
          return id;
        };
        const addSlashes = (str) => {
          return str.replace(/[\\"']/g, "\\$&");
        };
        const append = (parent, node) => {
          if (node) parent.append(node);
        };
        function getSettings(input, settings_user) {
          var settings = Object.assign({}, defaults3, settings_user);
          var attr_data = settings.dataAttr;
          var field_label = settings.labelField;
          var field_value = settings.valueField;
          var field_disabled = settings.disabledField;
          var field_optgroup = settings.optgroupField;
          var field_optgroup_label = settings.optgroupLabelField;
          var field_optgroup_value = settings.optgroupValueField;
          var tag_name = input.tagName.toLowerCase();
          var placeholder = input.getAttribute("placeholder") || input.getAttribute("data-placeholder");
          if (!placeholder && !settings.allowEmptyOption) {
            let option = input.querySelector('option[value=""]');
            if (option) {
              placeholder = option.textContent;
            }
          }
          var settings_element = {
            placeholder,
            options: [],
            optgroups: [],
            items: [],
            maxItems: null
          };
          var init_select = () => {
            var tagName;
            var options = settings_element.options;
            var optionsMap = {};
            var group_count = 1;
            let $order = 0;
            var readData = (el) => {
              var data = Object.assign({}, el.dataset);
              var json = attr_data && data[attr_data];
              if (typeof json === "string" && json.length) {
                data = Object.assign(data, JSON.parse(json));
              }
              return data;
            };
            var addOption = (option, group) => {
              var value = hash_key(option.value);
              if (value == null) return;
              if (!value && !settings.allowEmptyOption) return;
              if (optionsMap.hasOwnProperty(value)) {
                if (group) {
                  var arr = optionsMap[value][field_optgroup];
                  if (!arr) {
                    optionsMap[value][field_optgroup] = group;
                  } else if (!Array.isArray(arr)) {
                    optionsMap[value][field_optgroup] = [arr, group];
                  } else {
                    arr.push(group);
                  }
                }
              } else {
                var option_data = readData(option);
                option_data[field_label] = option_data[field_label] || option.textContent;
                option_data[field_value] = option_data[field_value] || value;
                option_data[field_disabled] = option_data[field_disabled] || option.disabled;
                option_data[field_optgroup] = option_data[field_optgroup] || group;
                option_data.$option = option;
                option_data.$order = option_data.$order || ++$order;
                optionsMap[value] = option_data;
                options.push(option_data);
              }
              if (option.selected) {
                settings_element.items.push(value);
              }
            };
            var addGroup = (optgroup) => {
              var id, optgroup_data;
              optgroup_data = readData(optgroup);
              optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute("label") || "";
              optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
              optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
              optgroup_data.$order = optgroup_data.$order || ++$order;
              settings_element.optgroups.push(optgroup_data);
              id = optgroup_data[field_optgroup_value];
              iterate(optgroup.children, (option) => {
                addOption(option, id);
              });
            };
            settings_element.maxItems = input.hasAttribute("multiple") ? null : 1;
            iterate(input.children, (child) => {
              tagName = child.tagName.toLowerCase();
              if (tagName === "optgroup") {
                addGroup(child);
              } else if (tagName === "option") {
                addOption(child);
              }
            });
          };
          var init_textbox = () => {
            const data_raw = input.getAttribute(attr_data);
            if (!data_raw) {
              var value = input.value.trim() || "";
              if (!settings.allowEmptyOption && !value.length) return;
              const values = value.split(settings.delimiter);
              iterate(values, (value2) => {
                const option = {};
                option[field_label] = value2;
                option[field_value] = value2;
                settings_element.options.push(option);
              });
              settings_element.items = values;
            } else {
              settings_element.options = JSON.parse(data_raw);
              iterate(settings_element.options, (opt) => {
                settings_element.items.push(opt[field_value]);
              });
            }
          };
          if (tag_name === "select") {
            init_select();
          } else {
            init_textbox();
          }
          return Object.assign({}, defaults3, settings_element, settings_user);
        }
        var instance_i = 0;
        class TomSelect3 extends MicroPlugin(MicroEvent) {
          constructor(input_arg, user_settings) {
            super();
            this.control_input = void 0;
            this.wrapper = void 0;
            this.dropdown = void 0;
            this.control = void 0;
            this.dropdown_content = void 0;
            this.focus_node = void 0;
            this.order = 0;
            this.settings = void 0;
            this.input = void 0;
            this.tabIndex = void 0;
            this.is_select_tag = void 0;
            this.rtl = void 0;
            this.inputId = void 0;
            this._destroy = void 0;
            this.sifter = void 0;
            this.isOpen = false;
            this.isDisabled = false;
            this.isReadOnly = false;
            this.isRequired = void 0;
            this.isInvalid = false;
            this.isValid = true;
            this.isLocked = false;
            this.isFocused = false;
            this.isInputHidden = false;
            this.isSetup = false;
            this.ignoreFocus = false;
            this.ignoreHover = false;
            this.hasOptions = false;
            this.currentResults = void 0;
            this.lastValue = "";
            this.caretPos = 0;
            this.loading = 0;
            this.loadedSearches = {};
            this.activeOption = null;
            this.activeItems = [];
            this.optgroups = {};
            this.options = {};
            this.userOptions = {};
            this.items = [];
            this.refreshTimeout = null;
            instance_i++;
            var dir;
            var input = getDom(input_arg);
            if (input.tomselect) {
              throw new Error("Tom Select already initialized on this element");
            }
            input.tomselect = this;
            var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
            dir = computedStyle.getPropertyValue("direction");
            const settings = getSettings(input, user_settings);
            this.settings = settings;
            this.input = input;
            this.tabIndex = input.tabIndex || 0;
            this.is_select_tag = input.tagName.toLowerCase() === "select";
            this.rtl = /rtl/i.test(dir);
            this.inputId = getId(input, "tomselect-" + instance_i);
            this.isRequired = input.required;
            this.sifter = new Sifter(this.options, {
              diacritics: settings.diacritics
            });
            settings.mode = settings.mode || (settings.maxItems === 1 ? "single" : "multi");
            if (typeof settings.hideSelected !== "boolean") {
              settings.hideSelected = settings.mode === "multi";
            }
            if (typeof settings.hidePlaceholder !== "boolean") {
              settings.hidePlaceholder = settings.mode !== "multi";
            }
            var filter = settings.createFilter;
            if (typeof filter !== "function") {
              if (typeof filter === "string") {
                filter = new RegExp(filter);
              }
              if (filter instanceof RegExp) {
                settings.createFilter = (input2) => filter.test(input2);
              } else {
                settings.createFilter = (value) => {
                  return this.settings.duplicates || !this.options[value];
                };
              }
            }
            this.initializePlugins(settings.plugins);
            this.setupCallbacks();
            this.setupTemplates();
            const wrapper = getDom("<div>");
            const control = getDom("<div>");
            const dropdown = this._render("dropdown");
            const dropdown_content = getDom(`<div role="listbox" tabindex="-1">`);
            const classes = this.input.getAttribute("class") || "";
            const inputMode = settings.mode;
            var control_input;
            addClasses(wrapper, settings.wrapperClass, classes, inputMode);
            addClasses(control, settings.controlClass);
            append(wrapper, control);
            addClasses(dropdown, settings.dropdownClass, inputMode);
            if (settings.copyClassesToDropdown) {
              addClasses(dropdown, classes);
            }
            addClasses(dropdown_content, settings.dropdownContentClass);
            append(dropdown, dropdown_content);
            getDom(settings.dropdownParent || wrapper).appendChild(dropdown);
            if (isHtmlString(settings.controlInput)) {
              control_input = getDom(settings.controlInput);
              var attrs = ["autocorrect", "autocapitalize", "autocomplete", "spellcheck"];
              iterate$1(attrs, (attr) => {
                if (input.getAttribute(attr)) {
                  setAttr(control_input, {
                    [attr]: input.getAttribute(attr)
                  });
                }
              });
              control_input.tabIndex = -1;
              control.appendChild(control_input);
              this.focus_node = control_input;
            } else if (settings.controlInput) {
              control_input = getDom(settings.controlInput);
              this.focus_node = control_input;
            } else {
              control_input = getDom("<input/>");
              this.focus_node = control;
            }
            this.wrapper = wrapper;
            this.dropdown = dropdown;
            this.dropdown_content = dropdown_content;
            this.control = control;
            this.control_input = control_input;
            this.setup();
          }
          /**
           * set up event bindings.
           *
           */
          setup() {
            const self2 = this;
            const settings = self2.settings;
            const control_input = self2.control_input;
            const dropdown = self2.dropdown;
            const dropdown_content = self2.dropdown_content;
            const wrapper = self2.wrapper;
            const control = self2.control;
            const input = self2.input;
            const focus_node = self2.focus_node;
            const passive_event = {
              passive: true
            };
            const listboxId = self2.inputId + "-ts-dropdown";
            setAttr(dropdown_content, {
              id: listboxId
            });
            setAttr(focus_node, {
              role: "combobox",
              "aria-haspopup": "listbox",
              "aria-expanded": "false",
              "aria-controls": listboxId
            });
            const control_id = getId(focus_node, self2.inputId + "-ts-control");
            const query = "label[for='" + escapeQuery(self2.inputId) + "']";
            const label = document.querySelector(query);
            const label_click = self2.focus.bind(self2);
            if (label) {
              addEvent(label, "click", label_click);
              setAttr(label, {
                for: control_id
              });
              const label_id = getId(label, self2.inputId + "-ts-label");
              setAttr(focus_node, {
                "aria-labelledby": label_id
              });
              setAttr(dropdown_content, {
                "aria-labelledby": label_id
              });
            }
            wrapper.style.width = input.style.width;
            if (self2.plugins.names.length) {
              const classes_plugins = "plugin-" + self2.plugins.names.join(" plugin-");
              addClasses([wrapper, dropdown], classes_plugins);
            }
            if ((settings.maxItems === null || settings.maxItems > 1) && self2.is_select_tag) {
              setAttr(input, {
                multiple: "multiple"
              });
            }
            if (settings.placeholder) {
              setAttr(control_input, {
                placeholder: settings.placeholder
              });
            }
            if (!settings.splitOn && settings.delimiter) {
              settings.splitOn = new RegExp("\\s*" + escape_regex(settings.delimiter) + "+\\s*");
            }
            if (settings.load && settings.loadThrottle) {
              settings.load = loadDebounce(settings.load, settings.loadThrottle);
            }
            addEvent(dropdown, "mousemove", () => {
              self2.ignoreHover = false;
            });
            addEvent(dropdown, "mouseenter", (e2) => {
              var target_match = parentMatch(e2.target, "[data-selectable]", dropdown);
              if (target_match) self2.onOptionHover(e2, target_match);
            }, {
              capture: true
            });
            addEvent(dropdown, "click", (evt) => {
              const option = parentMatch(evt.target, "[data-selectable]");
              if (option) {
                self2.onOptionSelect(evt, option);
                preventDefault(evt, true);
              }
            });
            addEvent(control, "click", (evt) => {
              var target_match = parentMatch(evt.target, "[data-ts-item]", control);
              if (target_match && self2.onItemSelect(evt, target_match)) {
                preventDefault(evt, true);
                return;
              }
              if (control_input.value != "") {
                return;
              }
              self2.onClick();
              preventDefault(evt, true);
            });
            addEvent(focus_node, "keydown", (e2) => self2.onKeyDown(e2));
            addEvent(control_input, "keypress", (e2) => self2.onKeyPress(e2));
            addEvent(control_input, "input", (e2) => self2.onInput(e2));
            addEvent(focus_node, "blur", (e2) => self2.onBlur(e2));
            addEvent(focus_node, "focus", (e2) => self2.onFocus(e2));
            addEvent(control_input, "paste", (e2) => self2.onPaste(e2));
            const doc_mousedown = (evt) => {
              const target = evt.composedPath()[0];
              if (!wrapper.contains(target) && !dropdown.contains(target)) {
                if (self2.isFocused) {
                  self2.blur();
                }
                self2.inputState();
                return;
              }
              if (target == control_input && self2.isOpen) {
                evt.stopPropagation();
              } else {
                preventDefault(evt, true);
              }
            };
            const win_scroll = () => {
              if (self2.isOpen) {
                self2.positionDropdown();
              }
            };
            addEvent(document, "mousedown", doc_mousedown);
            addEvent(window, "scroll", win_scroll, passive_event);
            addEvent(window, "resize", win_scroll, passive_event);
            this._destroy = () => {
              document.removeEventListener("mousedown", doc_mousedown);
              window.removeEventListener("scroll", win_scroll);
              window.removeEventListener("resize", win_scroll);
              if (label) label.removeEventListener("click", label_click);
            };
            this.revertSettings = {
              innerHTML: input.innerHTML,
              tabIndex: input.tabIndex
            };
            input.tabIndex = -1;
            input.insertAdjacentElement("afterend", self2.wrapper);
            self2.sync(false);
            settings.items = [];
            delete settings.optgroups;
            delete settings.options;
            addEvent(input, "invalid", () => {
              if (self2.isValid) {
                self2.isValid = false;
                self2.isInvalid = true;
                self2.refreshState();
              }
            });
            self2.updateOriginalInput();
            self2.refreshItems();
            self2.close(false);
            self2.inputState();
            self2.isSetup = true;
            if (input.disabled) {
              self2.disable();
            } else if (input.readOnly) {
              self2.setReadOnly(true);
            } else {
              self2.enable();
            }
            self2.on("change", this.onChange);
            addClasses(input, "tomselected", "ts-hidden-accessible");
            self2.trigger("initialize");
            if (settings.preload === true) {
              self2.preload();
            }
          }
          /**
           * Register options and optgroups
           *
           */
          setupOptions(options = [], optgroups = []) {
            this.addOptions(options);
            iterate$1(optgroups, (optgroup) => {
              this.registerOptionGroup(optgroup);
            });
          }
          /**
           * Sets up default rendering functions.
           */
          setupTemplates() {
            var self2 = this;
            var field_label = self2.settings.labelField;
            var field_optgroup = self2.settings.optgroupLabelField;
            var templates = {
              "optgroup": (data) => {
                let optgroup = document.createElement("div");
                optgroup.className = "optgroup";
                optgroup.appendChild(data.options);
                return optgroup;
              },
              "optgroup_header": (data, escape3) => {
                return '<div class="optgroup-header">' + escape3(data[field_optgroup]) + "</div>";
              },
              "option": (data, escape3) => {
                return "<div>" + escape3(data[field_label]) + "</div>";
              },
              "item": (data, escape3) => {
                return "<div>" + escape3(data[field_label]) + "</div>";
              },
              "option_create": (data, escape3) => {
                return '<div class="create">Add <strong>' + escape3(data.input) + "</strong>&hellip;</div>";
              },
              "no_results": () => {
                return '<div class="no-results">No results found</div>';
              },
              "loading": () => {
                return '<div class="spinner"></div>';
              },
              "not_loading": () => {
              },
              "dropdown": () => {
                return "<div></div>";
              }
            };
            self2.settings.render = Object.assign({}, templates, self2.settings.render);
          }
          /**
           * Maps fired events to callbacks provided
           * in the settings used when creating the control.
           */
          setupCallbacks() {
            var key, fn3;
            var callbacks = {
              "initialize": "onInitialize",
              "change": "onChange",
              "item_add": "onItemAdd",
              "item_remove": "onItemRemove",
              "item_select": "onItemSelect",
              "clear": "onClear",
              "option_add": "onOptionAdd",
              "option_remove": "onOptionRemove",
              "option_clear": "onOptionClear",
              "optgroup_add": "onOptionGroupAdd",
              "optgroup_remove": "onOptionGroupRemove",
              "optgroup_clear": "onOptionGroupClear",
              "dropdown_open": "onDropdownOpen",
              "dropdown_close": "onDropdownClose",
              "type": "onType",
              "load": "onLoad",
              "focus": "onFocus",
              "blur": "onBlur"
            };
            for (key in callbacks) {
              fn3 = this.settings[callbacks[key]];
              if (fn3) this.on(key, fn3);
            }
          }
          /**
           * Sync the Tom Select instance with the original input or select
           *
           */
          sync(get_settings = true) {
            const self2 = this;
            const settings = get_settings ? getSettings(self2.input, {
              delimiter: self2.settings.delimiter
            }) : self2.settings;
            self2.setupOptions(settings.options, settings.optgroups);
            self2.setValue(settings.items || [], true);
            self2.lastQuery = null;
          }
          /**
           * Triggered when the main control element
           * has a click event.
           *
           */
          onClick() {
            var self2 = this;
            if (self2.activeItems.length > 0) {
              self2.clearActiveItems();
              self2.focus();
              return;
            }
            if (self2.isFocused && self2.isOpen) {
              self2.blur();
            } else {
              self2.focus();
            }
          }
          /**
           * @deprecated v1.7
           *
           */
          onMouseDown() {
          }
          /**
           * Triggered when the value of the control has been changed.
           * This should propagate the event to the original DOM
           * input / select element.
           */
          onChange() {
            triggerEvent(this.input, "input");
            triggerEvent(this.input, "change");
          }
          /**
           * Triggered on <input> paste.
           *
           */
          onPaste(e2) {
            var self2 = this;
            if (self2.isInputHidden || self2.isLocked) {
              preventDefault(e2);
              return;
            }
            if (!self2.settings.splitOn) {
              return;
            }
            setTimeout(() => {
              var pastedText = self2.inputValue();
              if (!pastedText.match(self2.settings.splitOn)) {
                return;
              }
              var splitInput = pastedText.trim().split(self2.settings.splitOn);
              iterate$1(splitInput, (piece) => {
                const hash3 = hash_key(piece);
                if (hash3) {
                  if (this.options[piece]) {
                    self2.addItem(piece);
                  } else {
                    self2.createItem(piece);
                  }
                }
              });
            }, 0);
          }
          /**
           * Triggered on <input> keypress.
           *
           */
          onKeyPress(e2) {
            var self2 = this;
            if (self2.isLocked) {
              preventDefault(e2);
              return;
            }
            var character = String.fromCharCode(e2.keyCode || e2.which);
            if (self2.settings.create && self2.settings.mode === "multi" && character === self2.settings.delimiter) {
              self2.createItem();
              preventDefault(e2);
              return;
            }
          }
          /**
           * Triggered on <input> keydown.
           *
           */
          onKeyDown(e2) {
            var self2 = this;
            self2.ignoreHover = true;
            if (self2.isLocked) {
              if (e2.keyCode !== KEY_TAB) {
                preventDefault(e2);
              }
              return;
            }
            switch (e2.keyCode) {
              // ctrl+A: select all
              case KEY_A:
                if (isKeyDown(KEY_SHORTCUT, e2)) {
                  if (self2.control_input.value == "") {
                    preventDefault(e2);
                    self2.selectAll();
                    return;
                  }
                }
                break;
              // esc: close dropdown
              case KEY_ESC:
                if (self2.isOpen) {
                  preventDefault(e2, true);
                  self2.close();
                }
                self2.clearActiveItems();
                return;
              // down: open dropdown or move selection down
              case KEY_DOWN:
                if (!self2.isOpen && self2.hasOptions) {
                  self2.open();
                } else if (self2.activeOption) {
                  let next = self2.getAdjacent(self2.activeOption, 1);
                  if (next) self2.setActiveOption(next);
                }
                preventDefault(e2);
                return;
              // up: move selection up
              case KEY_UP:
                if (self2.activeOption) {
                  let prev = self2.getAdjacent(self2.activeOption, -1);
                  if (prev) self2.setActiveOption(prev);
                }
                preventDefault(e2);
                return;
              // return: select active option
              case KEY_RETURN:
                if (self2.canSelect(self2.activeOption)) {
                  self2.onOptionSelect(e2, self2.activeOption);
                  preventDefault(e2);
                } else if (self2.settings.create && self2.createItem()) {
                  preventDefault(e2);
                } else if (document.activeElement == self2.control_input && self2.isOpen) {
                  preventDefault(e2);
                }
                return;
              // left: modifiy item selection to the left
              case KEY_LEFT:
                self2.advanceSelection(-1, e2);
                return;
              // right: modifiy item selection to the right
              case KEY_RIGHT:
                self2.advanceSelection(1, e2);
                return;
              // tab: select active option and/or create item
              case KEY_TAB:
                if (self2.settings.selectOnTab) {
                  if (self2.canSelect(self2.activeOption)) {
                    self2.onOptionSelect(e2, self2.activeOption);
                    preventDefault(e2);
                  }
                  if (self2.settings.create && self2.createItem()) {
                    preventDefault(e2);
                  }
                }
                return;
              // delete|backspace: delete items
              case KEY_BACKSPACE:
              case KEY_DELETE:
                self2.deleteSelection(e2);
                return;
            }
            if (self2.isInputHidden && !isKeyDown(KEY_SHORTCUT, e2)) {
              preventDefault(e2);
            }
          }
          /**
           * Triggered on <input> keyup.
           *
           */
          onInput(e2) {
            if (this.isLocked) {
              return;
            }
            const value = this.inputValue();
            if (this.lastValue === value) return;
            this.lastValue = value;
            if (value == "") {
              this._onInput();
              return;
            }
            if (this.refreshTimeout) {
              clearTimeout(this.refreshTimeout);
            }
            this.refreshTimeout = timeout(() => {
              this.refreshTimeout = null;
              this._onInput();
            }, this.settings.refreshThrottle);
          }
          _onInput() {
            const value = this.lastValue;
            if (this.settings.shouldLoad.call(this, value)) {
              this.load(value);
            }
            this.refreshOptions();
            this.trigger("type", value);
          }
          /**
           * Triggered when the user rolls over
           * an option in the autocomplete dropdown menu.
           *
           */
          onOptionHover(evt, option) {
            if (this.ignoreHover) return;
            this.setActiveOption(option, false);
          }
          /**
           * Triggered on <input> focus.
           *
           */
          onFocus(e2) {
            var self2 = this;
            var wasFocused = self2.isFocused;
            if (self2.isDisabled || self2.isReadOnly) {
              self2.blur();
              preventDefault(e2);
              return;
            }
            if (self2.ignoreFocus) return;
            self2.isFocused = true;
            if (self2.settings.preload === "focus") self2.preload();
            if (!wasFocused) self2.trigger("focus");
            if (!self2.activeItems.length) {
              self2.inputState();
              self2.refreshOptions(!!self2.settings.openOnFocus);
            }
            self2.refreshState();
          }
          /**
           * Triggered on <input> blur.
           *
           */
          onBlur(e2) {
            if (document.hasFocus() === false) return;
            var self2 = this;
            if (!self2.isFocused) return;
            self2.isFocused = false;
            self2.ignoreFocus = false;
            var deactivate = () => {
              self2.close();
              self2.setActiveItem();
              self2.setCaret(self2.items.length);
              self2.trigger("blur");
            };
            if (self2.settings.create && self2.settings.createOnBlur) {
              self2.createItem(null, deactivate);
            } else {
              deactivate();
            }
          }
          /**
           * Triggered when the user clicks on an option
           * in the autocomplete dropdown menu.
           *
           */
          onOptionSelect(evt, option) {
            var value, self2 = this;
            if (option.parentElement && option.parentElement.matches("[data-disabled]")) {
              return;
            }
            if (option.classList.contains("create")) {
              self2.createItem(null, () => {
                if (self2.settings.closeAfterSelect) {
                  self2.close();
                }
              });
            } else {
              value = option.dataset.value;
              if (typeof value !== "undefined") {
                self2.lastQuery = null;
                self2.addItem(value);
                if (self2.settings.closeAfterSelect) {
                  self2.close();
                }
                if (!self2.settings.hideSelected && evt.type && /click/.test(evt.type)) {
                  self2.setActiveOption(option);
                }
              }
            }
          }
          /**
           * Return true if the given option can be selected
           *
           */
          canSelect(option) {
            if (this.isOpen && option && this.dropdown_content.contains(option)) {
              return true;
            }
            return false;
          }
          /**
           * Triggered when the user clicks on an item
           * that has been selected.
           *
           */
          onItemSelect(evt, item) {
            var self2 = this;
            if (!self2.isLocked && self2.settings.mode === "multi") {
              preventDefault(evt);
              self2.setActiveItem(item, evt);
              return true;
            }
            return false;
          }
          /**
           * Determines whether or not to invoke
           * the user-provided option provider / loader
           *
           * Note, there is a subtle difference between
           * this.canLoad() and this.settings.shouldLoad();
           *
           *	- settings.shouldLoad() is a user-input validator.
           *	When false is returned, the not_loading template
           *	will be added to the dropdown
           *
           *	- canLoad() is lower level validator that checks
           * 	the Tom Select instance. There is no inherent user
           *	feedback when canLoad returns false
           *
           */
          canLoad(value) {
            if (!this.settings.load) return false;
            if (this.loadedSearches.hasOwnProperty(value)) return false;
            return true;
          }
          /**
           * Invokes the user-provided option provider / loader.
           *
           */
          load(value) {
            const self2 = this;
            if (!self2.canLoad(value)) return;
            addClasses(self2.wrapper, self2.settings.loadingClass);
            self2.loading++;
            const callback2 = self2.loadCallback.bind(self2);
            self2.settings.load.call(self2, value, callback2);
          }
          /**
           * Invoked by the user-provided option provider
           *
           */
          loadCallback(options, optgroups) {
            const self2 = this;
            self2.loading = Math.max(self2.loading - 1, 0);
            self2.lastQuery = null;
            self2.clearActiveOption();
            self2.setupOptions(options, optgroups);
            self2.refreshOptions(self2.isFocused && !self2.isInputHidden);
            if (!self2.loading) {
              removeClasses(self2.wrapper, self2.settings.loadingClass);
            }
            self2.trigger("load", options, optgroups);
          }
          preload() {
            var classList = this.wrapper.classList;
            if (classList.contains("preloaded")) return;
            classList.add("preloaded");
            this.load("");
          }
          /**
           * Sets the input field of the control to the specified value.
           *
           */
          setTextboxValue(value = "") {
            var input = this.control_input;
            var changed = input.value !== value;
            if (changed) {
              input.value = value;
              triggerEvent(input, "update");
              this.lastValue = value;
            }
          }
          /**
           * Returns the value of the control. If multiple items
           * can be selected (e.g. <select multiple>), this returns
           * an array. If only one item can be selected, this
           * returns a string.
           *
           */
          getValue() {
            if (this.is_select_tag && this.input.hasAttribute("multiple")) {
              return this.items;
            }
            return this.items.join(this.settings.delimiter);
          }
          /**
           * Resets the selected items to the given value.
           *
           */
          setValue(value, silent) {
            var events = silent ? [] : ["change"];
            debounce_events(this, events, () => {
              this.clear(silent);
              this.addItems(value, silent);
            });
          }
          /**
           * Resets the number of max items to the given value
           *
           */
          setMaxItems(value) {
            if (value === 0) value = null;
            this.settings.maxItems = value;
            this.refreshState();
          }
          /**
           * Sets the selected item.
           *
           */
          setActiveItem(item, e2) {
            var self2 = this;
            var eventName;
            var i3, begin, end2, swap2;
            var last;
            if (self2.settings.mode === "single") return;
            if (!item) {
              self2.clearActiveItems();
              if (self2.isFocused) {
                self2.inputState();
              }
              return;
            }
            eventName = e2 && e2.type.toLowerCase();
            if (eventName === "click" && isKeyDown("shiftKey", e2) && self2.activeItems.length) {
              last = self2.getLastActive();
              begin = Array.prototype.indexOf.call(self2.control.children, last);
              end2 = Array.prototype.indexOf.call(self2.control.children, item);
              if (begin > end2) {
                swap2 = begin;
                begin = end2;
                end2 = swap2;
              }
              for (i3 = begin; i3 <= end2; i3++) {
                item = self2.control.children[i3];
                if (self2.activeItems.indexOf(item) === -1) {
                  self2.setActiveItemClass(item);
                }
              }
              preventDefault(e2);
            } else if (eventName === "click" && isKeyDown(KEY_SHORTCUT, e2) || eventName === "keydown" && isKeyDown("shiftKey", e2)) {
              if (item.classList.contains("active")) {
                self2.removeActiveItem(item);
              } else {
                self2.setActiveItemClass(item);
              }
            } else {
              self2.clearActiveItems();
              self2.setActiveItemClass(item);
            }
            self2.inputState();
            if (!self2.isFocused) {
              self2.focus();
            }
          }
          /**
           * Set the active and last-active classes
           *
           */
          setActiveItemClass(item) {
            const self2 = this;
            const last_active = self2.control.querySelector(".last-active");
            if (last_active) removeClasses(last_active, "last-active");
            addClasses(item, "active last-active");
            self2.trigger("item_select", item);
            if (self2.activeItems.indexOf(item) == -1) {
              self2.activeItems.push(item);
            }
          }
          /**
           * Remove active item
           *
           */
          removeActiveItem(item) {
            var idx = this.activeItems.indexOf(item);
            this.activeItems.splice(idx, 1);
            removeClasses(item, "active");
          }
          /**
           * Clears all the active items
           *
           */
          clearActiveItems() {
            removeClasses(this.activeItems, "active");
            this.activeItems = [];
          }
          /**
           * Sets the selected item in the dropdown menu
           * of available options.
           *
           */
          setActiveOption(option, scroll = true) {
            if (option === this.activeOption) {
              return;
            }
            this.clearActiveOption();
            if (!option) return;
            this.activeOption = option;
            setAttr(this.focus_node, {
              "aria-activedescendant": option.getAttribute("id")
            });
            setAttr(option, {
              "aria-selected": "true"
            });
            addClasses(option, "active");
            if (scroll) this.scrollToOption(option);
          }
          /**
           * Sets the dropdown_content scrollTop to display the option
           *
           */
          scrollToOption(option, behavior) {
            if (!option) return;
            const content = this.dropdown_content;
            const height_menu = content.clientHeight;
            const scrollTop = content.scrollTop || 0;
            const height_item = option.offsetHeight;
            const y6 = option.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
            if (y6 + height_item > height_menu + scrollTop) {
              this.scroll(y6 - height_menu + height_item, behavior);
            } else if (y6 < scrollTop) {
              this.scroll(y6, behavior);
            }
          }
          /**
           * Scroll the dropdown to the given position
           *
           */
          scroll(scrollTop, behavior) {
            const content = this.dropdown_content;
            if (behavior) {
              content.style.scrollBehavior = behavior;
            }
            content.scrollTop = scrollTop;
            content.style.scrollBehavior = "";
          }
          /**
           * Clears the active option
           *
           */
          clearActiveOption() {
            if (this.activeOption) {
              removeClasses(this.activeOption, "active");
              setAttr(this.activeOption, {
                "aria-selected": null
              });
            }
            this.activeOption = null;
            setAttr(this.focus_node, {
              "aria-activedescendant": null
            });
          }
          /**
           * Selects all items (CTRL + A).
           */
          selectAll() {
            const self2 = this;
            if (self2.settings.mode === "single") return;
            const activeItems = self2.controlChildren();
            if (!activeItems.length) return;
            self2.inputState();
            self2.close();
            self2.activeItems = activeItems;
            iterate$1(activeItems, (item) => {
              self2.setActiveItemClass(item);
            });
          }
          /**
           * Determines if the control_input should be in a hidden or visible state
           *
           */
          inputState() {
            var self2 = this;
            if (!self2.control.contains(self2.control_input)) return;
            setAttr(self2.control_input, {
              placeholder: self2.settings.placeholder
            });
            if (self2.activeItems.length > 0 || !self2.isFocused && self2.settings.hidePlaceholder && self2.items.length > 0) {
              self2.setTextboxValue();
              self2.isInputHidden = true;
            } else {
              if (self2.settings.hidePlaceholder && self2.items.length > 0) {
                setAttr(self2.control_input, {
                  placeholder: ""
                });
              }
              self2.isInputHidden = false;
            }
            self2.wrapper.classList.toggle("input-hidden", self2.isInputHidden);
          }
          /**
           * Get the input value
           */
          inputValue() {
            return this.control_input.value.trim();
          }
          /**
           * Gives the control focus.
           */
          focus() {
            var self2 = this;
            if (self2.isDisabled || self2.isReadOnly) return;
            self2.ignoreFocus = true;
            if (self2.control_input.offsetWidth) {
              self2.control_input.focus();
            } else {
              self2.focus_node.focus();
            }
            setTimeout(() => {
              self2.ignoreFocus = false;
              self2.onFocus();
            }, 0);
          }
          /**
           * Forces the control out of focus.
           *
           */
          blur() {
            this.focus_node.blur();
            this.onBlur();
          }
          /**
           * Returns a function that scores an object
           * to show how good of a match it is to the
           * provided query.
           *
           * @return {function}
           */
          getScoreFunction(query) {
            return this.sifter.getScoreFunction(query, this.getSearchOptions());
          }
          /**
           * Returns search options for sifter (the system
           * for scoring and sorting results).
           *
           * @see https://github.com/orchidjs/sifter.js
           * @return {object}
           */
          getSearchOptions() {
            var settings = this.settings;
            var sort = settings.sortField;
            if (typeof settings.sortField === "string") {
              sort = [{
                field: settings.sortField
              }];
            }
            return {
              fields: settings.searchField,
              conjunction: settings.searchConjunction,
              sort,
              nesting: settings.nesting
            };
          }
          /**
           * Searches through available options and returns
           * a sorted array of matches.
           *
           */
          search(query) {
            var result, calculateScore;
            var self2 = this;
            var options = this.getSearchOptions();
            if (self2.settings.score) {
              calculateScore = self2.settings.score.call(self2, query);
              if (typeof calculateScore !== "function") {
                throw new Error('Tom Select "score" setting must be a function that returns a function');
              }
            }
            if (query !== self2.lastQuery) {
              self2.lastQuery = query;
              result = self2.sifter.search(query, Object.assign(options, {
                score: calculateScore
              }));
              self2.currentResults = result;
            } else {
              result = Object.assign({}, self2.currentResults);
            }
            if (self2.settings.hideSelected) {
              result.items = result.items.filter((item) => {
                let hashed = hash_key(item.id);
                return !(hashed && self2.items.indexOf(hashed) !== -1);
              });
            }
            return result;
          }
          /**
           * Refreshes the list of available options shown
           * in the autocomplete dropdown menu.
           *
           */
          refreshOptions(triggerDropdown = true) {
            var i3, j6, k4, n3, optgroup, optgroups, html, has_create_option, active_group;
            var create;
            const groups = {};
            const groups_order = [];
            var self2 = this;
            var query = self2.inputValue();
            const same_query = query === self2.lastQuery || query == "" && self2.lastQuery == null;
            var results = self2.search(query);
            var active_option = null;
            var show_dropdown = self2.settings.shouldOpen || false;
            var dropdown_content = self2.dropdown_content;
            if (same_query) {
              active_option = self2.activeOption;
              if (active_option) {
                active_group = active_option.closest("[data-group]");
              }
            }
            n3 = results.items.length;
            if (typeof self2.settings.maxOptions === "number") {
              n3 = Math.min(n3, self2.settings.maxOptions);
            }
            if (n3 > 0) {
              show_dropdown = true;
            }
            const getGroupFragment = (optgroup2, order2) => {
              let group_order_i = groups[optgroup2];
              if (group_order_i !== void 0) {
                let order_group = groups_order[group_order_i];
                if (order_group !== void 0) {
                  return [group_order_i, order_group.fragment];
                }
              }
              let group_fragment = document.createDocumentFragment();
              group_order_i = groups_order.length;
              groups_order.push({
                fragment: group_fragment,
                order: order2,
                optgroup: optgroup2
              });
              return [group_order_i, group_fragment];
            };
            for (i3 = 0; i3 < n3; i3++) {
              let item = results.items[i3];
              if (!item) continue;
              let opt_value = item.id;
              let option = self2.options[opt_value];
              if (option === void 0) continue;
              let opt_hash = get_hash(opt_value);
              let option_el = self2.getOption(opt_hash, true);
              if (!self2.settings.hideSelected) {
                option_el.classList.toggle("selected", self2.items.includes(opt_hash));
              }
              optgroup = option[self2.settings.optgroupField] || "";
              optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
              for (j6 = 0, k4 = optgroups && optgroups.length; j6 < k4; j6++) {
                optgroup = optgroups[j6];
                let order2 = option.$order;
                let self_optgroup = self2.optgroups[optgroup];
                if (self_optgroup === void 0) {
                  optgroup = "";
                } else {
                  order2 = self_optgroup.$order;
                }
                const [group_order_i, group_fragment] = getGroupFragment(optgroup, order2);
                if (j6 > 0) {
                  option_el = option_el.cloneNode(true);
                  setAttr(option_el, {
                    id: option.$id + "-clone-" + j6,
                    "aria-selected": null
                  });
                  option_el.classList.add("ts-cloned");
                  removeClasses(option_el, "active");
                  if (self2.activeOption && self2.activeOption.dataset.value == opt_value) {
                    if (active_group && active_group.dataset.group === optgroup.toString()) {
                      active_option = option_el;
                    }
                  }
                }
                group_fragment.appendChild(option_el);
                if (optgroup != "") {
                  groups[optgroup] = group_order_i;
                }
              }
            }
            if (self2.settings.lockOptgroupOrder) {
              groups_order.sort((a5, b5) => {
                return a5.order - b5.order;
              });
            }
            html = document.createDocumentFragment();
            iterate$1(groups_order, (group_order) => {
              let group_fragment = group_order.fragment;
              let optgroup2 = group_order.optgroup;
              if (!group_fragment || !group_fragment.children.length) return;
              let group_heading = self2.optgroups[optgroup2];
              if (group_heading !== void 0) {
                let group_options = document.createDocumentFragment();
                let header = self2.render("optgroup_header", group_heading);
                append(group_options, header);
                append(group_options, group_fragment);
                let group_html = self2.render("optgroup", {
                  group: group_heading,
                  options: group_options
                });
                append(html, group_html);
              } else {
                append(html, group_fragment);
              }
            });
            dropdown_content.innerHTML = "";
            append(dropdown_content, html);
            if (self2.settings.highlight) {
              removeHighlight(dropdown_content);
              if (results.query.length && results.tokens.length) {
                iterate$1(results.tokens, (tok) => {
                  highlight(dropdown_content, tok.regex);
                });
              }
            }
            var add_template = (template2) => {
              let content = self2.render(template2, {
                input: query
              });
              if (content) {
                show_dropdown = true;
                dropdown_content.insertBefore(content, dropdown_content.firstChild);
              }
              return content;
            };
            if (self2.loading) {
              add_template("loading");
            } else if (!self2.settings.shouldLoad.call(self2, query)) {
              add_template("not_loading");
            } else if (results.items.length === 0) {
              add_template("no_results");
            }
            has_create_option = self2.canCreate(query);
            if (has_create_option) {
              create = add_template("option_create");
            }
            self2.hasOptions = results.items.length > 0 || has_create_option;
            if (show_dropdown) {
              if (results.items.length > 0) {
                if (!active_option && self2.settings.mode === "single" && self2.items[0] != void 0) {
                  active_option = self2.getOption(self2.items[0]);
                }
                if (!dropdown_content.contains(active_option)) {
                  let active_index = 0;
                  if (create && !self2.settings.addPrecedence) {
                    active_index = 1;
                  }
                  active_option = self2.selectable()[active_index];
                }
              } else if (create) {
                active_option = create;
              }
              if (triggerDropdown && !self2.isOpen) {
                self2.open();
                self2.scrollToOption(active_option, "auto");
              }
              self2.setActiveOption(active_option);
            } else {
              self2.clearActiveOption();
              if (triggerDropdown && self2.isOpen) {
                self2.close(false);
              }
            }
          }
          /**
           * Return list of selectable options
           *
           */
          selectable() {
            return this.dropdown_content.querySelectorAll("[data-selectable]");
          }
          /**
           * Adds an available option. If it already exists,
           * nothing will happen. Note: this does not refresh
           * the options list dropdown (use `refreshOptions`
           * for that).
           *
           * Usage:
           *
           *   this.addOption(data)
           *
           */
          addOption(data, user_created = false) {
            const self2 = this;
            if (Array.isArray(data)) {
              self2.addOptions(data, user_created);
              return false;
            }
            const key = hash_key(data[self2.settings.valueField]);
            if (key === null || self2.options.hasOwnProperty(key)) {
              return false;
            }
            data.$order = data.$order || ++self2.order;
            data.$id = self2.inputId + "-opt-" + data.$order;
            self2.options[key] = data;
            self2.lastQuery = null;
            if (user_created) {
              self2.userOptions[key] = user_created;
              self2.trigger("option_add", key, data);
            }
            return key;
          }
          /**
           * Add multiple options
           *
           */
          addOptions(data, user_created = false) {
            iterate$1(data, (dat) => {
              this.addOption(dat, user_created);
            });
          }
          /**
           * @deprecated 1.7.7
           */
          registerOption(data) {
            return this.addOption(data);
          }
          /**
           * Registers an option group to the pool of option groups.
           *
           * @return {boolean|string}
           */
          registerOptionGroup(data) {
            var key = hash_key(data[this.settings.optgroupValueField]);
            if (key === null) return false;
            data.$order = data.$order || ++this.order;
            this.optgroups[key] = data;
            return key;
          }
          /**
           * Registers a new optgroup for options
           * to be bucketed into.
           *
           */
          addOptionGroup(id, data) {
            var hashed_id;
            data[this.settings.optgroupValueField] = id;
            if (hashed_id = this.registerOptionGroup(data)) {
              this.trigger("optgroup_add", hashed_id, data);
            }
          }
          /**
           * Removes an existing option group.
           *
           */
          removeOptionGroup(id) {
            if (this.optgroups.hasOwnProperty(id)) {
              delete this.optgroups[id];
              this.clearCache();
              this.trigger("optgroup_remove", id);
            }
          }
          /**
           * Clears all existing option groups.
           */
          clearOptionGroups() {
            this.optgroups = {};
            this.clearCache();
            this.trigger("optgroup_clear");
          }
          /**
           * Updates an option available for selection. If
           * it is visible in the selected items or options
           * dropdown, it will be re-rendered automatically.
           *
           */
          updateOption(value, data) {
            const self2 = this;
            var item_new;
            var index_item;
            const value_old = hash_key(value);
            const value_new = hash_key(data[self2.settings.valueField]);
            if (value_old === null) return;
            const data_old = self2.options[value_old];
            if (data_old == void 0) return;
            if (typeof value_new !== "string") throw new Error("Value must be set in option data");
            const option = self2.getOption(value_old);
            const item = self2.getItem(value_old);
            data.$order = data.$order || data_old.$order;
            delete self2.options[value_old];
            self2.uncacheValue(value_new);
            self2.options[value_new] = data;
            if (option) {
              if (self2.dropdown_content.contains(option)) {
                const option_new = self2._render("option", data);
                replaceNode(option, option_new);
                if (self2.activeOption === option) {
                  self2.setActiveOption(option_new);
                }
              }
              option.remove();
            }
            if (item) {
              index_item = self2.items.indexOf(value_old);
              if (index_item !== -1) {
                self2.items.splice(index_item, 1, value_new);
              }
              item_new = self2._render("item", data);
              if (item.classList.contains("active")) addClasses(item_new, "active");
              replaceNode(item, item_new);
            }
            self2.lastQuery = null;
          }
          /**
           * Removes a single option.
           *
           */
          removeOption(value, silent) {
            const self2 = this;
            value = get_hash(value);
            self2.uncacheValue(value);
            delete self2.userOptions[value];
            delete self2.options[value];
            self2.lastQuery = null;
            self2.trigger("option_remove", value);
            self2.removeItem(value, silent);
          }
          /**
           * Clears all options.
           */
          clearOptions(filter) {
            const boundFilter = (filter || this.clearFilter).bind(this);
            this.loadedSearches = {};
            this.userOptions = {};
            this.clearCache();
            const selected = {};
            iterate$1(this.options, (option, key) => {
              if (boundFilter(option, key)) {
                selected[key] = option;
              }
            });
            this.options = this.sifter.items = selected;
            this.lastQuery = null;
            this.trigger("option_clear");
          }
          /**
           * Used by clearOptions() to decide whether or not an option should be removed
           * Return true to keep an option, false to remove
           *
           */
          clearFilter(option, value) {
            if (this.items.indexOf(value) >= 0) {
              return true;
            }
            return false;
          }
          /**
           * Returns the dom element of the option
           * matching the given value.
           *
           */
          getOption(value, create = false) {
            const hashed = hash_key(value);
            if (hashed === null) return null;
            const option = this.options[hashed];
            if (option != void 0) {
              if (option.$div) {
                return option.$div;
              }
              if (create) {
                return this._render("option", option);
              }
            }
            return null;
          }
          /**
           * Returns the dom element of the next or previous dom element of the same type
           * Note: adjacent options may not be adjacent DOM elements (optgroups)
           *
           */
          getAdjacent(option, direction, type = "option") {
            var self2 = this, all;
            if (!option) {
              return null;
            }
            if (type == "item") {
              all = self2.controlChildren();
            } else {
              all = self2.dropdown_content.querySelectorAll("[data-selectable]");
            }
            for (let i3 = 0; i3 < all.length; i3++) {
              if (all[i3] != option) {
                continue;
              }
              if (direction > 0) {
                return all[i3 + 1];
              }
              return all[i3 - 1];
            }
            return null;
          }
          /**
           * Returns the dom element of the item
           * matching the given value.
           *
           */
          getItem(item) {
            if (typeof item == "object") {
              return item;
            }
            var value = hash_key(item);
            return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
          }
          /**
           * "Selects" multiple items at once. Adds them to the list
           * at the current caret position.
           *
           */
          addItems(values, silent) {
            var self2 = this;
            var items = Array.isArray(values) ? values : [values];
            items = items.filter((x4) => self2.items.indexOf(x4) === -1);
            const last_item = items[items.length - 1];
            items.forEach((item) => {
              self2.isPending = item !== last_item;
              self2.addItem(item, silent);
            });
          }
          /**
           * "Selects" an item. Adds it to the list
           * at the current caret position.
           *
           */
          addItem(value, silent) {
            var events = silent ? [] : ["change", "dropdown_close"];
            debounce_events(this, events, () => {
              var item, wasFull;
              const self2 = this;
              const inputMode = self2.settings.mode;
              const hashed = hash_key(value);
              if (hashed && self2.items.indexOf(hashed) !== -1) {
                if (inputMode === "single") {
                  self2.close();
                }
                if (inputMode === "single" || !self2.settings.duplicates) {
                  return;
                }
              }
              if (hashed === null || !self2.options.hasOwnProperty(hashed)) return;
              if (inputMode === "single") self2.clear(silent);
              if (inputMode === "multi" && self2.isFull()) return;
              item = self2._render("item", self2.options[hashed]);
              if (self2.control.contains(item)) {
                item = item.cloneNode(true);
              }
              wasFull = self2.isFull();
              self2.items.splice(self2.caretPos, 0, hashed);
              self2.insertAtCaret(item);
              if (self2.isSetup) {
                if (!self2.isPending && self2.settings.hideSelected) {
                  let option = self2.getOption(hashed);
                  let next = self2.getAdjacent(option, 1);
                  if (next) {
                    self2.setActiveOption(next);
                  }
                }
                if (!self2.isPending && !self2.settings.closeAfterSelect) {
                  self2.refreshOptions(self2.isFocused && inputMode !== "single");
                }
                if (self2.settings.closeAfterSelect != false && self2.isFull()) {
                  self2.close();
                } else if (!self2.isPending) {
                  self2.positionDropdown();
                }
                self2.trigger("item_add", hashed, item);
                if (!self2.isPending) {
                  self2.updateOriginalInput({
                    silent
                  });
                }
              }
              if (!self2.isPending || !wasFull && self2.isFull()) {
                self2.inputState();
                self2.refreshState();
              }
            });
          }
          /**
           * Removes the selected item matching
           * the provided value.
           *
           */
          removeItem(item = null, silent) {
            const self2 = this;
            item = self2.getItem(item);
            if (!item) return;
            var i3, idx;
            const value = item.dataset.value;
            i3 = nodeIndex(item);
            item.remove();
            if (item.classList.contains("active")) {
              idx = self2.activeItems.indexOf(item);
              self2.activeItems.splice(idx, 1);
              removeClasses(item, "active");
            }
            self2.items.splice(i3, 1);
            self2.lastQuery = null;
            if (!self2.settings.persist && self2.userOptions.hasOwnProperty(value)) {
              self2.removeOption(value, silent);
            }
            if (i3 < self2.caretPos) {
              self2.setCaret(self2.caretPos - 1);
            }
            self2.updateOriginalInput({
              silent
            });
            self2.refreshState();
            self2.positionDropdown();
            self2.trigger("item_remove", value, item);
          }
          /**
           * Invokes the `create` method provided in the
           * TomSelect options that should provide the data
           * for the new item, given the user input.
           *
           * Once this completes, it will be added
           * to the item list.
           *
           */
          createItem(input = null, callback2 = () => {
          }) {
            if (arguments.length === 3) {
              callback2 = arguments[2];
            }
            if (typeof callback2 != "function") {
              callback2 = () => {
              };
            }
            var self2 = this;
            var caret = self2.caretPos;
            var output2;
            input = input || self2.inputValue();
            if (!self2.canCreate(input)) {
              callback2();
              return false;
            }
            self2.lock();
            var created = false;
            var create = (data) => {
              self2.unlock();
              if (!data || typeof data !== "object") return callback2();
              var value = hash_key(data[self2.settings.valueField]);
              if (typeof value !== "string") {
                return callback2();
              }
              self2.setTextboxValue();
              self2.addOption(data, true);
              self2.setCaret(caret);
              self2.addItem(value);
              callback2(data);
              created = true;
            };
            if (typeof self2.settings.create === "function") {
              output2 = self2.settings.create.call(this, input, create);
            } else {
              output2 = {
                [self2.settings.labelField]: input,
                [self2.settings.valueField]: input
              };
            }
            if (!created) {
              create(output2);
            }
            return true;
          }
          /**
           * Re-renders the selected item lists.
           */
          refreshItems() {
            var self2 = this;
            self2.lastQuery = null;
            if (self2.isSetup) {
              self2.addItems(self2.items);
            }
            self2.updateOriginalInput();
            self2.refreshState();
          }
          /**
           * Updates all state-dependent attributes
           * and CSS classes.
           */
          refreshState() {
            const self2 = this;
            self2.refreshValidityState();
            const isFull = self2.isFull();
            const isLocked = self2.isLocked;
            self2.wrapper.classList.toggle("rtl", self2.rtl);
            const wrap_classList = self2.wrapper.classList;
            wrap_classList.toggle("focus", self2.isFocused);
            wrap_classList.toggle("disabled", self2.isDisabled);
            wrap_classList.toggle("readonly", self2.isReadOnly);
            wrap_classList.toggle("required", self2.isRequired);
            wrap_classList.toggle("invalid", !self2.isValid);
            wrap_classList.toggle("locked", isLocked);
            wrap_classList.toggle("full", isFull);
            wrap_classList.toggle("input-active", self2.isFocused && !self2.isInputHidden);
            wrap_classList.toggle("dropdown-active", self2.isOpen);
            wrap_classList.toggle("has-options", isEmptyObject(self2.options));
            wrap_classList.toggle("has-items", self2.items.length > 0);
          }
          /**
           * Update the `required` attribute of both input and control input.
           *
           * The `required` property needs to be activated on the control input
           * for the error to be displayed at the right place. `required` also
           * needs to be temporarily deactivated on the input since the input is
           * hidden and can't show errors.
           */
          refreshValidityState() {
            var self2 = this;
            if (!self2.input.validity) {
              return;
            }
            self2.isValid = self2.input.validity.valid;
            self2.isInvalid = !self2.isValid;
          }
          /**
           * Determines whether or not more items can be added
           * to the control without exceeding the user-defined maximum.
           *
           * @returns {boolean}
           */
          isFull() {
            return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
          }
          /**
           * Refreshes the original <select> or <input>
           * element to reflect the current state.
           *
           */
          updateOriginalInput(opts = {}) {
            const self2 = this;
            var option, label;
            const empty_option = self2.input.querySelector('option[value=""]');
            if (self2.is_select_tag) {
              let AddSelected = function(option_el, value, label2) {
                if (!option_el) {
                  option_el = getDom('<option value="' + escape_html(value) + '">' + escape_html(label2) + "</option>");
                }
                if (option_el != empty_option) {
                  self2.input.append(option_el);
                }
                selected.push(option_el);
                if (option_el != empty_option || has_selected > 0) {
                  option_el.selected = true;
                }
                return option_el;
              };
              const selected = [];
              const has_selected = self2.input.querySelectorAll("option:checked").length;
              self2.input.querySelectorAll("option:checked").forEach((option_el) => {
                option_el.selected = false;
              });
              if (self2.items.length == 0 && self2.settings.mode == "single") {
                AddSelected(empty_option, "", "");
              } else {
                self2.items.forEach((value) => {
                  option = self2.options[value];
                  label = option[self2.settings.labelField] || "";
                  if (selected.includes(option.$option)) {
                    const reuse_opt = self2.input.querySelector(`option[value="${addSlashes(value)}"]:not(:checked)`);
                    AddSelected(reuse_opt, value, label);
                  } else {
                    option.$option = AddSelected(option.$option, value, label);
                  }
                });
              }
            } else {
              self2.input.value = self2.getValue();
            }
            if (self2.isSetup) {
              if (!opts.silent) {
                self2.trigger("change", self2.getValue());
              }
            }
          }
          /**
           * Shows the autocomplete dropdown containing
           * the available options.
           */
          open() {
            var self2 = this;
            if (self2.isLocked || self2.isOpen || self2.settings.mode === "multi" && self2.isFull()) return;
            self2.isOpen = true;
            setAttr(self2.focus_node, {
              "aria-expanded": "true"
            });
            self2.refreshState();
            applyCSS(self2.dropdown, {
              visibility: "hidden",
              display: "block"
            });
            self2.positionDropdown();
            applyCSS(self2.dropdown, {
              visibility: "visible",
              display: "block"
            });
            self2.focus();
            self2.trigger("dropdown_open", self2.dropdown);
          }
          /**
           * Closes the autocomplete dropdown menu.
           */
          close(setTextboxValue = true) {
            var self2 = this;
            var trigger = self2.isOpen;
            if (setTextboxValue) {
              self2.setTextboxValue();
              if (self2.settings.mode === "single" && self2.items.length) {
                self2.inputState();
              }
            }
            self2.isOpen = false;
            setAttr(self2.focus_node, {
              "aria-expanded": "false"
            });
            applyCSS(self2.dropdown, {
              display: "none"
            });
            if (self2.settings.hideSelected) {
              self2.clearActiveOption();
            }
            self2.refreshState();
            if (trigger) self2.trigger("dropdown_close", self2.dropdown);
          }
          /**
           * Calculates and applies the appropriate
           * position of the dropdown if dropdownParent = 'body'.
           * Otherwise, position is determined by css
           */
          positionDropdown() {
            if (this.settings.dropdownParent !== "body") {
              return;
            }
            var context2 = this.control;
            var rect = context2.getBoundingClientRect();
            var top2 = context2.offsetHeight + rect.top + window.scrollY;
            var left2 = rect.left + window.scrollX;
            applyCSS(this.dropdown, {
              width: rect.width + "px",
              top: top2 + "px",
              left: left2 + "px"
            });
          }
          /**
           * Resets / clears all selected items
           * from the control.
           *
           */
          clear(silent) {
            var self2 = this;
            if (!self2.items.length) return;
            var items = self2.controlChildren();
            iterate$1(items, (item) => {
              self2.removeItem(item, true);
            });
            self2.inputState();
            if (!silent) self2.updateOriginalInput();
            self2.trigger("clear");
          }
          /**
           * A helper method for inserting an element
           * at the current caret position.
           *
           */
          insertAtCaret(el) {
            const self2 = this;
            const caret = self2.caretPos;
            const target = self2.control;
            target.insertBefore(el, target.children[caret] || null);
            self2.setCaret(caret + 1);
          }
          /**
           * Removes the current selected item(s).
           *
           */
          deleteSelection(e2) {
            var direction, selection, caret, tail;
            var self2 = this;
            direction = e2 && e2.keyCode === KEY_BACKSPACE ? -1 : 1;
            selection = getSelection2(self2.control_input);
            const rm_items = [];
            if (self2.activeItems.length) {
              tail = getTail(self2.activeItems, direction);
              caret = nodeIndex(tail);
              if (direction > 0) {
                caret++;
              }
              iterate$1(self2.activeItems, (item) => rm_items.push(item));
            } else if ((self2.isFocused || self2.settings.mode === "single") && self2.items.length) {
              const items = self2.controlChildren();
              let rm_item;
              if (direction < 0 && selection.start === 0 && selection.length === 0) {
                rm_item = items[self2.caretPos - 1];
              } else if (direction > 0 && selection.start === self2.inputValue().length) {
                rm_item = items[self2.caretPos];
              }
              if (rm_item !== void 0) {
                rm_items.push(rm_item);
              }
            }
            if (!self2.shouldDelete(rm_items, e2)) {
              return false;
            }
            preventDefault(e2, true);
            if (typeof caret !== "undefined") {
              self2.setCaret(caret);
            }
            while (rm_items.length) {
              self2.removeItem(rm_items.pop());
            }
            self2.inputState();
            self2.positionDropdown();
            self2.refreshOptions(false);
            return true;
          }
          /**
           * Return true if the items should be deleted
           */
          shouldDelete(items, evt) {
            const values = items.map((item) => item.dataset.value);
            if (!values.length || typeof this.settings.onDelete === "function" && this.settings.onDelete(values, evt) === false) {
              return false;
            }
            return true;
          }
          /**
           * Selects the previous / next item (depending on the `direction` argument).
           *
           * > 0 - right
           * < 0 - left
           *
           */
          advanceSelection(direction, e2) {
            var last_active, adjacent, self2 = this;
            if (self2.rtl) direction *= -1;
            if (self2.inputValue().length) return;
            if (isKeyDown(KEY_SHORTCUT, e2) || isKeyDown("shiftKey", e2)) {
              last_active = self2.getLastActive(direction);
              if (last_active) {
                if (!last_active.classList.contains("active")) {
                  adjacent = last_active;
                } else {
                  adjacent = self2.getAdjacent(last_active, direction, "item");
                }
              } else if (direction > 0) {
                adjacent = self2.control_input.nextElementSibling;
              } else {
                adjacent = self2.control_input.previousElementSibling;
              }
              if (adjacent) {
                if (adjacent.classList.contains("active")) {
                  self2.removeActiveItem(last_active);
                }
                self2.setActiveItemClass(adjacent);
              }
            } else {
              self2.moveCaret(direction);
            }
          }
          moveCaret(direction) {
          }
          /**
           * Get the last active item
           *
           */
          getLastActive(direction) {
            let last_active = this.control.querySelector(".last-active");
            if (last_active) {
              return last_active;
            }
            var result = this.control.querySelectorAll(".active");
            if (result) {
              return getTail(result, direction);
            }
          }
          /**
           * Moves the caret to the specified index.
           *
           * The input must be moved by leaving it in place and moving the
           * siblings, due to the fact that focus cannot be restored once lost
           * on mobile webkit devices
           *
           */
          setCaret(new_pos) {
            this.caretPos = this.items.length;
          }
          /**
           * Return list of item dom elements
           *
           */
          controlChildren() {
            return Array.from(this.control.querySelectorAll("[data-ts-item]"));
          }
          /**
           * Disables user input on the control. Used while
           * items are being asynchronously created.
           */
          lock() {
            this.setLocked(true);
          }
          /**
           * Re-enables user input on the control.
           */
          unlock() {
            this.setLocked(false);
          }
          /**
           * Disable or enable user input on the control
           */
          setLocked(lock = this.isReadOnly || this.isDisabled) {
            this.isLocked = lock;
            this.refreshState();
          }
          /**
           * Disables user input on the control completely.
           * While disabled, it cannot receive focus.
           */
          disable() {
            this.setDisabled(true);
            this.close();
          }
          /**
           * Enables the control so that it can respond
           * to focus and user input.
           */
          enable() {
            this.setDisabled(false);
          }
          setDisabled(disabled) {
            this.focus_node.tabIndex = disabled ? -1 : this.tabIndex;
            this.isDisabled = disabled;
            this.input.disabled = disabled;
            this.control_input.disabled = disabled;
            this.setLocked();
          }
          setReadOnly(isReadOnly) {
            this.isReadOnly = isReadOnly;
            this.input.readOnly = isReadOnly;
            this.control_input.readOnly = isReadOnly;
            this.setLocked();
          }
          /**
           * Completely destroys the control and
           * unbinds all event listeners so that it can
           * be garbage collected.
           */
          destroy() {
            var self2 = this;
            var revertSettings = self2.revertSettings;
            self2.trigger("destroy");
            self2.off();
            self2.wrapper.remove();
            self2.dropdown.remove();
            self2.input.innerHTML = revertSettings.innerHTML;
            self2.input.tabIndex = revertSettings.tabIndex;
            removeClasses(self2.input, "tomselected", "ts-hidden-accessible");
            self2._destroy();
            delete self2.input.tomselect;
          }
          /**
           * A helper method for rendering "item" and
           * "option" templates, given the data.
           *
           */
          render(templateName, data) {
            var id, html;
            const self2 = this;
            if (typeof this.settings.render[templateName] !== "function") {
              return null;
            }
            html = self2.settings.render[templateName].call(this, data, escape_html);
            if (!html) {
              return null;
            }
            html = getDom(html);
            if (templateName === "option" || templateName === "option_create") {
              if (data[self2.settings.disabledField]) {
                setAttr(html, {
                  "aria-disabled": "true"
                });
              } else {
                setAttr(html, {
                  "data-selectable": ""
                });
              }
            } else if (templateName === "optgroup") {
              id = data.group[self2.settings.optgroupValueField];
              setAttr(html, {
                "data-group": id
              });
              if (data.group[self2.settings.disabledField]) {
                setAttr(html, {
                  "data-disabled": ""
                });
              }
            }
            if (templateName === "option" || templateName === "item") {
              const value = get_hash(data[self2.settings.valueField]);
              setAttr(html, {
                "data-value": value
              });
              if (templateName === "item") {
                addClasses(html, self2.settings.itemClass);
                setAttr(html, {
                  "data-ts-item": ""
                });
              } else {
                addClasses(html, self2.settings.optionClass);
                setAttr(html, {
                  role: "option",
                  id: data.$id
                });
                data.$div = html;
                self2.options[value] = data;
              }
            }
            return html;
          }
          /**
           * Type guarded rendering
           *
           */
          _render(templateName, data) {
            const html = this.render(templateName, data);
            if (html == null) {
              throw "HTMLElement expected";
            }
            return html;
          }
          /**
           * Clears the render cache for a template. If
           * no template is given, clears all render
           * caches.
           *
           */
          clearCache() {
            iterate$1(this.options, (option) => {
              if (option.$div) {
                option.$div.remove();
                delete option.$div;
              }
            });
          }
          /**
           * Removes a value from item and option caches
           *
           */
          uncacheValue(value) {
            const option_el = this.getOption(value);
            if (option_el) option_el.remove();
          }
          /**
           * Determines whether or not to display the
           * create item prompt, given a user input.
           *
           */
          canCreate(input) {
            return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
          }
          /**
           * Wraps this.`method` so that `new_fn` can be invoked 'before', 'after', or 'instead' of the original method
           *
           * this.hook('instead','onKeyDown',function( arg1, arg2 ...){
           *
           * });
           */
          hook(when, method, new_fn) {
            var self2 = this;
            var orig_method = self2[method];
            self2[method] = function() {
              var result, result_new;
              if (when === "after") {
                result = orig_method.apply(self2, arguments);
              }
              result_new = new_fn.apply(self2, arguments);
              if (when === "instead") {
                return result_new;
              }
              if (when === "before") {
                result = orig_method.apply(self2, arguments);
              }
              return result;
            };
          }
        }
        function change_listener() {
          addEvent(this.input, "change", () => {
            this.sync();
          });
        }
        function checkbox_options(userOptions) {
          var self2 = this;
          var orig_onOptionSelect = self2.onOptionSelect;
          self2.settings.hideSelected = false;
          const cbOptions = Object.assign({
            // so that the user may add different ones as well
            className: "tomselect-checkbox",
            // the following default to the historic plugin's values
            checkedClassNames: void 0,
            uncheckedClassNames: void 0
          }, userOptions);
          var UpdateChecked = function UpdateChecked2(checkbox, toCheck) {
            if (toCheck) {
              checkbox.checked = true;
              if (cbOptions.uncheckedClassNames) {
                checkbox.classList.remove(...cbOptions.uncheckedClassNames);
              }
              if (cbOptions.checkedClassNames) {
                checkbox.classList.add(...cbOptions.checkedClassNames);
              }
            } else {
              checkbox.checked = false;
              if (cbOptions.checkedClassNames) {
                checkbox.classList.remove(...cbOptions.checkedClassNames);
              }
              if (cbOptions.uncheckedClassNames) {
                checkbox.classList.add(...cbOptions.uncheckedClassNames);
              }
            }
          };
          var UpdateCheckbox = function UpdateCheckbox2(option) {
            setTimeout(() => {
              var checkbox = option.querySelector("input." + cbOptions.className);
              if (checkbox instanceof HTMLInputElement) {
                UpdateChecked(checkbox, option.classList.contains("selected"));
              }
            }, 1);
          };
          self2.hook("after", "setupTemplates", () => {
            var orig_render_option = self2.settings.render.option;
            self2.settings.render.option = (data, escape_html2) => {
              var rendered = getDom(orig_render_option.call(self2, data, escape_html2));
              var checkbox = document.createElement("input");
              if (cbOptions.className) {
                checkbox.classList.add(cbOptions.className);
              }
              checkbox.addEventListener("click", function(evt) {
                preventDefault(evt);
              });
              checkbox.type = "checkbox";
              const hashed = hash_key(data[self2.settings.valueField]);
              UpdateChecked(checkbox, !!(hashed && self2.items.indexOf(hashed) > -1));
              rendered.prepend(checkbox);
              return rendered;
            };
          });
          self2.on("item_remove", (value) => {
            var option = self2.getOption(value);
            if (option) {
              option.classList.remove("selected");
              UpdateCheckbox(option);
            }
          });
          self2.on("item_add", (value) => {
            var option = self2.getOption(value);
            if (option) {
              UpdateCheckbox(option);
            }
          });
          self2.hook("instead", "onOptionSelect", (evt, option) => {
            if (option.classList.contains("selected")) {
              option.classList.remove("selected");
              self2.removeItem(option.dataset.value);
              self2.refreshOptions();
              preventDefault(evt, true);
              return;
            }
            orig_onOptionSelect.call(self2, evt, option);
            UpdateCheckbox(option);
          });
        }
        function clear_button(userOptions) {
          const self2 = this;
          const options = Object.assign({
            className: "clear-button",
            title: "Clear All",
            html: (data) => {
              return `<div class="${data.className}" title="${data.title}">&#10799;</div>`;
            }
          }, userOptions);
          self2.on("initialize", () => {
            var button = getDom(options.html(options));
            button.addEventListener("click", (evt) => {
              if (self2.isLocked) return;
              self2.clear();
              if (self2.settings.mode === "single" && self2.settings.allowEmptyOption) {
                self2.addItem("");
              }
              evt.preventDefault();
              evt.stopPropagation();
            });
            self2.control.appendChild(button);
          });
        }
        const insertAfter = (referenceNode, newNode) => {
          var _referenceNode$parent;
          (_referenceNode$parent = referenceNode.parentNode) == null || _referenceNode$parent.insertBefore(newNode, referenceNode.nextSibling);
        };
        const insertBefore = (referenceNode, newNode) => {
          var _referenceNode$parent2;
          (_referenceNode$parent2 = referenceNode.parentNode) == null || _referenceNode$parent2.insertBefore(newNode, referenceNode);
        };
        const isBefore = (referenceNode, newNode) => {
          do {
            var _newNode;
            newNode = (_newNode = newNode) == null ? void 0 : _newNode.previousElementSibling;
            if (referenceNode == newNode) {
              return true;
            }
          } while (newNode && newNode.previousElementSibling);
          return false;
        };
        function drag_drop() {
          var self2 = this;
          if (self2.settings.mode !== "multi") return;
          var orig_lock = self2.lock;
          var orig_unlock = self2.unlock;
          let sortable = true;
          let drag_item;
          self2.hook("after", "setupTemplates", () => {
            var orig_render_item = self2.settings.render.item;
            self2.settings.render.item = (data, escape3) => {
              const item = getDom(orig_render_item.call(self2, data, escape3));
              setAttr(item, {
                "draggable": "true"
              });
              const mousedown = (evt) => {
                if (!sortable) preventDefault(evt);
                evt.stopPropagation();
              };
              const dragStart = (evt) => {
                drag_item = item;
                setTimeout(() => {
                  item.classList.add("ts-dragging");
                }, 0);
              };
              const dragOver = (evt) => {
                evt.preventDefault();
                item.classList.add("ts-drag-over");
                moveitem(item, drag_item);
              };
              const dragLeave = () => {
                item.classList.remove("ts-drag-over");
              };
              const moveitem = (targetitem, dragitem) => {
                if (dragitem === void 0) return;
                if (isBefore(dragitem, item)) {
                  insertAfter(targetitem, dragitem);
                } else {
                  insertBefore(targetitem, dragitem);
                }
              };
              const dragend = () => {
                var _drag_item;
                document.querySelectorAll(".ts-drag-over").forEach((el) => el.classList.remove("ts-drag-over"));
                (_drag_item = drag_item) == null || _drag_item.classList.remove("ts-dragging");
                drag_item = void 0;
                var values = [];
                self2.control.querySelectorAll(`[data-value]`).forEach((el) => {
                  if (el.dataset.value) {
                    let value = el.dataset.value;
                    if (value) {
                      values.push(value);
                    }
                  }
                });
                self2.setValue(values);
              };
              addEvent(item, "mousedown", mousedown);
              addEvent(item, "dragstart", dragStart);
              addEvent(item, "dragenter", dragOver);
              addEvent(item, "dragover", dragOver);
              addEvent(item, "dragleave", dragLeave);
              addEvent(item, "dragend", dragend);
              return item;
            };
          });
          self2.hook("instead", "lock", () => {
            sortable = false;
            return orig_lock.call(self2);
          });
          self2.hook("instead", "unlock", () => {
            sortable = true;
            return orig_unlock.call(self2);
          });
        }
        function dropdown_header(userOptions) {
          const self2 = this;
          const options = Object.assign({
            title: "Untitled",
            headerClass: "dropdown-header",
            titleRowClass: "dropdown-header-title",
            labelClass: "dropdown-header-label",
            closeClass: "dropdown-header-close",
            html: (data) => {
              return '<div class="' + data.headerClass + '"><div class="' + data.titleRowClass + '"><span class="' + data.labelClass + '">' + data.title + '</span><a class="' + data.closeClass + '">&times;</a></div></div>';
            }
          }, userOptions);
          self2.on("initialize", () => {
            var header = getDom(options.html(options));
            var close_link = header.querySelector("." + options.closeClass);
            if (close_link) {
              close_link.addEventListener("click", (evt) => {
                preventDefault(evt, true);
                self2.close();
              });
            }
            self2.dropdown.insertBefore(header, self2.dropdown.firstChild);
          });
        }
        function caret_position() {
          var self2 = this;
          self2.hook("instead", "setCaret", (new_pos) => {
            if (self2.settings.mode === "single" || !self2.control.contains(self2.control_input)) {
              new_pos = self2.items.length;
            } else {
              new_pos = Math.max(0, Math.min(self2.items.length, new_pos));
              if (new_pos != self2.caretPos && !self2.isPending) {
                self2.controlChildren().forEach((child, j6) => {
                  if (j6 < new_pos) {
                    self2.control_input.insertAdjacentElement("beforebegin", child);
                  } else {
                    self2.control.appendChild(child);
                  }
                });
              }
            }
            self2.caretPos = new_pos;
          });
          self2.hook("instead", "moveCaret", (direction) => {
            if (!self2.isFocused) return;
            const last_active = self2.getLastActive(direction);
            if (last_active) {
              const idx = nodeIndex(last_active);
              self2.setCaret(direction > 0 ? idx + 1 : idx);
              self2.setActiveItem();
              removeClasses(last_active, "last-active");
            } else {
              self2.setCaret(self2.caretPos + direction);
            }
          });
        }
        function dropdown_input() {
          const self2 = this;
          self2.settings.shouldOpen = true;
          self2.hook("before", "setup", () => {
            self2.focus_node = self2.control;
            addClasses(self2.control_input, "dropdown-input");
            const div2 = getDom('<div class="dropdown-input-wrap">');
            div2.append(self2.control_input);
            self2.dropdown.insertBefore(div2, self2.dropdown.firstChild);
            const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
            placeholder.placeholder = self2.settings.placeholder || "";
            self2.control.append(placeholder);
          });
          self2.on("initialize", () => {
            self2.control_input.addEventListener("keydown", (evt) => {
              switch (evt.keyCode) {
                case KEY_ESC:
                  if (self2.isOpen) {
                    preventDefault(evt, true);
                    self2.close();
                  }
                  self2.clearActiveItems();
                  return;
                case KEY_TAB:
                  self2.focus_node.tabIndex = -1;
                  break;
              }
              return self2.onKeyDown.call(self2, evt);
            });
            self2.on("blur", () => {
              self2.focus_node.tabIndex = self2.isDisabled ? -1 : self2.tabIndex;
            });
            self2.on("dropdown_open", () => {
              self2.control_input.focus();
            });
            const orig_onBlur = self2.onBlur;
            self2.hook("instead", "onBlur", (evt) => {
              if (evt && evt.relatedTarget == self2.control_input) return;
              return orig_onBlur.call(self2);
            });
            addEvent(self2.control_input, "blur", () => self2.onBlur());
            self2.hook("before", "close", () => {
              if (!self2.isOpen) return;
              self2.focus_node.focus({
                preventScroll: true
              });
            });
          });
        }
        function input_autogrow() {
          var self2 = this;
          self2.on("initialize", () => {
            var test_input = document.createElement("span");
            var control = self2.control_input;
            test_input.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ";
            self2.wrapper.appendChild(test_input);
            var transfer_styles = ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"];
            for (const style_name of transfer_styles) {
              test_input.style[style_name] = control.style[style_name];
            }
            var resize = () => {
              test_input.textContent = control.value;
              control.style.width = test_input.clientWidth + "px";
            };
            resize();
            self2.on("update item_add item_remove", resize);
            addEvent(control, "input", resize);
            addEvent(control, "keyup", resize);
            addEvent(control, "blur", resize);
            addEvent(control, "update", resize);
          });
        }
        function no_backspace_delete() {
          var self2 = this;
          var orig_deleteSelection = self2.deleteSelection;
          this.hook("instead", "deleteSelection", (evt) => {
            if (self2.activeItems.length) {
              return orig_deleteSelection.call(self2, evt);
            }
            return false;
          });
        }
        function no_active_items() {
          this.hook("instead", "setActiveItem", () => {
          });
          this.hook("instead", "selectAll", () => {
          });
        }
        function optgroup_columns() {
          var self2 = this;
          var orig_keydown = self2.onKeyDown;
          self2.hook("instead", "onKeyDown", (evt) => {
            var index2, option, options, optgroup;
            if (!self2.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
              return orig_keydown.call(self2, evt);
            }
            self2.ignoreHover = true;
            optgroup = parentMatch(self2.activeOption, "[data-group]");
            index2 = nodeIndex(self2.activeOption, "[data-selectable]");
            if (!optgroup) {
              return;
            }
            if (evt.keyCode === KEY_LEFT) {
              optgroup = optgroup.previousSibling;
            } else {
              optgroup = optgroup.nextSibling;
            }
            if (!optgroup) {
              return;
            }
            options = optgroup.querySelectorAll("[data-selectable]");
            option = options[Math.min(options.length - 1, index2)];
            if (option) {
              self2.setActiveOption(option);
            }
          });
        }
        function remove_button(userOptions) {
          const options = Object.assign({
            label: "&times;",
            title: "Remove",
            className: "remove",
            append: true
          }, userOptions);
          var self2 = this;
          if (!options.append) {
            return;
          }
          var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
          self2.hook("after", "setupTemplates", () => {
            var orig_render_item = self2.settings.render.item;
            self2.settings.render.item = (data, escape3) => {
              var item = getDom(orig_render_item.call(self2, data, escape3));
              var close_button = getDom(html);
              item.appendChild(close_button);
              addEvent(close_button, "mousedown", (evt) => {
                preventDefault(evt, true);
              });
              addEvent(close_button, "click", (evt) => {
                if (self2.isLocked) return;
                preventDefault(evt, true);
                if (self2.isLocked) return;
                if (!self2.shouldDelete([item], evt)) return;
                self2.removeItem(item);
                self2.refreshOptions(false);
                self2.inputState();
              });
              return item;
            };
          });
        }
        function restore_on_backspace(userOptions) {
          const self2 = this;
          const options = Object.assign({
            text: (option) => {
              return option[self2.settings.labelField];
            }
          }, userOptions);
          self2.on("item_remove", function(value) {
            if (!self2.isFocused) {
              return;
            }
            if (self2.control_input.value.trim() === "") {
              var option = self2.options[value];
              if (option) {
                self2.setTextboxValue(options.text.call(self2, option));
              }
            }
          });
        }
        function virtual_scroll() {
          const self2 = this;
          const orig_canLoad = self2.canLoad;
          const orig_clearActiveOption = self2.clearActiveOption;
          const orig_loadCallback = self2.loadCallback;
          var pagination = {};
          var dropdown_content;
          var loading_more = false;
          var load_more_opt;
          var default_values = [];
          if (!self2.settings.shouldLoadMore) {
            self2.settings.shouldLoadMore = () => {
              const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
              if (scroll_percent > 0.9) {
                return true;
              }
              if (self2.activeOption) {
                var selectable = self2.selectable();
                var index2 = Array.from(selectable).indexOf(self2.activeOption);
                if (index2 >= selectable.length - 2) {
                  return true;
                }
              }
              return false;
            };
          }
          if (!self2.settings.firstUrl) {
            throw "virtual_scroll plugin requires a firstUrl() method";
          }
          self2.settings.sortField = [{
            field: "$order"
          }, {
            field: "$score"
          }];
          const canLoadMore = (query) => {
            if (typeof self2.settings.maxOptions === "number" && dropdown_content.children.length >= self2.settings.maxOptions) {
              return false;
            }
            if (query in pagination && pagination[query]) {
              return true;
            }
            return false;
          };
          const clearFilter = (option, value) => {
            if (self2.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
              return true;
            }
            return false;
          };
          self2.setNextUrl = (value, next_url) => {
            pagination[value] = next_url;
          };
          self2.getUrl = (query) => {
            if (query in pagination) {
              const next_url = pagination[query];
              pagination[query] = false;
              return next_url;
            }
            self2.clearPagination();
            return self2.settings.firstUrl.call(self2, query);
          };
          self2.clearPagination = () => {
            pagination = {};
          };
          self2.hook("instead", "clearActiveOption", () => {
            if (loading_more) {
              return;
            }
            return orig_clearActiveOption.call(self2);
          });
          self2.hook("instead", "canLoad", (query) => {
            if (!(query in pagination)) {
              return orig_canLoad.call(self2, query);
            }
            return canLoadMore(query);
          });
          self2.hook("instead", "loadCallback", (options, optgroups) => {
            if (!loading_more) {
              self2.clearOptions(clearFilter);
            } else if (load_more_opt) {
              const first_option = options[0];
              if (first_option !== void 0) {
                load_more_opt.dataset.value = first_option[self2.settings.valueField];
              }
            }
            orig_loadCallback.call(self2, options, optgroups);
            loading_more = false;
          });
          self2.hook("after", "refreshOptions", () => {
            const query = self2.lastValue;
            var option;
            if (canLoadMore(query)) {
              option = self2.render("loading_more", {
                query
              });
              if (option) {
                option.setAttribute("data-selectable", "");
                load_more_opt = option;
              }
            } else if (query in pagination && !dropdown_content.querySelector(".no-results")) {
              option = self2.render("no_more_results", {
                query
              });
            }
            if (option) {
              addClasses(option, self2.settings.optionClass);
              dropdown_content.append(option);
            }
          });
          self2.on("initialize", () => {
            default_values = Object.keys(self2.options);
            dropdown_content = self2.dropdown_content;
            self2.settings.render = Object.assign({}, {
              loading_more: () => {
                return `<div class="loading-more-results">Loading more results ... </div>`;
              },
              no_more_results: () => {
                return `<div class="no-more-results">No more results</div>`;
              }
            }, self2.settings.render);
            dropdown_content.addEventListener("scroll", () => {
              if (!self2.settings.shouldLoadMore.call(self2)) {
                return;
              }
              if (!canLoadMore(self2.lastValue)) {
                return;
              }
              if (loading_more) return;
              loading_more = true;
              self2.load.call(self2, self2.lastValue);
            });
          });
        }
        TomSelect3.define("change_listener", change_listener);
        TomSelect3.define("checkbox_options", checkbox_options);
        TomSelect3.define("clear_button", clear_button);
        TomSelect3.define("drag_drop", drag_drop);
        TomSelect3.define("dropdown_header", dropdown_header);
        TomSelect3.define("caret_position", caret_position);
        TomSelect3.define("dropdown_input", dropdown_input);
        TomSelect3.define("input_autogrow", input_autogrow);
        TomSelect3.define("no_backspace_delete", no_backspace_delete);
        TomSelect3.define("no_active_items", no_active_items);
        TomSelect3.define("optgroup_columns", optgroup_columns);
        TomSelect3.define("remove_button", remove_button);
        TomSelect3.define("restore_on_backspace", restore_on_backspace);
        TomSelect3.define("virtual_scroll", virtual_scroll);
        return TomSelect3;
      });
    }
  });

  // node_modules/tributejs/dist/tribute.min.js
  var require_tribute_min = __commonJS({
    "node_modules/tributejs/dist/tribute.min.js"(exports, module2) {
      init_define_process();
      init_jquery();
      !function(e2, t4) {
        "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t4() : "function" == typeof define && define.amd ? define(t4) : (e2 = e2 || self).Tribute = t4();
      }(exports, function() {
        "use strict";
        function e2(e3, t5) {
          if (!(e3 instanceof t5)) throw new TypeError("Cannot call a class as a function");
        }
        function t4(e3, t5) {
          for (var n4 = 0; n4 < t5.length; n4++) {
            var i4 = t5[n4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e3, i4.key, i4);
          }
        }
        function n3(e3, n4, i4) {
          return n4 && t4(e3.prototype, n4), i4 && t4(e3, i4), e3;
        }
        function i3(e3, t5) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || function(e4, t6) {
            if (!(Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4))) return;
            var n4 = [], i4 = true, r4 = false, o4 = void 0;
            try {
              for (var u6, l6 = e4[Symbol.iterator](); !(i4 = (u6 = l6.next()).done) && (n4.push(u6.value), !t6 || n4.length !== t6); i4 = true) ;
            } catch (e5) {
              r4 = true, o4 = e5;
            } finally {
              try {
                i4 || null == l6.return || l6.return();
              } finally {
                if (r4) throw o4;
              }
            }
            return n4;
          }(e3, t5) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        if (Array.prototype.find || (Array.prototype.find = function(e3) {
          if (null === this) throw new TypeError("Array.prototype.find called on null or undefined");
          if ("function" != typeof e3) throw new TypeError("predicate must be a function");
          for (var t5, n4 = Object(this), i4 = n4.length >>> 0, r4 = arguments[1], o4 = 0; o4 < i4; o4++) if (t5 = n4[o4], e3.call(r4, t5, o4, n4)) return t5;
        }), window && "function" != typeof window.CustomEvent) {
          var r3 = function(e3, t5) {
            t5 = t5 || { bubbles: false, cancelable: false, detail: void 0 };
            var n4 = document.createEvent("CustomEvent");
            return n4.initCustomEvent(e3, t5.bubbles, t5.cancelable, t5.detail), n4;
          };
          void 0 !== window.Event && (r3.prototype = window.Event.prototype), window.CustomEvent = r3;
        }
        var o3 = function() {
          function t5(n4) {
            e2(this, t5), this.tribute = n4, this.tribute.events = this;
          }
          return n3(t5, [{ key: "bind", value: function(e3) {
            e3.boundKeydown = this.keydown.bind(e3, this), e3.boundKeyup = this.keyup.bind(e3, this), e3.boundInput = this.input.bind(e3, this), e3.addEventListener("keydown", e3.boundKeydown, false), e3.addEventListener("keyup", e3.boundKeyup, false), e3.addEventListener("input", e3.boundInput, false);
          } }, { key: "unbind", value: function(e3) {
            e3.removeEventListener("keydown", e3.boundKeydown, false), e3.removeEventListener("keyup", e3.boundKeyup, false), e3.removeEventListener("input", e3.boundInput, false), delete e3.boundKeydown, delete e3.boundKeyup, delete e3.boundInput;
          } }, { key: "keydown", value: function(e3, n4) {
            e3.shouldDeactivate(n4) && (e3.tribute.isActive = false, e3.tribute.hideMenu());
            var i4 = this;
            e3.commandEvent = false, t5.keys().forEach(function(t6) {
              t6.key === n4.keyCode && (e3.commandEvent = true, e3.callbacks()[t6.value.toLowerCase()](n4, i4));
            });
          } }, { key: "input", value: function(e3, t6) {
            e3.inputEvent = true, e3.keyup.call(this, e3, t6);
          } }, { key: "click", value: function(e3, t6) {
            var n4 = e3.tribute;
            if (n4.menu && n4.menu.contains(t6.target)) {
              var i4 = t6.target;
              for (t6.preventDefault(), t6.stopPropagation(); "li" !== i4.nodeName.toLowerCase(); ) if (!(i4 = i4.parentNode) || i4 === n4.menu) throw new Error("cannot find the <li> container for the click");
              n4.selectItemAtIndex(i4.getAttribute("data-index"), t6), n4.hideMenu();
            } else n4.current.element && !n4.current.externalTrigger && (n4.current.externalTrigger = false, setTimeout(function() {
              return n4.hideMenu();
            }));
          } }, { key: "keyup", value: function(e3, t6) {
            if (e3.inputEvent && (e3.inputEvent = false), e3.updateSelection(this), 27 !== t6.keyCode) {
              if (!e3.tribute.allowSpaces && e3.tribute.hasTrailingSpace) return e3.tribute.hasTrailingSpace = false, e3.commandEvent = true, void e3.callbacks().space(t6, this);
              if (!e3.tribute.isActive) if (e3.tribute.autocompleteMode) e3.callbacks().triggerChar(t6, this, "");
              else {
                var n4 = e3.getKeyCode(e3, this, t6);
                if (isNaN(n4) || !n4) return;
                var i4 = e3.tribute.triggers().find(function(e4) {
                  return e4.charCodeAt(0) === n4;
                });
                void 0 !== i4 && e3.callbacks().triggerChar(t6, this, i4);
              }
              e3.tribute.current.mentionText.length < e3.tribute.current.collection.menuShowMinLength || ((e3.tribute.current.trigger || e3.tribute.autocompleteMode) && false === e3.commandEvent || e3.tribute.isActive && 8 === t6.keyCode) && e3.tribute.showMenuFor(this, true);
            }
          } }, { key: "shouldDeactivate", value: function(e3) {
            if (!this.tribute.isActive) return false;
            if (0 === this.tribute.current.mentionText.length) {
              var n4 = false;
              return t5.keys().forEach(function(t6) {
                e3.keyCode === t6.key && (n4 = true);
              }), !n4;
            }
            return false;
          } }, { key: "getKeyCode", value: function(e3, t6, n4) {
            var i4 = e3.tribute, r4 = i4.range.getTriggerInfo(false, i4.hasTrailingSpace, true, i4.allowSpaces, i4.autocompleteMode);
            return !!r4 && r4.mentionTriggerChar.charCodeAt(0);
          } }, { key: "updateSelection", value: function(e3) {
            this.tribute.current.element = e3;
            var t6 = this.tribute.range.getTriggerInfo(false, this.tribute.hasTrailingSpace, true, this.tribute.allowSpaces, this.tribute.autocompleteMode);
            t6 && (this.tribute.current.selectedPath = t6.mentionSelectedPath, this.tribute.current.mentionText = t6.mentionText, this.tribute.current.selectedOffset = t6.mentionSelectedOffset);
          } }, { key: "callbacks", value: function() {
            var e3 = this;
            return { triggerChar: function(t6, n4, i4) {
              var r4 = e3.tribute;
              r4.current.trigger = i4;
              var o4 = r4.collection.find(function(e4) {
                return e4.trigger === i4;
              });
              r4.current.collection = o4, r4.current.mentionText.length >= r4.current.collection.menuShowMinLength && r4.inputEvent && r4.showMenuFor(n4, true);
            }, enter: function(t6, n4) {
              e3.tribute.isActive && e3.tribute.current.filteredItems && (t6.preventDefault(), t6.stopPropagation(), setTimeout(function() {
                e3.tribute.selectItemAtIndex(e3.tribute.menuSelected, t6), e3.tribute.hideMenu();
              }, 0));
            }, escape: function(t6, n4) {
              e3.tribute.isActive && (t6.preventDefault(), t6.stopPropagation(), e3.tribute.isActive = false, e3.tribute.hideMenu());
            }, tab: function(t6, n4) {
              e3.callbacks().enter(t6, n4);
            }, space: function(t6, n4) {
              e3.tribute.isActive && (e3.tribute.spaceSelectsMatch ? e3.callbacks().enter(t6, n4) : e3.tribute.allowSpaces || (t6.stopPropagation(), setTimeout(function() {
                e3.tribute.hideMenu(), e3.tribute.isActive = false;
              }, 0)));
            }, up: function(t6, n4) {
              if (e3.tribute.isActive && e3.tribute.current.filteredItems) {
                t6.preventDefault(), t6.stopPropagation();
                var i4 = e3.tribute.current.filteredItems.length, r4 = e3.tribute.menuSelected;
                i4 > r4 && r4 > 0 ? (e3.tribute.menuSelected--, e3.setActiveLi()) : 0 === r4 && (e3.tribute.menuSelected = i4 - 1, e3.setActiveLi(), e3.tribute.menu.scrollTop = e3.tribute.menu.scrollHeight);
              }
            }, down: function(t6, n4) {
              if (e3.tribute.isActive && e3.tribute.current.filteredItems) {
                t6.preventDefault(), t6.stopPropagation();
                var i4 = e3.tribute.current.filteredItems.length - 1, r4 = e3.tribute.menuSelected;
                i4 > r4 ? (e3.tribute.menuSelected++, e3.setActiveLi()) : i4 === r4 && (e3.tribute.menuSelected = 0, e3.setActiveLi(), e3.tribute.menu.scrollTop = 0);
              }
            }, delete: function(t6, n4) {
              e3.tribute.isActive && e3.tribute.current.mentionText.length < 1 ? e3.tribute.hideMenu() : e3.tribute.isActive && e3.tribute.showMenuFor(n4);
            } };
          } }, { key: "setActiveLi", value: function(e3) {
            var t6 = this.tribute.menu.querySelectorAll("li"), n4 = t6.length >>> 0;
            e3 && (this.tribute.menuSelected = parseInt(e3));
            for (var i4 = 0; i4 < n4; i4++) {
              var r4 = t6[i4];
              if (i4 === this.tribute.menuSelected) {
                r4.classList.add(this.tribute.current.collection.selectClass);
                var o4 = r4.getBoundingClientRect(), u6 = this.tribute.menu.getBoundingClientRect();
                if (o4.bottom > u6.bottom) {
                  var l6 = o4.bottom - u6.bottom;
                  this.tribute.menu.scrollTop += l6;
                } else if (o4.top < u6.top) {
                  var s5 = u6.top - o4.top;
                  this.tribute.menu.scrollTop -= s5;
                }
              } else r4.classList.remove(this.tribute.current.collection.selectClass);
            }
          } }, { key: "getFullHeight", value: function(e3, t6) {
            var n4 = e3.getBoundingClientRect().height;
            if (t6) {
              var i4 = e3.currentStyle || window.getComputedStyle(e3);
              return n4 + parseFloat(i4.marginTop) + parseFloat(i4.marginBottom);
            }
            return n4;
          } }], [{ key: "keys", value: function() {
            return [{ key: 9, value: "TAB" }, { key: 8, value: "DELETE" }, { key: 13, value: "ENTER" }, { key: 27, value: "ESCAPE" }, { key: 32, value: "SPACE" }, { key: 38, value: "UP" }, { key: 40, value: "DOWN" }];
          } }]), t5;
        }(), u5 = function() {
          function t5(n4) {
            e2(this, t5), this.tribute = n4, this.tribute.menuEvents = this, this.menu = this.tribute.menu;
          }
          return n3(t5, [{ key: "bind", value: function(e3) {
            var t6 = this;
            this.menuClickEvent = this.tribute.events.click.bind(null, this), this.menuContainerScrollEvent = this.debounce(function() {
              t6.tribute.isActive && t6.tribute.showMenuFor(t6.tribute.current.element, false);
            }, 300, false), this.windowResizeEvent = this.debounce(function() {
              t6.tribute.isActive && t6.tribute.range.positionMenuAtCaret(true);
            }, 300, false), this.tribute.range.getDocument().addEventListener("MSPointerDown", this.menuClickEvent, false), this.tribute.range.getDocument().addEventListener("mousedown", this.menuClickEvent, false), window.addEventListener("resize", this.windowResizeEvent), this.menuContainer ? this.menuContainer.addEventListener("scroll", this.menuContainerScrollEvent, false) : window.addEventListener("scroll", this.menuContainerScrollEvent);
          } }, { key: "unbind", value: function(e3) {
            this.tribute.range.getDocument().removeEventListener("mousedown", this.menuClickEvent, false), this.tribute.range.getDocument().removeEventListener("MSPointerDown", this.menuClickEvent, false), window.removeEventListener("resize", this.windowResizeEvent), this.menuContainer ? this.menuContainer.removeEventListener("scroll", this.menuContainerScrollEvent, false) : window.removeEventListener("scroll", this.menuContainerScrollEvent);
          } }, { key: "debounce", value: function(e3, t6, n4) {
            var i4, r4 = arguments, o4 = this;
            return function() {
              var u6 = o4, l6 = r4, s5 = n4 && !i4;
              clearTimeout(i4), i4 = setTimeout(function() {
                i4 = null, n4 || e3.apply(u6, l6);
              }, t6), s5 && e3.apply(u6, l6);
            };
          } }]), t5;
        }(), l5 = function() {
          function t5(n4) {
            e2(this, t5), this.tribute = n4, this.tribute.range = this;
          }
          return n3(t5, [{ key: "getDocument", value: function() {
            var e3;
            return this.tribute.current.collection && (e3 = this.tribute.current.collection.iframe), e3 ? e3.contentWindow.document : document;
          } }, { key: "positionMenuAtCaret", value: function(e3) {
            var t6, n4 = this, i4 = this.tribute.current, r4 = this.getTriggerInfo(false, this.tribute.hasTrailingSpace, true, this.tribute.allowSpaces, this.tribute.autocompleteMode);
            if (void 0 !== r4) {
              if (!this.tribute.positionMenu) return void (this.tribute.menu.style.cssText = "display: block;");
              t6 = this.isContentEditable(i4.element) ? this.getContentEditableCaretPosition(r4.mentionPosition) : this.getTextAreaOrInputUnderlinePosition(this.tribute.current.element, r4.mentionPosition), this.tribute.menu.style.cssText = "top: ".concat(t6.top, "px;\n                                     left: ").concat(t6.left, "px;\n                                     right: ").concat(t6.right, "px;\n                                     bottom: ").concat(t6.bottom, "px;\n                                     position: absolute;\n                                     display: block;"), "auto" === t6.left && (this.tribute.menu.style.left = "auto"), "auto" === t6.top && (this.tribute.menu.style.top = "auto"), e3 && this.scrollIntoView(), window.setTimeout(function() {
                var i5 = { width: n4.tribute.menu.offsetWidth, height: n4.tribute.menu.offsetHeight }, r5 = n4.isMenuOffScreen(t6, i5), o4 = window.innerWidth > i5.width && (r5.left || r5.right), u6 = window.innerHeight > i5.height && (r5.top || r5.bottom);
                (o4 || u6) && (n4.tribute.menu.style.cssText = "display: none", n4.positionMenuAtCaret(e3));
              }, 0);
            } else this.tribute.menu.style.cssText = "display: none";
          } }, { key: "selectElement", value: function(e3, t6, n4) {
            var i4, r4 = e3;
            if (t6) for (var o4 = 0; o4 < t6.length; o4++) {
              if (void 0 === (r4 = r4.childNodes[t6[o4]])) return;
              for (; r4.length < n4; ) n4 -= r4.length, r4 = r4.nextSibling;
              0 !== r4.childNodes.length || r4.length || (r4 = r4.previousSibling);
            }
            var u6 = this.getWindowSelection();
            (i4 = this.getDocument().createRange()).setStart(r4, n4), i4.setEnd(r4, n4), i4.collapse(true);
            try {
              u6.removeAllRanges();
            } catch (e4) {
            }
            u6.addRange(i4), e3.focus();
          } }, { key: "replaceTriggerText", value: function(e3, t6, n4, i4, r4) {
            var o4 = this.getTriggerInfo(true, n4, t6, this.tribute.allowSpaces, this.tribute.autocompleteMode);
            if (void 0 !== o4) {
              var u6 = this.tribute.current, l6 = new CustomEvent("tribute-replaced", { detail: { item: r4, instance: u6, context: o4, event: i4 } });
              if (this.isContentEditable(u6.element)) {
                e3 += "string" == typeof this.tribute.replaceTextSuffix ? this.tribute.replaceTextSuffix : "\xA0";
                var s5 = o4.mentionPosition + o4.mentionText.length;
                this.tribute.autocompleteMode || (s5 += o4.mentionTriggerChar.length), this.pasteHtml(e3, o4.mentionPosition, s5);
              } else {
                var a5 = this.tribute.current.element, c4 = "string" == typeof this.tribute.replaceTextSuffix ? this.tribute.replaceTextSuffix : " ";
                e3 += c4;
                var h4 = o4.mentionPosition, d5 = o4.mentionPosition + o4.mentionText.length + c4.length;
                this.tribute.autocompleteMode || (d5 += o4.mentionTriggerChar.length - 1), a5.value = a5.value.substring(0, h4) + e3 + a5.value.substring(d5, a5.value.length), a5.selectionStart = h4 + e3.length, a5.selectionEnd = h4 + e3.length;
              }
              u6.element.dispatchEvent(new CustomEvent("input", { bubbles: true })), u6.element.dispatchEvent(l6);
            }
          } }, { key: "pasteHtml", value: function(e3, t6, n4) {
            var i4, r4;
            r4 = this.getWindowSelection(), (i4 = this.getDocument().createRange()).setStart(r4.anchorNode, t6), i4.setEnd(r4.anchorNode, n4), i4.deleteContents();
            var o4 = this.getDocument().createElement("div");
            o4.innerHTML = e3;
            for (var u6, l6, s5 = this.getDocument().createDocumentFragment(); u6 = o4.firstChild; ) l6 = s5.appendChild(u6);
            i4.insertNode(s5), l6 && ((i4 = i4.cloneRange()).setStartAfter(l6), i4.collapse(true), r4.removeAllRanges(), r4.addRange(i4));
          } }, { key: "getWindowSelection", value: function() {
            return this.tribute.collection.iframe ? this.tribute.collection.iframe.contentWindow.getSelection() : window.getSelection();
          } }, { key: "getNodePositionInParent", value: function(e3) {
            if (null === e3.parentNode) return 0;
            for (var t6 = 0; t6 < e3.parentNode.childNodes.length; t6++) {
              if (e3.parentNode.childNodes[t6] === e3) return t6;
            }
          } }, { key: "getContentEditableSelectedPath", value: function(e3) {
            var t6 = this.getWindowSelection(), n4 = t6.anchorNode, i4 = [];
            if (null != n4) {
              for (var r4, o4 = n4.contentEditable; null !== n4 && "true" !== o4; ) r4 = this.getNodePositionInParent(n4), i4.push(r4), null !== (n4 = n4.parentNode) && (o4 = n4.contentEditable);
              return i4.reverse(), { selected: n4, path: i4, offset: t6.getRangeAt(0).startOffset };
            }
          } }, { key: "getTextPrecedingCurrentSelection", value: function() {
            var e3 = this.tribute.current, t6 = "";
            if (this.isContentEditable(e3.element)) {
              var n4 = this.getWindowSelection().anchorNode;
              if (null != n4) {
                var i4 = n4.textContent, r4 = this.getWindowSelection().getRangeAt(0).startOffset;
                i4 && r4 >= 0 && (t6 = i4.substring(0, r4));
              }
            } else {
              var o4 = this.tribute.current.element;
              if (o4) {
                var u6 = o4.selectionStart;
                o4.value && u6 >= 0 && (t6 = o4.value.substring(0, u6));
              }
            }
            return t6;
          } }, { key: "getLastWordInText", value: function(e3) {
            var t6 = (e3 = e3.replace(/\u00A0/g, " ")).split(/\s+/);
            return t6[t6.length - 1].trim();
          } }, { key: "getTriggerInfo", value: function(e3, t6, n4, i4, r4) {
            var o4, u6, l6, s5 = this, a5 = this.tribute.current;
            if (this.isContentEditable(a5.element)) {
              var c4 = this.getContentEditableSelectedPath(a5);
              c4 && (o4 = c4.selected, u6 = c4.path, l6 = c4.offset);
            } else o4 = this.tribute.current.element;
            var h4 = this.getTextPrecedingCurrentSelection(), d5 = this.getLastWordInText(h4);
            if (r4) return { mentionPosition: h4.length - d5.length, mentionText: d5, mentionSelectedElement: o4, mentionSelectedPath: u6, mentionSelectedOffset: l6 };
            if (null != h4) {
              var f4, m4 = -1;
              if (this.tribute.collection.forEach(function(e4) {
                var t7 = e4.trigger, i5 = e4.requireLeadingSpace ? s5.lastIndexWithLeadingSpace(h4, t7) : h4.lastIndexOf(t7);
                i5 > m4 && (m4 = i5, f4 = t7, n4 = e4.requireLeadingSpace);
              }), m4 >= 0 && (0 === m4 || !n4 || /[\xA0\s]/g.test(h4.substring(m4 - 1, m4)))) {
                var p4 = h4.substring(m4 + f4.length, h4.length);
                f4 = h4.substring(m4, m4 + f4.length);
                var v4 = p4.substring(0, 1), g4 = p4.length > 0 && (" " === v4 || "\xA0" === v4);
                t6 && (p4 = p4.trim());
                var b5 = i4 ? /[^\S ]/g : /[\xA0\s]/g;
                if (this.tribute.hasTrailingSpace = b5.test(p4), !g4 && (e3 || !b5.test(p4))) return { mentionPosition: m4, mentionText: p4, mentionSelectedElement: o4, mentionSelectedPath: u6, mentionSelectedOffset: l6, mentionTriggerChar: f4 };
              }
            }
          } }, { key: "lastIndexWithLeadingSpace", value: function(e3, t6) {
            for (var n4 = e3.split("").reverse().join(""), i4 = -1, r4 = 0, o4 = e3.length; r4 < o4; r4++) {
              for (var u6 = r4 === e3.length - 1, l6 = /\s/.test(n4[r4 + 1]), s5 = true, a5 = t6.length - 1; a5 >= 0; a5--) if (t6[a5] !== n4[r4 - a5]) {
                s5 = false;
                break;
              }
              if (s5 && (u6 || l6)) {
                i4 = e3.length - 1 - r4;
                break;
              }
            }
            return i4;
          } }, { key: "isContentEditable", value: function(e3) {
            return "INPUT" !== e3.nodeName && "TEXTAREA" !== e3.nodeName;
          } }, { key: "isMenuOffScreen", value: function(e3, t6) {
            var n4 = window.innerWidth, i4 = window.innerHeight, r4 = document.documentElement, o4 = (window.pageXOffset || r4.scrollLeft) - (r4.clientLeft || 0), u6 = (window.pageYOffset || r4.scrollTop) - (r4.clientTop || 0), l6 = "number" == typeof e3.top ? e3.top : u6 + i4 - e3.bottom - t6.height, s5 = "number" == typeof e3.right ? e3.right : e3.left + t6.width, a5 = "number" == typeof e3.bottom ? e3.bottom : e3.top + t6.height, c4 = "number" == typeof e3.left ? e3.left : o4 + n4 - e3.right - t6.width;
            return { top: l6 < Math.floor(u6), right: s5 > Math.ceil(o4 + n4), bottom: a5 > Math.ceil(u6 + i4), left: c4 < Math.floor(o4) };
          } }, { key: "getMenuDimensions", value: function() {
            var e3 = { width: null, height: null };
            return this.tribute.menu.style.cssText = "top: 0px;\n                                 left: 0px;\n                                 position: fixed;\n                                 display: block;\n                                 visibility; hidden;", e3.width = this.tribute.menu.offsetWidth, e3.height = this.tribute.menu.offsetHeight, this.tribute.menu.style.cssText = "display: none;", e3;
          } }, { key: "getTextAreaOrInputUnderlinePosition", value: function(e3, t6, n4) {
            var i4 = null !== window.mozInnerScreenX, r4 = this.getDocument().createElement("div");
            r4.id = "input-textarea-caret-position-mirror-div", this.getDocument().body.appendChild(r4);
            var o4 = r4.style, u6 = window.getComputedStyle ? getComputedStyle(e3) : e3.currentStyle;
            o4.whiteSpace = "pre-wrap", "INPUT" !== e3.nodeName && (o4.wordWrap = "break-word"), o4.position = "absolute", o4.visibility = "hidden", ["direction", "boxSizing", "width", "height", "overflowX", "overflowY", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontStyle", "fontVariant", "fontWeight", "fontStretch", "fontSize", "fontSizeAdjust", "lineHeight", "fontFamily", "textAlign", "textTransform", "textIndent", "textDecoration", "letterSpacing", "wordSpacing"].forEach(function(e4) {
              o4[e4] = u6[e4];
            }), i4 ? (o4.width = "".concat(parseInt(u6.width) - 2, "px"), e3.scrollHeight > parseInt(u6.height) && (o4.overflowY = "scroll")) : o4.overflow = "hidden", r4.textContent = e3.value.substring(0, t6), "INPUT" === e3.nodeName && (r4.textContent = r4.textContent.replace(/\s/g, "\xA0"));
            var l6 = this.getDocument().createElement("span");
            l6.textContent = e3.value.substring(t6) || ".", r4.appendChild(l6);
            var s5 = e3.getBoundingClientRect(), a5 = document.documentElement, c4 = (window.pageXOffset || a5.scrollLeft) - (a5.clientLeft || 0), h4 = (window.pageYOffset || a5.scrollTop) - (a5.clientTop || 0), d5 = 0, f4 = 0;
            this.menuContainerIsBody && (d5 = s5.top, f4 = s5.left);
            var m4 = { top: d5 + h4 + l6.offsetTop + parseInt(u6.borderTopWidth) + parseInt(u6.fontSize) - e3.scrollTop, left: f4 + c4 + l6.offsetLeft + parseInt(u6.borderLeftWidth) }, p4 = window.innerWidth, v4 = window.innerHeight, g4 = this.getMenuDimensions(), b5 = this.isMenuOffScreen(m4, g4);
            b5.right && (m4.right = p4 - m4.left, m4.left = "auto");
            var y6 = this.tribute.menuContainer ? this.tribute.menuContainer.offsetHeight : this.getDocument().body.offsetHeight;
            if (b5.bottom) {
              var w5 = y6 - (v4 - (this.tribute.menuContainer ? this.tribute.menuContainer.getBoundingClientRect() : this.getDocument().body.getBoundingClientRect()).top);
              m4.bottom = w5 + (v4 - s5.top - l6.offsetTop), m4.top = "auto";
            }
            return (b5 = this.isMenuOffScreen(m4, g4)).left && (m4.left = p4 > g4.width ? c4 + p4 - g4.width : c4, delete m4.right), b5.top && (m4.top = v4 > g4.height ? h4 + v4 - g4.height : h4, delete m4.bottom), this.getDocument().body.removeChild(r4), m4;
          } }, { key: "getContentEditableCaretPosition", value: function(e3) {
            var t6, n4 = this.getWindowSelection();
            (t6 = this.getDocument().createRange()).setStart(n4.anchorNode, e3), t6.setEnd(n4.anchorNode, e3), t6.collapse(false);
            var i4 = t6.getBoundingClientRect(), r4 = document.documentElement, o4 = (window.pageXOffset || r4.scrollLeft) - (r4.clientLeft || 0), u6 = (window.pageYOffset || r4.scrollTop) - (r4.clientTop || 0), l6 = { left: i4.left + o4, top: i4.top + i4.height + u6 }, s5 = window.innerWidth, a5 = window.innerHeight, c4 = this.getMenuDimensions(), h4 = this.isMenuOffScreen(l6, c4);
            h4.right && (l6.left = "auto", l6.right = s5 - i4.left - o4);
            var d5 = this.tribute.menuContainer ? this.tribute.menuContainer.offsetHeight : this.getDocument().body.offsetHeight;
            if (h4.bottom) {
              var f4 = d5 - (a5 - (this.tribute.menuContainer ? this.tribute.menuContainer.getBoundingClientRect() : this.getDocument().body.getBoundingClientRect()).top);
              l6.top = "auto", l6.bottom = f4 + (a5 - i4.top);
            }
            return (h4 = this.isMenuOffScreen(l6, c4)).left && (l6.left = s5 > c4.width ? o4 + s5 - c4.width : o4, delete l6.right), h4.top && (l6.top = a5 > c4.height ? u6 + a5 - c4.height : u6, delete l6.bottom), this.menuContainerIsBody || (l6.left = l6.left ? l6.left - this.tribute.menuContainer.offsetLeft : l6.left, l6.top = l6.top ? l6.top - this.tribute.menuContainer.offsetTop : l6.top), l6;
          } }, { key: "scrollIntoView", value: function(e3) {
            var t6, n4 = this.menu;
            if (void 0 !== n4) {
              for (; void 0 === t6 || 0 === t6.height; ) if (0 === (t6 = n4.getBoundingClientRect()).height && (void 0 === (n4 = n4.childNodes[0]) || !n4.getBoundingClientRect)) return;
              var i4 = t6.top, r4 = i4 + t6.height;
              if (i4 < 0) window.scrollTo(0, window.pageYOffset + t6.top - 20);
              else if (r4 > window.innerHeight) {
                var o4 = window.pageYOffset + t6.top - 20;
                o4 - window.pageYOffset > 100 && (o4 = window.pageYOffset + 100);
                var u6 = window.pageYOffset - (window.innerHeight - r4);
                u6 > o4 && (u6 = o4), window.scrollTo(0, u6);
              }
            }
          } }, { key: "menuContainerIsBody", get: function() {
            return this.tribute.menuContainer === document.body || !this.tribute.menuContainer;
          } }]), t5;
        }(), s4 = function() {
          function t5(n4) {
            e2(this, t5), this.tribute = n4, this.tribute.search = this;
          }
          return n3(t5, [{ key: "simpleFilter", value: function(e3, t6) {
            var n4 = this;
            return t6.filter(function(t7) {
              return n4.test(e3, t7);
            });
          } }, { key: "test", value: function(e3, t6) {
            return null !== this.match(e3, t6);
          } }, { key: "match", value: function(e3, t6, n4) {
            n4 = n4 || {};
            t6.length;
            var i4 = n4.pre || "", r4 = n4.post || "", o4 = n4.caseSensitive && t6 || t6.toLowerCase();
            if (n4.skip) return { rendered: t6, score: 0 };
            e3 = n4.caseSensitive && e3 || e3.toLowerCase();
            var u6 = this.traverse(o4, e3, 0, 0, []);
            return u6 ? { rendered: this.render(t6, u6.cache, i4, r4), score: u6.score } : null;
          } }, { key: "traverse", value: function(e3, t6, n4, i4, r4) {
            if (t6.length === i4) return { score: this.calculateScore(r4), cache: r4.slice() };
            if (!(e3.length === n4 || t6.length - i4 > e3.length - n4)) {
              for (var o4, u6, l6 = t6[i4], s5 = e3.indexOf(l6, n4); s5 > -1; ) {
                if (r4.push(s5), u6 = this.traverse(e3, t6, s5 + 1, i4 + 1, r4), r4.pop(), !u6) return o4;
                (!o4 || o4.score < u6.score) && (o4 = u6), s5 = e3.indexOf(l6, s5 + 1);
              }
              return o4;
            }
          } }, { key: "calculateScore", value: function(e3) {
            var t6 = 0, n4 = 1;
            return e3.forEach(function(i4, r4) {
              r4 > 0 && (e3[r4 - 1] + 1 === i4 ? n4 += n4 + 1 : n4 = 1), t6 += n4;
            }), t6;
          } }, { key: "render", value: function(e3, t6, n4, i4) {
            var r4 = e3.substring(0, t6[0]);
            return t6.forEach(function(o4, u6) {
              r4 += n4 + e3[o4] + i4 + e3.substring(o4 + 1, t6[u6 + 1] ? t6[u6 + 1] : e3.length);
            }), r4;
          } }, { key: "filter", value: function(e3, t6, n4) {
            var i4 = this;
            return n4 = n4 || {}, t6.reduce(function(t7, r4, o4, u6) {
              var l6 = r4;
              n4.extract && ((l6 = n4.extract(r4)) || (l6 = ""));
              var s5 = i4.match(e3, l6, n4);
              return null != s5 && (t7[t7.length] = { string: s5.rendered, score: s5.score, index: o4, original: r4 }), t7;
            }, []).sort(function(e4, t7) {
              var n5 = t7.score - e4.score;
              return n5 || e4.index - t7.index;
            });
          } }]), t5;
        }();
        return function() {
          function t5(n4) {
            var i4, r4 = this, a5 = n4.values, c4 = void 0 === a5 ? null : a5, h4 = n4.iframe, d5 = void 0 === h4 ? null : h4, f4 = n4.selectClass, m4 = void 0 === f4 ? "highlight" : f4, p4 = n4.containerClass, v4 = void 0 === p4 ? "tribute-container" : p4, g4 = n4.itemClass, b5 = void 0 === g4 ? "" : g4, y6 = n4.trigger, w5 = void 0 === y6 ? "@" : y6, T5 = n4.autocompleteMode, C4 = void 0 !== T5 && T5, S5 = n4.selectTemplate, E5 = void 0 === S5 ? null : S5, k4 = n4.menuItemTemplate, x4 = void 0 === k4 ? null : k4, M5 = n4.lookup, A4 = void 0 === M5 ? "key" : M5, L6 = n4.fillAttr, I4 = void 0 === L6 ? "value" : L6, N5 = n4.collection, O6 = void 0 === N5 ? null : N5, D6 = n4.menuContainer, P6 = void 0 === D6 ? null : D6, R6 = n4.noMatchTemplate, W5 = void 0 === R6 ? null : R6, H5 = n4.requireLeadingSpace, B4 = void 0 === H5 || H5, F5 = n4.allowSpaces, _26 = void 0 !== F5 && F5, j6 = n4.replaceTextSuffix, Y6 = void 0 === j6 ? null : j6, z5 = n4.positionMenu, K4 = void 0 === z5 || z5, q4 = n4.spaceSelectsMatch, U5 = void 0 !== q4 && q4, X6 = n4.searchOpts, Q5 = void 0 === X6 ? {} : X6, V5 = n4.menuItemLimit, G6 = void 0 === V5 ? null : V5, J4 = n4.menuShowMinLength, Z5 = void 0 === J4 ? 0 : J4;
            if (e2(this, t5), this.autocompleteMode = C4, this.menuSelected = 0, this.current = {}, this.inputEvent = false, this.isActive = false, this.menuContainer = P6, this.allowSpaces = _26, this.replaceTextSuffix = Y6, this.positionMenu = K4, this.hasTrailingSpace = false, this.spaceSelectsMatch = U5, this.autocompleteMode && (w5 = "", _26 = false), c4) this.collection = [{ trigger: w5, iframe: d5, selectClass: m4, containerClass: v4, itemClass: b5, selectTemplate: (E5 || t5.defaultSelectTemplate).bind(this), menuItemTemplate: (x4 || t5.defaultMenuItemTemplate).bind(this), noMatchTemplate: (i4 = W5, "string" == typeof i4 ? "" === i4.trim() ? null : i4 : "function" == typeof i4 ? i4.bind(r4) : W5 || function() {
              return "<li>No Match Found!</li>";
            }.bind(r4)), lookup: A4, fillAttr: I4, values: c4, requireLeadingSpace: B4, searchOpts: Q5, menuItemLimit: G6, menuShowMinLength: Z5 }];
            else {
              if (!O6) throw new Error("[Tribute] No collection specified.");
              this.autocompleteMode && console.warn("Tribute in autocomplete mode does not work for collections"), this.collection = O6.map(function(e3) {
                return { trigger: e3.trigger || w5, iframe: e3.iframe || d5, selectClass: e3.selectClass || m4, containerClass: e3.containerClass || v4, itemClass: e3.itemClass || b5, selectTemplate: (e3.selectTemplate || t5.defaultSelectTemplate).bind(r4), menuItemTemplate: (e3.menuItemTemplate || t5.defaultMenuItemTemplate).bind(r4), noMatchTemplate: function(e4) {
                  return "string" == typeof e4 ? "" === e4.trim() ? null : e4 : "function" == typeof e4 ? e4.bind(r4) : W5 || function() {
                    return "<li>No Match Found!</li>";
                  }.bind(r4);
                }(W5), lookup: e3.lookup || A4, fillAttr: e3.fillAttr || I4, values: e3.values, requireLeadingSpace: e3.requireLeadingSpace, searchOpts: e3.searchOpts || Q5, menuItemLimit: e3.menuItemLimit || G6, menuShowMinLength: e3.menuShowMinLength || Z5 };
              });
            }
            new l5(this), new o3(this), new u5(this), new s4(this);
          }
          return n3(t5, [{ key: "triggers", value: function() {
            return this.collection.map(function(e3) {
              return e3.trigger;
            });
          } }, { key: "attach", value: function(e3) {
            if (!e3) throw new Error("[Tribute] Must pass in a DOM node or NodeList.");
            if ("undefined" != typeof jQuery && e3 instanceof jQuery && (e3 = e3.get()), e3.constructor === NodeList || e3.constructor === HTMLCollection || e3.constructor === Array) for (var t6 = e3.length, n4 = 0; n4 < t6; ++n4) this._attach(e3[n4]);
            else this._attach(e3);
          } }, { key: "_attach", value: function(e3) {
            e3.hasAttribute("data-tribute") && console.warn("Tribute was already bound to " + e3.nodeName), this.ensureEditable(e3), this.events.bind(e3), e3.setAttribute("data-tribute", true);
          } }, { key: "ensureEditable", value: function(e3) {
            if (-1 === t5.inputTypes().indexOf(e3.nodeName)) {
              if (!e3.contentEditable) throw new Error("[Tribute] Cannot bind to " + e3.nodeName);
              e3.contentEditable = true;
            }
          } }, { key: "createMenu", value: function(e3) {
            var t6 = this.range.getDocument().createElement("div"), n4 = this.range.getDocument().createElement("ul");
            return t6.className = e3, t6.appendChild(n4), this.menuContainer ? this.menuContainer.appendChild(t6) : this.range.getDocument().body.appendChild(t6);
          } }, { key: "showMenuFor", value: function(e3, t6) {
            var n4 = this;
            if (!this.isActive || this.current.element !== e3 || this.current.mentionText !== this.currentMentionTextSnapshot) {
              this.currentMentionTextSnapshot = this.current.mentionText, this.menu || (this.menu = this.createMenu(this.current.collection.containerClass), e3.tributeMenu = this.menu, this.menuEvents.bind(this.menu)), this.isActive = true, this.menuSelected = 0, this.current.mentionText || (this.current.mentionText = "");
              var r4 = function(e4) {
                if (n4.isActive) {
                  var r5 = n4.search.filter(n4.current.mentionText, e4, { pre: n4.current.collection.searchOpts.pre || "<span>", post: n4.current.collection.searchOpts.post || "</span>", skip: n4.current.collection.searchOpts.skip, extract: function(e5) {
                    if ("string" == typeof n4.current.collection.lookup) return e5[n4.current.collection.lookup];
                    if ("function" == typeof n4.current.collection.lookup) return n4.current.collection.lookup(e5, n4.current.mentionText);
                    throw new Error("Invalid lookup attribute, lookup must be string or function.");
                  } });
                  n4.current.collection.menuItemLimit && (r5 = r5.slice(0, n4.current.collection.menuItemLimit)), n4.current.filteredItems = r5;
                  var o4 = n4.menu.querySelector("ul");
                  if (n4.range.positionMenuAtCaret(t6), !r5.length) {
                    var u6 = new CustomEvent("tribute-no-match", { detail: n4.menu });
                    return n4.current.element.dispatchEvent(u6), void ("function" == typeof n4.current.collection.noMatchTemplate && !n4.current.collection.noMatchTemplate() || !n4.current.collection.noMatchTemplate ? n4.hideMenu() : "function" == typeof n4.current.collection.noMatchTemplate ? o4.innerHTML = n4.current.collection.noMatchTemplate() : o4.innerHTML = n4.current.collection.noMatchTemplate);
                  }
                  o4.innerHTML = "";
                  var l6 = n4.range.getDocument().createDocumentFragment();
                  r5.forEach(function(e5, t7) {
                    var r6 = n4.range.getDocument().createElement("li");
                    r6.setAttribute("data-index", t7), r6.className = n4.current.collection.itemClass, r6.addEventListener("mousemove", function(e6) {
                      var t8 = i3(n4._findLiTarget(e6.target), 2), r7 = (t8[0], t8[1]);
                      0 !== e6.movementY && n4.events.setActiveLi(r7);
                    }), n4.menuSelected === t7 && r6.classList.add(n4.current.collection.selectClass), r6.innerHTML = n4.current.collection.menuItemTemplate(e5), l6.appendChild(r6);
                  }), o4.appendChild(l6);
                }
              };
              "function" == typeof this.current.collection.values ? this.current.collection.values(this.current.mentionText, r4) : r4(this.current.collection.values);
            }
          } }, { key: "_findLiTarget", value: function(e3) {
            if (!e3) return [];
            var t6 = e3.getAttribute("data-index");
            return t6 ? [e3, t6] : this._findLiTarget(e3.parentNode);
          } }, { key: "showMenuForCollection", value: function(e3, t6) {
            e3 !== document.activeElement && this.placeCaretAtEnd(e3), this.current.collection = this.collection[t6 || 0], this.current.externalTrigger = true, this.current.element = e3, e3.isContentEditable ? this.insertTextAtCursor(this.current.collection.trigger) : this.insertAtCaret(e3, this.current.collection.trigger), this.showMenuFor(e3);
          } }, { key: "placeCaretAtEnd", value: function(e3) {
            if (e3.focus(), void 0 !== window.getSelection && void 0 !== document.createRange) {
              var t6 = document.createRange();
              t6.selectNodeContents(e3), t6.collapse(false);
              var n4 = window.getSelection();
              n4.removeAllRanges(), n4.addRange(t6);
            } else if (void 0 !== document.body.createTextRange) {
              var i4 = document.body.createTextRange();
              i4.moveToElementText(e3), i4.collapse(false), i4.select();
            }
          } }, { key: "insertTextAtCursor", value: function(e3) {
            var t6, n4;
            (n4 = (t6 = window.getSelection()).getRangeAt(0)).deleteContents();
            var i4 = document.createTextNode(e3);
            n4.insertNode(i4), n4.selectNodeContents(i4), n4.collapse(false), t6.removeAllRanges(), t6.addRange(n4);
          } }, { key: "insertAtCaret", value: function(e3, t6) {
            var n4 = e3.scrollTop, i4 = e3.selectionStart, r4 = e3.value.substring(0, i4), o4 = e3.value.substring(e3.selectionEnd, e3.value.length);
            e3.value = r4 + t6 + o4, i4 += t6.length, e3.selectionStart = i4, e3.selectionEnd = i4, e3.focus(), e3.scrollTop = n4;
          } }, { key: "hideMenu", value: function() {
            this.menu && (this.menu.style.cssText = "display: none;", this.isActive = false, this.menuSelected = 0, this.current = {});
          } }, { key: "selectItemAtIndex", value: function(e3, t6) {
            if ("number" == typeof (e3 = parseInt(e3)) && !isNaN(e3)) {
              var n4 = this.current.filteredItems[e3], i4 = this.current.collection.selectTemplate(n4);
              null !== i4 && this.replaceText(i4, t6, n4);
            }
          } }, { key: "replaceText", value: function(e3, t6, n4) {
            this.range.replaceTriggerText(e3, true, true, t6, n4);
          } }, { key: "_append", value: function(e3, t6, n4) {
            if ("function" == typeof e3.values) throw new Error("Unable to append to values, as it is a function.");
            e3.values = n4 ? t6 : e3.values.concat(t6);
          } }, { key: "append", value: function(e3, t6, n4) {
            var i4 = parseInt(e3);
            if ("number" != typeof i4) throw new Error("please provide an index for the collection to update.");
            var r4 = this.collection[i4];
            this._append(r4, t6, n4);
          } }, { key: "appendCurrent", value: function(e3, t6) {
            if (!this.isActive) throw new Error("No active state. Please use append instead and pass an index.");
            this._append(this.current.collection, e3, t6);
          } }, { key: "detach", value: function(e3) {
            if (!e3) throw new Error("[Tribute] Must pass in a DOM node or NodeList.");
            if ("undefined" != typeof jQuery && e3 instanceof jQuery && (e3 = e3.get()), e3.constructor === NodeList || e3.constructor === HTMLCollection || e3.constructor === Array) for (var t6 = e3.length, n4 = 0; n4 < t6; ++n4) this._detach(e3[n4]);
            else this._detach(e3);
          } }, { key: "_detach", value: function(e3) {
            var t6 = this;
            this.events.unbind(e3), e3.tributeMenu && this.menuEvents.unbind(e3.tributeMenu), setTimeout(function() {
              e3.removeAttribute("data-tribute"), t6.isActive = false, e3.tributeMenu && e3.tributeMenu.remove();
            });
          } }, { key: "isActive", get: function() {
            return this._isActive;
          }, set: function(e3) {
            if (this._isActive != e3 && (this._isActive = e3, this.current.element)) {
              var t6 = new CustomEvent("tribute-active-".concat(e3));
              this.current.element.dispatchEvent(t6);
            }
          } }], [{ key: "defaultSelectTemplate", value: function(e3) {
            return void 0 === e3 ? "".concat(this.current.collection.trigger).concat(this.current.mentionText) : this.range.isContentEditable(this.current.element) ? '<span class="tribute-mention">' + (this.current.collection.trigger + e3.original[this.current.collection.fillAttr]) + "</span>" : this.current.collection.trigger + e3.original[this.current.collection.fillAttr];
          } }, { key: "defaultMenuItemTemplate", value: function(e3) {
            return e3.string;
          } }, { key: "inputTypes", value: function() {
            return ["TEXTAREA", "INPUT"];
          } }]), t5;
        }();
      });
    }
  });

  // node_modules/lodash.merge/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.merge/index.js"(exports, module2) {
      init_define_process();
      init_jquery();
      var LARGE_ARRAY_SIZE = 200;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var MAX_SAFE_INTEGER = 9007199254740991;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var asyncTag = "[object AsyncFunction]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var nullTag = "[object Null]";
      var objectTag = "[object Object]";
      var proxyTag = "[object Proxy]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var undefinedTag = "[object Undefined]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function baseTimes(n3, iteratee) {
        var index2 = -1, result = Array(n3);
        while (++index2 < n3) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object);
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var Symbol2 = root.Symbol;
      var Uint8Array2 = root.Uint8Array;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var objectCreate = Object.create;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var splice = arrayProto.splice;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var nativeMax = Math.max;
      var nativeNow = Date.now;
      var Map2 = getNative(root, "Map");
      var nativeCreate = getNative(Object, "create");
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size3 = data.size;
        data.set(key, value);
        this.size += data.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq2(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      var baseFor = createBaseFor();
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseRest(func, start5) {
        return setToString(overRest(func, start5, identity), func + "");
      }
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq2(object[index2], value);
        }
        return false;
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start5, transform) {
        start5 = nativeMax(start5 === void 0 ? func.length - 1 : start5, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start5, 0), array = Array(length);
          while (++index2 < length) {
            array[index2] = args[start5 + index2];
          }
          index2 = -1;
          var otherArgs = Array(start5 + 1);
          while (++index2 < start5) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start5] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setToString = shortOut(baseSetToString);
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var merge3 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      function constant(value) {
        return function() {
          return value;
        };
      }
      function identity(value) {
        return value;
      }
      function stubFalse() {
        return false;
      }
      module2.exports = merge3;
    }
  });

  // node_modules/cropperjs/dist/cropper.js
  var require_cropper = __commonJS({
    "node_modules/cropperjs/dist/cropper.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function(global3, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global3 = typeof globalThis !== "undefined" ? globalThis : global3 || self, global3.Cropper = factory());
      })(exports, function() {
        "use strict";
        function ownKeys(e2, r3) {
          var t4 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var o3 = Object.getOwnPropertySymbols(e2);
            r3 && (o3 = o3.filter(function(r4) {
              return Object.getOwnPropertyDescriptor(e2, r4).enumerable;
            })), t4.push.apply(t4, o3);
          }
          return t4;
        }
        function _objectSpread2(e2) {
          for (var r3 = 1; r3 < arguments.length; r3++) {
            var t4 = null != arguments[r3] ? arguments[r3] : {};
            r3 % 2 ? ownKeys(Object(t4), true).forEach(function(r4) {
              _defineProperty2(e2, r4, t4[r4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t4)) : ownKeys(Object(t4)).forEach(function(r4) {
              Object.defineProperty(e2, r4, Object.getOwnPropertyDescriptor(t4, r4));
            });
          }
          return e2;
        }
        function _toPrimitive(t4, r3) {
          if ("object" != typeof t4 || !t4) return t4;
          var e2 = t4[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i3 = e2.call(t4, r3 || "default");
            if ("object" != typeof i3) return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r3 ? String : Number)(t4);
        }
        function _toPropertyKey(t4) {
          var i3 = _toPrimitive(t4, "string");
          return "symbol" == typeof i3 ? i3 : i3 + "";
        }
        function _typeof2(o3) {
          "@babel/helpers - typeof";
          return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
            return typeof o4;
          } : function(o4) {
            return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
          }, _typeof2(o3);
        }
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target, props) {
          for (var i3 = 0; i3 < props.length; i3++) {
            var descriptor = props[i3];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties2(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false
          });
          return Constructor;
        }
        function _defineProperty2(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        }
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        }
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
        }
        function _unsupportedIterableToArray(o3, minLen) {
          if (!o3) return;
          if (typeof o3 === "string") return _arrayLikeToArray(o3, minLen);
          var n3 = Object.prototype.toString.call(o3).slice(8, -1);
          if (n3 === "Object" && o3.constructor) n3 = o3.constructor.name;
          if (n3 === "Map" || n3 === "Set") return Array.from(o3);
          if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray(o3, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) arr2[i3] = arr[i3];
          return arr2;
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined";
        var WINDOW = IS_BROWSER ? window : {};
        var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? "ontouchstart" in WINDOW.document.documentElement : false;
        var HAS_POINTER_EVENT = IS_BROWSER ? "PointerEvent" in WINDOW : false;
        var NAMESPACE = "cropper";
        var ACTION_ALL = "all";
        var ACTION_CROP = "crop";
        var ACTION_MOVE = "move";
        var ACTION_ZOOM = "zoom";
        var ACTION_EAST = "e";
        var ACTION_WEST = "w";
        var ACTION_SOUTH = "s";
        var ACTION_NORTH = "n";
        var ACTION_NORTH_EAST = "ne";
        var ACTION_NORTH_WEST = "nw";
        var ACTION_SOUTH_EAST = "se";
        var ACTION_SOUTH_WEST = "sw";
        var CLASS_CROP = "".concat(NAMESPACE, "-crop");
        var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
        var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
        var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
        var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
        var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
        var CLASS_MOVE = "".concat(NAMESPACE, "-move");
        var DATA_ACTION = "".concat(NAMESPACE, "Action");
        var DATA_PREVIEW = "".concat(NAMESPACE, "Preview");
        var DRAG_MODE_CROP = "crop";
        var DRAG_MODE_MOVE = "move";
        var DRAG_MODE_NONE = "none";
        var EVENT_CROP = "crop";
        var EVENT_CROP_END = "cropend";
        var EVENT_CROP_MOVE = "cropmove";
        var EVENT_CROP_START = "cropstart";
        var EVENT_DBLCLICK = "dblclick";
        var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? "touchstart" : "mousedown";
        var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? "touchmove" : "mousemove";
        var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? "touchend touchcancel" : "mouseup";
        var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? "pointerdown" : EVENT_TOUCH_START;
        var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? "pointermove" : EVENT_TOUCH_MOVE;
        var EVENT_POINTER_UP = HAS_POINTER_EVENT ? "pointerup pointercancel" : EVENT_TOUCH_END;
        var EVENT_READY = "ready";
        var EVENT_RESIZE = "resize";
        var EVENT_WHEEL = "wheel";
        var EVENT_ZOOM = "zoom";
        var MIME_TYPE_JPEG = "image/jpeg";
        var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
        var REGEXP_DATA_URL = /^data:/;
        var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
        var REGEXP_TAG_NAME = /^img|canvas$/i;
        var MIN_CONTAINER_WIDTH = 200;
        var MIN_CONTAINER_HEIGHT = 100;
        var DEFAULTS = {
          // Define the view mode of the cropper
          viewMode: 0,
          // 0, 1, 2, 3
          // Define the dragging mode of the cropper
          dragMode: DRAG_MODE_CROP,
          // 'crop', 'move' or 'none'
          // Define the initial aspect ratio of the crop box
          initialAspectRatio: NaN,
          // Define the aspect ratio of the crop box
          aspectRatio: NaN,
          // An object with the previous cropping result data
          data: null,
          // A selector for adding extra containers to preview
          preview: "",
          // Re-render the cropper when resize the window
          responsive: true,
          // Restore the cropped area after resize the window
          restore: true,
          // Check if the current image is a cross-origin image
          checkCrossOrigin: true,
          // Check the current image's Exif Orientation information
          checkOrientation: true,
          // Show the black modal
          modal: true,
          // Show the dashed lines for guiding
          guides: true,
          // Show the center indicator for guiding
          center: true,
          // Show the white modal to highlight the crop box
          highlight: true,
          // Show the grid background
          background: true,
          // Enable to crop the image automatically when initialize
          autoCrop: true,
          // Define the percentage of automatic cropping area when initializes
          autoCropArea: 0.8,
          // Enable to move the image
          movable: true,
          // Enable to rotate the image
          rotatable: true,
          // Enable to scale the image
          scalable: true,
          // Enable to zoom the image
          zoomable: true,
          // Enable to zoom the image by dragging touch
          zoomOnTouch: true,
          // Enable to zoom the image by wheeling mouse
          zoomOnWheel: true,
          // Define zoom ratio when zoom the image by wheeling mouse
          wheelZoomRatio: 0.1,
          // Enable to move the crop box
          cropBoxMovable: true,
          // Enable to resize the crop box
          cropBoxResizable: true,
          // Toggle drag mode between "crop" and "move" when click twice on the cropper
          toggleDragModeOnDblclick: true,
          // Size limitation
          minCanvasWidth: 0,
          minCanvasHeight: 0,
          minCropBoxWidth: 0,
          minCropBoxHeight: 0,
          minContainerWidth: MIN_CONTAINER_WIDTH,
          minContainerHeight: MIN_CONTAINER_HEIGHT,
          // Shortcuts of events
          ready: null,
          cropstart: null,
          cropmove: null,
          cropend: null,
          crop: null,
          zoom: null
        };
        var TEMPLATE = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>';
        var isNaN2 = Number.isNaN || WINDOW.isNaN;
        function isNumber2(value) {
          return typeof value === "number" && !isNaN2(value);
        }
        var isPositiveNumber = function isPositiveNumber2(value) {
          return value > 0 && value < Infinity;
        };
        function isUndefined(value) {
          return typeof value === "undefined";
        }
        function isObject2(value) {
          return _typeof2(value) === "object" && value !== null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        function isPlainObject(value) {
          if (!isObject2(value)) {
            return false;
          }
          try {
            var _constructor = value.constructor;
            var prototype = _constructor.prototype;
            return _constructor && prototype && hasOwnProperty2.call(prototype, "isPrototypeOf");
          } catch (error3) {
            return false;
          }
        }
        function isFunction2(value) {
          return typeof value === "function";
        }
        var slice = Array.prototype.slice;
        function toArray(value) {
          return Array.from ? Array.from(value) : slice.call(value);
        }
        function forEach(data, callback2) {
          if (data && isFunction2(callback2)) {
            if (Array.isArray(data) || isNumber2(data.length)) {
              toArray(data).forEach(function(value, key) {
                callback2.call(data, value, key, data);
              });
            } else if (isObject2(data)) {
              Object.keys(data).forEach(function(key) {
                callback2.call(data, data[key], key, data);
              });
            }
          }
          return data;
        }
        var assign2 = Object.assign || function assign3(target) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (isObject2(target) && args.length > 0) {
            args.forEach(function(arg) {
              if (isObject2(arg)) {
                Object.keys(arg).forEach(function(key) {
                  target[key] = arg[key];
                });
              }
            });
          }
          return target;
        };
        var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
        function normalizeDecimalNumber(value) {
          var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
          return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
        }
        var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
        function setStyle2(element, styles) {
          var style = element.style;
          forEach(styles, function(value, property) {
            if (REGEXP_SUFFIX.test(property) && isNumber2(value)) {
              value = "".concat(value, "px");
            }
            style[property] = value;
          });
        }
        function hasClass(element, value) {
          return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
        }
        function addClass(element, value) {
          if (!value) {
            return;
          }
          if (isNumber2(element.length)) {
            forEach(element, function(elem) {
              addClass(elem, value);
            });
            return;
          }
          if (element.classList) {
            element.classList.add(value);
            return;
          }
          var className = element.className.trim();
          if (!className) {
            element.className = value;
          } else if (className.indexOf(value) < 0) {
            element.className = "".concat(className, " ").concat(value);
          }
        }
        function removeClass(element, value) {
          if (!value) {
            return;
          }
          if (isNumber2(element.length)) {
            forEach(element, function(elem) {
              removeClass(elem, value);
            });
            return;
          }
          if (element.classList) {
            element.classList.remove(value);
            return;
          }
          if (element.className.indexOf(value) >= 0) {
            element.className = element.className.replace(value, "");
          }
        }
        function toggleClass(element, value, added) {
          if (!value) {
            return;
          }
          if (isNumber2(element.length)) {
            forEach(element, function(elem) {
              toggleClass(elem, value, added);
            });
            return;
          }
          if (added) {
            addClass(element, value);
          } else {
            removeClass(element, value);
          }
        }
        var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
        function toParamCase(value) {
          return value.replace(REGEXP_CAMEL_CASE, "$1-$2").toLowerCase();
        }
        function getData(element, name2) {
          if (isObject2(element[name2])) {
            return element[name2];
          }
          if (element.dataset) {
            return element.dataset[name2];
          }
          return element.getAttribute("data-".concat(toParamCase(name2)));
        }
        function setData(element, name2, data) {
          if (isObject2(data)) {
            element[name2] = data;
          } else if (element.dataset) {
            element.dataset[name2] = data;
          } else {
            element.setAttribute("data-".concat(toParamCase(name2)), data);
          }
        }
        function removeData(element, name2) {
          if (isObject2(element[name2])) {
            try {
              delete element[name2];
            } catch (error3) {
              element[name2] = void 0;
            }
          } else if (element.dataset) {
            try {
              delete element.dataset[name2];
            } catch (error3) {
              element.dataset[name2] = void 0;
            }
          } else {
            element.removeAttribute("data-".concat(toParamCase(name2)));
          }
        }
        var REGEXP_SPACES = /\s\s*/;
        var onceSupported = function() {
          var supported = false;
          if (IS_BROWSER) {
            var once = false;
            var listener = function listener2() {
            };
            var options = Object.defineProperty({}, "once", {
              get: function get3() {
                supported = true;
                return once;
              },
              /**
               * This setter can fix a `TypeError` in strict mode
               * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
               * @param {boolean} value - The value to set
               */
              set: function set2(value) {
                once = value;
              }
            });
            WINDOW.addEventListener("test", listener, options);
            WINDOW.removeEventListener("test", listener, options);
          }
          return supported;
        }();
        function removeListener2(element, type, listener) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var handler = listener;
          type.trim().split(REGEXP_SPACES).forEach(function(event2) {
            if (!onceSupported) {
              var listeners = element.listeners;
              if (listeners && listeners[event2] && listeners[event2][listener]) {
                handler = listeners[event2][listener];
                delete listeners[event2][listener];
                if (Object.keys(listeners[event2]).length === 0) {
                  delete listeners[event2];
                }
                if (Object.keys(listeners).length === 0) {
                  delete element.listeners;
                }
              }
            }
            element.removeEventListener(event2, handler, options);
          });
        }
        function addListener2(element, type, listener) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var _handler = listener;
          type.trim().split(REGEXP_SPACES).forEach(function(event2) {
            if (options.once && !onceSupported) {
              var _element$listeners = element.listeners, listeners = _element$listeners === void 0 ? {} : _element$listeners;
              _handler = function handler() {
                delete listeners[event2][listener];
                element.removeEventListener(event2, _handler, options);
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                listener.apply(element, args);
              };
              if (!listeners[event2]) {
                listeners[event2] = {};
              }
              if (listeners[event2][listener]) {
                element.removeEventListener(event2, listeners[event2][listener], options);
              }
              listeners[event2][listener] = _handler;
              element.listeners = listeners;
            }
            element.addEventListener(event2, _handler, options);
          });
        }
        function dispatchEvent2(element, type, data) {
          var event2;
          if (isFunction2(Event) && isFunction2(CustomEvent)) {
            event2 = new CustomEvent(type, {
              detail: data,
              bubbles: true,
              cancelable: true
            });
          } else {
            event2 = document.createEvent("CustomEvent");
            event2.initCustomEvent(type, true, true, data);
          }
          return element.dispatchEvent(event2);
        }
        function getOffset(element) {
          var box = element.getBoundingClientRect();
          return {
            left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
            top: box.top + (window.pageYOffset - document.documentElement.clientTop)
          };
        }
        var location2 = WINDOW.location;
        var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
        function isCrossOriginURL(url) {
          var parts = url.match(REGEXP_ORIGINS);
          return parts !== null && (parts[1] !== location2.protocol || parts[2] !== location2.hostname || parts[3] !== location2.port);
        }
        function addTimestamp(url) {
          var timestamp = "timestamp=".concat((/* @__PURE__ */ new Date()).getTime());
          return url + (url.indexOf("?") === -1 ? "?" : "&") + timestamp;
        }
        function getTransforms(_ref) {
          var rotate2 = _ref.rotate, scaleX = _ref.scaleX, scaleY = _ref.scaleY, translateX = _ref.translateX, translateY = _ref.translateY;
          var values = [];
          if (isNumber2(translateX) && translateX !== 0) {
            values.push("translateX(".concat(translateX, "px)"));
          }
          if (isNumber2(translateY) && translateY !== 0) {
            values.push("translateY(".concat(translateY, "px)"));
          }
          if (isNumber2(rotate2) && rotate2 !== 0) {
            values.push("rotate(".concat(rotate2, "deg)"));
          }
          if (isNumber2(scaleX) && scaleX !== 1) {
            values.push("scaleX(".concat(scaleX, ")"));
          }
          if (isNumber2(scaleY) && scaleY !== 1) {
            values.push("scaleY(".concat(scaleY, ")"));
          }
          var transform = values.length ? values.join(" ") : "none";
          return {
            WebkitTransform: transform,
            msTransform: transform,
            transform
          };
        }
        function getMaxZoomRatio(pointers) {
          var pointers2 = _objectSpread2({}, pointers);
          var maxRatio = 0;
          forEach(pointers, function(pointer, pointerId) {
            delete pointers2[pointerId];
            forEach(pointers2, function(pointer2) {
              var x1 = Math.abs(pointer.startX - pointer2.startX);
              var y1 = Math.abs(pointer.startY - pointer2.startY);
              var x22 = Math.abs(pointer.endX - pointer2.endX);
              var y22 = Math.abs(pointer.endY - pointer2.endY);
              var z1 = Math.sqrt(x1 * x1 + y1 * y1);
              var z22 = Math.sqrt(x22 * x22 + y22 * y22);
              var ratio = (z22 - z1) / z1;
              if (Math.abs(ratio) > Math.abs(maxRatio)) {
                maxRatio = ratio;
              }
            });
          });
          return maxRatio;
        }
        function getPointer(_ref2, endOnly) {
          var pageX = _ref2.pageX, pageY = _ref2.pageY;
          var end2 = {
            endX: pageX,
            endY: pageY
          };
          return endOnly ? end2 : _objectSpread2({
            startX: pageX,
            startY: pageY
          }, end2);
        }
        function getPointersCenter(pointers) {
          var pageX = 0;
          var pageY = 0;
          var count = 0;
          forEach(pointers, function(_ref3) {
            var startX = _ref3.startX, startY = _ref3.startY;
            pageX += startX;
            pageY += startY;
            count += 1;
          });
          pageX /= count;
          pageY /= count;
          return {
            pageX,
            pageY
          };
        }
        function getAdjustedSizes(_ref4) {
          var aspectRatio = _ref4.aspectRatio, height = _ref4.height, width = _ref4.width;
          var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain";
          var isValidWidth = isPositiveNumber(width);
          var isValidHeight = isPositiveNumber(height);
          if (isValidWidth && isValidHeight) {
            var adjustedWidth = height * aspectRatio;
            if (type === "contain" && adjustedWidth > width || type === "cover" && adjustedWidth < width) {
              height = width / aspectRatio;
            } else {
              width = height * aspectRatio;
            }
          } else if (isValidWidth) {
            height = width / aspectRatio;
          } else if (isValidHeight) {
            width = height * aspectRatio;
          }
          return {
            width,
            height
          };
        }
        function getRotatedSizes(_ref5) {
          var width = _ref5.width, height = _ref5.height, degree = _ref5.degree;
          degree = Math.abs(degree) % 180;
          if (degree === 90) {
            return {
              width: height,
              height: width
            };
          }
          var arc = degree % 90 * Math.PI / 180;
          var sinArc = Math.sin(arc);
          var cosArc = Math.cos(arc);
          var newWidth = width * cosArc + height * sinArc;
          var newHeight = width * sinArc + height * cosArc;
          return degree > 90 ? {
            width: newHeight,
            height: newWidth
          } : {
            width: newWidth,
            height: newHeight
          };
        }
        function getSourceCanvas(image, _ref6, _ref7, _ref8) {
          var imageAspectRatio = _ref6.aspectRatio, imageNaturalWidth = _ref6.naturalWidth, imageNaturalHeight = _ref6.naturalHeight, _ref6$rotate = _ref6.rotate, rotate2 = _ref6$rotate === void 0 ? 0 : _ref6$rotate, _ref6$scaleX = _ref6.scaleX, scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX, _ref6$scaleY = _ref6.scaleY, scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
          var aspectRatio = _ref7.aspectRatio, naturalWidth = _ref7.naturalWidth, naturalHeight = _ref7.naturalHeight;
          var _ref8$fillColor = _ref8.fillColor, fillColor = _ref8$fillColor === void 0 ? "transparent" : _ref8$fillColor, _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled, imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE, _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality, imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? "low" : _ref8$imageSmoothingQ, _ref8$maxWidth = _ref8.maxWidth, maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth, _ref8$maxHeight = _ref8.maxHeight, maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight, _ref8$minWidth = _ref8.minWidth, minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth, _ref8$minHeight = _ref8.minHeight, minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
          var canvas = document.createElement("canvas");
          var context2 = canvas.getContext("2d");
          var maxSizes = getAdjustedSizes({
            aspectRatio,
            width: maxWidth,
            height: maxHeight
          });
          var minSizes = getAdjustedSizes({
            aspectRatio,
            width: minWidth,
            height: minHeight
          }, "cover");
          var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
          var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));
          var destMaxSizes = getAdjustedSizes({
            aspectRatio: imageAspectRatio,
            width: maxWidth,
            height: maxHeight
          });
          var destMinSizes = getAdjustedSizes({
            aspectRatio: imageAspectRatio,
            width: minWidth,
            height: minHeight
          }, "cover");
          var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
          var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
          var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
          canvas.width = normalizeDecimalNumber(width);
          canvas.height = normalizeDecimalNumber(height);
          context2.fillStyle = fillColor;
          context2.fillRect(0, 0, width, height);
          context2.save();
          context2.translate(width / 2, height / 2);
          context2.rotate(rotate2 * Math.PI / 180);
          context2.scale(scaleX, scaleY);
          context2.imageSmoothingEnabled = imageSmoothingEnabled;
          context2.imageSmoothingQuality = imageSmoothingQuality;
          context2.drawImage.apply(context2, [image].concat(_toConsumableArray(params.map(function(param2) {
            return Math.floor(normalizeDecimalNumber(param2));
          }))));
          context2.restore();
          return canvas;
        }
        var fromCharCode = String.fromCharCode;
        function getStringFromCharCode(dataView, start5, length) {
          var str = "";
          length += start5;
          for (var i3 = start5; i3 < length; i3 += 1) {
            str += fromCharCode(dataView.getUint8(i3));
          }
          return str;
        }
        var REGEXP_DATA_URL_HEAD = /^data:.*,/;
        function dataURLToArrayBuffer(dataURL) {
          var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, "");
          var binary = atob(base64);
          var arrayBuffer = new ArrayBuffer(binary.length);
          var uint8 = new Uint8Array(arrayBuffer);
          forEach(uint8, function(value, i3) {
            uint8[i3] = binary.charCodeAt(i3);
          });
          return arrayBuffer;
        }
        function arrayBufferToDataURL(arrayBuffer, mimeType) {
          var chunks = [];
          var chunkSize = 8192;
          var uint8 = new Uint8Array(arrayBuffer);
          while (uint8.length > 0) {
            chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
            uint8 = uint8.subarray(chunkSize);
          }
          return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join("")));
        }
        function resetAndGetOrientation(arrayBuffer) {
          var dataView = new DataView(arrayBuffer);
          var orientation;
          try {
            var littleEndian;
            var app1Start;
            var ifdStart;
            if (dataView.getUint8(0) === 255 && dataView.getUint8(1) === 216) {
              var length = dataView.byteLength;
              var offset3 = 2;
              while (offset3 + 1 < length) {
                if (dataView.getUint8(offset3) === 255 && dataView.getUint8(offset3 + 1) === 225) {
                  app1Start = offset3;
                  break;
                }
                offset3 += 1;
              }
            }
            if (app1Start) {
              var exifIDCode = app1Start + 4;
              var tiffOffset = app1Start + 10;
              if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
                var endianness = dataView.getUint16(tiffOffset);
                littleEndian = endianness === 18761;
                if (littleEndian || endianness === 19789) {
                  if (dataView.getUint16(tiffOffset + 2, littleEndian) === 42) {
                    var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
                    if (firstIFDOffset >= 8) {
                      ifdStart = tiffOffset + firstIFDOffset;
                    }
                  }
                }
              }
            }
            if (ifdStart) {
              var _length = dataView.getUint16(ifdStart, littleEndian);
              var _offset;
              var i3;
              for (i3 = 0; i3 < _length; i3 += 1) {
                _offset = ifdStart + i3 * 12 + 2;
                if (dataView.getUint16(_offset, littleEndian) === 274) {
                  _offset += 8;
                  orientation = dataView.getUint16(_offset, littleEndian);
                  dataView.setUint16(_offset, 1, littleEndian);
                  break;
                }
              }
            }
          } catch (error3) {
            orientation = 1;
          }
          return orientation;
        }
        function parseOrientation(orientation) {
          var rotate2 = 0;
          var scaleX = 1;
          var scaleY = 1;
          switch (orientation) {
            // Flip horizontal
            case 2:
              scaleX = -1;
              break;
            // Rotate left 180
            case 3:
              rotate2 = -180;
              break;
            // Flip vertical
            case 4:
              scaleY = -1;
              break;
            // Flip vertical and rotate right 90
            case 5:
              rotate2 = 90;
              scaleY = -1;
              break;
            // Rotate right 90
            case 6:
              rotate2 = 90;
              break;
            // Flip horizontal and rotate right 90
            case 7:
              rotate2 = 90;
              scaleX = -1;
              break;
            // Rotate left 90
            case 8:
              rotate2 = -90;
              break;
          }
          return {
            rotate: rotate2,
            scaleX,
            scaleY
          };
        }
        var render2 = {
          render: function render3() {
            this.initContainer();
            this.initCanvas();
            this.initCropBox();
            this.renderCanvas();
            if (this.cropped) {
              this.renderCropBox();
            }
          },
          initContainer: function initContainer() {
            var element = this.element, options = this.options, container = this.container, cropper = this.cropper;
            var minWidth = Number(options.minContainerWidth);
            var minHeight = Number(options.minContainerHeight);
            addClass(cropper, CLASS_HIDDEN);
            removeClass(element, CLASS_HIDDEN);
            var containerData = {
              width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),
              height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)
            };
            this.containerData = containerData;
            setStyle2(cropper, {
              width: containerData.width,
              height: containerData.height
            });
            addClass(element, CLASS_HIDDEN);
            removeClass(cropper, CLASS_HIDDEN);
          },
          // Canvas (image wrapper)
          initCanvas: function initCanvas2() {
            var containerData = this.containerData, imageData = this.imageData;
            var viewMode = this.options.viewMode;
            var rotated = Math.abs(imageData.rotate) % 180 === 90;
            var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
            var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
            var aspectRatio = naturalWidth / naturalHeight;
            var canvasWidth = containerData.width;
            var canvasHeight = containerData.height;
            if (containerData.height * aspectRatio > containerData.width) {
              if (viewMode === 3) {
                canvasWidth = containerData.height * aspectRatio;
              } else {
                canvasHeight = containerData.width / aspectRatio;
              }
            } else if (viewMode === 3) {
              canvasHeight = containerData.width / aspectRatio;
            } else {
              canvasWidth = containerData.height * aspectRatio;
            }
            var canvasData = {
              aspectRatio,
              naturalWidth,
              naturalHeight,
              width: canvasWidth,
              height: canvasHeight
            };
            this.canvasData = canvasData;
            this.limited = viewMode === 1 || viewMode === 2;
            this.limitCanvas(true, true);
            canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
            canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
            canvasData.left = (containerData.width - canvasData.width) / 2;
            canvasData.top = (containerData.height - canvasData.height) / 2;
            canvasData.oldLeft = canvasData.left;
            canvasData.oldTop = canvasData.top;
            this.initialCanvasData = assign2({}, canvasData);
          },
          limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
            var options = this.options, containerData = this.containerData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
            var viewMode = options.viewMode;
            var aspectRatio = canvasData.aspectRatio;
            var cropped = this.cropped && cropBoxData;
            if (sizeLimited) {
              var minCanvasWidth = Number(options.minCanvasWidth) || 0;
              var minCanvasHeight = Number(options.minCanvasHeight) || 0;
              if (viewMode > 1) {
                minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
                minCanvasHeight = Math.max(minCanvasHeight, containerData.height);
                if (viewMode === 3) {
                  if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                    minCanvasWidth = minCanvasHeight * aspectRatio;
                  } else {
                    minCanvasHeight = minCanvasWidth / aspectRatio;
                  }
                }
              } else if (viewMode > 0) {
                if (minCanvasWidth) {
                  minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
                } else if (minCanvasHeight) {
                  minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
                } else if (cropped) {
                  minCanvasWidth = cropBoxData.width;
                  minCanvasHeight = cropBoxData.height;
                  if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                    minCanvasWidth = minCanvasHeight * aspectRatio;
                  } else {
                    minCanvasHeight = minCanvasWidth / aspectRatio;
                  }
                }
              }
              var _getAdjustedSizes = getAdjustedSizes({
                aspectRatio,
                width: minCanvasWidth,
                height: minCanvasHeight
              });
              minCanvasWidth = _getAdjustedSizes.width;
              minCanvasHeight = _getAdjustedSizes.height;
              canvasData.minWidth = minCanvasWidth;
              canvasData.minHeight = minCanvasHeight;
              canvasData.maxWidth = Infinity;
              canvasData.maxHeight = Infinity;
            }
            if (positionLimited) {
              if (viewMode > (cropped ? 0 : 1)) {
                var newCanvasLeft = containerData.width - canvasData.width;
                var newCanvasTop = containerData.height - canvasData.height;
                canvasData.minLeft = Math.min(0, newCanvasLeft);
                canvasData.minTop = Math.min(0, newCanvasTop);
                canvasData.maxLeft = Math.max(0, newCanvasLeft);
                canvasData.maxTop = Math.max(0, newCanvasTop);
                if (cropped && this.limited) {
                  canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
                  canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
                  canvasData.maxLeft = cropBoxData.left;
                  canvasData.maxTop = cropBoxData.top;
                  if (viewMode === 2) {
                    if (canvasData.width >= containerData.width) {
                      canvasData.minLeft = Math.min(0, newCanvasLeft);
                      canvasData.maxLeft = Math.max(0, newCanvasLeft);
                    }
                    if (canvasData.height >= containerData.height) {
                      canvasData.minTop = Math.min(0, newCanvasTop);
                      canvasData.maxTop = Math.max(0, newCanvasTop);
                    }
                  }
                }
              } else {
                canvasData.minLeft = -canvasData.width;
                canvasData.minTop = -canvasData.height;
                canvasData.maxLeft = containerData.width;
                canvasData.maxTop = containerData.height;
              }
            }
          },
          renderCanvas: function renderCanvas(changed, transformed) {
            var canvasData = this.canvasData, imageData = this.imageData;
            if (transformed) {
              var _getRotatedSizes = getRotatedSizes({
                width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
                height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
                degree: imageData.rotate || 0
              }), naturalWidth = _getRotatedSizes.width, naturalHeight = _getRotatedSizes.height;
              var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
              var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
              canvasData.left -= (width - canvasData.width) / 2;
              canvasData.top -= (height - canvasData.height) / 2;
              canvasData.width = width;
              canvasData.height = height;
              canvasData.aspectRatio = naturalWidth / naturalHeight;
              canvasData.naturalWidth = naturalWidth;
              canvasData.naturalHeight = naturalHeight;
              this.limitCanvas(true, false);
            }
            if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
              canvasData.left = canvasData.oldLeft;
            }
            if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
              canvasData.top = canvasData.oldTop;
            }
            canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
            canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
            this.limitCanvas(false, true);
            canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
            canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
            canvasData.oldLeft = canvasData.left;
            canvasData.oldTop = canvasData.top;
            setStyle2(this.canvas, assign2({
              width: canvasData.width,
              height: canvasData.height
            }, getTransforms({
              translateX: canvasData.left,
              translateY: canvasData.top
            })));
            this.renderImage(changed);
            if (this.cropped && this.limited) {
              this.limitCropBox(true, true);
            }
          },
          renderImage: function renderImage(changed) {
            var canvasData = this.canvasData, imageData = this.imageData;
            var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
            var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
            assign2(imageData, {
              width,
              height,
              left: (canvasData.width - width) / 2,
              top: (canvasData.height - height) / 2
            });
            setStyle2(this.image, assign2({
              width: imageData.width,
              height: imageData.height
            }, getTransforms(assign2({
              translateX: imageData.left,
              translateY: imageData.top
            }, imageData))));
            if (changed) {
              this.output();
            }
          },
          initCropBox: function initCropBox() {
            var options = this.options, canvasData = this.canvasData;
            var aspectRatio = options.aspectRatio || options.initialAspectRatio;
            var autoCropArea = Number(options.autoCropArea) || 0.8;
            var cropBoxData = {
              width: canvasData.width,
              height: canvasData.height
            };
            if (aspectRatio) {
              if (canvasData.height * aspectRatio > canvasData.width) {
                cropBoxData.height = cropBoxData.width / aspectRatio;
              } else {
                cropBoxData.width = cropBoxData.height * aspectRatio;
              }
            }
            this.cropBoxData = cropBoxData;
            this.limitCropBox(true, true);
            cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
            cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
            cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
            cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
            cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
            cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
            cropBoxData.oldLeft = cropBoxData.left;
            cropBoxData.oldTop = cropBoxData.top;
            this.initialCropBoxData = assign2({}, cropBoxData);
          },
          limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
            var options = this.options, containerData = this.containerData, canvasData = this.canvasData, cropBoxData = this.cropBoxData, limited = this.limited;
            var aspectRatio = options.aspectRatio;
            if (sizeLimited) {
              var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
              var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
              var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
              var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height;
              minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
              minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);
              if (aspectRatio) {
                if (minCropBoxWidth && minCropBoxHeight) {
                  if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
                    minCropBoxHeight = minCropBoxWidth / aspectRatio;
                  } else {
                    minCropBoxWidth = minCropBoxHeight * aspectRatio;
                  }
                } else if (minCropBoxWidth) {
                  minCropBoxHeight = minCropBoxWidth / aspectRatio;
                } else if (minCropBoxHeight) {
                  minCropBoxWidth = minCropBoxHeight * aspectRatio;
                }
                if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
                  maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
                } else {
                  maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
                }
              }
              cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
              cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
              cropBoxData.maxWidth = maxCropBoxWidth;
              cropBoxData.maxHeight = maxCropBoxHeight;
            }
            if (positionLimited) {
              if (limited) {
                cropBoxData.minLeft = Math.max(0, canvasData.left);
                cropBoxData.minTop = Math.max(0, canvasData.top);
                cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
                cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
              } else {
                cropBoxData.minLeft = 0;
                cropBoxData.minTop = 0;
                cropBoxData.maxLeft = containerData.width - cropBoxData.width;
                cropBoxData.maxTop = containerData.height - cropBoxData.height;
              }
            }
          },
          renderCropBox: function renderCropBox() {
            var options = this.options, containerData = this.containerData, cropBoxData = this.cropBoxData;
            if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
              cropBoxData.left = cropBoxData.oldLeft;
            }
            if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
              cropBoxData.top = cropBoxData.oldTop;
            }
            cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
            cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
            this.limitCropBox(false, true);
            cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
            cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
            cropBoxData.oldLeft = cropBoxData.left;
            cropBoxData.oldTop = cropBoxData.top;
            if (options.movable && options.cropBoxMovable) {
              setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
            }
            setStyle2(this.cropBox, assign2({
              width: cropBoxData.width,
              height: cropBoxData.height
            }, getTransforms({
              translateX: cropBoxData.left,
              translateY: cropBoxData.top
            })));
            if (this.cropped && this.limited) {
              this.limitCanvas(true, true);
            }
            if (!this.disabled) {
              this.output();
            }
          },
          output: function output2() {
            this.preview();
            dispatchEvent2(this.element, EVENT_CROP, this.getData());
          }
        };
        var preview = {
          initPreview: function initPreview() {
            var element = this.element, crossOrigin = this.crossOrigin;
            var preview2 = this.options.preview;
            var url = crossOrigin ? this.crossOriginUrl : this.url;
            var alt = element.alt || "The image to preview";
            var image = document.createElement("img");
            if (crossOrigin) {
              image.crossOrigin = crossOrigin;
            }
            image.src = url;
            image.alt = alt;
            this.viewBox.appendChild(image);
            this.viewBoxImage = image;
            if (!preview2) {
              return;
            }
            var previews = preview2;
            if (typeof preview2 === "string") {
              previews = element.ownerDocument.querySelectorAll(preview2);
            } else if (preview2.querySelector) {
              previews = [preview2];
            }
            this.previews = previews;
            forEach(previews, function(el) {
              var img = document.createElement("img");
              setData(el, DATA_PREVIEW, {
                width: el.offsetWidth,
                height: el.offsetHeight,
                html: el.innerHTML
              });
              if (crossOrigin) {
                img.crossOrigin = crossOrigin;
              }
              img.src = url;
              img.alt = alt;
              img.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"';
              el.innerHTML = "";
              el.appendChild(img);
            });
          },
          resetPreview: function resetPreview() {
            forEach(this.previews, function(element) {
              var data = getData(element, DATA_PREVIEW);
              setStyle2(element, {
                width: data.width,
                height: data.height
              });
              element.innerHTML = data.html;
              removeData(element, DATA_PREVIEW);
            });
          },
          preview: function preview2() {
            var imageData = this.imageData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
            var cropBoxWidth = cropBoxData.width, cropBoxHeight = cropBoxData.height;
            var width = imageData.width, height = imageData.height;
            var left2 = cropBoxData.left - canvasData.left - imageData.left;
            var top2 = cropBoxData.top - canvasData.top - imageData.top;
            if (!this.cropped || this.disabled) {
              return;
            }
            setStyle2(this.viewBoxImage, assign2({
              width,
              height
            }, getTransforms(assign2({
              translateX: -left2,
              translateY: -top2
            }, imageData))));
            forEach(this.previews, function(element) {
              var data = getData(element, DATA_PREVIEW);
              var originalWidth = data.width;
              var originalHeight = data.height;
              var newWidth = originalWidth;
              var newHeight = originalHeight;
              var ratio = 1;
              if (cropBoxWidth) {
                ratio = originalWidth / cropBoxWidth;
                newHeight = cropBoxHeight * ratio;
              }
              if (cropBoxHeight && newHeight > originalHeight) {
                ratio = originalHeight / cropBoxHeight;
                newWidth = cropBoxWidth * ratio;
                newHeight = originalHeight;
              }
              setStyle2(element, {
                width: newWidth,
                height: newHeight
              });
              setStyle2(element.getElementsByTagName("img")[0], assign2({
                width: width * ratio,
                height: height * ratio
              }, getTransforms(assign2({
                translateX: -left2 * ratio,
                translateY: -top2 * ratio
              }, imageData))));
            });
          }
        };
        var events = {
          bind: function bind() {
            var element = this.element, options = this.options, cropper = this.cropper;
            if (isFunction2(options.cropstart)) {
              addListener2(element, EVENT_CROP_START, options.cropstart);
            }
            if (isFunction2(options.cropmove)) {
              addListener2(element, EVENT_CROP_MOVE, options.cropmove);
            }
            if (isFunction2(options.cropend)) {
              addListener2(element, EVENT_CROP_END, options.cropend);
            }
            if (isFunction2(options.crop)) {
              addListener2(element, EVENT_CROP, options.crop);
            }
            if (isFunction2(options.zoom)) {
              addListener2(element, EVENT_ZOOM, options.zoom);
            }
            addListener2(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));
            if (options.zoomable && options.zoomOnWheel) {
              addListener2(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
                passive: false,
                capture: true
              });
            }
            if (options.toggleDragModeOnDblclick) {
              addListener2(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
            }
            addListener2(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
            addListener2(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));
            if (options.responsive) {
              addListener2(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
            }
          },
          unbind: function unbind() {
            var element = this.element, options = this.options, cropper = this.cropper;
            if (isFunction2(options.cropstart)) {
              removeListener2(element, EVENT_CROP_START, options.cropstart);
            }
            if (isFunction2(options.cropmove)) {
              removeListener2(element, EVENT_CROP_MOVE, options.cropmove);
            }
            if (isFunction2(options.cropend)) {
              removeListener2(element, EVENT_CROP_END, options.cropend);
            }
            if (isFunction2(options.crop)) {
              removeListener2(element, EVENT_CROP, options.crop);
            }
            if (isFunction2(options.zoom)) {
              removeListener2(element, EVENT_ZOOM, options.zoom);
            }
            removeListener2(cropper, EVENT_POINTER_DOWN, this.onCropStart);
            if (options.zoomable && options.zoomOnWheel) {
              removeListener2(cropper, EVENT_WHEEL, this.onWheel, {
                passive: false,
                capture: true
              });
            }
            if (options.toggleDragModeOnDblclick) {
              removeListener2(cropper, EVENT_DBLCLICK, this.onDblclick);
            }
            removeListener2(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
            removeListener2(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);
            if (options.responsive) {
              removeListener2(window, EVENT_RESIZE, this.onResize);
            }
          }
        };
        var handlers = {
          resize: function resize() {
            if (this.disabled) {
              return;
            }
            var options = this.options, container = this.container, containerData = this.containerData;
            var ratioX = container.offsetWidth / containerData.width;
            var ratioY = container.offsetHeight / containerData.height;
            var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY;
            if (ratio !== 1) {
              var canvasData;
              var cropBoxData;
              if (options.restore) {
                canvasData = this.getCanvasData();
                cropBoxData = this.getCropBoxData();
              }
              this.render();
              if (options.restore) {
                this.setCanvasData(forEach(canvasData, function(n3, i3) {
                  canvasData[i3] = n3 * ratio;
                }));
                this.setCropBoxData(forEach(cropBoxData, function(n3, i3) {
                  cropBoxData[i3] = n3 * ratio;
                }));
              }
            }
          },
          dblclick: function dblclick() {
            if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
              return;
            }
            this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
          },
          wheel: function wheel(event2) {
            var _this = this;
            var ratio = Number(this.options.wheelZoomRatio) || 0.1;
            var delta = 1;
            if (this.disabled) {
              return;
            }
            event2.preventDefault();
            if (this.wheeling) {
              return;
            }
            this.wheeling = true;
            setTimeout(function() {
              _this.wheeling = false;
            }, 50);
            if (event2.deltaY) {
              delta = event2.deltaY > 0 ? 1 : -1;
            } else if (event2.wheelDelta) {
              delta = -event2.wheelDelta / 120;
            } else if (event2.detail) {
              delta = event2.detail > 0 ? 1 : -1;
            }
            this.zoom(-delta * ratio, event2);
          },
          cropStart: function cropStart(event2) {
            var buttons = event2.buttons, button = event2.button;
            if (this.disabled || (event2.type === "mousedown" || event2.type === "pointerdown" && event2.pointerType === "mouse") && // No primary button (Usually the left button)
            (isNumber2(buttons) && buttons !== 1 || isNumber2(button) && button !== 0 || event2.ctrlKey)) {
              return;
            }
            var options = this.options, pointers = this.pointers;
            var action;
            if (event2.changedTouches) {
              forEach(event2.changedTouches, function(touch) {
                pointers[touch.identifier] = getPointer(touch);
              });
            } else {
              pointers[event2.pointerId || 0] = getPointer(event2);
            }
            if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
              action = ACTION_ZOOM;
            } else {
              action = getData(event2.target, DATA_ACTION);
            }
            if (!REGEXP_ACTIONS.test(action)) {
              return;
            }
            if (dispatchEvent2(this.element, EVENT_CROP_START, {
              originalEvent: event2,
              action
            }) === false) {
              return;
            }
            event2.preventDefault();
            this.action = action;
            this.cropping = false;
            if (action === ACTION_CROP) {
              this.cropping = true;
              addClass(this.dragBox, CLASS_MODAL);
            }
          },
          cropMove: function cropMove(event2) {
            var action = this.action;
            if (this.disabled || !action) {
              return;
            }
            var pointers = this.pointers;
            event2.preventDefault();
            if (dispatchEvent2(this.element, EVENT_CROP_MOVE, {
              originalEvent: event2,
              action
            }) === false) {
              return;
            }
            if (event2.changedTouches) {
              forEach(event2.changedTouches, function(touch) {
                assign2(pointers[touch.identifier] || {}, getPointer(touch, true));
              });
            } else {
              assign2(pointers[event2.pointerId || 0] || {}, getPointer(event2, true));
            }
            this.change(event2);
          },
          cropEnd: function cropEnd(event2) {
            if (this.disabled) {
              return;
            }
            var action = this.action, pointers = this.pointers;
            if (event2.changedTouches) {
              forEach(event2.changedTouches, function(touch) {
                delete pointers[touch.identifier];
              });
            } else {
              delete pointers[event2.pointerId || 0];
            }
            if (!action) {
              return;
            }
            event2.preventDefault();
            if (!Object.keys(pointers).length) {
              this.action = "";
            }
            if (this.cropping) {
              this.cropping = false;
              toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
            }
            dispatchEvent2(this.element, EVENT_CROP_END, {
              originalEvent: event2,
              action
            });
          }
        };
        var change = {
          change: function change2(event2) {
            var options = this.options, canvasData = this.canvasData, containerData = this.containerData, cropBoxData = this.cropBoxData, pointers = this.pointers;
            var action = this.action;
            var aspectRatio = options.aspectRatio;
            var left2 = cropBoxData.left, top2 = cropBoxData.top, width = cropBoxData.width, height = cropBoxData.height;
            var right2 = left2 + width;
            var bottom2 = top2 + height;
            var minLeft = 0;
            var minTop = 0;
            var maxWidth = containerData.width;
            var maxHeight = containerData.height;
            var renderable = true;
            var offset3;
            if (!aspectRatio && event2.shiftKey) {
              aspectRatio = width && height ? width / height : 1;
            }
            if (this.limited) {
              minLeft = cropBoxData.minLeft;
              minTop = cropBoxData.minTop;
              maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
              maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
            }
            var pointer = pointers[Object.keys(pointers)[0]];
            var range2 = {
              x: pointer.endX - pointer.startX,
              y: pointer.endY - pointer.startY
            };
            var check = function check2(side) {
              switch (side) {
                case ACTION_EAST:
                  if (right2 + range2.x > maxWidth) {
                    range2.x = maxWidth - right2;
                  }
                  break;
                case ACTION_WEST:
                  if (left2 + range2.x < minLeft) {
                    range2.x = minLeft - left2;
                  }
                  break;
                case ACTION_NORTH:
                  if (top2 + range2.y < minTop) {
                    range2.y = minTop - top2;
                  }
                  break;
                case ACTION_SOUTH:
                  if (bottom2 + range2.y > maxHeight) {
                    range2.y = maxHeight - bottom2;
                  }
                  break;
              }
            };
            switch (action) {
              // Move crop box
              case ACTION_ALL:
                left2 += range2.x;
                top2 += range2.y;
                break;
              // Resize crop box
              case ACTION_EAST:
                if (range2.x >= 0 && (right2 >= maxWidth || aspectRatio && (top2 <= minTop || bottom2 >= maxHeight))) {
                  renderable = false;
                  break;
                }
                check(ACTION_EAST);
                width += range2.x;
                if (width < 0) {
                  action = ACTION_WEST;
                  width = -width;
                  left2 -= width;
                }
                if (aspectRatio) {
                  height = width / aspectRatio;
                  top2 += (cropBoxData.height - height) / 2;
                }
                break;
              case ACTION_NORTH:
                if (range2.y <= 0 && (top2 <= minTop || aspectRatio && (left2 <= minLeft || right2 >= maxWidth))) {
                  renderable = false;
                  break;
                }
                check(ACTION_NORTH);
                height -= range2.y;
                top2 += range2.y;
                if (height < 0) {
                  action = ACTION_SOUTH;
                  height = -height;
                  top2 -= height;
                }
                if (aspectRatio) {
                  width = height * aspectRatio;
                  left2 += (cropBoxData.width - width) / 2;
                }
                break;
              case ACTION_WEST:
                if (range2.x <= 0 && (left2 <= minLeft || aspectRatio && (top2 <= minTop || bottom2 >= maxHeight))) {
                  renderable = false;
                  break;
                }
                check(ACTION_WEST);
                width -= range2.x;
                left2 += range2.x;
                if (width < 0) {
                  action = ACTION_EAST;
                  width = -width;
                  left2 -= width;
                }
                if (aspectRatio) {
                  height = width / aspectRatio;
                  top2 += (cropBoxData.height - height) / 2;
                }
                break;
              case ACTION_SOUTH:
                if (range2.y >= 0 && (bottom2 >= maxHeight || aspectRatio && (left2 <= minLeft || right2 >= maxWidth))) {
                  renderable = false;
                  break;
                }
                check(ACTION_SOUTH);
                height += range2.y;
                if (height < 0) {
                  action = ACTION_NORTH;
                  height = -height;
                  top2 -= height;
                }
                if (aspectRatio) {
                  width = height * aspectRatio;
                  left2 += (cropBoxData.width - width) / 2;
                }
                break;
              case ACTION_NORTH_EAST:
                if (aspectRatio) {
                  if (range2.y <= 0 && (top2 <= minTop || right2 >= maxWidth)) {
                    renderable = false;
                    break;
                  }
                  check(ACTION_NORTH);
                  height -= range2.y;
                  top2 += range2.y;
                  width = height * aspectRatio;
                } else {
                  check(ACTION_NORTH);
                  check(ACTION_EAST);
                  if (range2.x >= 0) {
                    if (right2 < maxWidth) {
                      width += range2.x;
                    } else if (range2.y <= 0 && top2 <= minTop) {
                      renderable = false;
                    }
                  } else {
                    width += range2.x;
                  }
                  if (range2.y <= 0) {
                    if (top2 > minTop) {
                      height -= range2.y;
                      top2 += range2.y;
                    }
                  } else {
                    height -= range2.y;
                    top2 += range2.y;
                  }
                }
                if (width < 0 && height < 0) {
                  action = ACTION_SOUTH_WEST;
                  height = -height;
                  width = -width;
                  top2 -= height;
                  left2 -= width;
                } else if (width < 0) {
                  action = ACTION_NORTH_WEST;
                  width = -width;
                  left2 -= width;
                } else if (height < 0) {
                  action = ACTION_SOUTH_EAST;
                  height = -height;
                  top2 -= height;
                }
                break;
              case ACTION_NORTH_WEST:
                if (aspectRatio) {
                  if (range2.y <= 0 && (top2 <= minTop || left2 <= minLeft)) {
                    renderable = false;
                    break;
                  }
                  check(ACTION_NORTH);
                  height -= range2.y;
                  top2 += range2.y;
                  width = height * aspectRatio;
                  left2 += cropBoxData.width - width;
                } else {
                  check(ACTION_NORTH);
                  check(ACTION_WEST);
                  if (range2.x <= 0) {
                    if (left2 > minLeft) {
                      width -= range2.x;
                      left2 += range2.x;
                    } else if (range2.y <= 0 && top2 <= minTop) {
                      renderable = false;
                    }
                  } else {
                    width -= range2.x;
                    left2 += range2.x;
                  }
                  if (range2.y <= 0) {
                    if (top2 > minTop) {
                      height -= range2.y;
                      top2 += range2.y;
                    }
                  } else {
                    height -= range2.y;
                    top2 += range2.y;
                  }
                }
                if (width < 0 && height < 0) {
                  action = ACTION_SOUTH_EAST;
                  height = -height;
                  width = -width;
                  top2 -= height;
                  left2 -= width;
                } else if (width < 0) {
                  action = ACTION_NORTH_EAST;
                  width = -width;
                  left2 -= width;
                } else if (height < 0) {
                  action = ACTION_SOUTH_WEST;
                  height = -height;
                  top2 -= height;
                }
                break;
              case ACTION_SOUTH_WEST:
                if (aspectRatio) {
                  if (range2.x <= 0 && (left2 <= minLeft || bottom2 >= maxHeight)) {
                    renderable = false;
                    break;
                  }
                  check(ACTION_WEST);
                  width -= range2.x;
                  left2 += range2.x;
                  height = width / aspectRatio;
                } else {
                  check(ACTION_SOUTH);
                  check(ACTION_WEST);
                  if (range2.x <= 0) {
                    if (left2 > minLeft) {
                      width -= range2.x;
                      left2 += range2.x;
                    } else if (range2.y >= 0 && bottom2 >= maxHeight) {
                      renderable = false;
                    }
                  } else {
                    width -= range2.x;
                    left2 += range2.x;
                  }
                  if (range2.y >= 0) {
                    if (bottom2 < maxHeight) {
                      height += range2.y;
                    }
                  } else {
                    height += range2.y;
                  }
                }
                if (width < 0 && height < 0) {
                  action = ACTION_NORTH_EAST;
                  height = -height;
                  width = -width;
                  top2 -= height;
                  left2 -= width;
                } else if (width < 0) {
                  action = ACTION_SOUTH_EAST;
                  width = -width;
                  left2 -= width;
                } else if (height < 0) {
                  action = ACTION_NORTH_WEST;
                  height = -height;
                  top2 -= height;
                }
                break;
              case ACTION_SOUTH_EAST:
                if (aspectRatio) {
                  if (range2.x >= 0 && (right2 >= maxWidth || bottom2 >= maxHeight)) {
                    renderable = false;
                    break;
                  }
                  check(ACTION_EAST);
                  width += range2.x;
                  height = width / aspectRatio;
                } else {
                  check(ACTION_SOUTH);
                  check(ACTION_EAST);
                  if (range2.x >= 0) {
                    if (right2 < maxWidth) {
                      width += range2.x;
                    } else if (range2.y >= 0 && bottom2 >= maxHeight) {
                      renderable = false;
                    }
                  } else {
                    width += range2.x;
                  }
                  if (range2.y >= 0) {
                    if (bottom2 < maxHeight) {
                      height += range2.y;
                    }
                  } else {
                    height += range2.y;
                  }
                }
                if (width < 0 && height < 0) {
                  action = ACTION_NORTH_WEST;
                  height = -height;
                  width = -width;
                  top2 -= height;
                  left2 -= width;
                } else if (width < 0) {
                  action = ACTION_SOUTH_WEST;
                  width = -width;
                  left2 -= width;
                } else if (height < 0) {
                  action = ACTION_NORTH_EAST;
                  height = -height;
                  top2 -= height;
                }
                break;
              // Move canvas
              case ACTION_MOVE:
                this.move(range2.x, range2.y);
                renderable = false;
                break;
              // Zoom canvas
              case ACTION_ZOOM:
                this.zoom(getMaxZoomRatio(pointers), event2);
                renderable = false;
                break;
              // Create crop box
              case ACTION_CROP:
                if (!range2.x || !range2.y) {
                  renderable = false;
                  break;
                }
                offset3 = getOffset(this.cropper);
                left2 = pointer.startX - offset3.left;
                top2 = pointer.startY - offset3.top;
                width = cropBoxData.minWidth;
                height = cropBoxData.minHeight;
                if (range2.x > 0) {
                  action = range2.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
                } else if (range2.x < 0) {
                  left2 -= width;
                  action = range2.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
                }
                if (range2.y < 0) {
                  top2 -= height;
                }
                if (!this.cropped) {
                  removeClass(this.cropBox, CLASS_HIDDEN);
                  this.cropped = true;
                  if (this.limited) {
                    this.limitCropBox(true, true);
                  }
                }
                break;
            }
            if (renderable) {
              cropBoxData.width = width;
              cropBoxData.height = height;
              cropBoxData.left = left2;
              cropBoxData.top = top2;
              this.action = action;
              this.renderCropBox();
            }
            forEach(pointers, function(p4) {
              p4.startX = p4.endX;
              p4.startY = p4.endY;
            });
          }
        };
        var methods = {
          // Show the crop box manually
          crop: function crop() {
            if (this.ready && !this.cropped && !this.disabled) {
              this.cropped = true;
              this.limitCropBox(true, true);
              if (this.options.modal) {
                addClass(this.dragBox, CLASS_MODAL);
              }
              removeClass(this.cropBox, CLASS_HIDDEN);
              this.setCropBoxData(this.initialCropBoxData);
            }
            return this;
          },
          // Reset the image and crop box to their initial states
          reset: function reset() {
            if (this.ready && !this.disabled) {
              this.imageData = assign2({}, this.initialImageData);
              this.canvasData = assign2({}, this.initialCanvasData);
              this.cropBoxData = assign2({}, this.initialCropBoxData);
              this.renderCanvas();
              if (this.cropped) {
                this.renderCropBox();
              }
            }
            return this;
          },
          // Clear the crop box
          clear: function clear() {
            if (this.cropped && !this.disabled) {
              assign2(this.cropBoxData, {
                left: 0,
                top: 0,
                width: 0,
                height: 0
              });
              this.cropped = false;
              this.renderCropBox();
              this.limitCanvas(true, true);
              this.renderCanvas();
              removeClass(this.dragBox, CLASS_MODAL);
              addClass(this.cropBox, CLASS_HIDDEN);
            }
            return this;
          },
          /**
           * Replace the image's src and rebuild the cropper
           * @param {string} url - The new URL.
           * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
           * @returns {Cropper} this
           */
          replace: function replace(url) {
            var hasSameSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            if (!this.disabled && url) {
              if (this.isImg) {
                this.element.src = url;
              }
              if (hasSameSize) {
                this.url = url;
                this.image.src = url;
                if (this.ready) {
                  this.viewBoxImage.src = url;
                  forEach(this.previews, function(element) {
                    element.getElementsByTagName("img")[0].src = url;
                  });
                }
              } else {
                if (this.isImg) {
                  this.replaced = true;
                }
                this.options.data = null;
                this.uncreate();
                this.load(url);
              }
            }
            return this;
          },
          // Enable (unfreeze) the cropper
          enable: function enable() {
            if (this.ready && this.disabled) {
              this.disabled = false;
              removeClass(this.cropper, CLASS_DISABLED);
            }
            return this;
          },
          // Disable (freeze) the cropper
          disable: function disable() {
            if (this.ready && !this.disabled) {
              this.disabled = true;
              addClass(this.cropper, CLASS_DISABLED);
            }
            return this;
          },
          /**
           * Destroy the cropper and remove the instance from the image
           * @returns {Cropper} this
           */
          destroy: function destroy2() {
            var element = this.element;
            if (!element[NAMESPACE]) {
              return this;
            }
            element[NAMESPACE] = void 0;
            if (this.isImg && this.replaced) {
              element.src = this.originalUrl;
            }
            this.uncreate();
            return this;
          },
          /**
           * Move the canvas with relative offsets
           * @param {number} offsetX - The relative offset distance on the x-axis.
           * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
           * @returns {Cropper} this
           */
          move: function move(offsetX) {
            var offsetY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : offsetX;
            var _this$canvasData = this.canvasData, left2 = _this$canvasData.left, top2 = _this$canvasData.top;
            return this.moveTo(isUndefined(offsetX) ? offsetX : left2 + Number(offsetX), isUndefined(offsetY) ? offsetY : top2 + Number(offsetY));
          },
          /**
           * Move the canvas to an absolute point
           * @param {number} x - The x-axis coordinate.
           * @param {number} [y=x] - The y-axis coordinate.
           * @returns {Cropper} this
           */
          moveTo: function moveTo(x4) {
            var y6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x4;
            var canvasData = this.canvasData;
            var changed = false;
            x4 = Number(x4);
            y6 = Number(y6);
            if (this.ready && !this.disabled && this.options.movable) {
              if (isNumber2(x4)) {
                canvasData.left = x4;
                changed = true;
              }
              if (isNumber2(y6)) {
                canvasData.top = y6;
                changed = true;
              }
              if (changed) {
                this.renderCanvas(true);
              }
            }
            return this;
          },
          /**
           * Zoom the canvas with a relative ratio
           * @param {number} ratio - The target ratio.
           * @param {Event} _originalEvent - The original event if any.
           * @returns {Cropper} this
           */
          zoom: function zoom(ratio, _originalEvent) {
            var canvasData = this.canvasData;
            ratio = Number(ratio);
            if (ratio < 0) {
              ratio = 1 / (1 - ratio);
            } else {
              ratio = 1 + ratio;
            }
            return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
          },
          /**
           * Zoom the canvas to an absolute ratio
           * @param {number} ratio - The target ratio.
           * @param {Object} pivot - The zoom pivot point coordinate.
           * @param {Event} _originalEvent - The original event if any.
           * @returns {Cropper} this
           */
          zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
            var options = this.options, canvasData = this.canvasData;
            var width = canvasData.width, height = canvasData.height, naturalWidth = canvasData.naturalWidth, naturalHeight = canvasData.naturalHeight;
            ratio = Number(ratio);
            if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
              var newWidth = naturalWidth * ratio;
              var newHeight = naturalHeight * ratio;
              if (dispatchEvent2(this.element, EVENT_ZOOM, {
                ratio,
                oldRatio: width / naturalWidth,
                originalEvent: _originalEvent
              }) === false) {
                return this;
              }
              if (_originalEvent) {
                var pointers = this.pointers;
                var offset3 = getOffset(this.cropper);
                var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
                  pageX: _originalEvent.pageX,
                  pageY: _originalEvent.pageY
                };
                canvasData.left -= (newWidth - width) * ((center.pageX - offset3.left - canvasData.left) / width);
                canvasData.top -= (newHeight - height) * ((center.pageY - offset3.top - canvasData.top) / height);
              } else if (isPlainObject(pivot) && isNumber2(pivot.x) && isNumber2(pivot.y)) {
                canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
                canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
              } else {
                canvasData.left -= (newWidth - width) / 2;
                canvasData.top -= (newHeight - height) / 2;
              }
              canvasData.width = newWidth;
              canvasData.height = newHeight;
              this.renderCanvas(true);
            }
            return this;
          },
          /**
           * Rotate the canvas with a relative degree
           * @param {number} degree - The rotate degree.
           * @returns {Cropper} this
           */
          rotate: function rotate2(degree) {
            return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
          },
          /**
           * Rotate the canvas to an absolute degree
           * @param {number} degree - The rotate degree.
           * @returns {Cropper} this
           */
          rotateTo: function rotateTo(degree) {
            degree = Number(degree);
            if (isNumber2(degree) && this.ready && !this.disabled && this.options.rotatable) {
              this.imageData.rotate = degree % 360;
              this.renderCanvas(true, true);
            }
            return this;
          },
          /**
           * Scale the image on the x-axis.
           * @param {number} scaleX - The scale ratio on the x-axis.
           * @returns {Cropper} this
           */
          scaleX: function scaleX(_scaleX) {
            var scaleY = this.imageData.scaleY;
            return this.scale(_scaleX, isNumber2(scaleY) ? scaleY : 1);
          },
          /**
           * Scale the image on the y-axis.
           * @param {number} scaleY - The scale ratio on the y-axis.
           * @returns {Cropper} this
           */
          scaleY: function scaleY(_scaleY) {
            var scaleX = this.imageData.scaleX;
            return this.scale(isNumber2(scaleX) ? scaleX : 1, _scaleY);
          },
          /**
           * Scale the image
           * @param {number} scaleX - The scale ratio on the x-axis.
           * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
           * @returns {Cropper} this
           */
          scale: function scale(scaleX) {
            var scaleY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : scaleX;
            var imageData = this.imageData;
            var transformed = false;
            scaleX = Number(scaleX);
            scaleY = Number(scaleY);
            if (this.ready && !this.disabled && this.options.scalable) {
              if (isNumber2(scaleX)) {
                imageData.scaleX = scaleX;
                transformed = true;
              }
              if (isNumber2(scaleY)) {
                imageData.scaleY = scaleY;
                transformed = true;
              }
              if (transformed) {
                this.renderCanvas(true, true);
              }
            }
            return this;
          },
          /**
           * Get the cropped area position and size data (base on the original image)
           * @param {boolean} [rounded=false] - Indicate if round the data values or not.
           * @returns {Object} The result cropped data.
           */
          getData: function getData2() {
            var rounded = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            var options = this.options, imageData = this.imageData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
            var data;
            if (this.ready && this.cropped) {
              data = {
                x: cropBoxData.left - canvasData.left,
                y: cropBoxData.top - canvasData.top,
                width: cropBoxData.width,
                height: cropBoxData.height
              };
              var ratio = imageData.width / imageData.naturalWidth;
              forEach(data, function(n3, i3) {
                data[i3] = n3 / ratio;
              });
              if (rounded) {
                var bottom2 = Math.round(data.y + data.height);
                var right2 = Math.round(data.x + data.width);
                data.x = Math.round(data.x);
                data.y = Math.round(data.y);
                data.width = right2 - data.x;
                data.height = bottom2 - data.y;
              }
            } else {
              data = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              };
            }
            if (options.rotatable) {
              data.rotate = imageData.rotate || 0;
            }
            if (options.scalable) {
              data.scaleX = imageData.scaleX || 1;
              data.scaleY = imageData.scaleY || 1;
            }
            return data;
          },
          /**
           * Set the cropped area position and size with new data
           * @param {Object} data - The new data.
           * @returns {Cropper} this
           */
          setData: function setData2(data) {
            var options = this.options, imageData = this.imageData, canvasData = this.canvasData;
            var cropBoxData = {};
            if (this.ready && !this.disabled && isPlainObject(data)) {
              var transformed = false;
              if (options.rotatable) {
                if (isNumber2(data.rotate) && data.rotate !== imageData.rotate) {
                  imageData.rotate = data.rotate;
                  transformed = true;
                }
              }
              if (options.scalable) {
                if (isNumber2(data.scaleX) && data.scaleX !== imageData.scaleX) {
                  imageData.scaleX = data.scaleX;
                  transformed = true;
                }
                if (isNumber2(data.scaleY) && data.scaleY !== imageData.scaleY) {
                  imageData.scaleY = data.scaleY;
                  transformed = true;
                }
              }
              if (transformed) {
                this.renderCanvas(true, true);
              }
              var ratio = imageData.width / imageData.naturalWidth;
              if (isNumber2(data.x)) {
                cropBoxData.left = data.x * ratio + canvasData.left;
              }
              if (isNumber2(data.y)) {
                cropBoxData.top = data.y * ratio + canvasData.top;
              }
              if (isNumber2(data.width)) {
                cropBoxData.width = data.width * ratio;
              }
              if (isNumber2(data.height)) {
                cropBoxData.height = data.height * ratio;
              }
              this.setCropBoxData(cropBoxData);
            }
            return this;
          },
          /**
           * Get the container size data.
           * @returns {Object} The result container data.
           */
          getContainerData: function getContainerData() {
            return this.ready ? assign2({}, this.containerData) : {};
          },
          /**
           * Get the image position and size data.
           * @returns {Object} The result image data.
           */
          getImageData: function getImageData() {
            return this.sized ? assign2({}, this.imageData) : {};
          },
          /**
           * Get the canvas position and size data.
           * @returns {Object} The result canvas data.
           */
          getCanvasData: function getCanvasData() {
            var canvasData = this.canvasData;
            var data = {};
            if (this.ready) {
              forEach(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function(n3) {
                data[n3] = canvasData[n3];
              });
            }
            return data;
          },
          /**
           * Set the canvas position and size with new data.
           * @param {Object} data - The new canvas data.
           * @returns {Cropper} this
           */
          setCanvasData: function setCanvasData(data) {
            var canvasData = this.canvasData;
            var aspectRatio = canvasData.aspectRatio;
            if (this.ready && !this.disabled && isPlainObject(data)) {
              if (isNumber2(data.left)) {
                canvasData.left = data.left;
              }
              if (isNumber2(data.top)) {
                canvasData.top = data.top;
              }
              if (isNumber2(data.width)) {
                canvasData.width = data.width;
                canvasData.height = data.width / aspectRatio;
              } else if (isNumber2(data.height)) {
                canvasData.height = data.height;
                canvasData.width = data.height * aspectRatio;
              }
              this.renderCanvas(true);
            }
            return this;
          },
          /**
           * Get the crop box position and size data.
           * @returns {Object} The result crop box data.
           */
          getCropBoxData: function getCropBoxData() {
            var cropBoxData = this.cropBoxData;
            var data;
            if (this.ready && this.cropped) {
              data = {
                left: cropBoxData.left,
                top: cropBoxData.top,
                width: cropBoxData.width,
                height: cropBoxData.height
              };
            }
            return data || {};
          },
          /**
           * Set the crop box position and size with new data.
           * @param {Object} data - The new crop box data.
           * @returns {Cropper} this
           */
          setCropBoxData: function setCropBoxData(data) {
            var cropBoxData = this.cropBoxData;
            var aspectRatio = this.options.aspectRatio;
            var widthChanged;
            var heightChanged;
            if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
              if (isNumber2(data.left)) {
                cropBoxData.left = data.left;
              }
              if (isNumber2(data.top)) {
                cropBoxData.top = data.top;
              }
              if (isNumber2(data.width) && data.width !== cropBoxData.width) {
                widthChanged = true;
                cropBoxData.width = data.width;
              }
              if (isNumber2(data.height) && data.height !== cropBoxData.height) {
                heightChanged = true;
                cropBoxData.height = data.height;
              }
              if (aspectRatio) {
                if (widthChanged) {
                  cropBoxData.height = cropBoxData.width / aspectRatio;
                } else if (heightChanged) {
                  cropBoxData.width = cropBoxData.height * aspectRatio;
                }
              }
              this.renderCropBox();
            }
            return this;
          },
          /**
           * Get a canvas drawn the cropped image.
           * @param {Object} [options={}] - The config options.
           * @returns {HTMLCanvasElement} - The result canvas.
           */
          getCroppedCanvas: function getCroppedCanvas() {
            var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (!this.ready || !window.HTMLCanvasElement) {
              return null;
            }
            var canvasData = this.canvasData;
            var source = getSourceCanvas(this.image, this.imageData, canvasData, options);
            if (!this.cropped) {
              return source;
            }
            var _this$getData = this.getData(options.rounded), initialX = _this$getData.x, initialY = _this$getData.y, initialWidth = _this$getData.width, initialHeight = _this$getData.height;
            var ratio = source.width / Math.floor(canvasData.naturalWidth);
            if (ratio !== 1) {
              initialX *= ratio;
              initialY *= ratio;
              initialWidth *= ratio;
              initialHeight *= ratio;
            }
            var aspectRatio = initialWidth / initialHeight;
            var maxSizes = getAdjustedSizes({
              aspectRatio,
              width: options.maxWidth || Infinity,
              height: options.maxHeight || Infinity
            });
            var minSizes = getAdjustedSizes({
              aspectRatio,
              width: options.minWidth || 0,
              height: options.minHeight || 0
            }, "cover");
            var _getAdjustedSizes = getAdjustedSizes({
              aspectRatio,
              width: options.width || (ratio !== 1 ? source.width : initialWidth),
              height: options.height || (ratio !== 1 ? source.height : initialHeight)
            }), width = _getAdjustedSizes.width, height = _getAdjustedSizes.height;
            width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
            height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
            var canvas = document.createElement("canvas");
            var context2 = canvas.getContext("2d");
            canvas.width = normalizeDecimalNumber(width);
            canvas.height = normalizeDecimalNumber(height);
            context2.fillStyle = options.fillColor || "transparent";
            context2.fillRect(0, 0, width, height);
            var _options$imageSmoothi = options.imageSmoothingEnabled, imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi, imageSmoothingQuality = options.imageSmoothingQuality;
            context2.imageSmoothingEnabled = imageSmoothingEnabled;
            if (imageSmoothingQuality) {
              context2.imageSmoothingQuality = imageSmoothingQuality;
            }
            var sourceWidth = source.width;
            var sourceHeight = source.height;
            var srcX = initialX;
            var srcY = initialY;
            var srcWidth;
            var srcHeight;
            var dstX;
            var dstY;
            var dstWidth;
            var dstHeight;
            if (srcX <= -initialWidth || srcX > sourceWidth) {
              srcX = 0;
              srcWidth = 0;
              dstX = 0;
              dstWidth = 0;
            } else if (srcX <= 0) {
              dstX = -srcX;
              srcX = 0;
              srcWidth = Math.min(sourceWidth, initialWidth + srcX);
              dstWidth = srcWidth;
            } else if (srcX <= sourceWidth) {
              dstX = 0;
              srcWidth = Math.min(initialWidth, sourceWidth - srcX);
              dstWidth = srcWidth;
            }
            if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
              srcY = 0;
              srcHeight = 0;
              dstY = 0;
              dstHeight = 0;
            } else if (srcY <= 0) {
              dstY = -srcY;
              srcY = 0;
              srcHeight = Math.min(sourceHeight, initialHeight + srcY);
              dstHeight = srcHeight;
            } else if (srcY <= sourceHeight) {
              dstY = 0;
              srcHeight = Math.min(initialHeight, sourceHeight - srcY);
              dstHeight = srcHeight;
            }
            var params = [srcX, srcY, srcWidth, srcHeight];
            if (dstWidth > 0 && dstHeight > 0) {
              var scale = width / initialWidth;
              params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
            }
            context2.drawImage.apply(context2, [source].concat(_toConsumableArray(params.map(function(param2) {
              return Math.floor(normalizeDecimalNumber(param2));
            }))));
            return canvas;
          },
          /**
           * Change the aspect ratio of the crop box.
           * @param {number} aspectRatio - The new aspect ratio.
           * @returns {Cropper} this
           */
          setAspectRatio: function setAspectRatio(aspectRatio) {
            var options = this.options;
            if (!this.disabled && !isUndefined(aspectRatio)) {
              options.aspectRatio = Math.max(0, aspectRatio) || NaN;
              if (this.ready) {
                this.initCropBox();
                if (this.cropped) {
                  this.renderCropBox();
                }
              }
            }
            return this;
          },
          /**
           * Change the drag mode.
           * @param {string} mode - The new drag mode.
           * @returns {Cropper} this
           */
          setDragMode: function setDragMode(mode) {
            var options = this.options, dragBox = this.dragBox, face = this.face;
            if (this.ready && !this.disabled) {
              var croppable = mode === DRAG_MODE_CROP;
              var movable = options.movable && mode === DRAG_MODE_MOVE;
              mode = croppable || movable ? mode : DRAG_MODE_NONE;
              options.dragMode = mode;
              setData(dragBox, DATA_ACTION, mode);
              toggleClass(dragBox, CLASS_CROP, croppable);
              toggleClass(dragBox, CLASS_MOVE, movable);
              if (!options.cropBoxMovable) {
                setData(face, DATA_ACTION, mode);
                toggleClass(face, CLASS_CROP, croppable);
                toggleClass(face, CLASS_MOVE, movable);
              }
            }
            return this;
          }
        };
        var AnotherCropper = WINDOW.Cropper;
        var Cropper2 = /* @__PURE__ */ function() {
          function Cropper3(element) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            _classCallCheck2(this, Cropper3);
            if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
              throw new Error("The first argument is required and must be an <img> or <canvas> element.");
            }
            this.element = element;
            this.options = assign2({}, DEFAULTS, isPlainObject(options) && options);
            this.cropped = false;
            this.disabled = false;
            this.pointers = {};
            this.ready = false;
            this.reloading = false;
            this.replaced = false;
            this.sized = false;
            this.sizing = false;
            this.init();
          }
          return _createClass2(Cropper3, [{
            key: "init",
            value: function init2() {
              var element = this.element;
              var tagName = element.tagName.toLowerCase();
              var url;
              if (element[NAMESPACE]) {
                return;
              }
              element[NAMESPACE] = this;
              if (tagName === "img") {
                this.isImg = true;
                url = element.getAttribute("src") || "";
                this.originalUrl = url;
                if (!url) {
                  return;
                }
                url = element.src;
              } else if (tagName === "canvas" && window.HTMLCanvasElement) {
                url = element.toDataURL();
              }
              this.load(url);
            }
          }, {
            key: "load",
            value: function load(url) {
              var _this = this;
              if (!url) {
                return;
              }
              this.url = url;
              this.imageData = {};
              var element = this.element, options = this.options;
              if (!options.rotatable && !options.scalable) {
                options.checkOrientation = false;
              }
              if (!options.checkOrientation || !window.ArrayBuffer) {
                this.clone();
                return;
              }
              if (REGEXP_DATA_URL.test(url)) {
                if (REGEXP_DATA_URL_JPEG.test(url)) {
                  this.read(dataURLToArrayBuffer(url));
                } else {
                  this.clone();
                }
                return;
              }
              var xhr = new XMLHttpRequest();
              var clone2 = this.clone.bind(this);
              this.reloading = true;
              this.xhr = xhr;
              xhr.onabort = clone2;
              xhr.onerror = clone2;
              xhr.ontimeout = clone2;
              xhr.onprogress = function() {
                if (xhr.getResponseHeader("content-type") !== MIME_TYPE_JPEG) {
                  xhr.abort();
                }
              };
              xhr.onload = function() {
                _this.read(xhr.response);
              };
              xhr.onloadend = function() {
                _this.reloading = false;
                _this.xhr = null;
              };
              if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
                url = addTimestamp(url);
              }
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.withCredentials = element.crossOrigin === "use-credentials";
              xhr.send();
            }
          }, {
            key: "read",
            value: function read2(arrayBuffer) {
              var options = this.options, imageData = this.imageData;
              var orientation = resetAndGetOrientation(arrayBuffer);
              var rotate2 = 0;
              var scaleX = 1;
              var scaleY = 1;
              if (orientation > 1) {
                this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);
                var _parseOrientation = parseOrientation(orientation);
                rotate2 = _parseOrientation.rotate;
                scaleX = _parseOrientation.scaleX;
                scaleY = _parseOrientation.scaleY;
              }
              if (options.rotatable) {
                imageData.rotate = rotate2;
              }
              if (options.scalable) {
                imageData.scaleX = scaleX;
                imageData.scaleY = scaleY;
              }
              this.clone();
            }
          }, {
            key: "clone",
            value: function clone2() {
              var element = this.element, url = this.url;
              var crossOrigin = element.crossOrigin;
              var crossOriginUrl = url;
              if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
                if (!crossOrigin) {
                  crossOrigin = "anonymous";
                }
                crossOriginUrl = addTimestamp(url);
              }
              this.crossOrigin = crossOrigin;
              this.crossOriginUrl = crossOriginUrl;
              var image = document.createElement("img");
              if (crossOrigin) {
                image.crossOrigin = crossOrigin;
              }
              image.src = crossOriginUrl || url;
              image.alt = element.alt || "The image to crop";
              this.image = image;
              image.onload = this.start.bind(this);
              image.onerror = this.stop.bind(this);
              addClass(image, CLASS_HIDE);
              element.parentNode.insertBefore(image, element.nextSibling);
            }
          }, {
            key: "start",
            value: function start5() {
              var _this2 = this;
              var image = this.image;
              image.onload = null;
              image.onerror = null;
              this.sizing = true;
              var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);
              var done = function done2(naturalWidth, naturalHeight) {
                assign2(_this2.imageData, {
                  naturalWidth,
                  naturalHeight,
                  aspectRatio: naturalWidth / naturalHeight
                });
                _this2.initialImageData = assign2({}, _this2.imageData);
                _this2.sizing = false;
                _this2.sized = true;
                _this2.build();
              };
              if (image.naturalWidth && !isIOSWebKit) {
                done(image.naturalWidth, image.naturalHeight);
                return;
              }
              var sizingImage = document.createElement("img");
              var body = document.body || document.documentElement;
              this.sizingImage = sizingImage;
              sizingImage.onload = function() {
                done(sizingImage.width, sizingImage.height);
                if (!isIOSWebKit) {
                  body.removeChild(sizingImage);
                }
              };
              sizingImage.src = image.src;
              if (!isIOSWebKit) {
                sizingImage.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;";
                body.appendChild(sizingImage);
              }
            }
          }, {
            key: "stop",
            value: function stop() {
              var image = this.image;
              image.onload = null;
              image.onerror = null;
              image.parentNode.removeChild(image);
              this.image = null;
            }
          }, {
            key: "build",
            value: function build() {
              if (!this.sized || this.ready) {
                return;
              }
              var element = this.element, options = this.options, image = this.image;
              var container = element.parentNode;
              var template2 = document.createElement("div");
              template2.innerHTML = TEMPLATE;
              var cropper = template2.querySelector(".".concat(NAMESPACE, "-container"));
              var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
              var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
              var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
              var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
              this.container = container;
              this.cropper = cropper;
              this.canvas = canvas;
              this.dragBox = dragBox;
              this.cropBox = cropBox;
              this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
              this.face = face;
              canvas.appendChild(image);
              addClass(element, CLASS_HIDDEN);
              container.insertBefore(cropper, element.nextSibling);
              removeClass(image, CLASS_HIDE);
              this.initPreview();
              this.bind();
              options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
              options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
              options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
              addClass(cropBox, CLASS_HIDDEN);
              if (!options.guides) {
                addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
              }
              if (!options.center) {
                addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
              }
              if (options.background) {
                addClass(cropper, "".concat(NAMESPACE, "-bg"));
              }
              if (!options.highlight) {
                addClass(face, CLASS_INVISIBLE);
              }
              if (options.cropBoxMovable) {
                addClass(face, CLASS_MOVE);
                setData(face, DATA_ACTION, ACTION_ALL);
              }
              if (!options.cropBoxResizable) {
                addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
                addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
              }
              this.render();
              this.ready = true;
              this.setDragMode(options.dragMode);
              if (options.autoCrop) {
                this.crop();
              }
              this.setData(options.data);
              if (isFunction2(options.ready)) {
                addListener2(element, EVENT_READY, options.ready, {
                  once: true
                });
              }
              dispatchEvent2(element, EVENT_READY);
            }
          }, {
            key: "unbuild",
            value: function unbuild() {
              if (!this.ready) {
                return;
              }
              this.ready = false;
              this.unbind();
              this.resetPreview();
              var parentNode = this.cropper.parentNode;
              if (parentNode) {
                parentNode.removeChild(this.cropper);
              }
              removeClass(this.element, CLASS_HIDDEN);
            }
          }, {
            key: "uncreate",
            value: function uncreate() {
              if (this.ready) {
                this.unbuild();
                this.ready = false;
                this.cropped = false;
              } else if (this.sizing) {
                this.sizingImage.onload = null;
                this.sizing = false;
                this.sized = false;
              } else if (this.reloading) {
                this.xhr.onabort = null;
                this.xhr.abort();
              } else if (this.image) {
                this.stop();
              }
            }
            /**
             * Get the no conflict cropper class.
             * @returns {Cropper} The cropper class.
             */
          }], [{
            key: "noConflict",
            value: function noConflict() {
              window.Cropper = AnotherCropper;
              return Cropper3;
            }
            /**
             * Change the default options.
             * @param {Object} options - The new default options.
             */
          }, {
            key: "setDefaults",
            value: function setDefaults(options) {
              assign2(DEFAULTS, isPlainObject(options) && options);
            }
          }]);
        }();
        assign2(Cropper2.prototype, render2, preview, events, handlers, change, methods);
        return Cropper2;
      });
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash2 = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e2) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            var value = array[index2];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (iteratee(array[index2], index2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (!predicate(array[index2], index2, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (comparator(value, array[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array[index2], index2, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index2 = -1, length = values.length, offset3 = array.length;
          while (++index2 < length) {
            array[offset3 + index2] = values[index2];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index2 = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index2];
          }
          while (++index2 < length) {
            accumulator = iteratee(accumulator, array[index2], index2, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (comparator(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index2 = -1, length = array.length;
          while (++index2 < length) {
            var current = iteratee(array[index2]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n3, iteratee) {
          var index2 = -1, result = Array(n3);
          while (++index2 < n3) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map3) {
          var index2 = -1, result = Array(map3.size);
          map3.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index2 = -1, length = array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray(set2) {
          var index2 = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        function setToPairs(set2) {
          var index2 = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index2] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index2 = string.length;
          while (index2-- && reWhitespace.test(string.charAt(index2))) {
          }
          return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context2) {
          context2 = context2 == null ? root : _26.defaults(root.Object(), context2, _26.pick(root, contextProps));
          var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context2["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty2 = objectProto.hasOwnProperty;
          var idCounter2 = 0;
          var maskSrcKey = function() {
            var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid2 ? "Symbol(src)_1." + uid2 : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e2) {
            }
          }();
          var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty2.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject2(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start5 = view.start, end2 = view.end, length = end2 - start5, index2 = isRight ? end2 : start5 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value = array[index2];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? undefined2 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size4 = data.size;
            data.set(key, value);
            this.size += data.size == size4 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index2 = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values2[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n3) {
            return shuffleSelf(copyArray(array), baseClamp(n3, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq2(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq2(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index2 = -1, length = paths.length, result2 = Array2(length), skip2 = object == null;
            while (++index2 < length) {
              result2[index2] = skip2 ? undefined2 : get3(object, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray2(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait3, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait3);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index2, collection2) {
              result2 = !!predicate(value, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index2 = -1, length = array.length;
            while (++index2 < length) {
              var value = array[index2], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start5, end2) {
            var length = array.length;
            start5 = toInteger(start5);
            if (start5 < 0) {
              start5 = -start5 > length ? 0 : length + start5;
            }
            end2 = end2 === undefined2 || end2 > length ? length : toInteger(end2);
            if (end2 < 0) {
              end2 += length;
            }
            end2 = start5 > end2 ? 0 : toLength(end2);
            while (start5 < end2) {
              array[start5++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index2, collection2) {
              if (predicate(value, index2, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index2 = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index2 < length) {
              var value = array[index2];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index2 = 0, length = path.length;
            while (object != null && index2 < length) {
              object = object[toKey(path[index2++])];
            }
            return index2 && index2 == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty2.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start5, end2) {
            return number >= nativeMin(start5, end2) && number < nativeMax(start5, end2);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index2 = -1, seen = caches[0];
            outer:
              while (++index2 < length && result2.length < maxLength) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index2--) {
              var data = matchData[index2];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index2 < length) {
              data = matchData[index2];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject2(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty2.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject2(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index2] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get3(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject2(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray2(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n3) {
            var length = array.length;
            if (!length) {
              return;
            }
            n3 += n3 < 0 ? length : 0;
            return isIndex(n3, length) ? array[n3] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray2(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index2 = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index2, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index2 = -1, length = paths.length, result2 = {};
            while (++index2 < length) {
              var path = paths[index2], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index2 < length) {
              var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index2 = indexes[length];
              if (length == lastIndex || index2 !== previous) {
                var previous = index2;
                if (isIndex(index2)) {
                  splice.call(array, index2, 1);
                } else {
                  baseUnset(array, index2);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start5, end2, step, fromRight) {
            var index2 = -1, length = nativeMax(nativeCeil((end2 - start5) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index2] = start5;
              start5 += step;
            }
            return result2;
          }
          function baseRepeat(string, n3) {
            var result2 = "";
            if (!string || n3 < 1 || n3 > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n3 % 2) {
                result2 += string;
              }
              n3 = nativeFloor(n3 / 2);
              if (n3) {
                string += string;
              }
            } while (n3);
            return result2;
          }
          function baseRest(func, start5) {
            return setToString(overRest(func, start5, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n3) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n3, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject2(object)) {
              return object;
            }
            path = castPath(path, object);
            var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index2 < length) {
              var key = toKey(path[index2]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index2 != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start5, end2) {
            var index2 = -1, length = array.length;
            if (start5 < 0) {
              start5 = -start5 > length ? 0 : length + start5;
            }
            end2 = end2 > length ? length : end2;
            if (end2 < 0) {
              end2 += length;
            }
            length = start5 > end2 ? 0 : end2 - start5 >>> 0;
            start5 >>>= 0;
            var result2 = Array2(length);
            while (++index2 < length) {
              result2[index2] = array[index2 + start5];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index2, collection2) {
              result2 = predicate(value, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index2 = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              if (!index2 || !eq2(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray2(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set3 = iteratee2 ? null : createSet(array);
              if (set3) {
                return setToArray(set3);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index2 = fromRight ? length : -1;
            while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length);
            while (++index2 < length) {
              var array = arrays[index2], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index2 < length) {
              var value = index2 < valsLength ? values2[index2] : undefined2;
              assignFunc(result2, props[index2], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray2(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start5, end2) {
            var length = array.length;
            end2 = end2 === undefined2 ? length : end2;
            return !start5 && end2 >= length ? array : baseSlice(array, start5, end2);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order2 = orders[index2];
                return result2 * (order2 == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset3 = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset3 + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset3 + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index2 = -1, length = source.length;
            array || (array = Array2(length));
            while (++index2 < length) {
              array[index2] = source[index2];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index2 = -1, length = props.length;
            while (++index2 < length) {
              var key = props[index2];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index2 < length) {
                var source = sources[index2];
                if (source) {
                  assigner(object, source, index2, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index2];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn3 = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn3.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder2(callback2) {
            return function(string) {
              return arrayReduce(words2(deburr(string).replace(reApos, "")), callback2, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn3 = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn3, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index2 = wrapper ? index2 : length;
              while (++index2 < length) {
                func = funcs[index2];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray2(value)) {
                  return wrapper.plant(value).value();
                }
                var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                while (++index3 < length) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn3 = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn3 = Ctor || createCtor(fn3);
              }
              return fn3.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn3 = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn3, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start5, end2, step) {
              if (step && typeof step != "number" && isIterateeCall(start5, end2, step)) {
                end2 = step = undefined2;
              }
              start5 = toFinite(start5);
              if (end2 === undefined2) {
                end2 = start5;
                start5 = 0;
              } else {
                end2 = toFinite(end2);
              }
              step = step === undefined2 ? start5 < end2 ? 1 : -1 : toFinite(step);
              return baseRange(start5, end2, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop4 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq2(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index2 < arrLength) {
              var arrValue = array[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq2(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop4 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map4, key) {
            var data = map4.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e2) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start5, end2, transforms) {
            var index2 = -1, length = transforms.length;
            while (++index2 < length) {
              var data = transforms[index2], size4 = data.size;
              switch (data.type) {
                case "drop":
                  start5 += size4;
                  break;
                case "dropRight":
                  end2 -= size4;
                  break;
                case "take":
                  end2 = nativeMin(end2, start5 + size4);
                  break;
                case "takeRight":
                  start5 = nativeMax(start5, end2 - size4);
                  break;
              }
            }
            return { "start": start5, "end": end2 };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index2 = -1, length = path.length, result2 = false;
            while (++index2 < length) {
              var key = toKey(path[index2]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index2 != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index2, object) {
            if (!isObject2(object)) {
              return false;
            }
            var type = typeof index2;
            if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
              return eq2(object[index2], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray2(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction2 : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start5, transform2) {
            start5 = nativeMax(start5 === undefined2 ? func.length - 1 : start5, 0);
            return function() {
              var args = arguments, index2 = -1, length = nativeMax(args.length - start5, 0), array = Array2(length);
              while (++index2 < length) {
                array[index2] = args[start5 + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start5 + 1);
              while (++index2 < start5) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start5] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index2 = indexes[length];
              array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait3) {
            return root.setTimeout(func, wait3);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference2, bitmask) {
            var source = reference2 + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size4) {
            var index2 = -1, length = array.length, lastIndex = length - 1;
            size4 = size4 === undefined2 ? length : size4;
            while (++index2 < size4) {
              var rand = baseRandom(index2, lastIndex), value = array[rand];
              array[rand] = array[index2];
              array[index2] = value;
            }
            array.length = size4;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e2) {
              }
              try {
                return func + "";
              } catch (e2) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size4, guard) {
            if (guard ? isIterateeCall(array, size4, guard) : size4 === undefined2) {
              size4 = 1;
            } else {
              size4 = nativeMax(toInteger(size4), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size4 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size4));
            while (index2 < length) {
              result2[resIndex++] = baseSlice(array, index2, index2 += size4);
            }
            return result2;
          }
          function compact2(array) {
            var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array[index2];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index2 = length;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            return baseSlice(array, n3 < 0 ? 0 : n3, length);
          }
          function dropRight(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            n3 = length - n3;
            return baseSlice(array, 0, n3 < 0 ? 0 : n3);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill2(array, value, start5, end2) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start5 && typeof start5 != "number" && isIterateeCall(array, value, start5)) {
              start5 = 0;
              end2 = length;
            }
            return baseFill(array, value, start5, end2);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = length - 1;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY2) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length) {
              var pair = pairs[index2];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseIndexOf(array, value, index2);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = length;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
          }
          function nth(array, n3) {
            return array && array.length ? baseNth(array, toInteger(n3)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index2) {
              return isIndex(index2, length) ? +index2 : index2;
            }).sort(compareAscending));
            return result2;
          });
          function remove2(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length) {
              var value = array[index2];
              if (predicate(value, index2, array)) {
                result2.push(value);
                indexes.push(index2);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start5, end2) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end2 && typeof end2 != "number" && isIterateeCall(array, start5, end2)) {
              start5 = 0;
              end2 = length;
            } else {
              start5 = start5 == null ? 0 : toInteger(start5);
              end2 = end2 === undefined2 ? length : toInteger(end2);
            }
            return baseSlice(array, start5, end2);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index2 = baseSortedIndex(array, value);
              if (index2 < length && eq2(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index2 = baseSortedIndex(array, value, true) - 1;
              if (eq2(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n3, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            return baseSlice(array, 0, n3 < 0 ? 0 : n3);
          }
          function takeRight(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            n3 = length - n3;
            return baseSlice(array, n3 < 0 ? 0 : n3, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index2) {
              return arrayMap(array, baseProperty(index2));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip2 = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start5 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start5)) {
              return this.thru(interceptor);
            }
            value = value.slice(start5, +start5 + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone3 = wrapperClone(parent2);
              clone3.__index__ = 0;
              clone3.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone3;
              } else {
                result2 = clone3;
              }
              var previous = clone3;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray2(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map3(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map3(collection, iteratee2), INFINITY2);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map3(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map3(collection, iteratee2) {
            var func = isArray2(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray2(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray2(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample2(collection) {
            var func = isArray2(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n3, guard) {
            if (guard ? isIterateeCall(collection, n3, guard) : n3 === undefined2) {
              n3 = 1;
            } else {
              n3 = toInteger(n3);
            }
            var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n3);
          }
          function shuffle(collection) {
            var func = isArray2(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size3(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray2(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now3 = ctxNow || function() {
            return root.Date.now();
          };
          function after2(n3, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n3 = toInteger(n3);
            return function() {
              if (--n3 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n3, guard) {
            n3 = guard ? undefined2 : n3;
            n3 = func && n3 == null ? func.length : n3;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n3);
          }
          function before2(n3, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n3 = toInteger(n3);
            return function() {
              if (--n3 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n3 <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce8(func, wait3, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait3 = toNumber(wait3) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait3) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait3);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait3 - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait3 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now3();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel2() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now3());
            }
            function debounced() {
              var time = now3(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait3);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait3);
              }
              return result2;
            }
            debounced.cancel = cancel2;
            debounced.flush = flush;
            return debounced;
          }
          var defer2 = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait3, args) {
            return baseDelay(func, toNumber(wait3) || 0, args);
          });
          function flip4(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before2(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index2 = -1, length = nativeMin(args.length, funcsLength);
              while (++index2 < length) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start5) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start5 = start5 === undefined2 ? start5 : toInteger(start5);
            return baseRest(func, start5);
          }
          function spread(func, start5) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start5 = start5 == null ? 0 : nativeMax(toInteger(start5), 0);
            return baseRest(function(args) {
              var array = args[start5], otherArgs = castSlice(args, 0, start5);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait3, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce8(func, wait3, {
              "leading": leading,
              "maxWait": wait3,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray2(value) ? value : [value];
          }
          function clone2(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq2(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt3 = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray2 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement4(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty2.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject2(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber2(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber2(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt3 = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY2 || value === -INFINITY2) {
              var sign2 = value < 0 ? -1 : 1;
              return sign2 * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject2(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign2 = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at3 = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults3 = baseRest(function(object, sources) {
            object = Object2(object);
            var index2 = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index2 < length) {
              var source = sources[index2];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq2(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get3(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty2.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge3 = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index2 = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index2 < length) {
              var value = object == null ? undefined2 : object[toKey(path[index2])];
              if (value === undefined2) {
                index2 = length;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set2(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
              return iteratee2(accumulator, value, index2, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp2(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange2(number, start5, end2) {
            start5 = toFinite(start5);
            if (end2 === undefined2) {
              end2 = start5;
              start5 = 0;
            } else {
              end2 = toFinite(end2);
            }
            number = toNumber(number);
            return baseInRange(number, start5, end2);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder2(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize3(word) : word);
          });
          function capitalize3(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end2 = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end2) == target;
          }
          function escape3(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder2(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder2(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n3, guard) {
            if (guard ? isIterateeCall(string, n3, guard) : n3 === undefined2) {
              n3 = 1;
            } else {
              n3 = toInteger(n3);
            }
            return baseRepeat(toString(string), n3);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder2(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder2(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template2(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate4 = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate4.source + "|" + (interpolate4 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset3) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index2, offset3).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset3 + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty2.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start5 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start5, end2).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end2).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start5 = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start5).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end2 = length - stringSize(omission);
            if (end2 < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end2 += result2.length - end2;
            }
            if (isRegExp(separator)) {
              if (string.slice(end2).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end2 : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end2) != end2) {
              var index2 = result2.lastIndexOf(separator);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder2(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words2(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e2) {
              return isError(e2) ? e2 : new Error2(e2);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index2 = -1;
              while (++index2 < length) {
                var pair = pairs[index2];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop4() {
          }
          function nthArg(n3) {
            n3 = toInteger(n3);
            return baseRest(function(args) {
              return baseNth(args, n3);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range2 = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n3, iteratee2) {
            n3 = toInteger(n3);
            if (n3 < 1 || n3 > MAX_SAFE_INTEGER) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n3, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n3 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index2 < n3) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray2(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix2) {
            var id = ++idCounter2;
            return toString(prefix2) + id;
          }
          var add3 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor2 = createRound("floor");
          function max3(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min3(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round5 = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after2;
          lodash.ary = ary;
          lodash.assign = assign2;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at3;
          lodash.before = before2;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact2;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce8;
          lodash.defaults = defaults3;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer2;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill2;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip4;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map3;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge3;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range2;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove2;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set2;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words2;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip2;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add3;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize3;
          lodash.ceil = ceil;
          lodash.clamp = clamp2;
          lodash.clone = clone2;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq2;
          lodash.escape = escape3;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor2;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get3;
          lodash.gt = gt3;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange2;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray2;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement4;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction2;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber2;
          lodash.isObject = isObject2;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt3;
          lodash.lte = lte;
          lodash.max = max3;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min3;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop4;
          lodash.now = now3;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round5;
          lodash.runInContext = runInContext2;
          lodash.sample = sample2;
          lodash.size = size3;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template2;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape2;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n3) {
              n3 = n3 === undefined2 ? 1 : nativeMax(toInteger(n3), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n3, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n3, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n3) {
              return this.reverse()[methodName](n3).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start5, end2) {
            start5 = toInteger(start5);
            var result2 = this;
            if (result2.__filtered__ && (start5 > 0 || end2 < 0)) {
              return new LazyWrapper(result2);
            }
            if (start5 < 0) {
              result2 = result2.takeRight(-start5);
            } else if (start5) {
              result2 = result2.drop(start5);
            }
            if (end2 !== undefined2) {
              end2 = toInteger(end2);
              result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start5);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray2(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray2(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty2.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _26 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _26;
          define(function() {
            return _26;
          });
        } else if (freeModule) {
          (freeModule.exports = _26)._ = _26;
          freeExports._ = _26;
        } else {
          root._ = _26;
        }
      }).call(exports);
    }
  });

  // node_modules/lazysizes/lazysizes.js
  var require_lazysizes = __commonJS({
    "node_modules/lazysizes/lazysizes.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function(window2, factory) {
        var lazySizes = factory(window2, window2.document, Date);
        window2.lazySizes = lazySizes;
        if (typeof module2 == "object" && module2.exports) {
          module2.exports = lazySizes;
        }
      })(
        typeof window != "undefined" ? window : {},
        /**
         * import("./types/global")
         * @typedef { import("./types/lazysizes-config").LazySizesConfigPartial } LazySizesConfigPartial
         */
        function l5(window2, document2, Date2) {
          "use strict";
          var lazysizes, lazySizesCfg;
          (function() {
            var prop;
            var lazySizesDefaults = {
              lazyClass: "lazyload",
              loadedClass: "lazyloaded",
              loadingClass: "lazyloading",
              preloadClass: "lazypreload",
              errorClass: "lazyerror",
              //strictClass: 'lazystrict',
              autosizesClass: "lazyautosizes",
              fastLoadedClass: "ls-is-cached",
              iframeLoadMode: 0,
              srcAttr: "data-src",
              srcsetAttr: "data-srcset",
              sizesAttr: "data-sizes",
              //preloadAfterLoad: false,
              minSize: 40,
              customMedia: {},
              init: true,
              expFactor: 1.5,
              hFac: 0.8,
              loadMode: 2,
              loadHidden: true,
              ricTimeout: 0,
              throttleDelay: 125
            };
            lazySizesCfg = window2.lazySizesConfig || window2.lazysizesConfig || {};
            for (prop in lazySizesDefaults) {
              if (!(prop in lazySizesCfg)) {
                lazySizesCfg[prop] = lazySizesDefaults[prop];
              }
            }
          })();
          if (!document2 || !document2.getElementsByClassName) {
            return {
              init: function() {
              },
              /**
               * @type { LazySizesConfigPartial }
               */
              cfg: lazySizesCfg,
              /**
               * @type { true }
               */
              noSupport: true
            };
          }
          var docElem = document2.documentElement;
          var supportPicture = window2.HTMLPictureElement;
          var _addEventListener = "addEventListener";
          var _getAttribute = "getAttribute";
          var addEventListener2 = window2[_addEventListener].bind(window2);
          var setTimeout2 = window2.setTimeout;
          var requestAnimationFrame2 = window2.requestAnimationFrame || setTimeout2;
          var requestIdleCallback = window2.requestIdleCallback;
          var regPicture = /^picture$/i;
          var loadEvents = ["load", "error", "lazyincluded", "_lazyloaded"];
          var regClassCache = {};
          var forEach = Array.prototype.forEach;
          var hasClass = function(ele, cls) {
            if (!regClassCache[cls]) {
              regClassCache[cls] = new RegExp("(\\s|^)" + cls + "(\\s|$)");
            }
            return regClassCache[cls].test(ele[_getAttribute]("class") || "") && regClassCache[cls];
          };
          var addClass = function(ele, cls) {
            if (!hasClass(ele, cls)) {
              ele.setAttribute("class", (ele[_getAttribute]("class") || "").trim() + " " + cls);
            }
          };
          var removeClass = function(ele, cls) {
            var reg;
            if (reg = hasClass(ele, cls)) {
              ele.setAttribute("class", (ele[_getAttribute]("class") || "").replace(reg, " "));
            }
          };
          var addRemoveLoadEvents = function(dom, fn3, add3) {
            var action = add3 ? _addEventListener : "removeEventListener";
            if (add3) {
              addRemoveLoadEvents(dom, fn3);
            }
            loadEvents.forEach(function(evt) {
              dom[action](evt, fn3);
            });
          };
          var triggerEvent = function(elem, name2, detail, noBubbles, noCancelable) {
            var event2 = document2.createEvent("Event");
            if (!detail) {
              detail = {};
            }
            detail.instance = lazysizes;
            event2.initEvent(name2, !noBubbles, !noCancelable);
            event2.detail = detail;
            elem.dispatchEvent(event2);
            return event2;
          };
          var updatePolyfill = function(el, full) {
            var polyfill;
            if (!supportPicture && (polyfill = window2.picturefill || lazySizesCfg.pf)) {
              if (full && full.src && !el[_getAttribute]("srcset")) {
                el.setAttribute("srcset", full.src);
              }
              polyfill({ reevaluate: true, elements: [el] });
            } else if (full && full.src) {
              el.src = full.src;
            }
          };
          var getCSS = function(elem, style) {
            return (getComputedStyle(elem, null) || {})[style];
          };
          var getWidth = function(elem, parent, width) {
            width = width || elem.offsetWidth;
            while (width < lazySizesCfg.minSize && parent && !elem._lazysizesWidth) {
              width = parent.offsetWidth;
              parent = parent.parentNode;
            }
            return width;
          };
          var rAF = function() {
            var running, waiting;
            var firstFns = [];
            var secondFns = [];
            var fns = firstFns;
            var run = function() {
              var runFns = fns;
              fns = firstFns.length ? secondFns : firstFns;
              running = true;
              waiting = false;
              while (runFns.length) {
                runFns.shift()();
              }
              running = false;
            };
            var rafBatch = function(fn3, queue) {
              if (running && !queue) {
                fn3.apply(this, arguments);
              } else {
                fns.push(fn3);
                if (!waiting) {
                  waiting = true;
                  (document2.hidden ? setTimeout2 : requestAnimationFrame2)(run);
                }
              }
            };
            rafBatch._lsFlush = run;
            return rafBatch;
          }();
          var rAFIt = function(fn3, simple) {
            return simple ? function() {
              rAF(fn3);
            } : function() {
              var that = this;
              var args = arguments;
              rAF(function() {
                fn3.apply(that, args);
              });
            };
          };
          var throttle = function(fn3) {
            var running;
            var lastTime = 0;
            var gDelay = lazySizesCfg.throttleDelay;
            var rICTimeout = lazySizesCfg.ricTimeout;
            var run = function() {
              running = false;
              lastTime = Date2.now();
              fn3();
            };
            var idleCallback = requestIdleCallback && rICTimeout > 49 ? function() {
              requestIdleCallback(run, { timeout: rICTimeout });
              if (rICTimeout !== lazySizesCfg.ricTimeout) {
                rICTimeout = lazySizesCfg.ricTimeout;
              }
            } : rAFIt(function() {
              setTimeout2(run);
            }, true);
            return function(isPriority) {
              var delay;
              if (isPriority = isPriority === true) {
                rICTimeout = 33;
              }
              if (running) {
                return;
              }
              running = true;
              delay = gDelay - (Date2.now() - lastTime);
              if (delay < 0) {
                delay = 0;
              }
              if (isPriority || delay < 9) {
                idleCallback();
              } else {
                setTimeout2(idleCallback, delay);
              }
            };
          };
          var debounce8 = function(func) {
            var timeout, timestamp;
            var wait3 = 99;
            var run = function() {
              timeout = null;
              func();
            };
            var later = function() {
              var last = Date2.now() - timestamp;
              if (last < wait3) {
                setTimeout2(later, wait3 - last);
              } else {
                (requestIdleCallback || run)(run);
              }
            };
            return function() {
              timestamp = Date2.now();
              if (!timeout) {
                timeout = setTimeout2(later, wait3);
              }
            };
          };
          var loader = function() {
            var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;
            var eLvW, elvH, eLtop, eLleft, eLright, eLbottom, isBodyHidden;
            var regImg = /^img$/i;
            var regIframe = /^iframe$/i;
            var supportScroll = "onscroll" in window2 && !/(gle|ing)bot/.test(navigator.userAgent);
            var shrinkExpand = 0;
            var currentExpand = 0;
            var isLoading = 0;
            var lowRuns = -1;
            var resetPreloading = function(e2) {
              isLoading--;
              if (!e2 || isLoading < 0 || !e2.target) {
                isLoading = 0;
              }
            };
            var isVisible = function(elem) {
              if (isBodyHidden == null) {
                isBodyHidden = getCSS(document2.body, "visibility") == "hidden";
              }
              return isBodyHidden || !(getCSS(elem.parentNode, "visibility") == "hidden" && getCSS(elem, "visibility") == "hidden");
            };
            var isNestedVisible = function(elem, elemExpand) {
              var outerRect;
              var parent = elem;
              var visible = isVisible(elem);
              eLtop -= elemExpand;
              eLbottom += elemExpand;
              eLleft -= elemExpand;
              eLright += elemExpand;
              while (visible && (parent = parent.offsetParent) && parent != document2.body && parent != docElem) {
                visible = (getCSS(parent, "opacity") || 1) > 0;
                if (visible && getCSS(parent, "overflow") != "visible") {
                  outerRect = parent.getBoundingClientRect();
                  visible = eLright > outerRect.left && eLleft < outerRect.right && eLbottom > outerRect.top - 1 && eLtop < outerRect.bottom + 1;
                }
              }
              return visible;
            };
            var checkElements = function() {
              var eLlen, i3, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal, defaultExpand, preloadExpand, hFac;
              var lazyloadElems = lazysizes.elements;
              if ((loadMode = lazySizesCfg.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {
                i3 = 0;
                lowRuns++;
                for (; i3 < eLlen; i3++) {
                  if (!lazyloadElems[i3] || lazyloadElems[i3]._lazyRace) {
                    continue;
                  }
                  if (!supportScroll || lazysizes.prematureUnveil && lazysizes.prematureUnveil(lazyloadElems[i3])) {
                    unveilElement(lazyloadElems[i3]);
                    continue;
                  }
                  if (!(elemExpandVal = lazyloadElems[i3][_getAttribute]("data-expand")) || !(elemExpand = elemExpandVal * 1)) {
                    elemExpand = currentExpand;
                  }
                  if (!defaultExpand) {
                    defaultExpand = !lazySizesCfg.expand || lazySizesCfg.expand < 1 ? docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370 : lazySizesCfg.expand;
                    lazysizes._defEx = defaultExpand;
                    preloadExpand = defaultExpand * lazySizesCfg.expFactor;
                    hFac = lazySizesCfg.hFac;
                    isBodyHidden = null;
                    if (currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document2.hidden) {
                      currentExpand = preloadExpand;
                      lowRuns = 0;
                    } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {
                      currentExpand = defaultExpand;
                    } else {
                      currentExpand = shrinkExpand;
                    }
                  }
                  if (beforeExpandVal !== elemExpand) {
                    eLvW = innerWidth + elemExpand * hFac;
                    elvH = innerHeight + elemExpand;
                    elemNegativeExpand = elemExpand * -1;
                    beforeExpandVal = elemExpand;
                  }
                  rect = lazyloadElems[i3].getBoundingClientRect();
                  if ((eLbottom = rect.bottom) >= elemNegativeExpand && (eLtop = rect.top) <= elvH && (eLright = rect.right) >= elemNegativeExpand * hFac && (eLleft = rect.left) <= eLvW && (eLbottom || eLright || eLleft || eLtop) && (lazySizesCfg.loadHidden || isVisible(lazyloadElems[i3])) && (isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4) || isNestedVisible(lazyloadElems[i3], elemExpand))) {
                    unveilElement(lazyloadElems[i3]);
                    loadedSomething = true;
                    if (isLoading > 9) {
                      break;
                    }
                  } else if (!loadedSomething && isCompleted && !autoLoadElem && isLoading < 4 && lowRuns < 4 && loadMode > 2 && (preloadElems[0] || lazySizesCfg.preloadAfterLoad) && (preloadElems[0] || !elemExpandVal && (eLbottom || eLright || eLleft || eLtop || lazyloadElems[i3][_getAttribute](lazySizesCfg.sizesAttr) != "auto"))) {
                    autoLoadElem = preloadElems[0] || lazyloadElems[i3];
                  }
                }
                if (autoLoadElem && !loadedSomething) {
                  unveilElement(autoLoadElem);
                }
              }
            };
            var throttledCheckElements = throttle(checkElements);
            var switchLoadingClass = function(e2) {
              var elem = e2.target;
              if (elem._lazyCache) {
                delete elem._lazyCache;
                return;
              }
              resetPreloading(e2);
              addClass(elem, lazySizesCfg.loadedClass);
              removeClass(elem, lazySizesCfg.loadingClass);
              addRemoveLoadEvents(elem, rafSwitchLoadingClass);
              triggerEvent(elem, "lazyloaded");
            };
            var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);
            var rafSwitchLoadingClass = function(e2) {
              rafedSwitchLoadingClass({ target: e2.target });
            };
            var changeIframeSrc = function(elem, src) {
              var loadMode2 = elem.getAttribute("data-load-mode") || lazySizesCfg.iframeLoadMode;
              if (loadMode2 == 0) {
                elem.contentWindow.location.replace(src);
              } else if (loadMode2 == 1) {
                elem.src = src;
              }
            };
            var handleSources = function(source) {
              var customMedia;
              var sourceSrcset = source[_getAttribute](lazySizesCfg.srcsetAttr);
              if (customMedia = lazySizesCfg.customMedia[source[_getAttribute]("data-media") || source[_getAttribute]("media")]) {
                source.setAttribute("media", customMedia);
              }
              if (sourceSrcset) {
                source.setAttribute("srcset", sourceSrcset);
              }
            };
            var lazyUnveil = rAFIt(function(elem, detail, isAuto, sizes, isImg) {
              var src, srcset, parent, isPicture, event2, firesLoad;
              if (!(event2 = triggerEvent(elem, "lazybeforeunveil", detail)).defaultPrevented) {
                if (sizes) {
                  if (isAuto) {
                    addClass(elem, lazySizesCfg.autosizesClass);
                  } else {
                    elem.setAttribute("sizes", sizes);
                  }
                }
                srcset = elem[_getAttribute](lazySizesCfg.srcsetAttr);
                src = elem[_getAttribute](lazySizesCfg.srcAttr);
                if (isImg) {
                  parent = elem.parentNode;
                  isPicture = parent && regPicture.test(parent.nodeName || "");
                }
                firesLoad = detail.firesLoad || "src" in elem && (srcset || src || isPicture);
                event2 = { target: elem };
                addClass(elem, lazySizesCfg.loadingClass);
                if (firesLoad) {
                  clearTimeout(resetPreloadingTimer);
                  resetPreloadingTimer = setTimeout2(resetPreloading, 2500);
                  addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
                }
                if (isPicture) {
                  forEach.call(parent.getElementsByTagName("source"), handleSources);
                }
                if (srcset) {
                  elem.setAttribute("srcset", srcset);
                } else if (src && !isPicture) {
                  if (regIframe.test(elem.nodeName)) {
                    changeIframeSrc(elem, src);
                  } else {
                    elem.src = src;
                  }
                }
                if (isImg && (srcset || isPicture)) {
                  updatePolyfill(elem, { src });
                }
              }
              if (elem._lazyRace) {
                delete elem._lazyRace;
              }
              removeClass(elem, lazySizesCfg.lazyClass);
              rAF(function() {
                var isLoaded = elem.complete && elem.naturalWidth > 1;
                if (!firesLoad || isLoaded) {
                  if (isLoaded) {
                    addClass(elem, lazySizesCfg.fastLoadedClass);
                  }
                  switchLoadingClass(event2);
                  elem._lazyCache = true;
                  setTimeout2(function() {
                    if ("_lazyCache" in elem) {
                      delete elem._lazyCache;
                    }
                  }, 9);
                }
                if (elem.loading == "lazy") {
                  isLoading--;
                }
              }, true);
            });
            var unveilElement = function(elem) {
              if (elem._lazyRace) {
                return;
              }
              var detail;
              var isImg = regImg.test(elem.nodeName);
              var sizes = isImg && (elem[_getAttribute](lazySizesCfg.sizesAttr) || elem[_getAttribute]("sizes"));
              var isAuto = sizes == "auto";
              if ((isAuto || !isCompleted) && isImg && (elem[_getAttribute]("src") || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesCfg.errorClass) && hasClass(elem, lazySizesCfg.lazyClass)) {
                return;
              }
              detail = triggerEvent(elem, "lazyunveilread").detail;
              if (isAuto) {
                autoSizer.updateElem(elem, true, elem.offsetWidth);
              }
              elem._lazyRace = true;
              isLoading++;
              lazyUnveil(elem, detail, isAuto, sizes, isImg);
            };
            var afterScroll = debounce8(function() {
              lazySizesCfg.loadMode = 3;
              throttledCheckElements();
            });
            var altLoadmodeScrollListner = function() {
              if (lazySizesCfg.loadMode == 3) {
                lazySizesCfg.loadMode = 2;
              }
              afterScroll();
            };
            var onload = function() {
              if (isCompleted) {
                return;
              }
              if (Date2.now() - started < 999) {
                setTimeout2(onload, 999);
                return;
              }
              isCompleted = true;
              lazySizesCfg.loadMode = 3;
              throttledCheckElements();
              addEventListener2("scroll", altLoadmodeScrollListner, true);
            };
            return {
              _: function() {
                started = Date2.now();
                lazysizes.elements = document2.getElementsByClassName(lazySizesCfg.lazyClass);
                preloadElems = document2.getElementsByClassName(lazySizesCfg.lazyClass + " " + lazySizesCfg.preloadClass);
                addEventListener2("scroll", throttledCheckElements, true);
                addEventListener2("resize", throttledCheckElements, true);
                addEventListener2("pageshow", function(e2) {
                  if (e2.persisted) {
                    var loadingElements = document2.querySelectorAll("." + lazySizesCfg.loadingClass);
                    if (loadingElements.length && loadingElements.forEach) {
                      requestAnimationFrame2(function() {
                        loadingElements.forEach(function(img) {
                          if (img.complete) {
                            unveilElement(img);
                          }
                        });
                      });
                    }
                  }
                });
                if (window2.MutationObserver) {
                  new MutationObserver(throttledCheckElements).observe(docElem, { childList: true, subtree: true, attributes: true });
                } else {
                  docElem[_addEventListener]("DOMNodeInserted", throttledCheckElements, true);
                  docElem[_addEventListener]("DOMAttrModified", throttledCheckElements, true);
                  setInterval(throttledCheckElements, 999);
                }
                addEventListener2("hashchange", throttledCheckElements, true);
                ["focus", "mouseover", "click", "load", "transitionend", "animationend"].forEach(function(name2) {
                  document2[_addEventListener](name2, throttledCheckElements, true);
                });
                if (/d$|^c/.test(document2.readyState)) {
                  onload();
                } else {
                  addEventListener2("load", onload);
                  document2[_addEventListener]("DOMContentLoaded", throttledCheckElements);
                  setTimeout2(onload, 2e4);
                }
                if (lazysizes.elements.length) {
                  checkElements();
                  rAF._lsFlush();
                } else {
                  throttledCheckElements();
                }
              },
              checkElems: throttledCheckElements,
              unveil: unveilElement,
              _aLSL: altLoadmodeScrollListner
            };
          }();
          var autoSizer = function() {
            var autosizesElems;
            var sizeElement = rAFIt(function(elem, parent, event2, width) {
              var sources, i3, len;
              elem._lazysizesWidth = width;
              width += "px";
              elem.setAttribute("sizes", width);
              if (regPicture.test(parent.nodeName || "")) {
                sources = parent.getElementsByTagName("source");
                for (i3 = 0, len = sources.length; i3 < len; i3++) {
                  sources[i3].setAttribute("sizes", width);
                }
              }
              if (!event2.detail.dataAttr) {
                updatePolyfill(elem, event2.detail);
              }
            });
            var getSizeElement = function(elem, dataAttr, width) {
              var event2;
              var parent = elem.parentNode;
              if (parent) {
                width = getWidth(elem, parent, width);
                event2 = triggerEvent(elem, "lazybeforesizes", { width, dataAttr: !!dataAttr });
                if (!event2.defaultPrevented) {
                  width = event2.detail.width;
                  if (width && width !== elem._lazysizesWidth) {
                    sizeElement(elem, parent, event2, width);
                  }
                }
              }
            };
            var updateElementsSizes = function() {
              var i3;
              var len = autosizesElems.length;
              if (len) {
                i3 = 0;
                for (; i3 < len; i3++) {
                  getSizeElement(autosizesElems[i3]);
                }
              }
            };
            var debouncedUpdateElementsSizes = debounce8(updateElementsSizes);
            return {
              _: function() {
                autosizesElems = document2.getElementsByClassName(lazySizesCfg.autosizesClass);
                addEventListener2("resize", debouncedUpdateElementsSizes);
              },
              checkElems: debouncedUpdateElementsSizes,
              updateElem: getSizeElement
            };
          }();
          var init2 = function() {
            if (!init2.i && document2.getElementsByClassName) {
              init2.i = true;
              autoSizer._();
              loader._();
            }
          };
          setTimeout2(function() {
            if (lazySizesCfg.init) {
              init2();
            }
          });
          lazysizes = {
            /**
             * @type { LazySizesConfigPartial }
             */
            cfg: lazySizesCfg,
            autoSizer,
            loader,
            init: init2,
            uP: updatePolyfill,
            aC: addClass,
            rC: removeClass,
            hC: hasClass,
            fire: triggerEvent,
            gW: getWidth,
            rAF
          };
          return lazysizes;
        }
      );
    }
  });

  // node_modules/jstz/dist/jstz.js
  var require_jstz = __commonJS({
    "node_modules/jstz/dist/jstz.js"(exports, module2) {
      init_define_process();
      init_jquery();
      (function(root) {
        var jstz2 = function() {
          "use strict";
          var HEMISPHERE_SOUTH = "s", consts = {
            DAY: 864e5,
            HOUR: 36e5,
            MINUTE: 6e4,
            SECOND: 1e3,
            BASELINE_YEAR: 2014,
            MAX_SCORE: 864e6,
            // 10 days
            AMBIGUITIES: {
              "America/Denver": ["America/Mazatlan"],
              "Europe/London": ["Africa/Casablanca"],
              "America/Chicago": ["America/Mexico_City"],
              "America/Asuncion": ["America/Campo_Grande", "America/Santiago"],
              "America/Montevideo": ["America/Sao_Paulo", "America/Santiago"],
              // Europe/Minsk should not be in this list... but Windows.
              "Asia/Beirut": ["Asia/Amman", "Asia/Jerusalem", "Europe/Helsinki", "Asia/Damascus", "Africa/Cairo", "Asia/Gaza", "Europe/Minsk"],
              "Pacific/Auckland": ["Pacific/Fiji"],
              "America/Los_Angeles": ["America/Santa_Isabel"],
              "America/New_York": ["America/Havana"],
              "America/Halifax": ["America/Goose_Bay"],
              "America/Godthab": ["America/Miquelon"],
              "Asia/Dubai": ["Asia/Yerevan"],
              "Asia/Jakarta": ["Asia/Krasnoyarsk"],
              "Asia/Shanghai": ["Asia/Irkutsk", "Australia/Perth"],
              "Australia/Sydney": ["Australia/Lord_Howe"],
              "Asia/Tokyo": ["Asia/Yakutsk"],
              "Asia/Dhaka": ["Asia/Omsk"],
              // In the real world Yerevan is not ambigous for Baku... but Windows.
              "Asia/Baku": ["Asia/Yerevan"],
              "Australia/Brisbane": ["Asia/Vladivostok"],
              "Pacific/Noumea": ["Asia/Vladivostok"],
              "Pacific/Majuro": ["Asia/Kamchatka", "Pacific/Fiji"],
              "Pacific/Tongatapu": ["Pacific/Apia"],
              "Asia/Baghdad": ["Europe/Minsk", "Europe/Moscow"],
              "Asia/Karachi": ["Asia/Yekaterinburg"],
              "Africa/Johannesburg": ["Asia/Gaza", "Africa/Cairo"]
            }
          }, get_date_offset = function get_date_offset2(date) {
            var offset3 = -date.getTimezoneOffset();
            return offset3 !== null ? offset3 : 0;
          }, lookup_key = function lookup_key2() {
            var january_offset = get_date_offset(new Date(consts.BASELINE_YEAR, 0, 2)), june_offset = get_date_offset(new Date(consts.BASELINE_YEAR, 5, 2)), diff = january_offset - june_offset;
            if (diff < 0) {
              return january_offset + ",1";
            } else if (diff > 0) {
              return june_offset + ",1," + HEMISPHERE_SOUTH;
            }
            return january_offset + ",0";
          }, get_from_internationalization_api = function get_from_internationalization_api2() {
            var format2, timezone;
            if (typeof Intl === "undefined" || typeof Intl.DateTimeFormat === "undefined") {
              return;
            }
            format2 = Intl.DateTimeFormat();
            if (typeof format2 === "undefined" || typeof format2.resolvedOptions === "undefined") {
              return;
            }
            timezone = format2.resolvedOptions().timeZone;
            if (timezone && (timezone.indexOf("/") > -1 || timezone === "UTC") && timezone.indexOf("Etc") != 0) {
              return timezone;
            }
          }, dst_dates = function dst_dates2(year) {
            var yearstart = new Date(year, 0, 1, 0, 0, 1, 0).getTime();
            var yearend = new Date(year, 12, 31, 23, 59, 59).getTime();
            var current = yearstart;
            var offset3 = new Date(current).getTimezoneOffset();
            var dst_start = null;
            var dst_end = null;
            while (current < yearend - 864e5) {
              var dateToCheck = new Date(current);
              var dateToCheckOffset = dateToCheck.getTimezoneOffset();
              if (dateToCheckOffset !== offset3) {
                if (dateToCheckOffset < offset3) {
                  dst_start = dateToCheck;
                }
                if (dateToCheckOffset > offset3) {
                  dst_end = dateToCheck;
                }
                offset3 = dateToCheckOffset;
              }
              current += 864e5;
            }
            if (dst_start && dst_end) {
              return {
                s: find_dst_fold(dst_start).getTime(),
                e: find_dst_fold(dst_end).getTime()
              };
            }
            return false;
          }, find_dst_fold = function find_dst_fold2(a_date, padding, iterator) {
            if (typeof padding === "undefined") {
              padding = consts.DAY;
              iterator = consts.HOUR;
            }
            var date_start = new Date(a_date.getTime() - padding).getTime();
            var date_end = a_date.getTime() + padding;
            var offset3 = new Date(date_start).getTimezoneOffset();
            var current = date_start;
            var dst_change = null;
            while (current < date_end - iterator) {
              var dateToCheck = new Date(current);
              var dateToCheckOffset = dateToCheck.getTimezoneOffset();
              if (dateToCheckOffset !== offset3) {
                dst_change = dateToCheck;
                break;
              }
              current += iterator;
            }
            if (padding === consts.DAY) {
              return find_dst_fold2(dst_change, consts.HOUR, consts.MINUTE);
            }
            if (padding === consts.HOUR) {
              return find_dst_fold2(dst_change, consts.MINUTE, consts.SECOND);
            }
            return dst_change;
          }, windows7_adaptations = function windows7_adaptions(rule_list, preliminary_timezone, score, sample2) {
            if (score !== "N/A") {
              return score;
            }
            if (preliminary_timezone === "Asia/Beirut") {
              if (sample2.name === "Africa/Cairo") {
                if (rule_list[6].s === 13983768e5 && rule_list[6].e === 14116788e5) {
                  return 0;
                }
              }
              if (sample2.name === "Asia/Jerusalem") {
                if (rule_list[6].s === 13959648e5 && rule_list[6].e === 14118588e5) {
                  return 0;
                }
              }
            } else if (preliminary_timezone === "America/Santiago") {
              if (sample2.name === "America/Asuncion") {
                if (rule_list[6].s === 14124816e5 && rule_list[6].e === 1397358e6) {
                  return 0;
                }
              }
              if (sample2.name === "America/Campo_Grande") {
                if (rule_list[6].s === 14136912e5 && rule_list[6].e === 13925196e5) {
                  return 0;
                }
              }
            } else if (preliminary_timezone === "America/Montevideo") {
              if (sample2.name === "America/Sao_Paulo") {
                if (rule_list[6].s === 14136876e5 && rule_list[6].e === 1392516e6) {
                  return 0;
                }
              }
            } else if (preliminary_timezone === "Pacific/Auckland") {
              if (sample2.name === "Pacific/Fiji") {
                if (rule_list[6].s === 14142456e5 && rule_list[6].e === 13961016e5) {
                  return 0;
                }
              }
            }
            return score;
          }, best_dst_match = function best_dst_match2(rule_list, preliminary_timezone) {
            var score_sample = function score_sample2(sample3) {
              var score2 = 0;
              for (var j7 = 0; j7 < rule_list.length; j7++) {
                if (!!sample3.rules[j7] && !!rule_list[j7]) {
                  if (rule_list[j7].s >= sample3.rules[j7].s && rule_list[j7].e <= sample3.rules[j7].e) {
                    score2 = 0;
                    score2 += Math.abs(rule_list[j7].s - sample3.rules[j7].s);
                    score2 += Math.abs(sample3.rules[j7].e - rule_list[j7].e);
                  } else {
                    score2 = "N/A";
                    break;
                  }
                  if (score2 > consts.MAX_SCORE) {
                    score2 = "N/A";
                    break;
                  }
                }
              }
              score2 = windows7_adaptations(rule_list, preliminary_timezone, score2, sample3);
              return score2;
            };
            var scoreboard = {};
            var dst_zones = jstz2.olson.dst_rules.zones;
            var dst_zones_length = dst_zones.length;
            var ambiguities = consts.AMBIGUITIES[preliminary_timezone];
            for (var i3 = 0; i3 < dst_zones_length; i3++) {
              var sample2 = dst_zones[i3];
              var score = score_sample(dst_zones[i3]);
              if (score !== "N/A") {
                scoreboard[sample2.name] = score;
              }
            }
            for (var tz in scoreboard) {
              if (scoreboard.hasOwnProperty(tz)) {
                for (var j6 = 0; j6 < ambiguities.length; j6++) {
                  if (ambiguities[j6] === tz) {
                    return tz;
                  }
                }
              }
            }
            return preliminary_timezone;
          }, get_by_dst = function get_by_dst2(preliminary_timezone) {
            var get_rules = function get_rules2() {
              var rule_list = [];
              for (var i3 = 0; i3 < jstz2.olson.dst_rules.years.length; i3++) {
                var year_rules = dst_dates(jstz2.olson.dst_rules.years[i3]);
                rule_list.push(year_rules);
              }
              return rule_list;
            };
            var check_has_dst = function check_has_dst2(rules2) {
              for (var i3 = 0; i3 < rules2.length; i3++) {
                if (rules2[i3] !== false) {
                  return true;
                }
              }
              return false;
            };
            var rules = get_rules();
            var has_dst = check_has_dst(rules);
            if (has_dst) {
              return best_dst_match(rules, preliminary_timezone);
            }
            return preliminary_timezone;
          }, determine = function determine2() {
            var preliminary_tz = get_from_internationalization_api();
            if (!preliminary_tz) {
              preliminary_tz = jstz2.olson.timezones[lookup_key()];
              if (typeof consts.AMBIGUITIES[preliminary_tz] !== "undefined") {
                preliminary_tz = get_by_dst(preliminary_tz);
              }
            }
            return {
              name: function() {
                return preliminary_tz;
              },
              stdTimezoneOffset: function() {
                return -lookup_key().split(",")[0];
              },
              timezoneOffset: function() {
                return -get_date_offset(/* @__PURE__ */ new Date());
              }
            };
          };
          return {
            determine
          };
        }();
        jstz2.olson = jstz2.olson || {};
        jstz2.olson.timezones = {
          "-720,0": "Etc/GMT+12",
          "-660,0": "Pacific/Pago_Pago",
          "-660,1,s": "Pacific/Apia",
          // Why? Because windows... cry!
          "-600,1": "America/Adak",
          "-600,0": "Pacific/Honolulu",
          "-570,0": "Pacific/Marquesas",
          "-540,0": "Pacific/Gambier",
          "-540,1": "America/Anchorage",
          "-480,1": "America/Los_Angeles",
          "-480,0": "Pacific/Pitcairn",
          "-420,0": "America/Phoenix",
          "-420,1": "America/Denver",
          "-360,0": "America/Guatemala",
          "-360,1": "America/Chicago",
          "-360,1,s": "Pacific/Easter",
          "-300,0": "America/Bogota",
          "-300,1": "America/New_York",
          "-270,0": "America/Caracas",
          "-240,1": "America/Halifax",
          "-240,0": "America/Santo_Domingo",
          "-240,1,s": "America/Asuncion",
          "-210,1": "America/St_Johns",
          "-180,1": "America/Godthab",
          "-180,0": "America/Argentina/Buenos_Aires",
          "-180,1,s": "America/Montevideo",
          "-120,0": "America/Noronha",
          "-120,1": "America/Noronha",
          "-60,1": "Atlantic/Azores",
          "-60,0": "Atlantic/Cape_Verde",
          "0,0": "UTC",
          "0,1": "Europe/London",
          "60,1": "Europe/Berlin",
          "60,0": "Africa/Lagos",
          "60,1,s": "Africa/Windhoek",
          "120,1": "Asia/Beirut",
          "120,0": "Africa/Johannesburg",
          "180,0": "Asia/Baghdad",
          "180,1": "Europe/Moscow",
          "210,1": "Asia/Tehran",
          "240,0": "Asia/Dubai",
          "240,1": "Asia/Baku",
          "270,0": "Asia/Kabul",
          "300,1": "Asia/Yekaterinburg",
          "300,0": "Asia/Karachi",
          "330,0": "Asia/Kolkata",
          "345,0": "Asia/Kathmandu",
          "360,0": "Asia/Dhaka",
          "360,1": "Asia/Omsk",
          "390,0": "Asia/Rangoon",
          "420,1": "Asia/Krasnoyarsk",
          "420,0": "Asia/Jakarta",
          "480,0": "Asia/Shanghai",
          "480,1": "Asia/Irkutsk",
          "525,0": "Australia/Eucla",
          "525,1,s": "Australia/Eucla",
          "540,1": "Asia/Yakutsk",
          "540,0": "Asia/Tokyo",
          "570,0": "Australia/Darwin",
          "570,1,s": "Australia/Adelaide",
          "600,0": "Australia/Brisbane",
          "600,1": "Asia/Vladivostok",
          "600,1,s": "Australia/Sydney",
          "630,1,s": "Australia/Lord_Howe",
          "660,1": "Asia/Kamchatka",
          "660,0": "Pacific/Noumea",
          "690,0": "Pacific/Norfolk",
          "720,1,s": "Pacific/Auckland",
          "720,0": "Pacific/Majuro",
          "765,1,s": "Pacific/Chatham",
          "780,0": "Pacific/Tongatapu",
          "780,1,s": "Pacific/Apia",
          "840,0": "Pacific/Kiritimati"
        };
        jstz2.olson.dst_rules = {
          "years": [
            2008,
            2009,
            2010,
            2011,
            2012,
            2013,
            2014
          ],
          "zones": [
            {
              "name": "Africa/Cairo",
              "rules": [
                {
                  "e": 12199572e5,
                  "s": 12090744e5
                },
                {
                  "e": 1250802e6,
                  "s": 1240524e6
                },
                {
                  "e": 12858804e5,
                  "s": 12840696e5
                },
                false,
                false,
                false,
                {
                  "e": 14116788e5,
                  "s": 1406844e6
                }
              ]
            },
            {
              "name": "Africa/Casablanca",
              "rules": [
                {
                  "e": 12202236e5,
                  "s": 12122784e5
                },
                {
                  "e": 12508092e5,
                  "s": 12438144e5
                },
                {
                  "e": 1281222e6,
                  "s": 12727584e5
                },
                {
                  "e": 13120668e5,
                  "s": 13017888e5
                },
                {
                  "e": 13489704e5,
                  "s": 1345428e6
                },
                {
                  "e": 13828392e5,
                  "s": 13761e8
                },
                {
                  "e": 14142888e5,
                  "s": 14069448e5
                }
              ]
            },
            {
              "name": "America/Asuncion",
              "rules": [
                {
                  "e": 12050316e5,
                  "s": 12243888e5
                },
                {
                  "e": 12364812e5,
                  "s": 12558384e5
                },
                {
                  "e": 12709548e5,
                  "s": 12860784e5
                },
                {
                  "e": 13024044e5,
                  "s": 1317528e6
                },
                {
                  "e": 1333854e6,
                  "s": 13495824e5
                },
                {
                  "e": 1364094e6,
                  "s": 1381032e6
                },
                {
                  "e": 13955436e5,
                  "s": 14124816e5
                }
              ]
            },
            {
              "name": "America/Campo_Grande",
              "rules": [
                {
                  "e": 12032172e5,
                  "s": 12243888e5
                },
                {
                  "e": 12346668e5,
                  "s": 12558384e5
                },
                {
                  "e": 12667212e5,
                  "s": 1287288e6
                },
                {
                  "e": 12981708e5,
                  "s": 13187376e5
                },
                {
                  "e": 13302252e5,
                  "s": 1350792e6
                },
                {
                  "e": 136107e7,
                  "s": 13822416e5
                },
                {
                  "e": 13925196e5,
                  "s": 14136912e5
                }
              ]
            },
            {
              "name": "America/Goose_Bay",
              "rules": [
                {
                  "e": 122559486e4,
                  "s": 120503526e4
                },
                {
                  "e": 125704446e4,
                  "s": 123648486e4
                },
                {
                  "e": 128909886e4,
                  "s": 126853926e4
                },
                {
                  "e": 13205556e5,
                  "s": 129998886e4
                },
                {
                  "e": 13520052e5,
                  "s": 13314456e5
                },
                {
                  "e": 13834548e5,
                  "s": 13628952e5
                },
                {
                  "e": 14149044e5,
                  "s": 13943448e5
                }
              ]
            },
            {
              "name": "America/Havana",
              "rules": [
                {
                  "e": 12249972e5,
                  "s": 12056436e5
                },
                {
                  "e": 12564468e5,
                  "s": 12364884e5
                },
                {
                  "e": 12885012e5,
                  "s": 12685428e5
                },
                {
                  "e": 13211604e5,
                  "s": 13005972e5
                },
                {
                  "e": 13520052e5,
                  "s": 13332564e5
                },
                {
                  "e": 13834548e5,
                  "s": 13628916e5
                },
                {
                  "e": 14149044e5,
                  "s": 13943412e5
                }
              ]
            },
            {
              "name": "America/Mazatlan",
              "rules": [
                {
                  "e": 1225008e6,
                  "s": 12074724e5
                },
                {
                  "e": 12564576e5,
                  "s": 1238922e6
                },
                {
                  "e": 1288512e6,
                  "s": 12703716e5
                },
                {
                  "e": 13199616e5,
                  "s": 13018212e5
                },
                {
                  "e": 13514112e5,
                  "s": 13332708e5
                },
                {
                  "e": 13828608e5,
                  "s": 13653252e5
                },
                {
                  "e": 14143104e5,
                  "s": 13967748e5
                }
              ]
            },
            {
              "name": "America/Mexico_City",
              "rules": [
                {
                  "e": 12250044e5,
                  "s": 12074688e5
                },
                {
                  "e": 1256454e6,
                  "s": 12389184e5
                },
                {
                  "e": 12885084e5,
                  "s": 1270368e6
                },
                {
                  "e": 1319958e6,
                  "s": 13018176e5
                },
                {
                  "e": 13514076e5,
                  "s": 13332672e5
                },
                {
                  "e": 13828572e5,
                  "s": 13653216e5
                },
                {
                  "e": 14143068e5,
                  "s": 13967712e5
                }
              ]
            },
            {
              "name": "America/Miquelon",
              "rules": [
                {
                  "e": 12255984e5,
                  "s": 12050388e5
                },
                {
                  "e": 1257048e6,
                  "s": 12364884e5
                },
                {
                  "e": 12891024e5,
                  "s": 12685428e5
                },
                {
                  "e": 1320552e6,
                  "s": 12999924e5
                },
                {
                  "e": 13520016e5,
                  "s": 1331442e6
                },
                {
                  "e": 13834512e5,
                  "s": 13628916e5
                },
                {
                  "e": 14149008e5,
                  "s": 13943412e5
                }
              ]
            },
            {
              "name": "America/Santa_Isabel",
              "rules": [
                {
                  "e": 12250116e5,
                  "s": 1207476e6
                },
                {
                  "e": 12564612e5,
                  "s": 12389256e5
                },
                {
                  "e": 12885156e5,
                  "s": 12703752e5
                },
                {
                  "e": 13199652e5,
                  "s": 13018248e5
                },
                {
                  "e": 13514148e5,
                  "s": 13332744e5
                },
                {
                  "e": 13828644e5,
                  "s": 13653288e5
                },
                {
                  "e": 1414314e6,
                  "s": 13967784e5
                }
              ]
            },
            {
              "name": "America/Santiago",
              "rules": [
                {
                  "e": 1206846e6,
                  "s": 1223784e6
                },
                {
                  "e": 1237086e6,
                  "s": 12552336e5
                },
                {
                  "e": 127035e7,
                  "s": 12866832e5
                },
                {
                  "e": 13048236e5,
                  "s": 13138992e5
                },
                {
                  "e": 13356684e5,
                  "s": 13465584e5
                },
                {
                  "e": 1367118e6,
                  "s": 13786128e5
                },
                {
                  "e": 13985676e5,
                  "s": 14100624e5
                }
              ]
            },
            {
              "name": "America/Sao_Paulo",
              "rules": [
                {
                  "e": 12032136e5,
                  "s": 12243852e5
                },
                {
                  "e": 12346632e5,
                  "s": 12558348e5
                },
                {
                  "e": 12667176e5,
                  "s": 12872844e5
                },
                {
                  "e": 12981672e5,
                  "s": 1318734e6
                },
                {
                  "e": 13302216e5,
                  "s": 13507884e5
                },
                {
                  "e": 13610664e5,
                  "s": 1382238e6
                },
                {
                  "e": 1392516e6,
                  "s": 14136876e5
                }
              ]
            },
            {
              "name": "Asia/Amman",
              "rules": [
                {
                  "e": 1225404e6,
                  "s": 12066552e5
                },
                {
                  "e": 12568536e5,
                  "s": 12381048e5
                },
                {
                  "e": 12883032e5,
                  "s": 12695544e5
                },
                {
                  "e": 13197528e5,
                  "s": 13016088e5
                },
                false,
                false,
                {
                  "e": 14147064e5,
                  "s": 13959576e5
                }
              ]
            },
            {
              "name": "Asia/Damascus",
              "rules": [
                {
                  "e": 12254868e5,
                  "s": 120726e7
                },
                {
                  "e": 125685e7,
                  "s": 12381048e5
                },
                {
                  "e": 12882996e5,
                  "s": 12701592e5
                },
                {
                  "e": 13197492e5,
                  "s": 13016088e5
                },
                {
                  "e": 13511988e5,
                  "s": 13330584e5
                },
                {
                  "e": 13826484e5,
                  "s": 1364508e6
                },
                {
                  "e": 14147028e5,
                  "s": 13959576e5
                }
              ]
            },
            {
              "name": "Asia/Dubai",
              "rules": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Gaza",
              "rules": [
                {
                  "e": 12199572e5,
                  "s": 12066552e5
                },
                {
                  "e": 12520152e5,
                  "s": 12381048e5
                },
                {
                  "e": 1281474e6,
                  "s": 126964086e4
                },
                {
                  "e": 1312146e6,
                  "s": 130160886e4
                },
                {
                  "e": 13481784e5,
                  "s": 13330584e5
                },
                {
                  "e": 13802292e5,
                  "s": 1364508e6
                },
                {
                  "e": 1414098e6,
                  "s": 13959576e5
                }
              ]
            },
            {
              "name": "Asia/Irkutsk",
              "rules": [
                {
                  "e": 12249576e5,
                  "s": 12068136e5
                },
                {
                  "e": 12564072e5,
                  "s": 12382632e5
                },
                {
                  "e": 12884616e5,
                  "s": 12697128e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Jerusalem",
              "rules": [
                {
                  "e": 12231612e5,
                  "s": 12066624e5
                },
                {
                  "e": 1254006e6,
                  "s": 1238112e6
                },
                {
                  "e": 1284246e6,
                  "s": 12695616e5
                },
                {
                  "e": 131751e7,
                  "s": 1301616e6
                },
                {
                  "e": 13483548e5,
                  "s": 13330656e5
                },
                {
                  "e": 13828284e5,
                  "s": 13645152e5
                },
                {
                  "e": 1414278e6,
                  "s": 13959648e5
                }
              ]
            },
            {
              "name": "Asia/Kamchatka",
              "rules": [
                {
                  "e": 12249432e5,
                  "s": 12067992e5
                },
                {
                  "e": 12563928e5,
                  "s": 12382488e5
                },
                {
                  "e": 12884508e5,
                  "s": 12696984e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Krasnoyarsk",
              "rules": [
                {
                  "e": 12249612e5,
                  "s": 12068172e5
                },
                {
                  "e": 12564108e5,
                  "s": 12382668e5
                },
                {
                  "e": 12884652e5,
                  "s": 12697164e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Omsk",
              "rules": [
                {
                  "e": 12249648e5,
                  "s": 12068208e5
                },
                {
                  "e": 12564144e5,
                  "s": 12382704e5
                },
                {
                  "e": 12884688e5,
                  "s": 126972e7
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Vladivostok",
              "rules": [
                {
                  "e": 12249504e5,
                  "s": 12068064e5
                },
                {
                  "e": 12564e8,
                  "s": 1238256e6
                },
                {
                  "e": 12884544e5,
                  "s": 12697056e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Yakutsk",
              "rules": [
                {
                  "e": 1224954e6,
                  "s": 120681e7
                },
                {
                  "e": 12564036e5,
                  "s": 12382596e5
                },
                {
                  "e": 1288458e6,
                  "s": 12697092e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Yekaterinburg",
              "rules": [
                {
                  "e": 12249684e5,
                  "s": 12068244e5
                },
                {
                  "e": 1256418e6,
                  "s": 1238274e6
                },
                {
                  "e": 12884724e5,
                  "s": 12697236e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Asia/Yerevan",
              "rules": [
                {
                  "e": 1224972e6,
                  "s": 1206828e6
                },
                {
                  "e": 12564216e5,
                  "s": 12382776e5
                },
                {
                  "e": 1288476e6,
                  "s": 12697272e5
                },
                {
                  "e": 13199256e5,
                  "s": 13011768e5
                },
                false,
                false,
                false
              ]
            },
            {
              "name": "Australia/Lord_Howe",
              "rules": [
                {
                  "e": 12074076e5,
                  "s": 12231342e5
                },
                {
                  "e": 12388572e5,
                  "s": 12545838e5
                },
                {
                  "e": 12703068e5,
                  "s": 12860334e5
                },
                {
                  "e": 13017564e5,
                  "s": 1317483e6
                },
                {
                  "e": 1333206e6,
                  "s": 13495374e5
                },
                {
                  "e": 13652604e5,
                  "s": 1380987e6
                },
                {
                  "e": 139671e7,
                  "s": 14124366e5
                }
              ]
            },
            {
              "name": "Australia/Perth",
              "rules": [
                {
                  "e": 12068136e5,
                  "s": 12249576e5
                },
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Europe/Helsinki",
              "rules": [
                {
                  "e": 12249828e5,
                  "s": 12068388e5
                },
                {
                  "e": 12564324e5,
                  "s": 12382884e5
                },
                {
                  "e": 12884868e5,
                  "s": 1269738e6
                },
                {
                  "e": 13199364e5,
                  "s": 13011876e5
                },
                {
                  "e": 1351386e6,
                  "s": 13326372e5
                },
                {
                  "e": 13828356e5,
                  "s": 13646916e5
                },
                {
                  "e": 14142852e5,
                  "s": 13961412e5
                }
              ]
            },
            {
              "name": "Europe/Minsk",
              "rules": [
                {
                  "e": 12249792e5,
                  "s": 12068352e5
                },
                {
                  "e": 12564288e5,
                  "s": 12382848e5
                },
                {
                  "e": 12884832e5,
                  "s": 12697344e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Europe/Moscow",
              "rules": [
                {
                  "e": 12249756e5,
                  "s": 12068316e5
                },
                {
                  "e": 12564252e5,
                  "s": 12382812e5
                },
                {
                  "e": 12884796e5,
                  "s": 12697308e5
                },
                false,
                false,
                false,
                false
              ]
            },
            {
              "name": "Pacific/Apia",
              "rules": [
                false,
                false,
                false,
                {
                  "e": 13017528e5,
                  "s": 13168728e5
                },
                {
                  "e": 13332024e5,
                  "s": 13489272e5
                },
                {
                  "e": 13652568e5,
                  "s": 13803768e5
                },
                {
                  "e": 13967064e5,
                  "s": 14118264e5
                }
              ]
            },
            {
              "name": "Pacific/Fiji",
              "rules": [
                false,
                false,
                {
                  "e": 12696984e5,
                  "s": 12878424e5
                },
                {
                  "e": 13271544e5,
                  "s": 1319292e6
                },
                {
                  "e": 1358604e6,
                  "s": 13507416e5
                },
                {
                  "e": 139005e7,
                  "s": 1382796e6
                },
                {
                  "e": 14215032e5,
                  "s": 14148504e5
                }
              ]
            },
            {
              "name": "Europe/London",
              "rules": [
                {
                  "e": 12249828e5,
                  "s": 12068388e5
                },
                {
                  "e": 12564324e5,
                  "s": 12382884e5
                },
                {
                  "e": 12884868e5,
                  "s": 1269738e6
                },
                {
                  "e": 13199364e5,
                  "s": 13011876e5
                },
                {
                  "e": 1351386e6,
                  "s": 13326372e5
                },
                {
                  "e": 13828356e5,
                  "s": 13646916e5
                },
                {
                  "e": 14142852e5,
                  "s": 13961412e5
                }
              ]
            }
          ]
        };
        if (typeof module2 !== "undefined" && typeof module2.exports !== "undefined") {
          module2.exports = jstz2;
        } else if (typeof define !== "undefined" && define !== null && define.amd != null) {
          define([], function() {
            return jstz2;
          });
        } else {
          if (typeof root === "undefined") {
            window.jstz = jstz2;
          } else {
            root.jstz = jstz2;
          }
        }
      })();
    }
  });

  // node_modules/jstz/index.js
  var require_jstz2 = __commonJS({
    "node_modules/jstz/index.js"(exports, module2) {
      init_define_process();
      init_jquery();
      module2.exports = require_jstz();
    }
  });

  // app/javascript/entrypoints/customer-center/customer-center.js
  init_define_process();
  init_jquery();

  // app/javascript/customer_center/application.js
  init_define_process();
  init_jquery();
  init_jquery();
  var import_ujs2 = __toESM(require_rails_ujs());

  // node_modules/cable_ready/dist/cable_ready.js
  init_define_process();
  init_jquery();

  // node_modules/morphdom/dist/morphdom-esm.js
  init_define_process();
  init_jquery();
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i3 = toNodeAttrs.length - 1; i3 >= 0; i3--) {
      attr = toNodeAttrs[i3];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d5 = fromNodeAttrs.length - 1; d5 >= 0; d5--) {
      attr = fromNodeAttrs[d5];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template2 = doc.createElement("template");
    template2.innerHTML = str;
    return template2.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name2, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name2) : doc.createElementNS(namespaceURI, name2);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name2) {
    if (fromEl[name2] !== toEl[name2]) {
      fromEl[name2] = toEl[name2];
      if (fromEl[name2]) {
        fromEl.setAttribute(name2, "");
      } else {
        fromEl.removeAttribute(name2);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i3 = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i3;
                break;
              }
              i3++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(
              curFromNodeChild,
              fromEl,
              true
              /* skip keyed nodes */
            );
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren2(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren2(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer: while (curToNodeChild) {
          toNextSibling = curToNodeChild.nextSibling;
          curToNodeKey = getNodeKey(curToNodeChild);
          while (curFromNodeChild) {
            fromNextSibling = curFromNodeChild.nextSibling;
            if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
              curToNodeChild = toNextSibling;
              curFromNodeChild = fromNextSibling;
              continue outer;
            }
            curFromNodeKey = getNodeKey(curFromNodeChild);
            var curFromNodeType = curFromNodeChild.nodeType;
            var isCompatible = void 0;
            if (curFromNodeType === curToNodeChild.nodeType) {
              if (curFromNodeType === ELEMENT_NODE) {
                if (curToNodeKey) {
                  if (curToNodeKey !== curFromNodeKey) {
                    if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                      if (fromNextSibling === matchingFromEl) {
                        isCompatible = false;
                      } else {
                        fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                        if (curFromNodeKey) {
                          addKeyedRemoval(curFromNodeKey);
                        } else {
                          removeNode(
                            curFromNodeChild,
                            fromEl,
                            true
                            /* skip keyed nodes */
                          );
                        }
                        curFromNodeChild = matchingFromEl;
                      }
                    } else {
                      isCompatible = false;
                    }
                  }
                } else if (curFromNodeKey) {
                  isCompatible = false;
                }
                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                if (isCompatible) {
                  morphEl(curFromNodeChild, curToNodeChild);
                }
              } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                isCompatible = true;
                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                  curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                }
              }
            }
            if (isCompatible) {
              curToNodeChild = toNextSibling;
              curFromNodeChild = fromNextSibling;
              continue outer;
            }
            if (curFromNodeKey) {
              addKeyedRemoval(curFromNodeKey);
            } else {
              removeNode(
                curFromNodeChild,
                fromEl,
                true
                /* skip keyed nodes */
              );
            }
            curFromNodeChild = fromNextSibling;
          }
          if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
            fromEl.appendChild(matchingFromEl);
            morphEl(matchingFromEl, curToNodeChild);
          } else {
            var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
            if (onBeforeNodeAddedResult !== false) {
              if (onBeforeNodeAddedResult) {
                curToNodeChild = onBeforeNodeAddedResult;
              }
              if (curToNodeChild.actualize) {
                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
              }
              fromEl.appendChild(curToNodeChild);
              handleNodeAdded(curToNodeChild);
            }
          }
          curToNodeChild = toNextSibling;
          curFromNodeChild = fromNextSibling;
        }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i3 = 0, len = keyedRemovalList.length; i3 < len; i3++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i3]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;

  // node_modules/cable_ready/dist/cable_ready.js
  var name = "cable_ready";
  var version = "5.0.3";
  var description = "CableReady helps you create great real-time user experiences by making it simple to trigger client-side DOM changes from server-side Ruby.";
  var keywords = ["ruby", "rails", "websockets", "actioncable", "cable", "ssr", "stimulus_reflex", "client-side", "dom"];
  var homepage = "https://cableready.stimulusreflex.com";
  var bugs = "https://github.com/stimulusreflex/cable_ready/issues";
  var repository = "https://github.com/stimulusreflex/cable_ready";
  var license = "MIT";
  var author = "Nathan Hopkins <natehop@gmail.com>";
  var contributors = ["Andrew Mason <andrewmcodes@protonmail.com>", "Julian Rubisch <julian@julianrubisch.at>", "Marco Roth <marco.roth@intergga.ch>", "Nathan Hopkins <natehop@gmail.com>"];
  var main = "./dist/cable_ready.js";
  var module = "./dist/cable_ready.js";
  var browser = "./dist/cable_ready.js";
  var unpkg = "./dist/cable_ready.umd.js";
  var umd = "./dist/cable_ready.umd.js";
  var files = ["dist/*", "javascript/*"];
  var scripts = {
    lint: "yarn run format --check",
    format: "yarn run prettier-standard ./javascript/**/*.js rollup.config.mjs",
    build: "yarn rollup -c",
    watch: "yarn rollup -wc",
    test: "web-test-runner javascript/test/**/*.test.js",
    "docs:dev": "vitepress dev docs",
    "docs:build": "vitepress build docs && cp ./docs/_redirects ./docs/.vitepress/dist",
    "docs:preview": "vitepress preview docs"
  };
  var dependencies = {
    morphdom: "2.6.1"
  };
  var devDependencies = {
    "@open-wc/testing": "^3.1.7",
    "@rollup/plugin-json": "^6.0.0",
    "@rollup/plugin-node-resolve": "^15.0.1",
    "@rollup/plugin-terser": "^0.4.0",
    "@web/dev-server-esbuild": "^0.3.3",
    "@web/dev-server-rollup": "^0.3.21",
    "@web/test-runner": "^0.15.1",
    "prettier-standard": "^16.4.1",
    rollup: "^3.19.1",
    sinon: "^15.0.2",
    vite: "^4.1.4",
    vitepress: "^1.0.0-beta.1",
    "vitepress-plugin-search": "^1.0.4-alpha.19"
  };
  var packageInfo = {
    name,
    version,
    description,
    keywords,
    homepage,
    bugs,
    repository,
    license,
    author,
    contributors,
    main,
    module,
    browser,
    import: "./dist/cable_ready.js",
    unpkg,
    umd,
    files,
    scripts,
    dependencies,
    devDependencies
  };
  var inputTags = {
    INPUT: true,
    TEXTAREA: true,
    SELECT: true
  };
  var mutableTags = {
    INPUT: true,
    TEXTAREA: true,
    OPTION: true
  };
  var textInputTypes = {
    "datetime-local": true,
    "select-multiple": true,
    "select-one": true,
    color: true,
    date: true,
    datetime: true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    textarea: true,
    time: true,
    url: true,
    week: true
  };
  var activeElement;
  var ActiveElement = {
    get element() {
      return activeElement;
    },
    set(element) {
      activeElement = element;
    }
  };
  var isTextInput = (element) => inputTags[element.tagName] && textInputTypes[element.type];
  var assignFocus = (selector) => {
    const element = selector && selector.nodeType === Node.ELEMENT_NODE ? selector : document.querySelector(selector);
    const focusElement = element || ActiveElement.element;
    if (focusElement && focusElement.focus) focusElement.focus();
  };
  var dispatch = (element, name2, detail = {}) => {
    const init2 = {
      bubbles: true,
      cancelable: true,
      detail
    };
    const event2 = new CustomEvent(name2, init2);
    element.dispatchEvent(event2);
    if (window.jQuery) window.jQuery(element).trigger(name2, detail);
  };
  var xpathToElement = (xpath) => document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
  var xpathToElementArray = (xpath, reverse = false) => {
    const snapshotList = document.evaluate(xpath, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    const snapshots = [];
    for (let i3 = 0; i3 < snapshotList.snapshotLength; i3++) {
      snapshots.push(snapshotList.snapshotItem(i3));
    }
    return reverse ? snapshots.reverse() : snapshots;
  };
  var getClassNames = (names2) => Array.from(names2).flat();
  var processElements = (operation, callback2) => {
    Array.from(operation.selectAll ? operation.element : [operation.element]).forEach(callback2);
  };
  var kebabize = createCompounder(function(result, word, index2) {
    return result + (index2 ? "-" : "") + word.toLowerCase();
  });
  function createCompounder(callback2) {
    return function(str) {
      return words(str).reduce(callback2, "");
    };
  }
  var words = (str) => {
    str = str == null ? "" : str;
    return str.match(/([A-Z]{2,}|[0-9]+|[A-Z]?[a-z]+|[A-Z])/g) || [];
  };
  var operate = (operation, callback2) => {
    if (!operation.cancel) {
      operation.delay ? setTimeout(callback2, operation.delay) : callback2();
      return true;
    }
    return false;
  };
  var before = (target, operation) => dispatch(target, `cable-ready:before-${kebabize(operation.operation)}`, operation);
  var after = (target, operation) => dispatch(target, `cable-ready:after-${kebabize(operation.operation)}`, operation);
  function debounce(fn3, delay = 250) {
    let timer;
    return (...args) => {
      const callback2 = () => fn3.apply(this, args);
      if (timer) clearTimeout(timer);
      timer = setTimeout(callback2, delay);
    };
  }
  function handleErrors(response2) {
    if (!response2.ok) throw Error(response2.statusText);
    return response2;
  }
  function safeScalar(val) {
    if (val !== void 0 && !["string", "number", "boolean"].includes(typeof val)) console.warn(`Operation expects a string, number or boolean, but got ${val} (${typeof val})`);
    return val != null ? val : "";
  }
  function safeString(str) {
    if (str !== void 0 && typeof str !== "string") console.warn(`Operation expects a string, but got ${str} (${typeof str})`);
    return str != null ? String(str) : "";
  }
  function safeArray(arr) {
    if (arr !== void 0 && !Array.isArray(arr)) console.warn(`Operation expects an array, but got ${arr} (${typeof arr})`);
    return arr != null ? Array.from(arr) : [];
  }
  function safeObject(obj) {
    if (obj !== void 0 && typeof obj !== "object") console.warn(`Operation expects an object, but got ${obj} (${typeof obj})`);
    return obj != null ? Object(obj) : {};
  }
  function safeStringOrArray(elem) {
    if (elem !== void 0 && !Array.isArray(elem) && typeof elem !== "string") console.warn(`Operation expects an Array or a String, but got ${elem} (${typeof elem})`);
    return elem == null ? "" : Array.isArray(elem) ? Array.from(elem) : String(elem);
  }
  function fragmentToString(fragment) {
    return new XMLSerializer().serializeToString(fragment);
  }
  async function graciouslyFetch(url, additionalHeaders) {
    try {
      const response2 = await fetch(url, {
        headers: {
          "X-REQUESTED-WITH": "XmlHttpRequest",
          ...additionalHeaders
        }
      });
      if (response2 == void 0) return;
      handleErrors(response2);
      return response2;
    } catch (e2) {
      console.error(`Could not fetch ${url}`);
    }
  }
  var BoundedQueue = class {
    constructor(maxSize) {
      this.maxSize = maxSize;
      this.queue = [];
    }
    push(item) {
      if (this.isFull()) {
        this.shift();
      }
      this.queue.push(item);
    }
    shift() {
      return this.queue.shift();
    }
    isFull() {
      return this.queue.length === this.maxSize;
    }
  };
  var utils = Object.freeze({
    __proto__: null,
    BoundedQueue,
    after,
    assignFocus,
    before,
    debounce,
    dispatch,
    fragmentToString,
    getClassNames,
    graciouslyFetch,
    handleErrors,
    isTextInput,
    kebabize,
    operate,
    processElements,
    safeArray,
    safeObject,
    safeScalar,
    safeString,
    safeStringOrArray,
    xpathToElement,
    xpathToElementArray
  });
  var shouldMorph = (operation) => (fromEl, toEl) => !shouldMorphCallbacks.map((callback2) => typeof callback2 === "function" ? callback2(operation, fromEl, toEl) : true).includes(false);
  var didMorph = (operation) => (el) => {
    didMorphCallbacks.forEach((callback2) => {
      if (typeof callback2 === "function") callback2(operation, el);
    });
  };
  var verifyNotMutable = (detail, fromEl, toEl) => {
    if (!mutableTags[fromEl.tagName] && fromEl.isEqualNode(toEl)) return false;
    return true;
  };
  var verifyNotContentEditable = (detail, fromEl, toEl) => {
    if (fromEl === ActiveElement.element && fromEl.isContentEditable) return false;
    return true;
  };
  var verifyNotPermanent = (detail, fromEl, toEl) => {
    const { permanentAttributeName } = detail;
    if (!permanentAttributeName) return true;
    const permanent = fromEl.closest(`[${permanentAttributeName}]`);
    if (!permanent && fromEl === ActiveElement.element && isTextInput(fromEl)) {
      const ignore = {
        value: true
      };
      Array.from(toEl.attributes).forEach((attribute) => {
        if (!ignore[attribute.name]) fromEl.setAttribute(attribute.name, attribute.value);
      });
      return false;
    }
    return !permanent;
  };
  var shouldMorphCallbacks = [verifyNotMutable, verifyNotPermanent, verifyNotContentEditable];
  var didMorphCallbacks = [];
  var morph_callbacks = Object.freeze({
    __proto__: null,
    didMorph,
    didMorphCallbacks,
    shouldMorph,
    shouldMorphCallbacks,
    verifyNotContentEditable,
    verifyNotMutable,
    verifyNotPermanent
  });
  var Operations = {
    // DOM Mutations
    append: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { html, focusSelector } = operation;
          element.insertAdjacentHTML("beforeend", safeScalar(html));
          assignFocus(focusSelector);
        });
        after(element, operation);
      });
    },
    graft: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { parent, focusSelector } = operation;
          const parentElement = document.querySelector(parent);
          if (parentElement) {
            parentElement.appendChild(element);
            assignFocus(focusSelector);
          }
        });
        after(element, operation);
      });
    },
    innerHtml: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { html, focusSelector } = operation;
          element.innerHTML = safeScalar(html);
          assignFocus(focusSelector);
        });
        after(element, operation);
      });
    },
    insertAdjacentHtml: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { html, position, focusSelector } = operation;
          element.insertAdjacentHTML(position || "beforeend", safeScalar(html));
          assignFocus(focusSelector);
        });
        after(element, operation);
      });
    },
    insertAdjacentText: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { text, position, focusSelector } = operation;
          element.insertAdjacentText(position || "beforeend", safeScalar(text));
          assignFocus(focusSelector);
        });
        after(element, operation);
      });
    },
    outerHtml: (operation) => {
      processElements(operation, (element) => {
        const parent = element.parentElement;
        const idx = parent && Array.from(parent.children).indexOf(element);
        before(element, operation);
        operate(operation, () => {
          const { html, focusSelector } = operation;
          element.outerHTML = safeScalar(html);
          assignFocus(focusSelector);
        });
        after(parent ? parent.children[idx] : document.documentElement, operation);
      });
    },
    prepend: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { html, focusSelector } = operation;
          element.insertAdjacentHTML("afterbegin", safeScalar(html));
          assignFocus(focusSelector);
        });
        after(element, operation);
      });
    },
    remove: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { focusSelector } = operation;
          element.remove();
          assignFocus(focusSelector);
        });
        after(document, operation);
      });
    },
    replace: (operation) => {
      processElements(operation, (element) => {
        const parent = element.parentElement;
        const idx = parent && Array.from(parent.children).indexOf(element);
        before(element, operation);
        operate(operation, () => {
          const { html, focusSelector } = operation;
          element.outerHTML = safeScalar(html);
          assignFocus(focusSelector);
        });
        after(parent ? parent.children[idx] : document.documentElement, operation);
      });
    },
    textContent: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { text, focusSelector } = operation;
          element.textContent = safeScalar(text);
          assignFocus(focusSelector);
        });
        after(element, operation);
      });
    },
    // Element Property Mutations
    addCssClass: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { name: name2 } = operation;
          element.classList.add(...getClassNames([safeStringOrArray(name2)]));
        });
        after(element, operation);
      });
    },
    removeAttribute: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { name: name2 } = operation;
          element.removeAttribute(safeString(name2));
        });
        after(element, operation);
      });
    },
    removeCssClass: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { name: name2 } = operation;
          element.classList.remove(...getClassNames([safeStringOrArray(name2)]));
          if (element.classList.length === 0) element.removeAttribute("class");
        });
        after(element, operation);
      });
    },
    setAttribute: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { name: name2, value } = operation;
          element.setAttribute(safeString(name2), safeScalar(value));
        });
        after(element, operation);
      });
    },
    setDatasetProperty: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { name: name2, value } = operation;
          element.dataset[safeString(name2)] = safeScalar(value);
        });
        after(element, operation);
      });
    },
    setProperty: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { name: name2, value } = operation;
          if (name2 in element) element[safeString(name2)] = safeScalar(value);
        });
        after(element, operation);
      });
    },
    setStyle: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { name: name2, value } = operation;
          element.style[safeString(name2)] = safeScalar(value);
        });
        after(element, operation);
      });
    },
    setStyles: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { styles } = operation;
          for (let [name2, value] of Object.entries(styles)) element.style[safeString(name2)] = safeScalar(value);
        });
        after(element, operation);
      });
    },
    setValue: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { value } = operation;
          element.value = safeScalar(value);
        });
        after(element, operation);
      });
    },
    // DOM Events and Meta-Operations
    dispatchEvent: (operation) => {
      processElements(operation, (element) => {
        before(element, operation);
        operate(operation, () => {
          const { name: name2, detail } = operation;
          dispatch(element, safeString(name2), safeObject(detail));
        });
        after(element, operation);
      });
    },
    setMeta: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { name: name2, content } = operation;
        let meta = document.head.querySelector(`meta[name='${name2}']`);
        if (!meta) {
          meta = document.createElement("meta");
          meta.name = safeString(name2);
          document.head.appendChild(meta);
        }
        meta.content = safeScalar(content);
      });
      after(document, operation);
    },
    setTitle: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { title } = operation;
        document.title = safeScalar(title);
      });
      after(document, operation);
    },
    // Browser Manipulations
    clearStorage: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { type } = operation;
        const storage = type === "session" ? sessionStorage : localStorage;
        storage.clear();
      });
      after(document, operation);
    },
    go: (operation) => {
      before(window, operation);
      operate(operation, () => {
        const { delta } = operation;
        history.go(delta);
      });
      after(window, operation);
    },
    pushState: (operation) => {
      before(window, operation);
      operate(operation, () => {
        const { state, title, url } = operation;
        history.pushState(safeObject(state), safeString(title), safeString(url));
      });
      after(window, operation);
    },
    redirectTo: (operation) => {
      before(window, operation);
      operate(operation, () => {
        let { url, action, turbo } = operation;
        action = action || "advance";
        url = safeString(url);
        if (turbo === void 0) turbo = true;
        if (turbo) {
          if (window.Turbo) window.Turbo.visit(url, {
            action
          });
          if (window.Turbolinks) window.Turbolinks.visit(url, {
            action
          });
          if (!window.Turbo && !window.Turbolinks) window.location.href = url;
        } else {
          window.location.href = url;
        }
      });
      after(window, operation);
    },
    reload: (operation) => {
      before(window, operation);
      operate(operation, () => {
        window.location.reload();
      });
      after(window, operation);
    },
    removeStorageItem: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { key, type } = operation;
        const storage = type === "session" ? sessionStorage : localStorage;
        storage.removeItem(safeString(key));
      });
      after(document, operation);
    },
    replaceState: (operation) => {
      before(window, operation);
      operate(operation, () => {
        const { state, title, url } = operation;
        history.replaceState(safeObject(state), safeString(title), safeString(url));
      });
      after(window, operation);
    },
    scrollIntoView: (operation) => {
      const { element } = operation;
      before(element, operation);
      operate(operation, () => {
        element.scrollIntoView(operation);
      });
      after(element, operation);
    },
    setCookie: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { cookie } = operation;
        document.cookie = safeScalar(cookie);
      });
      after(document, operation);
    },
    setFocus: (operation) => {
      const { element } = operation;
      before(element, operation);
      operate(operation, () => {
        assignFocus(element);
      });
      after(element, operation);
    },
    setStorageItem: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { key, value, type } = operation;
        const storage = type === "session" ? sessionStorage : localStorage;
        storage.setItem(safeString(key), safeScalar(value));
      });
      after(document, operation);
    },
    // Notifications
    consoleLog: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { message, level } = operation;
        level && ["warn", "info", "error"].includes(level) ? console[level](message) : console.log(message);
      });
      after(document, operation);
    },
    consoleTable: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { data, columns } = operation;
        console.table(data, safeArray(columns));
      });
      after(document, operation);
    },
    notification: (operation) => {
      before(document, operation);
      operate(operation, () => {
        const { title, options } = operation;
        Notification.requestPermission().then((result) => {
          operation.permission = result;
          if (result === "granted") new Notification(safeString(title), safeObject(options));
        });
      });
      after(document, operation);
    },
    // Morph operations
    morph: (operation) => {
      processElements(operation, (element) => {
        const { html } = operation;
        const template2 = document.createElement("template");
        template2.innerHTML = String(safeScalar(html)).trim();
        operation.content = template2.content;
        const parent = element.parentElement;
        const idx = parent && Array.from(parent.children).indexOf(element);
        before(element, operation);
        operate(operation, () => {
          const { childrenOnly, focusSelector } = operation;
          morphdom_esm_default(element, childrenOnly ? template2.content : template2.innerHTML, {
            childrenOnly: !!childrenOnly,
            onBeforeElUpdated: shouldMorph(operation),
            onElUpdated: didMorph(operation)
          });
          assignFocus(focusSelector);
        });
        after(parent ? parent.children[idx] : document.documentElement, operation);
      });
    }
  };
  var operations = Operations;
  var add = (newOperations) => {
    operations = {
      ...operations,
      ...newOperations
    };
  };
  var addOperations = (operations2) => {
    add(operations2);
  };
  var addOperation = (name2, operation) => {
    const operations2 = {};
    operations2[name2] = operation;
    add(operations2);
  };
  var OperationStore = {
    get all() {
      return operations;
    }
  };
  var missingElement = "warn";
  var MissingElement$1 = {
    get behavior() {
      return missingElement;
    },
    set(value) {
      if (["warn", "ignore", "event", "exception"].includes(value)) missingElement = value;
      else console.warn("Invalid 'onMissingElement' option. Defaulting to 'warn'.");
    }
  };
  var perform = (operations2, options = {
    onMissingElement: MissingElement$1.behavior
  }) => {
    const batches = {};
    operations2.forEach((operation) => {
      if (!!operation.batch) batches[operation.batch] = batches[operation.batch] ? ++batches[operation.batch] : 1;
    });
    operations2.forEach((operation) => {
      const name2 = operation.operation;
      try {
        if (operation.selector) {
          if (operation.xpath) {
            operation.element = operation.selectAll ? xpathToElementArray(operation.selector) : xpathToElement(operation.selector);
          } else {
            operation.element = operation.selectAll ? document.querySelectorAll(operation.selector) : document.querySelector(operation.selector);
          }
        } else {
          operation.element = document;
        }
        if (operation.element || options.onMissingElement !== "ignore") {
          ActiveElement.set(document.activeElement);
          const cableReadyOperation = OperationStore.all[name2];
          if (cableReadyOperation) {
            cableReadyOperation(operation);
            if (!!operation.batch && --batches[operation.batch] === 0) dispatch(document, "cable-ready:batch-complete", {
              batch: operation.batch
            });
          } else {
            console.error(`CableReady couldn't find the "${name2}" operation. Make sure you use the camelized form when calling an operation method.`);
          }
        }
      } catch (e2) {
        if (operation.element) {
          console.error(`CableReady detected an error in ${name2 || "operation"}: ${e2.message}. If you need to support older browsers make sure you've included the corresponding polyfills. https://docs.stimulusreflex.com/setup#polyfills-for-ie11.`);
          console.error(e2);
        } else {
          const warning = `CableReady ${name2 || ""} operation failed due to missing DOM element for selector: '${operation.selector}'`;
          switch (options.onMissingElement) {
            case "ignore":
              break;
            case "event":
              dispatch(document, "cable-ready:missing-element", {
                warning,
                operation
              });
              break;
            case "exception":
              throw warning;
            default:
              console.warn(warning);
          }
        }
      }
    });
  };
  var performAsync = (operations2, options = {
    onMissingElement: MissingElement$1.behavior
  }) => new Promise((resolve2, reject) => {
    try {
      resolve2(perform(operations2, options));
    } catch (err) {
      reject(err);
    }
  });
  var SubscribingElement = class extends HTMLElement {
    static get tagName() {
      throw new Error("Implement the tagName() getter in the inheriting class");
    }
    static define() {
      if (!customElements.get(this.tagName)) {
        customElements.define(this.tagName, this);
      }
    }
    disconnectedCallback() {
      if (this.channel) this.channel.unsubscribe();
    }
    createSubscription(consumer3, channel, receivedCallback) {
      this.channel = consumer3.subscriptions.create({
        channel,
        identifier: this.identifier
      }, {
        received: receivedCallback
      });
    }
    get preview() {
      return document.documentElement.hasAttribute("data-turbolinks-preview") || document.documentElement.hasAttribute("data-turbo-preview");
    }
    get identifier() {
      return this.getAttribute("identifier");
    }
  };
  var consumer;
  var BACKOFF = [25, 50, 75, 100, 200, 250, 500, 800, 1e3, 2e3];
  var wait = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));
  var getConsumerWithRetry = async (retry = 0) => {
    if (consumer) return consumer;
    if (retry >= BACKOFF.length) {
      throw new Error("Couldn't obtain a Action Cable consumer within 5s");
    }
    await wait(BACKOFF[retry]);
    return await getConsumerWithRetry(retry + 1);
  };
  var CableConsumer = {
    setConsumer(value) {
      consumer = value;
    },
    get consumer() {
      return consumer;
    },
    async getConsumer() {
      return await getConsumerWithRetry();
    }
  };
  var StreamFromElement = class extends SubscribingElement {
    static get tagName() {
      return "cable-ready-stream-from";
    }
    async connectedCallback() {
      if (this.preview) return;
      const consumer3 = await CableConsumer.getConsumer();
      if (consumer3) {
        this.createSubscription(consumer3, "CableReady::Stream", this.performOperations.bind(this));
      } else {
        console.error("The `cable_ready_stream_from` helper cannot connect. You must initialize CableReady with an Action Cable consumer.");
      }
    }
    performOperations(data) {
      if (data.cableReady) perform(data.operations, {
        onMissingElement: this.onMissingElement
      });
    }
    get onMissingElement() {
      const value = this.getAttribute("missing") || MissingElement$1.behavior;
      if (["warn", "ignore", "event"].includes(value)) return value;
      else {
        console.warn("Invalid 'missing' attribute. Defaulting to 'warn'.");
        return "warn";
      }
    }
  };
  var debugging = false;
  var Debug = {
    get enabled() {
      return debugging;
    },
    get disabled() {
      return !debugging;
    },
    get value() {
      return debugging;
    },
    set(value) {
      debugging = !!value;
    },
    set debug(value) {
      debugging = !!value;
    }
  };
  var request = (data, blocks) => {
    if (Debug.disabled) return;
    const message = `\u2191 Updatable request affecting ${blocks.length} element(s): `;
    console.log(message, {
      elements: blocks.map((b5) => b5.element),
      identifiers: blocks.map((b5) => b5.element.getAttribute("identifier")),
      data
    });
    return message;
  };
  var cancel = (timestamp, reason) => {
    if (Debug.disabled) return;
    const duration = /* @__PURE__ */ new Date() - timestamp;
    const message = `\u274C Updatable request canceled after ${duration}ms: ${reason}`;
    console.log(message);
    return message;
  };
  var response = (timestamp, element, urls) => {
    if (Debug.disabled) return;
    const duration = /* @__PURE__ */ new Date() - timestamp;
    const message = `\u2193 Updatable response: All URLs fetched in ${duration}ms`;
    console.log(message, {
      element,
      urls
    });
    return message;
  };
  var morphStart = (timestamp, element) => {
    if (Debug.disabled) return;
    const duration = /* @__PURE__ */ new Date() - timestamp;
    const message = `\u21BB Updatable morph: starting after ${duration}ms`;
    console.log(message, {
      element
    });
    return message;
  };
  var morphEnd = (timestamp, element) => {
    if (Debug.disabled) return;
    const duration = /* @__PURE__ */ new Date() - timestamp;
    const message = `\u21BA Updatable morph: completed after ${duration}ms`;
    console.log(message, {
      element
    });
    return message;
  };
  var Log = {
    request,
    cancel,
    response,
    morphStart,
    morphEnd
  };
  var AppearanceObserver = class {
    constructor(delegate, element = null) {
      __publicField(this, "observeVisibility", () => {
        document.addEventListener("visibilitychange", this.handleVisibilityChange);
      });
      __publicField(this, "unobserveVisibility", () => {
        document.removeEventListener("visibilitychange", this.handleVisibilityChange);
      });
      __publicField(this, "intersect", (entries) => {
        entries.forEach((entry) => {
          if (entry.target === this.element) {
            if (entry.isIntersecting && document.visibilityState === "visible") {
              this.intersecting = true;
              this.delegate.appearedInViewport();
            } else {
              this.intersecting = false;
              this.delegate.disappearedFromViewport();
            }
          }
        });
      });
      __publicField(this, "handleVisibilityChange", (event2) => {
        if (document.visibilityState === "visible" && this.intersecting) {
          this.delegate.appearedInViewport();
        } else {
          this.delegate.disappearedFromViewport();
        }
      });
      this.delegate = delegate;
      this.element = element || delegate;
      this.started = false;
      this.intersecting = false;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
        this.observeVisibility();
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
        this.unobserveVisibility();
      }
    }
  };
  var template = `
<style>
  :host {
    display: block;
  }
</style>
<slot></slot>
`;
  var UpdatesForElement = class extends SubscribingElement {
    static get tagName() {
      return "cable-ready-updates-for";
    }
    constructor() {
      super();
      const shadowRoot = this.attachShadow({
        mode: "open"
      });
      shadowRoot.innerHTML = template;
      this.triggerElementLog = new BoundedQueue(10);
      this.targetElementLog = new BoundedQueue(10);
      this.appearanceObserver = new AppearanceObserver(this);
      this.visible = false;
      this.didTransitionToVisible = false;
    }
    async connectedCallback() {
      if (this.preview) return;
      this.update = debounce(this.update.bind(this), this.debounce);
      const consumer3 = await CableConsumer.getConsumer();
      if (consumer3) {
        this.createSubscription(consumer3, "CableReady::Stream", this.update);
      } else {
        console.error("The `cable_ready_updates_for` helper cannot connect. You must initialize CableReady with an Action Cable consumer.");
      }
      if (this.observeAppearance) {
        this.appearanceObserver.start();
      }
    }
    disconnectedCallback() {
      if (this.observeAppearance) {
        this.appearanceObserver.stop();
      }
    }
    async update(data) {
      this.lastUpdateTimestamp = /* @__PURE__ */ new Date();
      const blocks = Array.from(document.querySelectorAll(this.query), (element) => new Block(element)).filter((block) => block.shouldUpdate(data));
      this.triggerElementLog.push(`${(/* @__PURE__ */ new Date()).toLocaleString()}: ${Log.request(data, blocks)}`);
      if (blocks.length === 0) {
        this.triggerElementLog.push(`${(/* @__PURE__ */ new Date()).toLocaleString()}: ${Log.cancel(this.lastUpdateTimestamp, "All elements filtered out")}`);
        return;
      }
      if (blocks[0].element !== this && !this.didTransitionToVisible) {
        this.triggerElementLog.push(`${(/* @__PURE__ */ new Date()).toLocaleString()}: ${Log.cancel(this.lastUpdateTimestamp, "Update already requested")}`);
        return;
      }
      ActiveElement.set(document.activeElement);
      this.html = {};
      const uniqueUrls = [...new Set(blocks.map((block) => block.url))];
      await Promise.all(uniqueUrls.map(async (url) => {
        if (!this.html.hasOwnProperty(url)) {
          const response2 = await graciouslyFetch(url, {
            "X-Cable-Ready": "update"
          });
          this.html[url] = await response2.text();
        }
      }));
      this.triggerElementLog.push(`${(/* @__PURE__ */ new Date()).toLocaleString()}: ${Log.response(this.lastUpdateTimestamp, this, uniqueUrls)}`);
      this.index = {};
      blocks.forEach((block) => {
        this.index.hasOwnProperty(block.url) ? this.index[block.url]++ : this.index[block.url] = 0;
        block.process(data, this.html, this.index, this.lastUpdateTimestamp);
      });
    }
    appearedInViewport() {
      if (!this.visible) {
        this.didTransitionToVisible = true;
        this.update({});
      }
      this.visible = true;
    }
    disappearedFromViewport() {
      this.visible = false;
    }
    get query() {
      return `${this.tagName}[identifier="${this.identifier}"]`;
    }
    get identifier() {
      return this.getAttribute("identifier");
    }
    get debounce() {
      return this.hasAttribute("debounce") ? parseInt(this.getAttribute("debounce")) : 20;
    }
    get observeAppearance() {
      return this.hasAttribute("observe-appearance");
    }
  };
  var Block = class {
    constructor(element) {
      this.element = element;
    }
    async process(data, html, fragmentsIndex, startTimestamp) {
      const blockIndex = fragmentsIndex[this.url];
      const template2 = document.createElement("template");
      this.element.setAttribute("updating", "updating");
      template2.innerHTML = String(html[this.url]).trim();
      await this.resolveTurboFrames(template2.content);
      const fragments = template2.content.querySelectorAll(this.query);
      if (fragments.length <= blockIndex) {
        console.warn(`Update aborted due to insufficient number of elements. The offending url is ${this.url}, the offending element is:`, this.element);
        return;
      }
      const operation = {
        element: this.element,
        html: fragments[blockIndex],
        permanentAttributeName: "data-ignore-updates"
      };
      dispatch(this.element, "cable-ready:before-update", operation);
      this.element.targetElementLog.push(`${(/* @__PURE__ */ new Date()).toLocaleString()}: ${Log.morphStart(startTimestamp, this.element)}`);
      morphdom_esm_default(this.element, fragments[blockIndex], {
        childrenOnly: true,
        onBeforeElUpdated: shouldMorph(operation),
        onElUpdated: (_26) => {
          this.element.removeAttribute("updating");
          this.element.didTransitionToVisible = false;
          dispatch(this.element, "cable-ready:after-update", operation);
          assignFocus(operation.focusSelector);
        }
      });
      this.element.targetElementLog.push(`${(/* @__PURE__ */ new Date()).toLocaleString()}: ${Log.morphEnd(startTimestamp, this.element)}`);
    }
    async resolveTurboFrames(documentFragment) {
      const reloadingTurboFrames = [...documentFragment.querySelectorAll('turbo-frame[src]:not([loading="lazy"])')];
      return Promise.all(reloadingTurboFrames.map((frame) => new Promise(async (resolve2) => {
        const frameResponse = await graciouslyFetch(frame.getAttribute("src"), {
          "Turbo-Frame": frame.id,
          "X-Cable-Ready": "update"
        });
        const frameTemplate = document.createElement("template");
        frameTemplate.innerHTML = await frameResponse.text();
        await this.resolveTurboFrames(frameTemplate.content);
        const selector = `turbo-frame#${frame.id}`;
        const frameContent = frameTemplate.content.querySelector(selector);
        const content = frameContent ? frameContent.innerHTML.trim() : "";
        documentFragment.querySelector(selector).innerHTML = content;
        resolve2();
      })));
    }
    shouldUpdate(data) {
      return !this.ignoresInnerUpdates && this.hasChangesSelectedForUpdate(data) && (!this.observeAppearance || this.visible);
    }
    hasChangesSelectedForUpdate(data) {
      const only = this.element.getAttribute("only");
      return !(only && data.changed && !only.split(" ").some((attribute) => data.changed.includes(attribute)));
    }
    get ignoresInnerUpdates() {
      return this.element.hasAttribute("ignore-inner-updates") && this.element.hasAttribute("performing-inner-update");
    }
    get url() {
      return this.element.hasAttribute("url") ? this.element.getAttribute("url") : location.href;
    }
    get identifier() {
      return this.element.identifier;
    }
    get query() {
      return this.element.query;
    }
    get visible() {
      return this.element.visible;
    }
    get observeAppearance() {
      return this.element.observeAppearance;
    }
  };
  var registerInnerUpdates = () => {
    document.addEventListener("stimulus-reflex:before", (event2) => {
      recursiveMarkUpdatesForElements(event2.detail.element);
    });
    document.addEventListener("stimulus-reflex:after", (event2) => {
      setTimeout(() => {
        recursiveUnmarkUpdatesForElements(event2.detail.element);
      });
    });
    document.addEventListener("turbo:submit-start", (event2) => {
      recursiveMarkUpdatesForElements(event2.target);
    });
    document.addEventListener("turbo:submit-end", (event2) => {
      setTimeout(() => {
        recursiveUnmarkUpdatesForElements(event2.target);
      });
    });
    document.addEventListener("turbo-boost:command:start", (event2) => {
      recursiveMarkUpdatesForElements(event2.target);
    });
    document.addEventListener("turbo-boost:command:finish", (event2) => {
      setTimeout(() => {
        recursiveUnmarkUpdatesForElements(event2.target);
      });
    });
    document.addEventListener("turbo-boost:command:error", (event2) => {
      setTimeout(() => {
        recursiveUnmarkUpdatesForElements(event2.target);
      });
    });
  };
  var recursiveMarkUpdatesForElements = (leaf) => {
    const closestUpdatesFor = leaf && leaf.parentElement && leaf.parentElement.closest("cable-ready-updates-for");
    if (closestUpdatesFor) {
      closestUpdatesFor.setAttribute("performing-inner-update", "");
      recursiveMarkUpdatesForElements(closestUpdatesFor);
    }
  };
  var recursiveUnmarkUpdatesForElements = (leaf) => {
    const closestUpdatesFor = leaf && leaf.parentElement && leaf.parentElement.closest("cable-ready-updates-for");
    if (closestUpdatesFor) {
      closestUpdatesFor.removeAttribute("performing-inner-update");
      recursiveUnmarkUpdatesForElements(closestUpdatesFor);
    }
  };
  var defineElements = () => {
    registerInnerUpdates();
    StreamFromElement.define();
    UpdatesForElement.define();
  };
  var initialize = (initializeOptions = {}) => {
    const { consumer: consumer3, onMissingElement, debug } = initializeOptions;
    Debug.set(!!debug);
    if (consumer3) {
      CableConsumer.setConsumer(consumer3);
    } else {
      console.error("CableReady requires a reference to your Action Cable `consumer` for its helpers to function.\nEnsure that you have imported the `CableReady` package as well as `consumer` from your `channels` folder, then call `CableReady.initialize({ consumer })`.");
    }
    if (onMissingElement) {
      MissingElement.set(onMissingElement);
    }
    defineElements();
  };
  var global2 = {
    perform,
    performAsync,
    shouldMorphCallbacks,
    didMorphCallbacks,
    initialize,
    addOperation,
    addOperations,
    version: packageInfo.version,
    cable: CableConsumer,
    get DOMOperations() {
      console.warn("DEPRECATED: Please use `CableReady.operations` instead of `CableReady.DOMOperations`");
      return OperationStore.all;
    },
    get operations() {
      return OperationStore.all;
    },
    get consumer() {
      return CableConsumer.consumer;
    }
  };
  window.CableReady = global2;

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  init_define_process();
  init_jquery();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function") return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name2) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name2);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return candidate?.type == "submit" ? candidate : null;
  }
  function clickCaptured(event2) {
    const submitter = findSubmitterFromClickTarget(event2.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype) return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var _FrameElement = class _FrameElement extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "loaded", Promise.resolve());
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name2) {
      if (name2 == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name2 == "src") {
        this.delegate.sourceURLChanged();
      } else if (name2 == "disabled") {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value) {
      if (value) {
        this.setAttribute("refresh", value);
      } else {
        this.removeAttribute("refresh");
      }
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
    }
  };
  __publicField(_FrameElement, "delegateConstructor");
  var FrameElement = _FrameElement;
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction$1(form, submitter) {
    const action = submitter?.getAttribute("formaction") || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix2 = getPrefix(url);
    return baseURL.href === expandURL(prefix2).href || baseURL.href.startsWith(prefix2);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response2) {
      this.response = response2;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name2) {
      return this.response.headers.get(name2);
    }
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name: name2, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name2, value);
    }
  }
  function createDocumentFragment(html) {
    const template2 = document.createElement("template");
    template2.innerHTML = html;
    return template2.content;
  }
  function dispatch2(eventName, { target, cancelable, detail } = {}) {
    const event2 = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event2);
    } else {
      document.documentElement.dispatchEvent(event2);
    }
    return event2;
  }
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  function nextAnimationFrame() {
    return new Promise((resolve2) => requestAnimationFrame(() => resolve2()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve2) => setTimeout(() => resolve2(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i3) => {
      const value = values[i3] == void 0 ? "" : values[i3];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_26, i3) => {
      if (i3 == 8 || i3 == 13 || i3 == 18 || i3 == 23) {
        return "-";
      } else if (i3 == 14) {
        return "4";
      } else if (i3 == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements2) {
    for (const value of elements2.map((element) => element?.getAttribute(attributeName))) {
      if (typeof value == "string") return value;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements2) {
    return elements2.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements2) {
    for (const element of elements2) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements2) {
    for (const element of elements2) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve2) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve2();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve2, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements2) {
    const action = getAttribute("data-turbo-action", ...elements2);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name2) {
    return document.querySelector(`meta[name="${name2}"]`);
  }
  function getMetaContent(name2) {
    const element = getMetaElement(name2);
    return element && element.content;
  }
  function setMetaContent(name2, content) {
    let element = getMetaElement(name2);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name2);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
    }
  }
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  async function around(callback2, reader) {
    const before2 = reader();
    callback2();
    await nextAnimationFrame();
    const after2 = reader();
    return [before2, after2];
  }
  function doesNotTargetIFrame(name2) {
    if (name2 === "_blank") {
      return false;
    } else if (name2) {
      for (const element of document.getElementsByName(name2)) {
        if (element instanceof HTMLIFrameElement) return false;
      }
      return true;
    } else {
      return true;
    }
  }
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  function getLocationForLink(link) {
    return expandURL(link.getAttribute("href") || "");
  }
  function debounce2(fn3, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback2 = () => fn3.apply(this, args);
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback2, delay);
    };
  }
  var LimitedSet = class extends Set {
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, {
      ...options,
      headers: modifiedHeaders
    });
  }
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var _resolveRequestPromise, _FetchRequest_instances, allowRequestToBeIntercepted_fn, willDelegateErrorHandling_fn;
  var FetchRequest = class {
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      __privateAdd(this, _FetchRequest_instances);
      __publicField(this, "abortController", new AbortController());
      __privateAdd(this, _resolveRequestPromise, (_value) => {
      });
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method: method.toUpperCase(),
        headers: { ...this.defaultHeaders },
        body,
        signal: this.abortSignal,
        referrer: this.delegate.referrer?.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod.toUpperCase();
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value) {
      this.fetchOptions.headers = value;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value) {
      this.fetchOptions.body = value;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      const event2 = await __privateMethod(this, _FetchRequest_instances, allowRequestToBeIntercepted_fn).call(this, fetchOptions);
      try {
        this.delegate.requestStarted(this);
        if (event2.detail.fetchRequest) {
          this.response = event2.detail.fetchRequest.response;
        } else {
          this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
        }
        const response2 = await this.response;
        return await this.receive(response2);
      } catch (error3) {
        if (error3.name !== "AbortError") {
          if (__privateMethod(this, _FetchRequest_instances, willDelegateErrorHandling_fn).call(this, error3)) {
            this.delegate.requestErrored(this, error3);
          }
          throw error3;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response2) {
      const fetchResponse = new FetchResponse(response2);
      const event2 = dispatch2("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event2.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
  };
  _resolveRequestPromise = new WeakMap();
  _FetchRequest_instances = new WeakSet();
  allowRequestToBeIntercepted_fn = async function(fetchOptions) {
    const requestInterception = new Promise((resolve2) => __privateSet(this, _resolveRequestPromise, resolve2));
    const event2 = dispatch2("turbo:before-fetch-request", {
      cancelable: true,
      detail: {
        fetchOptions,
        url: this.url,
        resume: __privateGet(this, _resolveRequestPromise)
      },
      target: this.target
    });
    this.url = event2.detail.url;
    if (event2.defaultPrevented) await requestInterception;
    return event2;
  };
  willDelegateErrorHandling_fn = function(error3) {
    const event2 = dispatch2("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: { request: this, error: error3 }
    });
    return !event2.defaultPrevented;
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name2, value] of requestBody) {
      if (value instanceof File) continue;
      else entries.push([name2, value]);
    }
    return entries;
  }
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  var AppearanceObserver2 = class {
    constructor(delegate, element) {
      __publicField(this, "started", false);
      __publicField(this, "intersect", (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry?.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      });
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  __publicField(StreamMessage, "contentType", "text/vnd.turbo-stream.html");
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var PREFETCH_DELAY = 100;
  var _prefetchTimeout, _prefetched;
  var PrefetchCache = class {
    constructor() {
      __privateAdd(this, _prefetchTimeout, null);
      __privateAdd(this, _prefetched, null);
    }
    get(url) {
      if (__privateGet(this, _prefetched) && __privateGet(this, _prefetched).url === url && __privateGet(this, _prefetched).expire > Date.now()) {
        return __privateGet(this, _prefetched).request;
      }
    }
    setLater(url, request2, ttl) {
      this.clear();
      __privateSet(this, _prefetchTimeout, setTimeout(() => {
        request2.perform();
        this.set(url, request2, ttl);
        __privateSet(this, _prefetchTimeout, null);
      }, PREFETCH_DELAY));
    }
    set(url, request2, ttl) {
      __privateSet(this, _prefetched, { url, request: request2, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) });
    }
    clear() {
      if (__privateGet(this, _prefetchTimeout)) clearTimeout(__privateGet(this, _prefetchTimeout));
      __privateSet(this, _prefetched, null);
    }
  };
  _prefetchTimeout = new WeakMap();
  _prefetched = new WeakMap();
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      __publicField(this, "state", FormSubmissionState.initialized);
      const method = getMethod(formElement, submitter);
      const action = getAction(getFormAction(formElement, submitter), method);
      const body = buildFormData(formElement, submitter);
      const enctype = getEnctype(formElement, submitter);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    static confirmMethod(message, _element, _submitter) {
      return Promise.resolve(confirm(message));
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value) {
      this.fetchRequest.method = value;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value) {
      this.fetchRequest.url = expandURL(value);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const answer = await _FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request2) {
      if (!request2.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request2.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request2)) {
        request2.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      this.state = FormSubmissionState.waiting;
      this.submitter?.setAttribute("disabled", "");
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch2("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request2, response2) {
      prefetchCache.clear();
      this.result = { success: response2.succeeded, fetchResponse: response2 };
    }
    requestSucceededWithResponse(request2, response2) {
      if (response2.clientError || response2.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response2);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request2) && responseSucceededWithoutRedirect(response2)) {
        const error3 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error3);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response2 };
        this.delegate.formSubmissionSucceededWithResponse(this, response2);
      }
    }
    requestFailedWithResponse(request2, response2) {
      this.result = { success: false, fetchResponse: response2 };
      this.delegate.formSubmissionFailedWithResponse(this, response2);
    }
    requestErrored(request2, error3) {
      this.result = { success: false, error: error3 };
      this.delegate.formSubmissionErrored(this, error3);
    }
    requestFinished(_request) {
      this.state = FormSubmissionState.stopped;
      this.submitter?.removeAttribute("disabled");
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch2("turbo:submit-end", {
        target: this.formElement,
        detail: { formSubmission: this, ...this.result }
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith) return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText) return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request2) {
      return !request2.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request2) {
      return !request2.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      return this.submitter?.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name2 = submitter?.getAttribute("name");
    const value = submitter?.getAttribute("value");
    if (name2) {
      formData.append(name2, value || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response2) {
    return response2.statusCode == 200 && !response2.redirected;
  }
  function getFormAction(formElement, submitter) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter?.hasAttribute("formaction")) {
      return submitter.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  function getMethod(formElement, submitter) {
    const method = submitter?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  function getEnctype(formElement, submitter) {
    return fetchEnctypeFromString(submitter?.getAttribute("formenctype") || formElement.enctype);
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id) {
      return getPermanentElementById(this.element, id);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id) {
    return node.querySelector(`#${id}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    constructor(delegate, eventTarget) {
      __publicField(this, "started", false);
      __publicField(this, "submitCaptured", () => {
        this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
        this.eventTarget.addEventListener("submit", this.submitBubbled, false);
      });
      __publicField(this, "submitBubbled", (event2) => {
        if (!event2.defaultPrevented) {
          const form = event2.target instanceof HTMLFormElement ? event2.target : void 0;
          const submitter = event2.submitter || void 0;
          if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
            event2.preventDefault();
            event2.stopImmediatePropagation();
            this.delegate.formSubmitted(form, submitter);
          }
        }
      });
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  function submissionDoesNotDismissDialog(form, submitter) {
    const method = submitter?.getAttribute("formmethod") || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter) {
    const target = submitter?.getAttribute("formtarget") || form.getAttribute("target");
    return doesNotTargetIFrame(target);
  }
  var _resolveRenderPromise, _resolveInterceptionPromise;
  var View = class {
    constructor(delegate, element) {
      __privateAdd(this, _resolveRenderPromise, (_value) => {
      });
      __privateAdd(this, _resolveInterceptionPromise, (_value) => {
      });
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x4, y: y6 }) {
      this.scrollRoot.scrollTo(x4, y6);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    async render(renderer) {
      const { isPreview: isPreview2, shouldRender, willRender, newSnapshot: snapshot } = renderer;
      const shouldInvalidate = willRender;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve2) => __privateSet(this, _resolveRenderPromise, resolve2));
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve2) => __privateSet(this, _resolveInterceptionPromise, resolve2));
          const options = { resume: __privateGet(this, _resolveInterceptionPromise), render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender) await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview2, this.renderer.renderMethod);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          __privateGet(this, _resolveRenderPromise).call(this, void 0);
          delete this.renderPromise;
        }
      } else if (shouldInvalidate) {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview2) {
      if (isPreview2) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction) {
      this.element.setAttribute("data-turbo-visit-direction", direction);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  _resolveRenderPromise = new WeakMap();
  _resolveInterceptionPromise = new WeakMap();
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      __publicField(this, "clickBubbled", (event2) => {
        if (this.clickEventIsSignificant(event2)) {
          this.clickEvent = event2;
        } else {
          delete this.clickEvent;
        }
      });
      __publicField(this, "linkClicked", (event2) => {
        if (this.clickEvent && this.clickEventIsSignificant(event2)) {
          if (this.delegate.shouldInterceptLinkClick(event2.target, event2.detail.url, event2.detail.originalEvent)) {
            this.clickEvent.preventDefault();
            event2.preventDefault();
            this.delegate.linkClickIntercepted(event2.target, event2.detail.url, event2.detail.originalEvent);
          }
        }
        delete this.clickEvent;
      });
      __publicField(this, "willVisit", (_event) => {
        delete this.clickEvent;
      });
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickEventIsSignificant(event2) {
      const target = event2.composed ? event2.target?.parentElement : event2.target;
      const element = findLinkFromClickTarget(target) || target;
      return element instanceof Element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    constructor(delegate, eventTarget) {
      __publicField(this, "started", false);
      __publicField(this, "clickCaptured", () => {
        this.eventTarget.removeEventListener("click", this.clickBubbled, false);
        this.eventTarget.addEventListener("click", this.clickBubbled, false);
      });
      __publicField(this, "clickBubbled", (event2) => {
        if (event2 instanceof MouseEvent && this.clickEventIsSignificant(event2)) {
          const target = event2.composedPath && event2.composedPath()[0] || event2.target;
          const link = findLinkFromClickTarget(target);
          if (link && doesNotTargetIFrame(link.target)) {
            const location2 = getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2, event2)) {
              event2.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      });
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event2) {
      return !(event2.target && event2.target.isContentEditable || event2.defaultPrevented || event2.which > 1 || event2.altKey || event2.ctrlKey || event2.metaKey || event2.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name2, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name: name2, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method) form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction) form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream) form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback2) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback2();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone2 = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone2);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder?.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var _activeElement;
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, renderElement, isPreview2, willRender = true) {
      __privateAdd(this, _activeElement, null);
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview2;
      this.willRender = willRender;
      this.renderElement = renderElement;
      this.promise = new Promise((resolve2, reject) => this.resolvingFunctions = { resolve: resolve2, reject });
    }
    get shouldRender() {
      return true;
    }
    get shouldAutofocus() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback2) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback2);
    }
    focusFirstAutofocusableElement() {
      if (this.shouldAutofocus) {
        const element = this.connectedSnapshot.firstAutofocusableElement;
        if (element) {
          element.focus();
        }
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (__privateGet(this, _activeElement)) return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        __privateSet(this, _activeElement, this.currentSnapshot.activeElement);
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(__privateGet(this, _activeElement)) && __privateGet(this, _activeElement) instanceof HTMLElement) {
        __privateGet(this, _activeElement).focus();
        __privateSet(this, _activeElement, null);
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  _activeElement = new WeakMap();
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = frameElement.ownerDocument?.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview2, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview2, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextRepaint();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextRepaint();
      this.focusFirstAutofocusableElement();
      await nextRepaint();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var _ProgressBar = class _ProgressBar {
    constructor() {
      __publicField(this, "hiding", false);
      __publicField(this, "value", 0);
      __publicField(this, "visible", false);
      __publicField(this, "trickle", () => {
        this.setValue(this.value + Math.random() / 100);
      });
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback2) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback2, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  __publicField(_ProgressBar, "animationDuration", 300);
  var ProgressBar = _ProgressBar;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      __publicField(this, "detailsByOuterHTML", this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result ? result[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return {
          ...result,
          [outerHTML]: {
            ...details,
            elements: [...details.elements, element]
          }
        };
      }, {}));
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements: elements2 } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements2];
        } else if (elements2.length > 1) {
          return [...result, ...elements2.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name2) {
      const element = this.findMetaElementByName(name2);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name2) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name2) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name2) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name2;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index2, source] of selectElements.entries()) {
        const clone2 = clonedSelectElements[index2];
        for (const option of clone2.selectedOptions) option.selected = false;
        for (const option of source.selectedOptions) clone2.options[option.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      const root = this.getSetting("root") ?? "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name2) {
      return this.headSnapshot.getMetaValue(`turbo-${name2}`);
    }
  };
  var _viewTransitionStarted, _lastOperation;
  var ViewTransitioner = class {
    constructor() {
      __privateAdd(this, _viewTransitionStarted, false);
      __privateAdd(this, _lastOperation, Promise.resolve());
    }
    renderChange(useViewTransition, render2) {
      if (useViewTransition && this.viewTransitionsAvailable && !__privateGet(this, _viewTransitionStarted)) {
        __privateSet(this, _viewTransitionStarted, true);
        __privateSet(this, _lastOperation, __privateGet(this, _lastOperation).then(async () => {
          await document.startViewTransition(render2).finished;
        }));
      } else {
        __privateSet(this, _lastOperation, __privateGet(this, _lastOperation).then(render2));
      }
      return __privateGet(this, _lastOperation);
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  _viewTransitionStarted = new WeakMap();
  _lastOperation = new WeakMap();
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      __publicField(this, "identifier", uuid());
      // Required by turbo-ios
      __publicField(this, "timingMetrics", {});
      __publicField(this, "followedRedirect", false);
      __publicField(this, "historyChanged", false);
      __publicField(this, "scrolled", false);
      __publicField(this, "shouldCacheSnapshot", true);
      __publicField(this, "acceptsStreamResponse", false);
      __publicField(this, "snapshotCached", false);
      __publicField(this, "state", VisitState.initialized);
      __publicField(this, "viewTransitioner", new ViewTransitioner());
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response: response2,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction
      } = {
        ...defaultOptions,
        ...options
      };
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response2;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response2 = this.response) {
      this.response = response2;
      if (response2) {
        const { statusCode } = response2;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot) this.cacheSnapshot();
          if (this.view.renderPromise) await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            await this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview2 = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise) await this.view.renderPromise;
            await this.renderPageSnapshot(snapshot, isPreview2);
            this.adapter.visitRendered(this);
            if (!isPreview2) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    // Fetch request delegate
    prepareRequest(request2) {
      if (this.acceptsStreamResponse) {
        request2.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request2, response2) {
      const responseHTML = await response2.responseHTML;
      const { redirected, statusCode } = response2;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response2.redirected ? response2.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request2, response2) {
      const responseHTML = await response2.responseHTML;
      const { redirected, statusCode } = response2;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return { ...this.timingMetrics };
    }
    // Private
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback2) {
      this.cancelRender();
      this.frame = await nextRepaint();
      await callback2();
      delete this.frame;
    }
    async renderPageSnapshot(snapshot, isPreview2) {
      await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
        await this.view.renderPage(snapshot, isPreview2, this.willRender, this);
        this.performScroll();
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      __publicField(this, "progressBar", new ProgressBar());
      __publicField(this, "showProgressBar", () => {
        this.progressBar.show();
      });
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload(reason) {
      dispatch2("turbo:reload", { detail: reason });
      window.location.href = this.location?.toString() || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      __publicField(this, "selector", "[data-turbo-temporary]");
      __publicField(this, "deprecatedSelector", "[data-turbo-cache=false]");
      __publicField(this, "started", false);
      __publicField(this, "removeTemporaryElements", (_event) => {
        for (const element of this.temporaryElements) {
          element.remove();
        }
      });
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements2 = document.querySelectorAll(this.deprecatedSelector);
      if (elements2.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements2];
    }
  };
  var _FrameRedirector_instances, shouldSubmit_fn, shouldRedirect_fn, findFrameElement_fn;
  var FrameRedirector = class {
    constructor(session2, element) {
      __privateAdd(this, _FrameRedirector_instances);
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return __privateMethod(this, _FrameRedirector_instances, shouldRedirect_fn).call(this, element);
    }
    linkClickIntercepted(element, url, event2) {
      const frame = __privateMethod(this, _FrameRedirector_instances, findFrameElement_fn).call(this, element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event2);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == null && __privateMethod(this, _FrameRedirector_instances, shouldSubmit_fn).call(this, element, submitter) && __privateMethod(this, _FrameRedirector_instances, shouldRedirect_fn).call(this, element, submitter);
    }
    formSubmitted(element, submitter) {
      const frame = __privateMethod(this, _FrameRedirector_instances, findFrameElement_fn).call(this, element, submitter);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter);
      }
    }
  };
  _FrameRedirector_instances = new WeakSet();
  shouldSubmit_fn = function(form, submitter) {
    const action = getAction$1(form, submitter);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL(meta?.content ?? "/");
    return __privateMethod(this, _FrameRedirector_instances, shouldRedirect_fn).call(this, form, submitter) && locationIsVisitable(action, rootLocation);
  };
  shouldRedirect_fn = function(element, submitter) {
    const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
    if (isNavigatable) {
      const frame = __privateMethod(this, _FrameRedirector_instances, findFrameElement_fn).call(this, element, submitter);
      return frame ? frame != element.closest("turbo-frame") : false;
    } else {
      return false;
    }
  };
  findFrameElement_fn = function(element, submitter) {
    const id = submitter?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
    if (id && id != "_top") {
      const frame = this.element.querySelector(`#${id}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame;
      }
    }
  };
  var History = class {
    constructor(delegate) {
      __publicField(this, "location");
      __publicField(this, "restorationIdentifier", uuid());
      __publicField(this, "restorationData", {});
      __publicField(this, "started", false);
      __publicField(this, "pageLoaded", false);
      __publicField(this, "currentIndex", 0);
      // Event handlers
      __publicField(this, "onPopState", (event2) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event2.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier, restorationIndex } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            const direction = restorationIndex > this.currentIndex ? "forward" : "back";
            this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
            this.currentIndex = restorationIndex;
          }
        }
      });
      __publicField(this, "onPageLoad", async (_event) => {
        await nextMicrotask();
        this.pageLoaded = true;
      });
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = history.state?.turbo?.restorationIndex || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState) ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = {
        ...restorationData,
        ...additionalData
      };
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = history.scrollRestoration ?? "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var _prefetchedLink, _enable, _tryToPrefetchRequest, _cancelRequestIfObsolete, _cancelPrefetchRequest, _tryToUsePrefetchedRequest, _LinkPrefetchObserver_instances, cacheTtl_get, isPrefetchable_fn;
  var LinkPrefetchObserver = class {
    constructor(delegate, eventTarget) {
      __privateAdd(this, _LinkPrefetchObserver_instances);
      __publicField(this, "started", false);
      __privateAdd(this, _prefetchedLink, null);
      __privateAdd(this, _enable, () => {
        this.eventTarget.addEventListener("mouseenter", __privateGet(this, _tryToPrefetchRequest), {
          capture: true,
          passive: true
        });
        this.eventTarget.addEventListener("mouseleave", __privateGet(this, _cancelRequestIfObsolete), {
          capture: true,
          passive: true
        });
        this.eventTarget.addEventListener("turbo:before-fetch-request", __privateGet(this, _tryToUsePrefetchedRequest), true);
        this.started = true;
      });
      __privateAdd(this, _tryToPrefetchRequest, (event2) => {
        if (getMetaContent("turbo-prefetch") === "false") return;
        const target = event2.target;
        const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
        if (isLink && __privateMethod(this, _LinkPrefetchObserver_instances, isPrefetchable_fn).call(this, target)) {
          const link = target;
          const location2 = getLocationForLink(link);
          if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
            __privateSet(this, _prefetchedLink, link);
            const fetchRequest = new FetchRequest(
              this,
              FetchMethod.get,
              location2,
              new URLSearchParams(),
              target
            );
            prefetchCache.setLater(location2.toString(), fetchRequest, __privateGet(this, _LinkPrefetchObserver_instances, cacheTtl_get));
          }
        }
      });
      __privateAdd(this, _cancelRequestIfObsolete, (event2) => {
        if (event2.target === __privateGet(this, _prefetchedLink)) __privateGet(this, _cancelPrefetchRequest).call(this);
      });
      __privateAdd(this, _cancelPrefetchRequest, () => {
        prefetchCache.clear();
        __privateSet(this, _prefetchedLink, null);
      });
      __privateAdd(this, _tryToUsePrefetchedRequest, (event2) => {
        if (event2.target.tagName !== "FORM" && event2.detail.fetchOptions.method === "GET") {
          const cached = prefetchCache.get(event2.detail.url.toString());
          if (cached) {
            event2.detail.fetchRequest = cached;
          }
          prefetchCache.clear();
        }
      });
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started) return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", __privateGet(this, _enable), { once: true });
      } else {
        __privateGet(this, _enable).call(this);
      }
    }
    stop() {
      if (!this.started) return;
      this.eventTarget.removeEventListener("mouseenter", __privateGet(this, _tryToPrefetchRequest), {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", __privateGet(this, _cancelRequestIfObsolete), {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", __privateGet(this, _tryToUsePrefetchedRequest), true);
      this.started = false;
    }
    prepareRequest(request2) {
      const link = request2.target;
      request2.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link.closest("turbo-frame");
      const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request2.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
  };
  _prefetchedLink = new WeakMap();
  _enable = new WeakMap();
  _tryToPrefetchRequest = new WeakMap();
  _cancelRequestIfObsolete = new WeakMap();
  _cancelPrefetchRequest = new WeakMap();
  _tryToUsePrefetchedRequest = new WeakMap();
  _LinkPrefetchObserver_instances = new WeakSet();
  cacheTtl_get = function() {
    return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
  };
  isPrefetchable_fn = function(link) {
    const href = link.getAttribute("href");
    if (!href) return false;
    if (unfetchableLink(link)) return false;
    if (linkToTheSamePage(link)) return false;
    if (linkOptsOut(link)) return false;
    if (nonSafeLink(link)) return false;
    if (eventPrevented(link)) return false;
    return true;
  };
  var unfetchableLink = (link) => {
    return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
  };
  var linkToTheSamePage = (link) => {
    return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
  };
  var linkOptsOut = (link) => {
    if (link.getAttribute("data-turbo-prefetch") === "false") return true;
    if (link.getAttribute("data-turbo") === "false") return true;
    const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
    return false;
  };
  var nonSafeLink = (link) => {
    const turboMethod = link.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
    if (isUJS(link)) return true;
    if (link.hasAttribute("data-turbo-confirm")) return true;
    if (link.hasAttribute("data-turbo-stream")) return true;
    return false;
  };
  var isUJS = (link) => {
    return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
  };
  var eventPrevented = (link) => {
    const event2 = dispatch2("turbo:before-prefetch", { target: link, cancelable: true });
    return event2.defaultPrevented;
  };
  var _Navigator_instances, getActionForFormSubmission_fn, getDefaultAction_fn;
  var Navigator = class {
    constructor(delegate) {
      __privateAdd(this, _Navigator_instances);
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
        referrer: this.location,
        ...options
      });
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = __privateMethod(this, _Navigator_instances, getActionForFormSubmission_fn).call(this, formSubmission, fetchResponse);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        if (!snapshot.shouldPreserveScrollPosition) {
          this.view.scrollToTop();
        }
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error3) {
      console.error(error3);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
      delete this.currentVisit;
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
  };
  _Navigator_instances = new WeakSet();
  getActionForFormSubmission_fn = function(formSubmission, fetchResponse) {
    const { submitter, formElement } = formSubmission;
    return getVisitAction(submitter, formElement) || __privateMethod(this, _Navigator_instances, getDefaultAction_fn).call(this, fetchResponse);
  };
  getDefaultAction_fn = function(fetchResponse) {
    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
    return sameLocationRedirect ? "replace" : "advance";
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    constructor(delegate) {
      __publicField(this, "stage", PageStage.initial);
      __publicField(this, "started", false);
      __publicField(this, "interpretReadyState", () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      });
      __publicField(this, "pageWillUnload", () => {
        this.delegate.pageWillUnload();
      });
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      __publicField(this, "started", false);
      __publicField(this, "onScroll", () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      });
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
        if (elementInStream) {
          permanentElementMap[id] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  async function withAutofocusFromFragment(fragment, callback2) {
    const generatedID = `turbo-stream-autofocus-${uuid()}`;
    const turboStreams = fragment.querySelectorAll("turbo-stream");
    const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
    let willAutofocusId = null;
    if (elementWithAutofocus) {
      if (elementWithAutofocus.id) {
        willAutofocusId = elementWithAutofocus.id;
      } else {
        willAutofocusId = generatedID;
      }
      elementWithAutofocus.id = willAutofocusId;
    }
    callback2();
    await nextRepaint();
    const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
    if (hasNoActiveElement && willAutofocusId) {
      const elementToAutofocus = document.getElementById(willAutofocusId);
      if (elementIsFocusable(elementToAutofocus)) {
        elementToAutofocus.focus();
      }
      if (elementToAutofocus && elementToAutofocus.id == generatedID) {
        elementToAutofocus.removeAttribute("id");
      }
    }
  }
  async function withPreservedFocus(callback2) {
    const [activeElementBeforeRender, activeElementAfterRender] = await around(callback2, () => document.activeElement);
    const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
    if (restoreFocusTo) {
      const elementToFocus = document.getElementById(restoreFocusTo);
      if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
        elementToFocus.focus();
      }
    }
  }
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus) return elementWithAutofocus;
    }
    return null;
  }
  var _started;
  var StreamObserver = class {
    constructor(delegate) {
      __publicField(this, "sources", /* @__PURE__ */ new Set());
      __privateAdd(this, _started, false);
      __publicField(this, "inspectFetchResponse", (event2) => {
        const response2 = fetchResponseFromEvent(event2);
        if (response2 && fetchResponseIsStream(response2)) {
          event2.preventDefault();
          this.receiveMessageResponse(response2);
        }
      });
      __publicField(this, "receiveMessageEvent", (event2) => {
        if (__privateGet(this, _started) && typeof event2.data == "string") {
          this.receiveMessageHTML(event2.data);
        }
      });
      this.delegate = delegate;
    }
    start() {
      if (!__privateGet(this, _started)) {
        __privateSet(this, _started, true);
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (__privateGet(this, _started)) {
        __privateSet(this, _started, false);
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    async receiveMessageResponse(response2) {
      const html = await response2.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  _started = new WeakMap();
  function fetchResponseFromEvent(event2) {
    const fetchResponse = event2.detail?.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response2) {
    const contentType = response2.contentType ?? "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var Idiomorph = /* @__PURE__ */ function() {
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults3 = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx = createMorphContext(oldNode, normalizedContent, config);
      return morphNormalizedContent(oldNode, normalizedContent, ctx);
    }
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
      if (ctx.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx.morphStyle === "innerHTML") {
        morphChildren2(normalizedNewContent, oldNode, ctx);
        return oldNode.children;
      } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx.morphStyle;
      }
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    function morphOldNodeTo(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement) ;
      else if (newContent == null) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        oldNode.remove();
        ctx.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx.callbacks.afterNodeAdded(newContent);
        ctx.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ;
        else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx);
        } else {
          syncNodeFrom(newContent, oldNode, ctx);
          if (!ignoreValueOfActiveElement(oldNode, ctx)) {
            morphChildren2(newContent, oldNode, ctx);
          }
        }
        ctx.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    function morphChildren2(newParent, oldParent, ctx) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
          oldParent.appendChild(newChild);
          ctx.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx)) {
          morphOldNodeTo(insertionPoint, newChild, ctx);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
          morphOldNodeTo(idSetMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
          morphOldNodeTo(softMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx);
      }
    }
    function ignoreAttribute(attr, to3, updateType, ctx) {
      if (attr === "value" && ctx.ignoreActiveValue && to3 === document.activeElement) {
        return true;
      }
      return ctx.callbacks.beforeAttributeUpdated(attr, to3, updateType) === false;
    }
    function syncNodeFrom(from2, to3, ctx) {
      let type = from2.nodeType;
      if (type === 1) {
        const fromAttributes = from2.attributes;
        const toAttributes = to3.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to3, "update", ctx)) {
            continue;
          }
          if (to3.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to3.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i3 = toAttributes.length - 1; 0 <= i3; i3--) {
          const toAttribute = toAttributes[i3];
          if (ignoreAttribute(toAttribute.name, to3, "remove", ctx)) {
            continue;
          }
          if (!from2.hasAttribute(toAttribute.name)) {
            to3.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to3.nodeValue !== from2.nodeValue) {
          to3.nodeValue = from2.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to3, ctx)) {
        syncInputValue(from2, to3, ctx);
      }
    }
    function syncBooleanAttribute(from2, to3, attributeName, ctx) {
      if (from2[attributeName] !== to3[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to3, "update", ctx);
        if (!ignoreUpdate) {
          to3[attributeName] = from2[attributeName];
        }
        if (from2[attributeName]) {
          if (!ignoreUpdate) {
            to3.setAttribute(attributeName, from2[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to3, "remove", ctx)) {
            to3.removeAttribute(attributeName);
          }
        }
      }
    }
    function syncInputValue(from2, to3, ctx) {
      if (from2 instanceof HTMLInputElement && to3 instanceof HTMLInputElement && from2.type !== "file") {
        let fromValue = from2.value;
        let toValue = to3.value;
        syncBooleanAttribute(from2, to3, "checked", ctx);
        syncBooleanAttribute(from2, to3, "disabled", ctx);
        if (!from2.hasAttribute("value")) {
          if (!ignoreAttribute("value", to3, "remove", ctx)) {
            to3.value = "";
            to3.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to3, "update", ctx)) {
            to3.setAttribute("value", fromValue);
            to3.value = fromValue;
          }
        }
      } else if (from2 instanceof HTMLOptionElement) {
        syncBooleanAttribute(from2, to3, "selected", ctx);
      } else if (from2 instanceof HTMLTextAreaElement && to3 instanceof HTMLTextAreaElement) {
        let fromValue = from2.value;
        let toValue = to3.value;
        if (ignoreAttribute("value", to3, "update", ctx)) {
          return;
        }
        if (fromValue !== toValue) {
          to3.value = fromValue;
        }
        if (to3.firstChild && to3.firstChild.nodeValue !== fromValue) {
          to3.firstChild.nodeValue = fromValue;
        }
      }
    }
    function handleHeadElement(newHeadTag, currentHead, ctx) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve2 = null;
            let promise = new Promise(function(_resolve2) {
              resolve2 = _resolve2;
            });
            newElt.addEventListener("load", function() {
              resolve2();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    function noOp() {
    }
    function mergeDefaults(config) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults3);
      Object.assign(finalConfig, config);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults3.callbacks);
      Object.assign(finalConfig.callbacks, config.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults3.head);
      Object.assign(finalConfig.head, config.head);
      return finalConfig;
    }
    function createMorphContext(oldNode, newContent, config) {
      config = mergeDefaults(config);
      return {
        target: oldNode,
        newContent,
        config,
        morphStyle: config.morphStyle,
        ignoreActive: config.ignoreActive,
        ignoreActiveValue: config.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config.callbacks,
        head: config.head
      };
    }
    function isIdSetMatch(node1, node2, ctx) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx, node1, node2) > 0;
        }
      }
      return false;
    }
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    function removeNodesBetween(startInclusive, endExclusive, ctx) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx);
      }
      removeIdsFromConsideration(ctx, endExclusive);
      return endExclusive.nextSibling;
    }
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    function parseContent(newContent) {
      let parser = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    function findBestNodeMatch(newContent, oldNode, ctx) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx);
        if (newScore > score) {
          bestElement = currentElement;
          score = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    function scoreElement(node1, node2, ctx) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx, node1, node2);
      }
      return 0;
    }
    function removeNode(tempNode, ctx) {
      removeIdsFromConsideration(ctx, tempNode);
      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;
      tempNode.remove();
      ctx.callbacks.afterNodeRemoved(tempNode);
    }
    function isIdInConsideration(ctx, id) {
      return !ctx.deadIds.has(id);
    }
    function idIsWithinNode(ctx, id, targetNode) {
      let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id);
    }
    function removeIdsFromConsideration(ctx, node) {
      let idSet = ctx.idMap.get(node) || EMPTY_SET;
      for (const id of idSet) {
        ctx.deadIds.add(id);
      }
    }
    function getIdIntersectionCount(ctx, node1, node2) {
      let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id of sourceSet) {
        if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    return {
      morph,
      defaults: defaults3
    };
  }();
  function morphElements(currentElement, newElement, { callbacks, ...options } = {}) {
    Idiomorph.morph(currentElement, newElement, {
      ...options,
      callbacks: new DefaultIdiomorphCallbacks(callbacks)
    });
  }
  function morphChildren(currentElement, newElement) {
    morphElements(currentElement, newElement.children, {
      morphStyle: "innerHTML"
    });
  }
  var _beforeNodeMorphed;
  var DefaultIdiomorphCallbacks = class {
    constructor({ beforeNodeMorphed } = {}) {
      __privateAdd(this, _beforeNodeMorphed);
      __publicField(this, "beforeNodeAdded", (node) => {
        return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
      });
      __publicField(this, "beforeNodeMorphed", (currentElement, newElement) => {
        if (currentElement instanceof Element) {
          if (!currentElement.hasAttribute("data-turbo-permanent") && __privateGet(this, _beforeNodeMorphed).call(this, currentElement, newElement)) {
            const event2 = dispatch2("turbo:before-morph-element", {
              cancelable: true,
              target: currentElement,
              detail: { currentElement, newElement }
            });
            return !event2.defaultPrevented;
          } else {
            return false;
          }
        }
      });
      __publicField(this, "beforeAttributeUpdated", (attributeName, target, mutationType) => {
        const event2 = dispatch2("turbo:before-morph-attribute", {
          cancelable: true,
          target,
          detail: { attributeName, mutationType }
        });
        return !event2.defaultPrevented;
      });
      __publicField(this, "beforeNodeRemoved", (node) => {
        return this.beforeNodeMorphed(node);
      });
      __publicField(this, "afterNodeMorphed", (currentElement, newElement) => {
        if (currentElement instanceof Element) {
          dispatch2("turbo:morph-element", {
            target: currentElement,
            detail: { currentElement, newElement }
          });
        }
      });
      __privateSet(this, _beforeNodeMorphed, beforeNodeMorphed || (() => true));
    }
  };
  _beforeNodeMorphed = new WeakMap();
  var MorphingFrameRenderer = class extends FrameRenderer {
    static renderElement(currentElement, newElement) {
      dispatch2("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      morphChildren(currentElement, newElement);
    }
  };
  var _PageRenderer_instances, setLanguage_fn;
  var PageRenderer = class extends Renderer {
    constructor() {
      super(...arguments);
      __privateAdd(this, _PageRenderer_instances);
    }
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      __privateMethod(this, _PageRenderer_instances, setLanguage_fn).call(this);
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
      if (this.willRender) {
        this.removeUnusedDynamicStylesheetElements();
      }
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index2, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index2, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index2, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  _PageRenderer_instances = new WeakSet();
  setLanguage_fn = function() {
    const { documentElement } = this.currentSnapshot;
    const { lang } = this.newSnapshot;
    if (lang) {
      documentElement.setAttribute("lang", lang);
    } else {
      documentElement.removeAttribute("lang");
    }
  };
  var MorphingPageRenderer = class extends PageRenderer {
    static renderElement(currentElement, newElement) {
      morphElements(currentElement, newElement, {
        callbacks: {
          beforeNodeMorphed: (element) => !canRefreshFrame(element)
        }
      });
      for (const frame of currentElement.querySelectorAll("turbo-frame")) {
        if (canRefreshFrame(frame)) refreshFrame(frame);
      }
      dispatch2("turbo:morph", { detail: { currentElement, newElement } });
    }
    async preservingPermanentElements(callback2) {
      return await callback2();
    }
    get renderMethod() {
      return "morph";
    }
    get shouldAutofocus() {
      return false;
    }
  };
  function canRefreshFrame(frame) {
    return frame instanceof FrameElement && frame.src && frame.refresh === "morph" && !frame.closest("[data-turbo-permanent]");
  }
  function refreshFrame(frame) {
    frame.addEventListener("turbo:before-frame-render", ({ detail }) => {
      detail.render = MorphingFrameRenderer.renderElement;
    }, { once: true });
    frame.reload();
  }
  var SnapshotCache = class {
    constructor(size3) {
      __publicField(this, "keys", []);
      __publicField(this, "snapshots", {});
      this.size = size3;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index2 = this.keys.indexOf(key);
      if (index2 > -1) this.keys.splice(index2, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      __publicField(this, "snapshotCache", new SnapshotCache(10));
      __publicField(this, "lastRenderedLocation", new URL(location.href));
      __publicField(this, "forceReloaded", false);
    }
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview2 = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
      const renderer = new rendererClass(this.snapshot, snapshot, rendererClass.renderElement, isPreview2, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2?.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2?.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var _preloadAll;
  var Preloader = class {
    constructor(delegate, snapshotCache) {
      __publicField(this, "selector", "a[data-turbo-preload]");
      __privateAdd(this, _preloadAll, () => {
        this.preloadOnLoadLinksForView(document.body);
      });
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", __privateGet(this, _preloadAll));
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", __privateGet(this, _preloadAll));
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link)) {
          this.preloadURL(link);
        }
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
      await fetchRequest.perform();
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    async requestSucceededWithResponse(fetchRequest, fetchResponse) {
      try {
        const responseHTML = await fetchResponse.responseHTML;
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        this.snapshotCache.put(fetchRequest.url, snapshot);
      } catch (_26) {
      }
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
  };
  _preloadAll = new WeakMap();
  var _Cache_instances, setCacheControl_fn;
  var Cache = class {
    constructor(session2) {
      __privateAdd(this, _Cache_instances);
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      __privateMethod(this, _Cache_instances, setCacheControl_fn).call(this, "");
    }
    exemptPageFromCache() {
      __privateMethod(this, _Cache_instances, setCacheControl_fn).call(this, "no-cache");
    }
    exemptPageFromPreview() {
      __privateMethod(this, _Cache_instances, setCacheControl_fn).call(this, "no-preview");
    }
  };
  _Cache_instances = new WeakSet();
  setCacheControl_fn = function(value) {
    setMetaContent("turbo-cache-control", value);
  };
  var _pageRefreshDebouncePeriod;
  var Session = class {
    constructor(recentRequests2) {
      __publicField(this, "navigator", new Navigator(this));
      __publicField(this, "history", new History(this));
      __publicField(this, "view", new PageView(this, document.documentElement));
      __publicField(this, "adapter", new BrowserAdapter(this));
      __publicField(this, "pageObserver", new PageObserver(this));
      __publicField(this, "cacheObserver", new CacheObserver());
      __publicField(this, "linkPrefetchObserver", new LinkPrefetchObserver(this, document));
      __publicField(this, "linkClickObserver", new LinkClickObserver(this, window));
      __publicField(this, "formSubmitObserver", new FormSubmitObserver(this, document));
      __publicField(this, "scrollObserver", new ScrollObserver(this));
      __publicField(this, "streamObserver", new StreamObserver(this));
      __publicField(this, "formLinkClickObserver", new FormLinkClickObserver(this, document.documentElement));
      __publicField(this, "frameRedirector", new FrameRedirector(this, document.documentElement));
      __publicField(this, "streamMessageRenderer", new StreamMessageRenderer());
      __publicField(this, "cache", new Cache(this));
      __publicField(this, "drive", true);
      __publicField(this, "enabled", true);
      __publicField(this, "progressBarDelay", 500);
      __publicField(this, "started", false);
      __publicField(this, "formMode", "on");
      __privateAdd(this, _pageRefreshDebouncePeriod, 150);
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      if (!isRecentRequest && !this.navigator.currentVisit) {
        this.visit(url, { action: "replace", shouldCacheSnapshot: false });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    setFormMode(mode) {
      this.formMode = mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return __privateGet(this, _pageRefreshDebouncePeriod);
    }
    set pageRefreshDebouncePeriod(value) {
      this.refresh = debounce2(this.debouncedRefresh.bind(this), value);
      __privateSet(this, _pageRefreshDebouncePeriod, value);
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, event2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event2);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter) {
      const action = getAction$1(form, submitter);
      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      if (!this.navigator.currentVisit?.silent) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event2 = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event2;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event2 = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event2.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event2 = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event2.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event2) {
      return dispatch2("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event2 },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch2("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch2("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch2("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch2("turbo:before-render", {
        detail: { newBody, ...options },
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch2("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch2("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch2("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch2("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter) {
      if (this.formMode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
        if (this.formMode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (this.drive || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  _pageRefreshDebouncePeriod = new WeakMap();
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  function setFormMode(mode) {
    session.setFormMode(mode);
  }
  var Turbo2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
  };
  var _currentFetchRequest, _resolveVisitPromise, _connected, _hasBeenLoaded, _ignoredAttributes, _FrameController_instances, loadSourceURL_fn, loadFrameResponse_fn, visit_fn, navigateFrame_fn, handleUnvisitableFrameResponse_fn, willHandleFrameMissingFromResponse_fn, handleFrameMissingFromResponse_fn, throwFrameMissingError_fn, visitResponse_fn, findFrameElement_fn2, formActionIsVisitable_fn, shouldInterceptNavigation_fn, isIgnoringChangesTo_fn, ignoringChangesToAttribute_fn, withCurrentNavigationElement_fn;
  var FrameController = class {
    constructor(element) {
      __privateAdd(this, _FrameController_instances);
      __publicField(this, "fetchResponseLoaded", (_fetchResponse) => Promise.resolve());
      __privateAdd(this, _currentFetchRequest, null);
      __privateAdd(this, _resolveVisitPromise, () => {
      });
      __privateAdd(this, _connected, false);
      __privateAdd(this, _hasBeenLoaded, false);
      __privateAdd(this, _ignoredAttributes, /* @__PURE__ */ new Set());
      __publicField(this, "action", null);
      __publicField(this, "visitCachedSnapshot", ({ element }) => {
        const frame = element.querySelector("#" + this.element.id);
        if (frame && this.previousFrameElement) {
          frame.replaceChildren(...this.previousFrameElement.children);
        }
        delete this.previousFrameElement;
      });
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver2(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!__privateGet(this, _connected)) {
        __privateSet(this, _connected, true);
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (__privateGet(this, _connected)) {
        __privateSet(this, _connected, false);
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
      }
    }
    sourceURLChanged() {
      if (__privateMethod(this, _FrameController_instances, isIgnoringChangesTo_fn).call(this, "src")) return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || __privateGet(this, _hasBeenLoaded)) {
        __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
      }
    }
    sourceURLReloaded() {
      const { src } = this.element;
      this.element.removeAttribute("complete");
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await __privateMethod(this, _FrameController_instances, loadFrameResponse_fn).call(this, fetchResponse, document2);
          } else {
            await __privateMethod(this, _FrameController_instances, handleUnvisitableFrameResponse_fn).call(this, fetchResponse);
          }
        }
      } finally {
        this.fetchResponseLoaded = () => Promise.resolve();
      }
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link) {
      return __privateMethod(this, _FrameController_instances, shouldInterceptNavigation_fn).call(this, link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, link);
      if (frame) form.setAttribute("data-turbo-frame", frame.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return __privateMethod(this, _FrameController_instances, shouldInterceptNavigation_fn).call(this, element);
    }
    linkClickIntercepted(element, location2) {
      __privateMethod(this, _FrameController_instances, navigateFrame_fn).call(this, element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == this.element && __privateMethod(this, _FrameController_instances, shouldInterceptNavigation_fn).call(this, element, submitter);
    }
    formSubmitted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request2) {
      request2.headers["Turbo-Frame"] = this.id;
      if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
        request2.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      __privateGet(this, _resolveVisitPromise).call(this);
    }
    async requestSucceededWithResponse(request2, response2) {
      await this.loadResponse(response2);
      __privateGet(this, _resolveVisitPromise).call(this);
    }
    async requestFailedWithResponse(request2, response2) {
      await this.loadResponse(response2);
      __privateGet(this, _resolveVisitPromise).call(this);
    }
    requestErrored(request2, error3) {
      console.error(error3);
      __privateGet(this, _resolveVisitPromise).call(this);
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response2) {
      const frame = __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
      frame.delegate.loadResponse(response2);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error3) {
      console.error(error3);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event2 = dispatch2("turbo:before-frame-render", {
        target: this.element,
        detail: { newFrame, ...options },
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event2;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    proposeVisitIfNavigatedWithAction(frame, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = await fetchResponse.responseHTML;
            const response2 = { statusCode, redirected, responseHTML };
            const options = {
              response: response2,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action) options.action = this.action;
            session.visit(frame.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error3) {
        console.error(error3);
        return new FrameElement();
      }
      return null;
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      __privateMethod(this, _FrameController_instances, ignoringChangesToAttribute_fn).call(this, "src", () => {
        this.element.src = sourceURL ?? null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || __privateGet(this, _resolveVisitPromise).call(this) !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      if (value) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    }
    get isActive() {
      return this.element.isActive && __privateGet(this, _connected);
    }
    get rootLocation() {
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = meta?.content ?? "/";
      return expandURL(root);
    }
  };
  _currentFetchRequest = new WeakMap();
  _resolveVisitPromise = new WeakMap();
  _connected = new WeakMap();
  _hasBeenLoaded = new WeakMap();
  _ignoredAttributes = new WeakMap();
  _FrameController_instances = new WeakSet();
  loadSourceURL_fn = async function() {
    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
      this.element.loaded = __privateMethod(this, _FrameController_instances, visit_fn).call(this, expandURL(this.sourceURL));
      this.appearanceObserver.stop();
      await this.element.loaded;
      __privateSet(this, _hasBeenLoaded, true);
    }
  };
  loadFrameResponse_fn = async function(fetchResponse, document2) {
    const newFrameElement = await this.extractForeignFrameElement(document2.body);
    if (newFrameElement) {
      const snapshot = new Snapshot(newFrameElement);
      const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
      if (this.view.renderPromise) await this.view.renderPromise;
      this.changeHistory();
      await this.view.render(renderer);
      this.complete = true;
      session.frameRendered(fetchResponse, this.element);
      session.frameLoaded(this.element);
      await this.fetchResponseLoaded(fetchResponse);
    } else if (__privateMethod(this, _FrameController_instances, willHandleFrameMissingFromResponse_fn).call(this, fetchResponse)) {
      __privateMethod(this, _FrameController_instances, handleFrameMissingFromResponse_fn).call(this, fetchResponse);
    }
  };
  visit_fn = async function(url) {
    const request2 = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
    __privateGet(this, _currentFetchRequest)?.cancel();
    __privateSet(this, _currentFetchRequest, request2);
    return new Promise((resolve2) => {
      __privateSet(this, _resolveVisitPromise, () => {
        __privateSet(this, _resolveVisitPromise, () => {
        });
        __privateSet(this, _currentFetchRequest, null);
        resolve2();
      });
      request2.perform();
    });
  };
  navigateFrame_fn = function(element, url, submitter) {
    const frame = __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, element, submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));
    __privateMethod(this, _FrameController_instances, withCurrentNavigationElement_fn).call(this, element, () => {
      frame.src = url;
    });
  };
  handleUnvisitableFrameResponse_fn = async function(fetchResponse) {
    console.warn(
      `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
    );
    await __privateMethod(this, _FrameController_instances, visitResponse_fn).call(this, fetchResponse.response);
  };
  willHandleFrameMissingFromResponse_fn = function(fetchResponse) {
    this.element.setAttribute("complete", "");
    const response2 = fetchResponse.response;
    const visit2 = async (url, options) => {
      if (url instanceof Response) {
        __privateMethod(this, _FrameController_instances, visitResponse_fn).call(this, url);
      } else {
        session.visit(url, options);
      }
    };
    const event2 = dispatch2("turbo:frame-missing", {
      target: this.element,
      detail: { response: response2, visit: visit2 },
      cancelable: true
    });
    return !event2.defaultPrevented;
  };
  handleFrameMissingFromResponse_fn = function(fetchResponse) {
    this.view.missing();
    __privateMethod(this, _FrameController_instances, throwFrameMissingError_fn).call(this, fetchResponse);
  };
  throwFrameMissingError_fn = function(fetchResponse) {
    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
    throw new TurboFrameMissingError(message);
  };
  visitResponse_fn = async function(response2) {
    const wrapped = new FetchResponse(response2);
    const responseHTML = await wrapped.responseHTML;
    const { location: location2, redirected, statusCode } = wrapped;
    return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
  };
  findFrameElement_fn2 = function(element, submitter) {
    const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
    return getFrameElementById(id) ?? this.element;
  };
  formActionIsVisitable_fn = function(form, submitter) {
    const action = getAction$1(form, submitter);
    return locationIsVisitable(expandURL(action), this.rootLocation);
  };
  shouldInterceptNavigation_fn = function(element, submitter) {
    const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
    if (element instanceof HTMLFormElement && !__privateMethod(this, _FrameController_instances, formActionIsVisitable_fn).call(this, element, submitter)) {
      return false;
    }
    if (!this.enabled || id == "_top") {
      return false;
    }
    if (id) {
      const frameElement = getFrameElementById(id);
      if (frameElement) {
        return !frameElement.disabled;
      }
    }
    if (!session.elementIsNavigatable(element)) {
      return false;
    }
    if (submitter && !session.elementIsNavigatable(submitter)) {
      return false;
    }
    return true;
  };
  isIgnoringChangesTo_fn = function(attributeName) {
    return __privateGet(this, _ignoredAttributes).has(attributeName);
  };
  ignoringChangesToAttribute_fn = function(attributeName, callback2) {
    __privateGet(this, _ignoredAttributes).add(attributeName);
    callback2();
    __privateGet(this, _ignoredAttributes).delete(attributeName);
  };
  withCurrentNavigationElement_fn = function(element, callback2) {
    this.currentNavigationElement = element;
    callback2();
    delete this.currentNavigationElement;
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e2) => e2.parentElement?.insertBefore(this.templateContent, e2.nextSibling));
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e2) => e2.parentElement?.insertBefore(this.templateContent, e2));
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e2) => e2.remove());
    },
    replace() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphElements(targetElement, this.templateContent);
        } else {
          targetElement.replaceWith(this.templateContent);
        }
      });
    },
    update() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphChildren(targetElement, this.templateContent);
        } else {
          targetElement.innerHTML = "";
          targetElement.append(this.templateContent);
        }
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var _StreamElement_instances, raise_fn;
  var _StreamElement = class _StreamElement extends HTMLElement {
    constructor() {
      super(...arguments);
      __privateAdd(this, _StreamElement_instances);
    }
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error3) {
        console.error(error3);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      return this.renderPromise ?? (this.renderPromise = (async () => {
        const event2 = this.beforeRenderEvent;
        if (this.dispatchEvent(event2)) {
          await nextRepaint();
          await event2.detail.render(this);
        }
      })());
    }
    disconnect() {
      try {
        this.remove();
      } catch {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c4) => c4.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      const existingChildren = this.targetElements.flatMap((e2) => [...e2.children]).filter((c4) => !!c4.id);
      const newChildrenIds = [...this.templateContent?.children || []].filter((c4) => !!c4.id).map((c4) => c4.id);
      return existingChildren.filter((c4) => newChildrenIds.includes(c4.id));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        __privateMethod(this, _StreamElement_instances, raise_fn).call(this, "unknown action");
      }
      __privateMethod(this, _StreamElement_instances, raise_fn).call(this, "action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        __privateMethod(this, _StreamElement_instances, raise_fn).call(this, "target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template2 = this.ownerDocument.createElement("template");
        this.appendChild(template2);
        return template2;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      __privateMethod(this, _StreamElement_instances, raise_fn).call(this, "first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    get description() {
      return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      const element = this.ownerDocument?.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      const elements2 = this.ownerDocument?.querySelectorAll(this.targets);
      if (elements2.length !== 0) {
        return Array.prototype.slice.call(elements2);
      } else {
        return [];
      }
    }
  };
  _StreamElement_instances = new WeakSet();
  raise_fn = function(message) {
    throw new Error(`${this.description}: ${message}`);
  };
  var StreamElement = _StreamElement;
  var StreamSourceElement = class extends HTMLElement {
    constructor() {
      super(...arguments);
      __publicField(this, "streamSource", null);
    }
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element) return;
    if (element.hasAttribute("data-turbo-suppress-warning")) return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = { ...Turbo2, StreamActions };
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  init_define_process();
  init_jquery();
  function encodeMethodIntoRequestBody(event2) {
    if (event2.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event2;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter, body, form) {
    const formMethod = determineFormMethod(submitter);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter) {
    if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
      if (submitter.name === "_method") {
        return submitter.value;
      } else if (submitter.hasAttribute("formmethod")) {
        return submitter.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // node_modules/form-request-submit-polyfill/form-request-submit-polyfill.js
  init_define_process();
  init_jquery();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function") return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name2) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name2);
    }
  })(HTMLFormElement.prototype);

  // node_modules/@ungap/custom-elements/index.js
  init_define_process();
  init_jquery();
  (function() {
    "use strict";
    var Lie = typeof Promise === "function" ? Promise : function(fn3) {
      var queue = [], resolved = 0, value;
      fn3(function($7) {
        value = $7;
        resolved = 1;
        queue.splice(0).forEach(then);
      });
      return {
        then
      };
      function then(fn4) {
        return resolved ? setTimeout(fn4, 0, value) : queue.push(fn4), this;
      }
    };
    var attributesObserver = function(whenDefined2, MutationObserver2) {
      var attributeChanged = function attributeChanged2(records) {
        for (var i3 = 0, length = records.length; i3 < length; i3++) {
          dispatch4(records[i3]);
        }
      };
      var dispatch4 = function dispatch5(_ref2) {
        var target = _ref2.target, attributeName = _ref2.attributeName, oldValue = _ref2.oldValue;
        target.attributeChangedCallback(attributeName, oldValue, target.getAttribute(attributeName));
      };
      return function(target, is2) {
        var attributeFilter = target.constructor.observedAttributes;
        if (attributeFilter) {
          whenDefined2(is2).then(function() {
            new MutationObserver2(attributeChanged).observe(target, {
              attributes: true,
              attributeOldValue: true,
              attributeFilter
            });
            for (var i3 = 0, length = attributeFilter.length; i3 < length; i3++) {
              if (target.hasAttribute(attributeFilter[i3])) dispatch4({
                target,
                attributeName: attributeFilter[i3],
                oldValue: null
              });
            }
          });
        }
        return target;
      };
    };
    var TRUE = true, FALSE = false;
    var QSA$1 = "querySelectorAll";
    function add3(node) {
      this.observe(node, {
        subtree: TRUE,
        childList: TRUE
      });
    }
    var notify = function notify2(callback2, root, MO) {
      var loop = function loop2(nodes, added, removed, connected, pass) {
        for (var i3 = 0, length = nodes.length; i3 < length; i3++) {
          var node = nodes[i3];
          if (pass || QSA$1 in node) {
            if (connected) {
              if (!added.has(node)) {
                added.add(node);
                removed["delete"](node);
                callback2(node, connected);
              }
            } else if (!removed.has(node)) {
              removed.add(node);
              added["delete"](node);
              callback2(node, connected);
            }
            if (!pass) loop2(node[QSA$1]("*"), added, removed, connected, TRUE);
          }
        }
      };
      var observer = new (MO || MutationObserver)(function(records) {
        for (var added = /* @__PURE__ */ new Set(), removed = /* @__PURE__ */ new Set(), i3 = 0, length = records.length; i3 < length; i3++) {
          var _records$i = records[i3], addedNodes = _records$i.addedNodes, removedNodes = _records$i.removedNodes;
          loop(removedNodes, added, removed, FALSE, FALSE);
          loop(addedNodes, added, removed, TRUE, FALSE);
        }
      });
      observer.add = add3;
      observer.add(root || document);
      return observer;
    };
    var QSA = "querySelectorAll";
    var _self$1 = self, document$2 = _self$1.document, Element$1 = _self$1.Element, MutationObserver$2 = _self$1.MutationObserver, Set$2 = _self$1.Set, WeakMap$1 = _self$1.WeakMap;
    var elements2 = function elements3(element) {
      return QSA in element;
    };
    var filter = [].filter;
    var qsaObserver = function(options) {
      var live = new WeakMap$1();
      var drop = function drop2(elements3) {
        for (var i3 = 0, length = elements3.length; i3 < length; i3++) {
          live["delete"](elements3[i3]);
        }
      };
      var flush = function flush2() {
        var records = observer.takeRecords();
        for (var i3 = 0, length = records.length; i3 < length; i3++) {
          parse3(filter.call(records[i3].removedNodes, elements2), false);
          parse3(filter.call(records[i3].addedNodes, elements2), true);
        }
      };
      var matches = function matches2(element) {
        return element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
      };
      var notifier = function notifier2(element, connected) {
        var selectors;
        if (connected) {
          for (var q4, m4 = matches(element), i3 = 0, length = query2.length; i3 < length; i3++) {
            if (m4.call(element, q4 = query2[i3])) {
              if (!live.has(element)) live.set(element, new Set$2());
              selectors = live.get(element);
              if (!selectors.has(q4)) {
                selectors.add(q4);
                options.handle(element, connected, q4);
              }
            }
          }
        } else if (live.has(element)) {
          selectors = live.get(element);
          live["delete"](element);
          selectors.forEach(function(q5) {
            options.handle(element, connected, q5);
          });
        }
      };
      var parse3 = function parse4(elements3) {
        var connected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        for (var i3 = 0, length = elements3.length; i3 < length; i3++) {
          notifier(elements3[i3], connected);
        }
      };
      var query2 = options.query;
      var root = options.root || document$2;
      var observer = notify(notifier, root, MutationObserver$2);
      var attachShadow2 = Element$1.prototype.attachShadow;
      if (attachShadow2) Element$1.prototype.attachShadow = function(init2) {
        var shadowRoot = attachShadow2.call(this, init2);
        observer.add(shadowRoot);
        return shadowRoot;
      };
      if (query2.length) parse3(root[QSA](query2));
      return {
        drop,
        flush,
        observer,
        parse: parse3
      };
    };
    var _self = self, document$1 = _self.document, Map2 = _self.Map, MutationObserver$1 = _self.MutationObserver, Object$1 = _self.Object, Set$1 = _self.Set, WeakMap2 = _self.WeakMap, Element3 = _self.Element, HTMLElement2 = _self.HTMLElement, Node2 = _self.Node, Error2 = _self.Error, TypeError2 = _self.TypeError, Reflect2 = _self.Reflect;
    var Promise$1 = self.Promise || Lie;
    var defineProperty = Object$1.defineProperty, keys = Object$1.keys, getOwnPropertyNames = Object$1.getOwnPropertyNames, setPrototypeOf = Object$1.setPrototypeOf;
    var legacy = !self.customElements;
    var expando = function expando2(element) {
      var key = keys(element);
      var value = [];
      var length = key.length;
      for (var i3 = 0; i3 < length; i3++) {
        value[i3] = element[key[i3]];
        delete element[key[i3]];
      }
      return function() {
        for (var _i2 = 0; _i2 < length; _i2++) {
          element[key[_i2]] = value[_i2];
        }
      };
    };
    if (legacy) {
      var HTMLBuiltIn = function HTMLBuiltIn2() {
        var constructor = this.constructor;
        if (!classes.has(constructor)) throw new TypeError2("Illegal constructor");
        var is2 = classes.get(constructor);
        if (override) return augment(override, is2);
        var element = createElement.call(document$1, is2);
        return augment(setPrototypeOf(element, constructor.prototype), is2);
      };
      var createElement = document$1.createElement;
      var classes = new Map2();
      var defined2 = new Map2();
      var prototypes = new Map2();
      var registry2 = new Map2();
      var query = [];
      var handle2 = function handle3(element, connected, selector) {
        var proto = prototypes.get(selector);
        if (connected && !proto.isPrototypeOf(element)) {
          var redefine = expando(element);
          override = setPrototypeOf(element, proto);
          try {
            new proto.constructor();
          } finally {
            override = null;
            redefine();
          }
        }
        var method = "".concat(connected ? "" : "dis", "connectedCallback");
        if (method in proto) element[method]();
      };
      var _qsaObserver = qsaObserver({
        query,
        handle: handle2
      }), parse2 = _qsaObserver.parse;
      var override = null;
      var whenDefined = function whenDefined2(name2) {
        if (!defined2.has(name2)) {
          var _26, $7 = new Lie(function($8) {
            _26 = $8;
          });
          defined2.set(name2, {
            $: $7,
            _: _26
          });
        }
        return defined2.get(name2).$;
      };
      var augment = attributesObserver(whenDefined, MutationObserver$1);
      defineProperty(self, "customElements", {
        configurable: true,
        value: {
          define: function define3(is2, Class) {
            if (registry2.has(is2)) throw new Error2('the name "'.concat(is2, '" has already been used with this registry'));
            classes.set(Class, is2);
            prototypes.set(is2, Class.prototype);
            registry2.set(is2, Class);
            query.push(is2);
            whenDefined(is2).then(function() {
              parse2(document$1.querySelectorAll(is2));
            });
            defined2.get(is2)._(Class);
          },
          get: function get4(is2) {
            return registry2.get(is2);
          },
          whenDefined
        }
      });
      defineProperty(HTMLBuiltIn.prototype = HTMLElement2.prototype, "constructor", {
        value: HTMLBuiltIn
      });
      defineProperty(self, "HTMLElement", {
        configurable: true,
        value: HTMLBuiltIn
      });
      defineProperty(document$1, "createElement", {
        configurable: true,
        value: function value(name2, options) {
          var is2 = options && options.is;
          var Class = is2 ? registry2.get(is2) : registry2.get(name2);
          return Class ? new Class() : createElement.call(document$1, name2);
        }
      });
      if (!("isConnected" in Node2.prototype)) defineProperty(Node2.prototype, "isConnected", {
        configurable: true,
        get: function get4() {
          return !(this.ownerDocument.compareDocumentPosition(this) & this.DOCUMENT_POSITION_DISCONNECTED);
        }
      });
    } else {
      try {
        var LI = function LI2() {
          return self.Reflect.construct(HTMLLIElement, [], LI2);
        };
        LI.prototype = HTMLLIElement.prototype;
        var is = "extends-li";
        self.customElements.define("extends-li", LI, {
          "extends": "li"
        });
        legacy = document$1.createElement("li", {
          is
        }).outerHTML.indexOf(is) < 0;
        var _self$customElements = self.customElements, get3 = _self$customElements.get, _whenDefined = _self$customElements.whenDefined;
        defineProperty(self.customElements, "whenDefined", {
          configurable: true,
          value: function value(is2) {
            var _this = this;
            return _whenDefined.call(this, is2).then(function(Class) {
              return Class || get3.call(_this, is2);
            });
          }
        });
      } catch (o_O) {
        legacy = !legacy;
      }
    }
    if (legacy) {
      var parseShadow = function parseShadow2(element) {
        var root = shadowRoots.get(element);
        _parse(root.querySelectorAll(this), element.isConnected);
      };
      var customElements2 = self.customElements;
      var attachShadow = Element3.prototype.attachShadow;
      var _createElement = document$1.createElement;
      var define2 = customElements2.define, _get = customElements2.get;
      var _ref = Reflect2 || {
        construct: function construct2(HTMLElement3) {
          return HTMLElement3.call(this);
        }
      }, construct = _ref.construct;
      var shadowRoots = new WeakMap2();
      var shadows = new Set$1();
      var _classes = new Map2();
      var _defined = new Map2();
      var _prototypes = new Map2();
      var _registry = new Map2();
      var shadowed = [];
      var _query = [];
      var getCE = function getCE2(is2) {
        return _registry.get(is2) || _get.call(customElements2, is2);
      };
      var _handle = function _handle2(element, connected, selector) {
        var proto = _prototypes.get(selector);
        if (connected && !proto.isPrototypeOf(element)) {
          var redefine = expando(element);
          _override = setPrototypeOf(element, proto);
          try {
            new proto.constructor();
          } finally {
            _override = null;
            redefine();
          }
        }
        var method = "".concat(connected ? "" : "dis", "connectedCallback");
        if (method in proto) element[method]();
      };
      var _qsaObserver2 = qsaObserver({
        query: _query,
        handle: _handle
      }), _parse = _qsaObserver2.parse;
      var _qsaObserver3 = qsaObserver({
        query: shadowed,
        handle: function handle3(element, connected) {
          if (shadowRoots.has(element)) {
            if (connected) shadows.add(element);
            else shadows["delete"](element);
            if (_query.length) parseShadow.call(_query, element);
          }
        }
      }), parseShadowed = _qsaObserver3.parse;
      var _whenDefined2 = function _whenDefined22(name2) {
        if (!_defined.has(name2)) {
          var _26, $7 = new Promise$1(function($8) {
            _26 = $8;
          });
          _defined.set(name2, {
            $: $7,
            _: _26
          });
        }
        return _defined.get(name2).$;
      };
      var _augment = attributesObserver(_whenDefined2, MutationObserver$1);
      var _override = null;
      getOwnPropertyNames(self).filter(function(k4) {
        return /^HTML/.test(k4);
      }).forEach(function(k4) {
        var HTMLElement3 = self[k4];
        function HTMLBuiltIn2() {
          var constructor = this.constructor;
          if (!_classes.has(constructor)) throw new TypeError2("Illegal constructor");
          var _classes$get = _classes.get(constructor), is2 = _classes$get.is, tag = _classes$get.tag;
          if (is2) {
            if (_override) return _augment(_override, is2);
            var element = _createElement.call(document$1, tag);
            element.setAttribute("is", is2);
            return _augment(setPrototypeOf(element, constructor.prototype), is2);
          } else return construct.call(this, HTMLElement3, [], constructor);
        }
        defineProperty(HTMLBuiltIn2.prototype = HTMLElement3.prototype, "constructor", {
          value: HTMLBuiltIn2
        });
        defineProperty(self, k4, {
          value: HTMLBuiltIn2
        });
      });
      defineProperty(document$1, "createElement", {
        configurable: true,
        value: function value(name2, options) {
          var is2 = options && options.is;
          if (is2) {
            var Class = _registry.get(is2);
            if (Class && _classes.get(Class).tag === name2) return new Class();
          }
          var element = _createElement.call(document$1, name2);
          if (is2) element.setAttribute("is", is2);
          return element;
        }
      });
      if (attachShadow) Element3.prototype.attachShadow = function(init2) {
        var root = attachShadow.call(this, init2);
        shadowRoots.set(this, root);
        return root;
      };
      defineProperty(customElements2, "get", {
        configurable: true,
        value: getCE
      });
      defineProperty(customElements2, "whenDefined", {
        configurable: true,
        value: _whenDefined2
      });
      defineProperty(customElements2, "define", {
        configurable: true,
        value: function value(is2, Class, options) {
          if (getCE(is2)) throw new Error2("'".concat(is2, "' has already been defined as a custom element"));
          var selector;
          var tag = options && options["extends"];
          _classes.set(Class, tag ? {
            is: is2,
            tag
          } : {
            is: "",
            tag: is2
          });
          if (tag) {
            selector = "".concat(tag, '[is="').concat(is2, '"]');
            _prototypes.set(selector, Class.prototype);
            _registry.set(is2, Class);
            _query.push(selector);
          } else {
            define2.apply(customElements2, arguments);
            shadowed.push(selector = is2);
          }
          _whenDefined2(is2).then(function() {
            if (tag) {
              _parse(document$1.querySelectorAll(selector));
              shadows.forEach(parseShadow, [selector]);
            } else parseShadowed(document$1.querySelectorAll(selector));
          });
          _defined.get(is2)._(Class);
        }
      });
    }
  })();

  // app/javascript/customer_center/application.js
  var ActiveStorage = __toESM(require_activestorage());

  // projects/cf_utils/ApplicationCable/index.js
  init_define_process();
  init_jquery();

  // node_modules/@anycable/web/index.js
  init_define_process();
  init_jquery();

  // node_modules/@anycable/core/index.js
  init_define_process();
  init_jquery();

  // node_modules/@anycable/core/channel/index.js
  init_define_process();
  init_jquery();

  // node_modules/nanoevents/index.js
  init_define_process();
  init_jquery();
  var createNanoEvents = () => ({
    events: {},
    emit(event2, ...args) {
      let callbacks = this.events[event2] || [];
      for (let i3 = 0, length = callbacks.length; i3 < length; i3++) {
        callbacks[i3](...args);
      }
    },
    on(event2, cb) {
      this.events[event2]?.push(cb) || (this.events[event2] = [cb]);
      return () => {
        this.events[event2] = this.events[event2]?.filter((i3) => cb !== i3);
      };
    }
  });

  // node_modules/@anycable/core/protocol/index.js
  init_define_process();
  init_jquery();
  var ReasonError = class extends Error {
    constructor(msg, reason) {
      if (msg instanceof Error) {
        super(msg.message);
        this.cause = msg;
      } else {
        super(msg);
      }
      this.reason = reason;
      this.name = "ReasonError";
    }
  };
  var SubscriptionRejectedError = class extends ReasonError {
    constructor(reason) {
      super("Rejected", reason);
      this.name = "SubscriptionRejectedError";
    }
  };
  var SubscriptionTimeoutError = class extends ReasonError {
    constructor(msg) {
      super(msg || "Timed out to receive subscription ack");
      this.name = "SubscriptionTimeoutError";
    }
  };
  var DisconnectedError = class extends ReasonError {
    constructor(error3, reason) {
      if (reason) {
        super(error3, reason);
      } else {
        super("Disconnected", error3);
      }
      this.name = "DisconnectedError";
    }
  };
  var StaleConnectionError = class extends DisconnectedError {
    constructor(msg) {
      super(msg, "stale_connection");
      this.name = "StaleConnectionError";
    }
  };

  // node_modules/@anycable/core/stringify-params/index.js
  init_define_process();
  init_jquery();
  function stringifyParams(params) {
    if (!params) return "";
    let parts = Object.keys(params).sort().filter((k4) => params[k4] !== void 0).map((k4) => {
      let v4 = JSON.stringify(params[k4]);
      return `${JSON.stringify(k4)}:${v4}`;
    });
    return `{${parts.join(",")}}`;
  }

  // node_modules/@anycable/core/channel/index.js
  var STATE = Symbol("state");
  var Channel = class {
    // Unique channel identifier
    // static identifier = ''
    constructor(params = {}) {
      this.emitter = createNanoEvents();
      this.params = Object.freeze(params);
      this.initialConnect = true;
      this[STATE] = "idle";
    }
    get identifier() {
      if (this._identifier) return this._identifier;
      this._identifier = stringifyParams({
        channel: this.channelId,
        ...this.params
      });
      return this._identifier;
    }
    get channelId() {
      return this.constructor.identifier;
    }
    get state() {
      return this[STATE];
    }
    attached(receiver) {
      if (this.receiver) {
        if (this.receiver !== receiver) {
          throw Error("Already connected to a different receiver");
        }
        return false;
      }
      this.receiver = receiver;
      return true;
    }
    connecting() {
      this[STATE] = "connecting";
    }
    connected() {
      if (this.state === "connected") return;
      if (this.state === "closed") return;
      this[STATE] = "connected";
      let restored = false;
      if (this.initialConnect) {
        this.initialConnect = false;
        this.emit("connect", { reconnect: false, restored });
      } else {
        this.emit("connect", { reconnect: true, restored });
      }
    }
    restored() {
      if (this.state === "connected") throw Error("Already connected");
      this[STATE] = "connected";
      let restored = true;
      let reconnect = true;
      this.initialConnect = false;
      this.emit("connect", { reconnect, restored });
    }
    disconnected(err) {
      if (this.state === "disconnected" || this.state === "closed") return;
      this[STATE] = "disconnected";
      this.emit("disconnect", err);
    }
    closed(err) {
      if (this.state === "closed") return;
      this[STATE] = "closed";
      delete this.receiver;
      this.initialConnect = true;
      this.emit("close", err);
    }
    disconnect() {
      if (this.state === "idle" || this.state === "closed") {
        return;
      }
      this.receiver.unsubscribe(this);
    }
    async perform(action, payload) {
      if (this.state === "idle" || this.state === "closed") {
        throw Error("Channel is not subscribed");
      }
      return this.receiver.perform(this.identifier, action, payload);
    }
    async send(payload) {
      return this.perform(void 0, payload);
    }
    async whisper(payload) {
      try {
        await this.perform("$whisper", payload);
      } catch (e2) {
        let logger = this.receiver ? this.receiver.logger : null;
        if (logger) {
          logger.warn("whisper failed: ", e2);
        }
      }
    }
    receive(msg, meta) {
      this.emit("message", msg, meta);
    }
    on(event2, callback2) {
      return this.emitter.on(event2, callback2);
    }
    once(event2, callback2) {
      let unbind = this.emitter.on(event2, (...args) => {
        unbind();
        callback2(...args);
      });
      return unbind;
    }
    emit(event2, ...args) {
      return this.emitter.emit(event2, ...args);
    }
    ensureSubscribed() {
      if (this.state === "connected") return Promise.resolve();
      if (this.state === "closed") {
        return Promise.reject(Error("Channel is unsubscribed"));
      }
      return this.pendingSubscribe();
    }
    // This promise resolves when subscription is confirmed
    // and rejects when rejected or closed.
    // It ignores disconnect events.
    pendingSubscribe() {
      if (this._pendingSubscribe) return this._pendingSubscribe;
      this._pendingSubscribe = new Promise((resolve2, reject) => {
        let unbind = [() => delete this._pendingSubscribe];
        unbind.push(
          this.on("connect", () => {
            unbind.forEach((clbk) => clbk());
            resolve2();
          })
        );
        unbind.push(
          this.on("close", (err) => {
            unbind.forEach((clbk) => clbk());
            reject(
              err || new ReasonError(
                "Channel was disconnected before subscribing",
                "canceled"
              )
            );
          })
        );
      });
      return this._pendingSubscribe;
    }
  };

  // node_modules/@anycable/core/hub/index.js
  init_define_process();
  init_jquery();
  var Subscription = class {
    constructor(id) {
      this.id = id;
      this.intent = "unsubscribed";
      this.state = "idle";
      this.channels = [];
      this.disposed = false;
      this._pendings = [];
    }
    add(channel) {
      if (this.channels.includes(channel)) return;
      this.channels.push(channel);
    }
    remove(channel) {
      let ind = this.channels.indexOf(channel);
      if (ind > -1) this.channels.splice(ind, 1);
    }
    notify(state, ...args) {
      this.state = state === "restored" ? "connected" : state;
      if (args.length === 1) {
        this.channels.forEach((channel) => channel[state](args[0]));
      } else {
        this.channels.forEach((channel) => channel[state]());
      }
    }
    pending(intent) {
      this._checkIntent(intent);
      let nextPending = this._pendings[0];
      if (!nextPending || nextPending.intent !== intent) return Promise.resolve();
      return nextPending.promise;
    }
    ensureResubscribed() {
      if (this.disposed) return;
      this.intent = void 0;
      this.ensureSubscribed();
    }
    ensureSubscribed() {
      if (this.intent === "subscribed") return;
      if (this.disposed) throw Error("Subscription is disposed");
      this.intent = "subscribed";
      let merged = this._mergeWithPending("unsubscribed");
      if (merged) return;
      this.subscriber(this);
    }
    maybeUnsubscribe() {
      if (this.disposed) return;
      if (this.intent === "unsubscribed") return;
      if (this.channels.length > 0) return;
      this.intent = "unsubscribed";
      let merged = this._mergeWithPending("subscribed");
      if (merged) return;
      this.unsubscriber(this);
    }
    async acquire(intent) {
      this._checkIntent(intent);
      let resolver;
      let promise = new Promise((resolve2) => {
        resolver = resolve2;
      });
      let lock = {
        promise,
        intent,
        release: () => {
          this._pendings.splice(this._pendings.indexOf(lock), 1);
          resolver(lock);
        },
        canceled: false,
        acquired: false
      };
      let top2 = this._pendingTop;
      this._pendings.push(lock);
      if (top2) {
        await top2.promise;
      }
      if (this.gvl) {
        await this.gvl.acquire(lock, intent);
      }
      lock.acquired = true;
      return lock;
    }
    close(err) {
      this.disposed = true;
      this.intent = void 0;
      this.notify("closed", err);
    }
    _checkIntent(event2) {
      if (event2 === "unsubscribed" || event2 === "subscribed") return;
      throw Error(`Unknown subscription intent: ${event2}`);
    }
    get _pendingTop() {
      return this._pendings.length ? this._pendings[this._pendings.length - 1] : void 0;
    }
    _mergeWithPending(intent) {
      let top2 = this._pendingTop;
      if (!top2) return false;
      if (top2.acquired) return false;
      if (top2.intent !== intent) return false;
      this._pendings.pop();
      top2.canceled = true;
      return true;
    }
  };
  var GlobalLock = class {
    constructor() {
      this.queue = [];
    }
    async acquire(lock, intent) {
      if (intent !== "subscribed") return;
      this.queue.push(
        lock.promise.then(() => {
          this.queue.splice(this.queue.indexOf(lock), 1);
        })
      );
      if (this.queue.length > 1) {
        await this.queue[this.queue.length - 2];
      }
    }
  };
  var Subscriptions = class {
    constructor(opts) {
      if (opts.concurrentSubscribes === false) {
        this.glv = new GlobalLock();
      }
      this._subscriptions = {};
      this._localToRemote = {};
    }
    all() {
      return Object.values(this._subscriptions);
    }
    get(id) {
      return this._subscriptions[id];
    }
    create(id, { subscribe, unsubscribe }) {
      let sub = this._subscriptions[id] = new Subscription(id);
      sub.remoteId = this._localToRemote[id];
      sub.subscriber = subscribe;
      sub.unsubscriber = unsubscribe;
      sub.gvl = this.glv;
      return sub;
    }
    remove(id) {
      delete this._subscriptions[id];
      delete this._localToRemote[id];
    }
    storeRemoteId(localId, remoteId) {
      this._localToRemote[localId] = remoteId;
      let sub = this.get(localId);
      if (sub) sub.remoteId = remoteId;
    }
  };
  var Hub = class {
    constructor(opts = {}) {
      this.subscriptions = new Subscriptions(opts);
      this._pendingMessages = [];
      this._remoteToLocal = {};
    }
    subscribe(localId, remoteId) {
      this._remoteToLocal[remoteId] = localId;
      this.subscriptions.storeRemoteId(localId, remoteId);
      this.flush(remoteId);
    }
    unsubscribe(localId) {
      let sub = this.subscriptions.get(localId);
      if (!sub) return;
      let remoteId = sub.remoteId;
      if (remoteId) delete this._remoteToLocal[remoteId];
      this.subscriptions.remove(localId);
    }
    transmit(id, msg, meta) {
      let localId = this._remoteToLocal[id];
      if (!localId) {
        this._pendingMessages.push([id, msg, meta]);
        return;
      }
      let sub = this.subscriptions.get(localId);
      if (!sub) return;
      sub.channels.forEach((channel) => {
        channel.receive(msg, meta);
      });
    }
    close() {
      this._pendingMessages.length = 0;
    }
    get size() {
      return this.channels.length;
    }
    get channels() {
      return this.subscriptions.all().flatMap((sub) => sub.channels);
    }
    flush(id) {
      let left2 = [];
      for (let item of this._pendingMessages) {
        if (item[0] === id) this.transmit(item[0], item[1], item[2]);
        else left2.push(item);
      }
      this._pendingMessages = left2;
    }
  };

  // node_modules/@anycable/core/logger/index.js
  init_define_process();
  init_jquery();
  var LEVEL_TO_NAME = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  var BaseLogger = class {
    constructor(level) {
      this.level = level || "warn";
    }
    log(level, msg, details) {
      if (LEVEL_TO_NAME[level] < LEVEL_TO_NAME[this.level]) return;
      this.writeLogEntry(level, msg, details);
    }
    writeLogEntry() {
      throw Error("Not implemented");
    }
    debug(msg, details) {
      this.log("debug", msg, details);
    }
    info(msg, details) {
      this.log("info", msg, details);
    }
    warn(msg, details) {
      this.log("warn", msg, details);
    }
    error(msg, details) {
      this.log("error", msg, details);
    }
  };
  var NoopLogger = class extends BaseLogger {
    writeLogEntry() {
    }
  };

  // node_modules/@anycable/core/encoder/index.js
  init_define_process();
  init_jquery();
  var JSONEncoder = class {
    encode(msg) {
      return JSON.stringify(msg);
    }
    decode(raw) {
      try {
        return JSON.parse(raw);
      } catch (_e2) {
      }
    }
  };

  // node_modules/@anycable/core/action_cable/index.js
  init_define_process();
  init_jquery();
  var commandID = 0;
  var ActionCableProtocol = class {
    constructor(opts = {}) {
      let { logger } = opts;
      this.logger = logger || new NoopLogger();
      this.pendingSubscriptions = {};
      this.pendingUnsubscriptions = {};
      this.subscribeCooldownInterval = opts.subscribeCooldownInterval || 250;
      this.subscribeRetryInterval = opts.subscribeRetryInterval || 5e3;
    }
    attached(cable) {
      this.cable = cable;
    }
    subscribe(channel, params) {
      let subscriptionPayload = { channel };
      if (params) {
        Object.assign(subscriptionPayload, params);
      }
      let identifier = stringifyParams(subscriptionPayload);
      if (this.pendingUnsubscriptions[identifier]) {
        let cooldown = this.subscribeCooldownInterval * 1.5;
        this.logger.debug(
          `unsubscribed recently, cooldown for ${cooldown}`,
          identifier
        );
        return new Promise((resolve2) => {
          setTimeout(() => {
            resolve2(this.subscribe(channel, params));
          }, cooldown);
        });
      }
      if (this.pendingSubscriptions[identifier]) {
        this.logger.warn("subscription is already pending, skipping", identifier);
        return Promise.reject(Error("Already subscribing"));
      }
      let retryInterval = this.subscribeRetryInterval;
      return new Promise((resolve2, reject) => {
        let id = ++commandID;
        this.pendingSubscriptions[identifier] = {
          resolve: resolve2,
          reject,
          id
        };
        this.cable.send(this.buildSubscribeRequest(identifier));
        this.maybeRetrySubscribe(id, identifier, retryInterval);
      });
    }
    buildSubscribeRequest(identifier) {
      return {
        command: "subscribe",
        identifier
      };
    }
    maybeRetrySubscribe(id, identifier, retryInterval) {
      setTimeout(() => {
        let sub = this.pendingSubscriptions[identifier];
        if (!sub) return;
        if (sub.id !== id) return;
        this.logger.warn(
          `no subscription ack received in ${retryInterval}ms, retrying subscribe`,
          identifier
        );
        this.cable.send(this.buildSubscribeRequest(identifier));
        this.maybeExpireSubscribe(id, identifier, retryInterval);
      }, retryInterval);
    }
    maybeExpireSubscribe(id, identifier, retryInterval) {
      setTimeout(() => {
        let sub = this.pendingSubscriptions[identifier];
        if (!sub) return;
        if (sub.id !== id) return;
        delete this.pendingSubscriptions[identifier];
        sub.reject(
          new SubscriptionTimeoutError(
            `Haven't received subscription ack in ${retryInterval * 2}ms for ${identifier}`
          )
        );
      }, retryInterval);
    }
    unsubscribe(identifier) {
      this.cable.send({
        command: "unsubscribe",
        identifier
      });
      this.pendingUnsubscriptions[identifier] = true;
      setTimeout(() => {
        delete this.pendingUnsubscriptions[identifier];
      }, this.subscribeCooldownInterval);
      return Promise.resolve();
    }
    perform(identifier, action, payload) {
      if (action === "$whisper") {
        return this.whisper(identifier, payload);
      }
      if (!payload) {
        payload = {};
      }
      payload.action = action;
      this.cable.send({
        command: "message",
        identifier,
        data: JSON.stringify(payload)
      });
      return Promise.resolve();
    }
    whisper(identifier, data) {
      this.cable.send({
        command: "whisper",
        identifier,
        data
      });
      return Promise.resolve();
    }
    receive(msg) {
      if (typeof msg !== "object") {
        this.logger.error("unsupported message format", { message: msg });
        return;
      }
      let { type, identifier, message, reason, reconnect } = msg;
      if (type === "ping") {
        return this.cable.keepalive(msg.message);
      } else {
        this.cable.keepalive();
      }
      if (type === "welcome") {
        let sessionId = msg.sid;
        if (sessionId) this.cable.setSessionId(sessionId);
        return this.cable.connected();
      }
      if (type === "disconnect") {
        let err = new DisconnectedError(reason);
        this.reset(err);
        if (reconnect === false) {
          this.cable.closed(err);
        } else {
          this.cable.disconnected(err);
        }
        return;
      }
      if (type === "confirm_subscription") {
        let subscription = this.pendingSubscriptions[identifier];
        if (!subscription) {
          this.logger.error("subscription not found, unsubscribing", {
            type,
            identifier
          });
          this.unsubscribe(identifier);
          return;
        }
        delete this.pendingSubscriptions[identifier];
        return subscription.resolve(identifier);
      }
      if (type === "reject_subscription") {
        let subscription = this.pendingSubscriptions[identifier];
        if (!subscription) {
          return this.logger.error("subscription not found", { type, identifier });
        }
        delete this.pendingSubscriptions[identifier];
        return subscription.reject(new SubscriptionRejectedError());
      }
      if (message) {
        return { identifier, message };
      }
      this.logger.warn(`unknown message type: ${type}`, { message: msg });
    }
    reset(err) {
      for (let identifier in this.pendingSubscriptions) {
        this.pendingSubscriptions[identifier].reject(err);
      }
      this.pendingSubscriptions = {};
    }
    recoverableClosure() {
      return false;
    }
  };

  // node_modules/@anycable/core/action_cable_ext/index.js
  init_define_process();
  init_jquery();
  var now = () => Date.now() / 1e3 | 0;
  var ActionCableExtendedProtocol = class extends ActionCableProtocol {
    constructor(opts = {}) {
      super(opts);
      this.streamsPositions = {};
      this.subscriptionStreams = {};
      this.pendingHistory = {};
      this.restoreSince = opts.historyTimestamp;
      if (this.restoreSince === void 0) this.restoreSince = now();
      this.sessionId = void 0;
      this.sendPongs = opts.pongs;
    }
    receive(msg) {
      if (typeof msg !== "object") {
        this.logger.error("unsupported message format", { message: msg });
        return;
      }
      let { type, identifier, message } = msg;
      if (type === "disconnect" || type === "reject_subscription") {
        return super.receive(msg);
      }
      if (type === "confirm_subscription") {
        if (!this.subscriptionStreams[identifier]) {
          this.subscriptionStreams[identifier] = /* @__PURE__ */ new Set();
        }
        return super.receive(msg);
      }
      if (type === "ping") {
        if (!this.restoreSince === false) {
          this.restoreSince = now();
        }
        if (this.sendPongs) {
          this.sendPong();
        }
        return this.cable.keepalive(msg.message);
      } else {
        this.cable.keepalive();
      }
      if (type === "confirm_history") {
        this.logger.debug("history result received", msg);
        return;
      }
      if (type === "reject_history") {
        this.logger.warn("failed to retrieve history", msg);
        return;
      }
      if (type === "welcome") {
        this.sessionId = msg.sid;
        if (this.sessionId) this.cable.setSessionId(this.sessionId);
        if (msg.restored) {
          let restoredIds = msg.restored_ids || Object.keys(this.subscriptionStreams);
          for (let restoredId of restoredIds) {
            this.cable.send({
              identifier: restoredId,
              command: "history",
              history: this.historyRequestFor(restoredId)
            });
          }
          return this.cable.restored(restoredIds);
        }
        return this.cable.connected(this.sessionId);
      }
      if (message) {
        let meta = this.trackStreamPosition(
          identifier,
          msg.stream_id,
          msg.epoch,
          msg.offset
        );
        return { identifier, message, meta };
      }
      this.logger.warn(`unknown message type: ${type}`, { message: msg });
    }
    buildSubscribeRequest(identifier) {
      let req = super.buildSubscribeRequest(identifier);
      let historyReq = this.historyRequestFor(identifier);
      if (historyReq) {
        req.history = historyReq;
        this.pendingHistory[identifier] = true;
      }
      return req;
    }
    // TODO: Which error can be non-recoverable?
    recoverableClosure() {
      return !!this.sessionId;
    }
    historyRequestFor(identifier) {
      let streams = {};
      let hasStreams = false;
      if (this.subscriptionStreams[identifier]) {
        for (let stream of this.subscriptionStreams[identifier]) {
          let record = this.streamsPositions[stream];
          if (record) {
            hasStreams = true;
            streams[stream] = record;
          }
        }
      }
      if (!hasStreams && !this.restoreSince) return;
      return { since: this.restoreSince, streams };
    }
    trackStreamPosition(identifier, stream, epoch, offset3) {
      if (!stream || !epoch) return;
      if (!this.subscriptionStreams[identifier]) {
        this.subscriptionStreams[identifier] = /* @__PURE__ */ new Set();
      }
      this.subscriptionStreams[identifier].add(stream);
      this.streamsPositions[stream] = { epoch, offset: offset3 };
      return { stream, epoch, offset: offset3 };
    }
    // Send pongs asynchrounouslyno need to block the main thread
    async sendPong() {
      await new Promise((resolve2) => setTimeout(resolve2, 0));
      if (this.cable.state === "connected") {
        this.cable.send({ command: "pong" });
      }
    }
  };

  // node_modules/@anycable/core/cable/index.js
  init_define_process();
  init_jquery();
  var NoConnectionError = class extends ReasonError {
    constructor() {
      super("No connection", "closed");
      this.name = "NoConnectionError";
    }
  };
  var GhostChannel = class extends Channel {
    constructor(channelId, params) {
      super(params);
      this.channelId = channelId;
    }
    set channelId(val) {
      this._channelId = val;
    }
    get channelId() {
      return this._channelId;
    }
  };
  __publicField(GhostChannel, "identifier", "__ghost__");
  var PUBSUB_CHANNEL = "$pubsub";
  var PubSubChannel = class extends Channel {
    async perform(action, payload) {
      if (action === "$whisper") {
        return super.perform(action, payload);
      }
      throw Error("not implemented");
    }
  };
  __publicField(PubSubChannel, "identifier", PUBSUB_CHANNEL);
  var STATE2 = Symbol("state");
  var Cable = class {
    constructor({ transport, protocol, encoder, logger, lazy, hubOptions }) {
      this.emitter = createNanoEvents();
      this.transport = transport;
      this.encoder = encoder;
      this.logger = logger || new NoopLogger();
      this.protocol = protocol;
      this.protocol.attached(this);
      this.hub = new Hub(hubOptions || {});
      this[STATE2] = "idle";
      this.handleClose = this.handleClose.bind(this);
      this.handleIncoming = this.handleIncoming.bind(this);
      this.transport.on("close", this.handleClose);
      this.transport.on("data", this.handleIncoming);
      this.initialConnect = true;
      this.recovering = false;
      if (lazy === false) {
        this.connect().catch(() => {
        });
      }
    }
    get state() {
      return this[STATE2];
    }
    async connect() {
      if (this.state === "connected") return Promise.resolve();
      if (this.state === "connecting") {
        return this.pendingConnect();
      }
      this[STATE2] = "connecting";
      let promise = this.pendingConnect();
      this.logger.debug("connecting");
      try {
        await this.transport.open();
      } catch (err) {
        this.handleClose(err);
      }
      return promise;
    }
    setSessionId(sessionId) {
      this.sessionId = sessionId;
      this.transport.setParam("sid", sessionId);
    }
    connected() {
      if (this.state === "connected") return;
      this.logger.info("connected");
      this[STATE2] = "connected";
      if (this.recovering) {
        this.hub.subscriptions.all().forEach(
          (subscription) => subscription.notify(
            "disconnected",
            new DisconnectedError("recovery_failed")
          )
        );
      }
      this.hub.subscriptions.all().forEach((subscription) => this._resubscribe(subscription));
      let restored = false;
      this.recovering = false;
      if (this.initialConnect) {
        this.initialConnect = false;
        this.emit("connect", { reconnect: false, restored });
      } else {
        this.emit("connect", { reconnect: true, restored });
      }
    }
    restored(remoteIds) {
      this.logger.info("connection recovered", { remoteIds });
      this[STATE2] = "connected";
      this.hub.subscriptions.all().forEach((subscription) => {
        if (remoteIds && subscription.remoteId && remoteIds.includes(subscription.remoteId)) {
          subscription.notify("restored");
        } else {
          subscription.notify(
            "disconnected",
            new DisconnectedError("recovery_failed")
          );
          this._resubscribe(subscription);
        }
      });
      let reconnect = !this.initialConnect;
      let restored = true;
      this.recovering = false;
      this.initialConnect = false;
      this.emit("connect", { reconnect, restored });
    }
    handleClose(err) {
      this.logger.debug("transport closed", { error: err });
      this.disconnected(new DisconnectedError(err, "transport_closed"));
    }
    disconnected(err) {
      if (!(this.state === "connected" || this.state === "connecting")) {
        return;
      }
      this.logger.info("disconnected", { reason: err });
      this[STATE2] = "disconnected";
      this.recovering = this.protocol.recoverableClosure(err);
      if (this.recovering) {
        this.hub.subscriptions.all().forEach((subscription) => subscription.notify("connecting"));
      } else {
        this.hub.subscriptions.all().forEach((subscription) => {
          subscription.notify("disconnected", err);
        });
      }
      this.protocol.reset(err);
      this.hub.close();
      this.transport.close();
      this.emit("disconnect", err);
    }
    closed(reason) {
      if (this.state === "closed" || this.state === "idle") return;
      let err;
      if (reason) {
        err = reason instanceof DisconnectedError ? reason : new DisconnectedError(reason, void 0);
      }
      this.logger.info("closed", { reason: reason || "user" });
      this[STATE2] = "closed";
      let channelErr = err || new DisconnectedError("cable_closed");
      this.hub.subscriptions.all().forEach((subscription) => subscription.notify("disconnected", channelErr));
      this.hub.close();
      this.protocol.reset();
      this.transport.close();
      this.initialConnect = true;
      this.emit("close", err);
    }
    disconnect() {
      this.closed();
    }
    handleIncoming(raw) {
      if (this.state === "closed" || this.state === "idle") {
        return;
      }
      let data = this.encoder.decode(raw);
      if (data === void 0) {
        this.logger.error("failed to decode message", { message: raw });
        return;
      }
      this.logger.debug("incoming data", data);
      let processed = this.protocol.receive(data);
      if (processed) {
        this.logger.debug("processed incoming message", processed);
        let { identifier, message, meta } = processed;
        this.hub.transmit(identifier, message, meta);
      }
    }
    send(msg) {
      if (this.state === "closed") {
        throw Error("Cable is closed");
      }
      let data = this.encoder.encode(msg);
      if (data === void 0) {
        this.logger.error("failed to encode message", { message: msg });
        return;
      }
      this.logger.debug("outgoing message", msg);
      this.transport.send(data);
    }
    keepalive(msg) {
      this.emit("keepalive", msg);
    }
    streamFrom(name2) {
      let channel = new PubSubChannel({ stream_name: name2 });
      return this.subscribe(channel);
    }
    streamFromSigned(name2) {
      let channel = new PubSubChannel({ signed_stream_name: name2 });
      return this.subscribe(channel);
    }
    subscribeTo(ChannelClass, params) {
      let channel;
      let ghostName;
      if (typeof ChannelClass === "string") {
        ghostName = ChannelClass;
        ChannelClass = GhostChannel;
      }
      channel = ghostName ? new ChannelClass(ghostName, params) : new ChannelClass(params);
      return this.subscribe(channel);
    }
    subscribe(channel) {
      if (!channel.attached(this)) return channel;
      let identifier = channel.identifier;
      channel.connecting();
      let subscription = this.hub.subscriptions.get(identifier) || this.hub.subscriptions.create(identifier, {
        subscribe: (sub) => {
          return this._subscribe(sub, channel.channelId, channel.params);
        },
        unsubscribe: (sub) => this._unsubscribe(sub)
      });
      subscription.add(channel);
      if (subscription.intent === "subscribed" && subscription.state === "connected") {
        channel.connected();
      }
      subscription.ensureSubscribed();
      return channel;
    }
    async _resubscribe(subscription) {
      if (subscription.intent !== "subscribed") return;
      let channel = subscription.channels[0];
      if (!channel) return;
      subscription.notify("connecting");
      subscription.ensureResubscribed();
    }
    async _subscribe(subscription, channelId, params) {
      let identifier = subscription.id;
      if (this.state === "idle") {
        this.connect().catch(() => {
        });
      }
      if (this.state !== "connected") {
        this.logger.debug("cancel subscribe, no connection", { identifier });
        return;
      }
      this.logger.debug("acquiring subscribe lock", { identifier });
      let lock = await subscription.acquire("subscribed");
      if (lock.canceled) {
        this.logger.debug("subscribe lock has been canceled", { identifier });
        lock.release();
        return;
      }
      this.logger.debug("subscribe lock has been acquired", { identifier });
      if (subscription.intent !== "subscribed") {
        this.logger.debug("cancel subscribe request, already unsubscribed");
        lock.release();
        return;
      }
      if (this.state !== "connected") {
        this.logger.debug("cancel subscribe, no connection", { identifier });
        lock.release();
        return;
      }
      if (subscription.state === "connected") {
        this.logger.debug("already connected, skip subscribe command", {
          identifier
        });
        subscription.notify("connected");
        lock.release();
        return;
      }
      let channelMeta = {
        identifier: channelId,
        params
      };
      this.logger.debug("subscribing", channelMeta);
      try {
        let remoteId = await this.protocol.subscribe(channelId, params);
        this.hub.subscribe(identifier, remoteId);
        this.logger.debug("subscribed", { ...channelMeta, remoteId });
        subscription.notify("connected");
      } catch (err) {
        if (err) {
          if (err instanceof SubscriptionRejectedError) {
            this.logger.warn("rejected", channelMeta);
          }
          if (err instanceof DisconnectedError) {
            this.logger.debug(
              "disconnected during subscription; will retry on connect",
              channelMeta
            );
            lock.release();
            return;
          }
          this.logger.error("failed to subscribe", {
            error: err,
            ...channelMeta
          });
        }
        subscription.close(err);
        this.hub.unsubscribe(identifier);
      }
      lock.release();
    }
    unsubscribe(channel) {
      let identifier = channel.identifier;
      let subscription = this.hub.subscriptions.get(identifier);
      if (!subscription) {
        throw Error(`Subscription not found: ${identifier}`);
      }
      subscription.remove(channel);
      channel.closed();
      subscription.maybeUnsubscribe();
    }
    async _unsubscribe(subscription) {
      let identifier = subscription.id;
      this.logger.debug("acquiring unsubscribe lock", { identifier });
      let lock = await subscription.acquire("unsubscribed");
      if (lock.canceled) {
        this.logger.debug("unsubscribe lock has been canceled", { identifier });
        lock.release();
        return;
      }
      this.logger.debug("unsubscribe lock has been acquired", { identifier });
      if (subscription.intent !== "unsubscribed") {
        this.logger.debug("cancel unsubscribe, no longer needed", {
          identifier,
          intent: subscription.intent
        });
        lock.release();
        return;
      }
      if (subscription.state === "disconnected" || subscription.state === "closed") {
        this.logger.debug(
          `already ${subscription.state} connected, skip unsubscribe command`,
          { identifier }
        );
        lock.release();
        return;
      }
      let remoteId = subscription.remoteId;
      this.logger.debug("unsubscribing...", { remoteId });
      if (this.state !== "connected") {
        this.logger.debug("unsubscribe skipped (cable is not connected)", {
          id: identifier
        });
        subscription.close();
        this.hub.unsubscribe(identifier);
        lock.release();
        return;
      }
      try {
        await this.protocol.unsubscribe(remoteId);
        this.logger.debug("unsubscribed remotely", { id: identifier });
      } catch (err) {
        if (err) {
          if (err instanceof DisconnectedError) {
            this.logger.debug(
              "cable disconnected during the unsubscribe command execution",
              { id: identifier, error: err }
            );
          } else {
            this.logger.error("unsubscribe failed", {
              id: identifier,
              error: err
            });
          }
        }
      }
      if (subscription.intent === "unsubscribed") {
        subscription.close();
        this.hub.unsubscribe(identifier);
      } else {
        subscription.state = "closed";
      }
      lock.release();
    }
    async perform(identifier, action, payload) {
      if (this.state === "connecting") {
        await this.pendingConnect();
      }
      if (this.state === "closed" || this.state === "disconnected") {
        throw new NoConnectionError();
      }
      let subscription = this.hub.subscriptions.get(identifier);
      if (!subscription) {
        throw Error(`Subscription not found: ${identifier}`);
      }
      await subscription.pending("subscribed");
      if (subscription.intent !== "subscribed") {
        throw Error(`Subscription is closed: ${identifier}`);
      }
      let remoteId = subscription.remoteId;
      let performMeta = {
        id: remoteId,
        action,
        payload
      };
      this.logger.debug("perform", performMeta);
      try {
        let res = await this.protocol.perform(remoteId, action, payload);
        if (res) {
          this.logger.debug("perform result", {
            message: res,
            request: performMeta
          });
        }
        return res;
      } catch (err) {
        this.logger.error("perform failed", {
          error: err,
          request: performMeta
        });
        throw err;
      }
    }
    on(event2, callback2) {
      return this.emitter.on(event2, callback2);
    }
    once(event2, callback2) {
      let unbind = this.emitter.on(event2, (...args) => {
        unbind();
        callback2(...args);
      });
      return unbind;
    }
    emit(event2, ...args) {
      return this.emitter.emit(event2, ...args);
    }
    pendingConnect() {
      if (this._pendingConnect) return this._pendingConnect;
      this._pendingConnect = new Promise((resolve2, reject) => {
        let unbind = [() => delete this._pendingConnect];
        unbind.push(
          this.on("connect", () => {
            unbind.forEach((clbk) => clbk());
            resolve2();
          })
        );
        unbind.push(
          this.on("close", (err) => {
            unbind.forEach((clbk) => clbk());
            reject(err);
          })
        );
        unbind.push(
          this.on("disconnect", (err) => {
            unbind.forEach((clbk) => clbk());
            reject(err);
          })
        );
      });
      return this._pendingConnect;
    }
  };

  // node_modules/@anycable/core/monitor/index.js
  init_define_process();
  init_jquery();
  var defaults = {
    maxMissingPings: 2,
    maxReconnectAttempts: Infinity
  };
  var now2 = () => Date.now();
  var backoffWithJitter = (interval, opts) => {
    opts = opts || {};
    let { backoffRate, jitterRatio, maxInterval } = opts;
    backoffRate = backoffRate || 2;
    if (jitterRatio === void 0) jitterRatio = 0.5;
    return (attempts) => {
      let left2 = interval * backoffRate ** attempts;
      let right2 = left2 * backoffRate;
      let delay = left2 + (right2 - left2) * Math.random();
      let deviation = 2 * (Math.random() - 0.5) * jitterRatio;
      delay = delay * (1 + deviation);
      if (maxInterval && maxInterval < delay) delay = maxInterval;
      return delay;
    };
  };
  var Monitor = class {
    constructor({ pingInterval, ...opts }) {
      this.pingInterval = pingInterval;
      if (!this.pingInterval) {
        throw Error(`Incorrect pingInterval is provided: ${pingInterval}`);
      }
      opts = Object.assign({}, defaults, opts);
      this.strategy = opts.reconnectStrategy;
      if (!this.strategy) {
        throw Error("Reconnect strategy must be provided");
      }
      this.maxMissingPings = opts.maxMissingPings;
      this.maxReconnectAttempts = opts.maxReconnectAttempts;
      this.logger = opts.logger || new NoopLogger();
      this.state = "pending_connect";
      this.attempts = 0;
      this.disconnectedAt = now2();
    }
    watch(target) {
      this.target = target;
      this.initListeners();
    }
    reconnectNow() {
      if (this.state === "connected" || this.state === "pending_connect" || this.state === "closed") {
        return false;
      }
      this.cancelReconnect();
      this.state = "pending_connect";
      this.target.connect().catch((err) => {
        this.logger.info("Failed at reconnecting: " + err);
      });
      return true;
    }
    initListeners() {
      this.unbind = [];
      this.unbind.push(
        this.target.on("connect", () => {
          this.attempts = 0;
          this.pingedAt = now2();
          this.state = "connected";
          this.cancelReconnect();
          this.startPolling();
        })
      );
      this.unbind.push(
        this.target.on("disconnect", () => {
          this.disconnectedAt = now2();
          this.state = "disconnected";
          this.stopPolling();
          this.scheduleReconnect();
        })
      );
      this.unbind.push(
        this.target.on("close", () => {
          this.disconnectedAt = now2();
          this.state = "closed";
          this.cancelReconnect();
          this.stopPolling();
        })
      );
      this.unbind.push(
        this.target.on("keepalive", () => {
          this.pingedAt = now2();
        })
      );
      this.unbind.push(() => {
        this.cancelReconnect();
        this.stopPolling();
      });
    }
    dispose() {
      delete this.target;
      if (this.unbind) {
        this.unbind.forEach((clbk) => clbk());
      }
      delete this.unbind;
    }
    startPolling() {
      if (this.pollId) {
        clearTimeout(this.pollId);
      }
      let pollDelay = this.pingInterval + (Math.random() - 0.5) * this.pingInterval * 0.5;
      this.pollId = setTimeout(() => {
        this.checkStale();
        if (this.state === "connected") this.startPolling();
      }, pollDelay);
    }
    stopPolling() {
      if (this.pollId) {
        clearTimeout(this.pollId);
      }
    }
    checkStale() {
      let diff = now2() - this.pingedAt;
      if (diff > this.maxMissingPings * this.pingInterval) {
        this.logger.warn(`Stale connection: ${diff}ms without pings`);
        this.state = "pending_disconnect";
        this.target.disconnected(new StaleConnectionError());
      }
    }
    scheduleReconnect() {
      if (this.attempts >= this.maxReconnectAttempts) {
        this.target.close();
        return;
      }
      let delay = this.strategy(this.attempts);
      this.attempts++;
      this.logger.info(`Reconnecting in ${delay}ms (${this.attempts} attempt)`);
      this.state = "pending_reconnect";
      this.reconnnectId = setTimeout(() => this.reconnectNow(), delay);
    }
    cancelReconnect() {
      if (this.reconnnectId) {
        clearTimeout(this.reconnnectId);
        delete this.reconnnectId;
      }
    }
  };

  // node_modules/@anycable/core/transport/index.js
  init_define_process();
  init_jquery();
  var FallbackTransport = class {
    constructor(transports, opts = {}) {
      this.transports = transports;
      this.transport = null;
      this.emitter = createNanoEvents();
      this.unbind = [];
      this.logger = opts.logger || new NoopLogger();
    }
    displayName() {
      return "fallbacked transport";
    }
    async open() {
      for (let i3 = 0; i3 < this.transports.length; i3++) {
        let transport = this.transports[i3];
        try {
          this.transport = transport;
          this.resetListeners();
          this.logger.debug(`Trying to connect via ${transport.displayName()}`);
          await transport.open();
          this.logger.debug(`Connected via ${transport.displayName()}`);
          return;
        } catch (e2) {
          this.logger.debug(
            `Failed to connect via ${transport.displayName()}: ${e2.message}`
          );
        }
      }
      this.transport = null;
      this.resetListeners();
      throw new Error(`Couldn't connect via any available transport`);
    }
    send(data) {
      if (!this.transport) {
        throw new Error("No transport is open");
      }
      this.transport.send(data);
    }
    async close() {
      if (!this.transport) {
        throw new Error("No transport is open");
      }
      await this.transport.close();
      this.transport = null;
    }
    setURL() {
      throw new Error("Not implemented. Set URL for each transport separately");
    }
    setParam(key, val) {
      this.transports.forEach((transport) => {
        transport.setParam(key, val);
      });
    }
    on(event2, callback2) {
      return this.emitter.on(event2, callback2);
    }
    once(event2, callback2) {
      let unbind = this.emitter.on(event2, (...args) => {
        unbind();
        callback2(...args);
      });
      return unbind;
    }
    get url() {
      if (!this.transport) return "";
      return this.transport.url;
    }
    resetListeners() {
      this.unbind.forEach((clbk) => clbk());
      this.unbind.length = 0;
      if (!this.transport) return;
      this.unbind.push(
        this.transport.on("open", () => {
          this.emitter.emit("open");
        }),
        this.transport.on("data", (data) => {
          this.emitter.emit("data", data);
        }),
        this.transport.on("close", (ev) => {
          this.emitter.emit("close", ev);
        }),
        this.transport.on("error", (ev) => {
          this.emitter.emit("error", ev);
        })
      );
    }
  };

  // node_modules/@anycable/core/websocket/index.js
  init_define_process();
  init_jquery();
  var WebSocketTransport = class {
    constructor(url, opts = {}) {
      this.url = url;
      let Impl = opts.websocketImplementation;
      if (Impl) {
        this.Impl = Impl;
      } else if (typeof WebSocket !== "undefined") {
        this.Impl = WebSocket;
      } else {
        throw new Error("No WebSocket support");
      }
      this.connected = false;
      this.emitter = createNanoEvents();
      let { format: format2, subprotocol } = opts;
      this.format = format2 || "text";
      this.connectionOptions = opts.websocketOptions;
      this.subprotocol = subprotocol;
    }
    displayName() {
      return "WebSocket(" + this.url + ")";
    }
    open() {
      if (this.connectionOptions) {
        this.ws = new this.Impl(
          this.url,
          this.subprotocol,
          this.connectionOptions
        );
      } else {
        this.ws = new this.Impl(this.url, this.subprotocol);
      }
      this.ws.binaryType = "arraybuffer";
      this.initListeners();
      return new Promise((resolve2, reject) => {
        let unbind = [];
        unbind.push(
          this.once("open", () => {
            unbind.forEach((clbk) => clbk());
            resolve2();
          })
        );
        unbind.push(
          this.once("close", () => {
            unbind.forEach((clbk) => clbk());
            reject(Error("WS connection closed"));
          })
        );
      });
    }
    setURL(url) {
      this.url = url;
    }
    setParam(key, val) {
      let url = new URL(this.url);
      url.searchParams.set(key, val);
      let newURL = `${url.protocol}//${url.host}${url.pathname}?${url.searchParams}`;
      this.setURL(newURL);
    }
    send(data) {
      if (!this.ws || !this.connected) {
        throw Error("WebSocket is not connected");
      } else {
        this.ws.send(data);
      }
    }
    close() {
      if (this.ws) {
        this.onclose();
      } else {
        this.connected = false;
      }
    }
    on(event2, callback2) {
      return this.emitter.on(event2, callback2);
    }
    once(event2, callback2) {
      let unbind = this.emitter.on(event2, (...args) => {
        unbind();
        callback2(...args);
      });
      return unbind;
    }
    initListeners() {
      this.ws.onerror = (event2) => {
        if (this.connected) {
          this.emitter.emit("error", event2.error || new Error("WS Error"));
        }
      };
      this.ws.onclose = () => {
        this.onclose();
      };
      this.ws.onmessage = (event2) => {
        let data = event2.data;
        if (this.format === "binary") {
          data = new Uint8Array(data);
        }
        this.emitter.emit("data", data);
      };
      this.ws.onopen = () => {
        this.connected = true;
        this.emitter.emit("open");
      };
    }
    onclose() {
      this.ws.onclose = void 0;
      this.ws.onmessage = void 0;
      this.ws.onopen = void 0;
      this.ws.close();
      delete this.ws;
      this.connected = false;
      this.emitter.emit("close");
    }
  };

  // node_modules/@anycable/core/create-cable/index.js
  init_define_process();
  init_jquery();
  var DEFAULT_OPTIONS = {
    protocol: "actioncable-v1-json",
    pingInterval: 3e3,
    maxReconnectAttempts: Infinity,
    maxMissingPings: 2,
    logLevel: "warn",
    lazy: true
  };
  function createCable(url, opts) {
    if (typeof url === "object" && typeof opts === "undefined") {
      opts = url;
      url = void 0;
    }
    opts = opts || {};
    if (!url && !opts.transport) throw Error("URL or transport must be specified");
    opts = Object.assign({}, DEFAULT_OPTIONS, opts);
    let {
      protocol,
      websocketImplementation,
      websocketFormat,
      websocketOptions,
      fallbacks,
      logLevel,
      logger,
      transport,
      encoder,
      lazy,
      monitor,
      pingInterval,
      reconnectStrategy,
      maxMissingPings,
      maxReconnectAttempts,
      subprotocol,
      tokenRefresher,
      historyTimestamp,
      protocolOptions,
      concurrentSubscribes
    } = opts;
    logger = logger || new NoopLogger(logLevel);
    if (typeof protocol === "string") {
      subprotocol = subprotocol || protocol;
      let protocolName = protocol.substring(0, protocol.lastIndexOf("-"));
      let protocolEncoderName = protocol.substring(protocol.lastIndexOf("-") + 1);
      protocolOptions = protocolOptions || {};
      if (protocolName === "actioncable-v1") {
        protocol = new ActionCableProtocol({ logger, ...protocolOptions });
      } else if (protocolName === "actioncable-v1-ext") {
        protocol = new ActionCableExtendedProtocol({
          logger,
          historyTimestamp,
          ...protocolOptions
        });
      } else {
        throw Error(`Protocol is not supported yet: ${protocol}`);
      }
      if (protocolEncoderName === "json") {
        encoder = encoder || new JSONEncoder();
        websocketFormat = websocketFormat || "text";
      } else if (protocolEncoderName === "msgpack") {
        websocketFormat = "binary";
        if (!encoder) {
          throw Error(
            "Msgpack encoder must be specified explicitly. Use `@anycable/msgpack-encoder` package or build your own"
          );
        }
      } else if (protocolEncoderName === "protobuf") {
        websocketFormat = websocketFormat || "binary";
        if (!encoder) {
          throw Error(
            "Protobuf encoder must be specified explicitly. Use `@anycable/protobuf-encoder` package or build your own"
          );
        }
      } else {
        throw Error(`Protocol is not supported yet: ${protocol}`);
      }
    }
    if (!protocol) throw Error("Protocol must be specified");
    transport = transport || new WebSocketTransport(url, {
      websocketImplementation,
      websocketOptions,
      subprotocol,
      format: websocketFormat
    });
    if (fallbacks) {
      transport = new FallbackTransport([transport, ...fallbacks], { logger });
    }
    reconnectStrategy = reconnectStrategy || backoffWithJitter(pingInterval);
    if (monitor !== false) {
      monitor = monitor || new Monitor({
        pingInterval,
        reconnectStrategy,
        maxMissingPings,
        maxReconnectAttempts,
        logger
      });
    }
    let hubOptions = { concurrentSubscribes };
    let cable = new Cable({
      protocol,
      transport,
      encoder,
      logger,
      lazy,
      hubOptions
    });
    if (monitor) {
      monitor.watch(cable);
      cable.monitor = monitor;
    }
    if (tokenRefresher) {
      watchForExpiredToken(cable, async () => {
        try {
          await tokenRefresher(transport);
        } catch (err) {
          logger.error("Failed to refresh authentication token: " + err);
          return false;
        }
        cable.connect().catch(() => {
        });
        return true;
      });
    }
    return cable;
  }
  function watchForExpiredToken(cable, callback2) {
    let attempted = false;
    cable.on("connect", () => attempted = false);
    cable.on("close", async (ev) => {
      if (!ev) return;
      if (attempted) {
        cable.logger.warn("Token auto-refresh is disabled", ev);
        return;
      }
      if (ev.reason === "token_expired") {
        attempted = true;
        await callback2();
      }
    });
  }
  var ActionCableSubscription = class {
    constructor(channel) {
      this.channel = channel;
    }
    notify(callback2, ...args) {
      if (typeof this[callback2] !== "function") return;
      this[callback2](...args);
    }
    perform(action, data = {}) {
      this.channel.perform(action, data);
    }
    send(data) {
      this.channel.send(data);
    }
    get identifier() {
      return this.channel.identifier;
    }
    unsubscribe() {
      return this.channel.disconnect();
    }
  };
  var ActionCableChannel = class extends GhostChannel {
    constructor(channelName, params, mixin) {
      super(channelName, params);
      this.subscription = new ActionCableSubscription(this);
      Object.assign(this.subscription, mixin);
      this.on("connect", () => this.subscription.notify("connected"));
      this.on(
        "disconnect",
        () => this.subscription.notify("disconnected", { allowReconnect: true })
      );
      this.on("message", (val) => this.subscription.notify("received", val));
      this.on("close", (err) => {
        if (err && err instanceof SubscriptionRejectedError) {
          this.subscription.notify("rejected");
        } else {
          this.subscription.notify("disconnected", { allowReconnect: false });
        }
      });
    }
  };
  var ActionCableSubscriptions = class {
    constructor(cable) {
      this.cable = cable;
    }
    create(channel, mixin) {
      let channelName;
      let params;
      if (typeof channel === "object") {
        channelName = channel.channel;
        delete channel.channel;
        params = channel;
      } else {
        channelName = channel;
        params = {};
      }
      let cableChannel = new ActionCableChannel(channelName, params, mixin);
      cableChannel.subscription.notify("initialized");
      this.cable.subscribe(cableChannel);
      return cableChannel.subscription;
    }
    findAll(identifier) {
      return this.cable.hub.channels.filter((channel) => channel.identifier === identifier).map((channel) => channel.subscription);
    }
  };
  var ActionCableConsumer = class {
    constructor(cable) {
      this.cable = cable;
      this.subscriptions = new ActionCableSubscriptions(cable);
    }
  };

  // node_modules/@anycable/web/logger/index.js
  init_define_process();
  init_jquery();
  var Logger = class extends BaseLogger {
    writeLogEntry(level, msg, details) {
      if (details) {
        console[level](msg, details);
      } else {
        console[level](msg);
      }
    }
  };

  // node_modules/@anycable/web/monitor/index.js
  init_define_process();
  init_jquery();
  var Monitor2 = class extends Monitor {
    watch(cable) {
      super.watch(cable);
      this.initActivityListeners();
    }
    initActivityListeners() {
      if (typeof document !== "undefined" && typeof window !== "undefined" && document.addEventListener && window.addEventListener) {
        let visibility = () => {
          if (!document.hidden) {
            if (this.reconnectNow()) {
              this.logger.debug("Trigger reconnect due to visibility change");
            }
          }
        };
        let connect = (event2) => {
          if (this.reconnectNow()) {
            this.logger.debug("Trigger reconnect", { event: event2 });
          }
        };
        let disconnectFrozen = () => this.disconnect(new DisconnectedError("page_frozen"));
        document.addEventListener("visibilitychange", visibility, false);
        window.addEventListener("focus", connect, false);
        window.addEventListener("online", connect, false);
        window.addEventListener("resume", connect, false);
        window.addEventListener("freeze", disconnectFrozen, false);
        this.unbind.push(() => {
          document.removeEventListener("visibilitychange", visibility, false);
          window.removeEventListener("focus", connect, false);
          window.removeEventListener("online", connect, false);
          window.removeEventListener("resume", connect, false);
          window.removeEventListener("freeze", disconnectFrozen, false);
        });
      }
    }
    disconnect(err) {
      if (this.state === "disconnected" || this.state === "closed") return;
      this.logger.info("Disconnecting", { reason: err.message });
      this.cancelReconnect();
      this.stopPolling();
      this.state = "pending_disconnect";
      this.target.disconnected(err);
    }
  };

  // node_modules/@anycable/web/index.js
  var metaPrefixes = ["cable", "action-cable"];
  var defaultUrl = "/cable";
  var fetchMeta = (doc2, key) => {
    for (let prefix2 of metaPrefixes) {
      let element = doc2.head.querySelector(`meta[name='${prefix2}-${key}']`);
      if (element) {
        return element.getAttribute("content");
      }
    }
  };
  var absoluteWSUrl = (path) => {
    if (path.match(/wss?:\/\//)) return path;
    if (typeof window !== "undefined") {
      let proto = window.location.protocol.replace("http", "ws");
      return `${proto}//${window.location.host}${path}`;
    }
    return path;
  };
  var generateUrlFromDOM = () => {
    if (typeof document !== "undefined" && document.head) {
      let url = fetchMeta(document, "url");
      if (url) {
        return absoluteWSUrl(url);
      }
    }
    return absoluteWSUrl(defaultUrl);
  };
  var historyTimestampFromMeta = () => {
    if (typeof document !== "undefined" && document.head) {
      let value = fetchMeta(document, "history-timestamp");
      if (value) {
        return value | 0;
      }
    }
  };
  function createCable2(url, opts) {
    if (typeof url === "object" && typeof opts === "undefined") {
      opts = url;
      url = void 0;
    }
    url = url || generateUrlFromDOM();
    opts = opts || {};
    opts.historyTimestamp || (opts.historyTimestamp = historyTimestampFromMeta());
    opts = Object.assign({}, DEFAULT_OPTIONS, opts);
    let {
      logLevel,
      logger,
      pingInterval,
      reconnectStrategy,
      maxMissingPings,
      maxReconnectAttempts
    } = opts;
    logger = opts.logger = opts.logger || new Logger(logLevel);
    reconnectStrategy = opts.reconnectStrategy = opts.reconnectStrategy || backoffWithJitter(pingInterval);
    if (opts.monitor !== false) {
      opts.monitor = opts.monitor || new Monitor2({
        pingInterval,
        reconnectStrategy,
        maxMissingPings,
        maxReconnectAttempts,
        logger
      });
    }
    return createCable(url, opts);
  }
  function createConsumer2(url, opts) {
    let cable = createCable2(url, opts);
    return new ActionCableConsumer(cable);
  }

  // projects/cf_utils/ApplicationCable/ActionCableGetConfigShim.js
  init_define_process();
  init_jquery();
  var metaPrefixes2 = ["cable", "action-cable"];
  var defaultUrl2 = "/cable";
  var fetchMeta2 = (doc2, key) => {
    for (let prefix2 of metaPrefixes2) {
      let element = doc2.head.querySelector(`meta[name='${prefix2}-${key}']`);
      if (element) {
        return element.getAttribute("content");
      }
    }
  };
  var absoluteWSUrl2 = (path) => {
    if (path.match(/wss?:\/\//)) return path;
    if (typeof window !== "undefined") {
      let proto = window.location.protocol.replace("http", "ws");
      return `${proto}//${window.location.host}${path}`;
    }
    return path;
  };
  var generateUrlFromDOM2 = () => {
    if (typeof document !== "undefined" && document.head) {
      let url = fetchMeta2(document, "url");
      if (url) {
        return absoluteWSUrl2(url);
      }
    }
    return absoluteWSUrl2(defaultUrl2);
  };
  var ActionCableGetConfigShim_default = generateUrlFromDOM2;

  // projects/cf_utils/ApplicationCable/index.js
  var ANYCABLE_OPTIONS = {
    protocol: "actioncable-v1-json",
    concurrentSubscribes: false
  };
  function getCableUrlWithCurrentContext() {
    const url = new URL(ActionCableGetConfigShim_default());
    const currentContext = document.querySelector('meta[name="action-cable-context"]')?.content;
    if (currentContext) {
      url.searchParams.append("uid", currentContext);
    }
    return url.toString();
  }
  function getCableOptions() {
    const currentProtocol = document.querySelector('meta[name="action-cable-protocol"]')?.content;
    return {
      ...ANYCABLE_OPTIONS,
      protocol: currentProtocol || ANYCABLE_OPTIONS.protocol
    };
  }
  async function refreshCableUrlWithCurrentContext(event2) {
    window.applicationCableConsumer.cable.transport.setURL(getCableUrlWithCurrentContext());
  }
  function getOrCreateApplicationCableConsumer() {
    if (!window.applicationCableConsumer) {
      window.applicationCableConsumer = createConsumer2(
        getCableUrlWithCurrentContext(),
        getCableOptions()
      );
      window.applicationCableConsumer.cable.on("disconnect", refreshCableUrlWithCurrentContext);
    }
    return window.applicationCableConsumer;
  }
  var consumer2 = getOrCreateApplicationCableConsumer();
  var ApplicationCable_default = consumer2;

  // node_modules/@anycable/turbo-stream/index.js
  init_define_process();
  init_jquery();

  // node_modules/@anycable/turbo-stream/channel.js
  init_define_process();
  init_jquery();
  var TurboChannel = class extends Channel {
    constructor(element, channelId, params) {
      super(params);
      this.element = element;
      this.channelId = channelId;
    }
    set channelId(val) {
      this._channelId = val;
    }
    get channelId() {
      return this._channelId;
    }
  };
  __publicField(TurboChannel, "identifier", "__turbo__");

  // node_modules/@anycable/turbo-stream/start.js
  init_define_process();
  init_jquery();

  // node_modules/@anycable/turbo-stream/stream_source_element.js
  init_define_process();
  init_jquery();

  // node_modules/@anycable/turbo-stream/snakeize.js
  init_define_process();
  init_jquery();
  function walk(obj) {
    if (!obj || typeof obj !== "object") return obj;
    if (obj instanceof Date || obj instanceof RegExp) return obj;
    if (Array.isArray(obj)) return obj.map(walk);
    return Object.keys(obj).reduce((acc, key) => {
      let camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, (m4, x4) => {
        return "_" + x4.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // node_modules/@anycable/turbo-stream/turbo.js
  init_define_process();
  init_jquery();
  function isPreview() {
    return document.documentElement.hasAttribute("data-turbo-preview");
  }

  // node_modules/@anycable/turbo-stream/stream_source_element.js
  var TurboStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      if (isPreview()) return;
      let cable = this.constructor.cable;
      let ChannelClass = this.constructor.channelClass;
      let channelName = this.getAttribute("channel");
      let signedStreamName = this.getAttribute("signed-stream-name");
      let params = walk({ ...this.dataset });
      this.listeners = [];
      this.channel = new ChannelClass(this, channelName, {
        signed_stream_name: signedStreamName,
        ...params
      });
      this.listeners.push(
        this.channel.on("connect", () => this.setAttribute("connected", ""))
      );
      this.listeners.push(
        this.channel.on("disconnect", () => this.removeAttribute("connected"))
      );
      this.listeners.push(
        this.channel.on("message", this.dispatchMessageEvent.bind(this))
      );
      cable.subscribe(this.channel);
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.channel) {
        for (let listener of this.listeners) {
          listener();
        }
        this.listeners.length = 0;
        let ch = this.channel;
        let delay = this.constructor.delayedUnsubscribe;
        if (delay) {
          setTimeout(() => ch.disconnect(), delay);
        } else {
          ch.disconnect();
        }
      }
    }
    dispatchMessageEvent(data) {
      let event2 = new MessageEvent("message", { data });
      return this.dispatchEvent(event2);
    }
  };
  __publicField(TurboStreamSourceElement, "cable");
  __publicField(TurboStreamSourceElement, "channelClass");
  __publicField(TurboStreamSourceElement, "delayedUnsubscribe");

  // node_modules/@anycable/turbo-stream/start.js
  var DEFAULT_SOCKET_HEADER = "X-Socket-ID";
  function start2(cable, opts = {}) {
    let tagName = opts.tagName || "turbo-cable-stream-source";
    let channelClass = opts.channelClass || TurboChannel;
    let delayedUnsubscribe = opts.delayedUnsubscribe || 0;
    if (delayedUnsubscribe === true) delayedUnsubscribe = 300;
    let C4 = class extends TurboStreamSourceElement {
    };
    C4.cable = cable;
    C4.channelClass = channelClass;
    C4.delayedUnsubscribe = delayedUnsubscribe;
    if (customElements.get(tagName) === void 0) {
      customElements.define(tagName, C4);
    }
    if (opts.requestSocketIDHeader) {
      let headerName = opts.requestSocketIDHeader === true ? DEFAULT_SOCKET_HEADER : opts.requestSocketIDHeader;
      document.addEventListener("turbo:before-fetch-request", (event2) => {
        if (cable.sessionId && !event2.detail.fetchOptions.headers[headerName]) {
          event2.detail.fetchOptions.headers[headerName] = cable.sessionId;
        }
      });
    }
  }

  // app/javascript/channels/index.js
  init_define_process();
  init_jquery();

  // node_modules/@stimulus_reflex/futurism/dist/futurism.min.js
  init_define_process();
  init_jquery();
  var t = (t4) => {
    t4.subscriptions.create("Futurism::Channel", { connected() {
      window.Futurism = this, document.addEventListener("futurism:appear", /* @__PURE__ */ ((e2, t5 = 20) => {
        let s4, r3 = [];
        return (...n3) => {
          clearTimeout(s4), r3 = [...r3, ...n3], s4 = setTimeout(() => {
            s4 = null, e2(r3), r3 = [];
          }, t5);
        };
      })((e2) => {
        this.send({ signed_params: e2.map((e3) => e3.target.dataset.signedParams), sgids: e2.map((e3) => e3.target.dataset.sgid), signed_controllers: e2.map((e3) => e3.target.dataset.signedController), urls: e2.map((e3) => window.location.href), broadcast_each: e2.map((e3) => e3.target.dataset.broadcastEach) });
      }));
    }, received(t5) {
      t5.cableReady && (global2.perform(t5.operations, { emitMissingElementWarnings: false }), document.dispatchEvent(new CustomEvent("futurism:appeared", { bubbles: true, cancelable: true })));
    } });
  };
  var s = (e2, t4 = null) => {
    if (!window.Futurism) return () => {
      setTimeout(() => s(e2, t4)(), 1);
    };
    const r3 = e2.target ? e2.target : e2, n3 = new CustomEvent("futurism:appear", { bubbles: true, detail: { target: r3, observer: t4 } });
    return () => {
      r3.dispatchEvent(n3);
    };
  };
  var r = async (e2, t4 = 0) => {
    try {
      return await e2();
    } catch (n3) {
      if (t4 > 10) throw n3;
      return await (s4 = 1.15 ** t4 * 2e3, new Promise((e3) => setTimeout(e3, s4))), r(e2, t4 + 1);
    }
    var s4;
  };
  var n = (e2, t4) => {
    e2.forEach(async (e3) => {
      e3.isIntersecting && await r(s(e3, t4));
    });
  };
  var a = (e2) => {
    Object.assign(e2, { observer: new IntersectionObserver(n.bind(e2), {}) }), e2.hasAttribute("keep") || e2.observer.observe(e2);
  };
  var i = (e2) => {
    "true" === e2.dataset.eager && (e2.observer && e2.observer.disconnect(), r(s(e2)));
  };
  var o = class extends HTMLElement {
    connectedCallback() {
      a(this), i(this);
    }
  };
  var c = class extends HTMLTableRowElement {
    connectedCallback() {
      a(this), i(this);
    }
  };
  var u = class extends HTMLLIElement {
    connectedCallback() {
      a(this), i(this);
    }
  };
  var m = (e2) => {
    customElements.get("futurism-element") || (customElements.define("futurism-element", o), customElements.define("futurism-table-row", c, { extends: "tr" }), customElements.define("futurism-li", u, { extends: "li" }));
  };
  var d = (e2) => {
    (async function(e3) {
      const t4 = new TextEncoder("utf-8").encode(e3), s4 = await crypto.subtle.digest("SHA-256", t4);
      return Array.from(new Uint8Array(s4)).map((e4) => ("00" + e4.toString(16)).slice(-2)).join("");
    })(e2.detail.element.outerHTML).then((t4) => {
      e2.detail.element.setAttribute("keep", ""), sessionStorage.setItem(`futurism-${t4}`, e2.detail.element.outerHTML), e2.target.dataset.futurismHash = t4;
    });
  };
  var l = (e2) => {
    Object.entries(sessionStorage).filter(([e3, t4]) => e3.startsWith("futurism-")).forEach(([e3, t4]) => {
      const s4 = /^futurism-(.*)/.exec(e3), r3 = document.querySelector(`[data-futurism-hash="${s4[1]}"]`);
      r3 && (r3.outerHTML = t4, sessionStorage.removeItem(e3));
    });
  };
  var b = () => {
    (() => {
      const e2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (customElements) if (e2) document.write('<script src="//unpkg.com/@ungap/custom-elements-builtin"><\/script>');
      else try {
        customElements.define("built-in", document.createElement("tr").constructor, { extends: "tr" });
      } catch (e3) {
        document.write('<script src="//unpkg.com/@ungap/custom-elements-builtin"><\/script>');
      }
      else document.write('<script src="//unpkg.com/document-register-element"><\/script>');
    })(), document.addEventListener("DOMContentLoaded", m), document.addEventListener("turbo:load", m), document.addEventListener("turbo:before-cache", l), document.addEventListener("turbolinks:load", m), document.addEventListener("turbolinks:before-cache", l), document.addEventListener("cable-ready:after-outer-html", d);
  };

  // import-glob:./**/*_channel.js
  init_define_process();
  init_jquery();

  // app/javascript/channels/users_channel.js
  init_define_process();
  init_jquery();
  var eventNamespace = "users-channel";
  var usersChannel = ApplicationCable_default.subscriptions.create("UsersChannel", {
    connected() {
      window.usersChannelConnected = true;
      document.dispatchEvent(new CustomEvent(`${eventNamespace}:connected`, { bubbles: true }));
    },
    disconnected() {
      window.usersChannelConnected = false;
      document.dispatchEvent(new CustomEvent(`${eventNamespace}:disconnected`, { bubbles: true }));
    },
    received(data) {
      if (data.cableReady) global2.perform(data.operations);
    }
  });
  var users_channel_default = usersChannel;

  // import-glob:./**/*_channel.js
  var context = {
    "users_channel.js": users_channel_default
  };

  // app/javascript/channels/index.js
  if (context) {
  }
  b();
  t(ApplicationCable_default);

  // app/javascript/customer_center/controllers/index.js
  init_define_process();
  init_jquery();

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  init_define_process();
  init_jquery();
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event2) {
      const extendedEvent2 = extendEvent(event2);
      for (const binding of this.bindings) {
        if (extendedEvent2.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent2);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event2) {
    if ("immediatePropagationStopped" in event2) {
      return event2;
    } else {
      const { stopImmediatePropagation } = event2;
      return Object.assign(event2, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map3) => listeners.concat(Array.from(map3.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error3, message, detail = {}) {
      this.application.handleError(error3, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event: event2, value }) {
      if (value)
        event2.stopPropagation();
      return true;
    },
    prevent({ event: event2, value }) {
      if (value)
        event2.preventDefault();
      return true;
    },
    self({ event: event2, value, element }) {
      if (value) {
        return element === event2.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[1];
    let keyFilter = matches[2];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches[3]),
      eventName,
      eventOptions: matches[6] ? parseEventOptions(matches[6]) : {},
      identifier: matches[4],
      methodName: matches[5],
      keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_26, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_26, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  var Action = class {
    constructor(element, index2, descriptor, schema) {
      this.element = element;
      this.index = index2;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    isFilterTarget(event2) {
      if (!this.keyFilter) {
        return false;
      }
      const filteres = this.keyFilter.split("+");
      const modifiers = ["meta", "ctrl", "alt", "shift"];
      const [meta, ctrl, alt, shift2] = modifiers.map((modifier) => filteres.includes(modifier));
      if (event2.metaKey !== meta || event2.ctrlKey !== ctrl || event2.altKey !== alt || event2.shiftKey !== shift2) {
        return true;
      }
      const standardFilter = filteres.filter((key) => !modifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event2.key.toLowerCase();
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name: name2, value } of Array.from(this.element.attributes)) {
        const match = name2.match(pattern);
        const key = match && match[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e2) => e2.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context2, action) {
      this.context = context2;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event2) {
      if (this.willBeInvokedByEvent(event2) && this.applyEventModifiers(event2)) {
        this.invokeWithEvent(event2);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event2) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      let passes = true;
      for (const [name2, value] of Object.entries(this.eventOptions)) {
        if (name2 in actionDescriptorFilters) {
          const filter = actionDescriptorFilters[name2];
          passes = passes && filter({ name: name2, value, event: event2, element });
        } else {
          continue;
        }
      }
      return passes;
    }
    invokeWithEvent(event2) {
      const { target, currentTarget } = event2;
      try {
        const { params } = this.action;
        const actionEvent = Object.assign(event2, { params });
        this.method.call(this.controller, actionEvent);
        this.context.logDebugActivity(this.methodName, { event: event2, target, currentTarget, action: this.methodName });
      } catch (error3) {
        const { identifier, controller, element, index: index2 } = this;
        const detail = { identifier, controller, element, index: index2, event: event2 };
        this.context.handleError(error3, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event2) {
      const eventTarget = event2.target;
      if (event2 instanceof KeyboardEvent && this.action.isFilterTarget(event2)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback2) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback2();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(node, attributeName) {
      const element = node;
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback2) {
      this.elementObserver.pause(callback2);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add2(map3, key, value) {
    fetch2(map3, key).add(value);
  }
  function del(map3, key, value) {
    fetch2(map3, key).delete(value);
    prune(map3, key);
  }
  function fetch2(map3, key) {
    let values = map3.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map3.set(key, values);
    }
    return values;
  }
  function prune(map3, key) {
    const values = map3.get(key);
    if (values != null && values.size == 0) {
      map3.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets2 = Array.from(this.valuesByKey.values());
      return sets2.reduce((values, set2) => values.concat(Array.from(set2)), []);
    }
    get size() {
      const sets2 = Array.from(this.valuesByKey.values());
      return sets2.reduce((size3, set2) => size3 + set2.size, 0);
    }
    add(key, value) {
      add2(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets2 = Array.from(this.valuesByKey.values());
      return sets2.some((set2) => set2.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details = {}) {
      this.selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback2) {
      this.elementObserver.pause(callback2);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const matches = element.matches(this.selector);
      if (this.delegate.selectorMatchElement) {
        return matches && this.delegate.selectorMatchElement(element, this.details);
      }
      return matches;
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector)).filter((match2) => this.matchElement(match2));
      return match.concat(matches);
    }
    elementMatched(element) {
      this.selectorMatched(element);
    }
    elementUnmatched(element) {
      this.selectorUnmatched(element);
    }
    elementAttributeChanged(element, _attributeName) {
      const matches = this.matchElement(element);
      const matchedBefore = this.matchesByElement.has(this.selector, element);
      if (!matches && matchedBefore) {
        this.selectorUnmatched(element);
      }
    }
    selectorMatched(element) {
      if (this.delegate.selectorMatched) {
        this.delegate.selectorMatched(element, this.selector, this.details);
        this.matchesByElement.add(this.selector, element);
      }
    }
    selectorUnmatched(element) {
      this.delegate.selectorUnmatched(element, this.selector, this.details);
      this.matchesByElement.delete(this.selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback2) {
      this.attributeObserver.pause(callback2);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index2) => ({ element, attributeName, content, index: index2 }));
  }
  function zip(left2, right2) {
    const length = Math.max(left2.length, right2.length);
    return Array.from({ length }, (_26, index2) => [left2[index2], right2[index2]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error3) {
        return { error: error3 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context2, delegate) {
      this.context = context2;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context2, receiver) {
      this.context = context2;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name2, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name2];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name2, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name: name2, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name2, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name2, rawValue, rawOldValue) {
      const changedMethodName = `${name2}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name2];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error3) {
          if (error3 instanceof TypeError) {
            error3.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error3.message}`;
          }
          throw error3;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors2 = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors2[descriptor.name] = descriptor;
      });
      return descriptors2;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context2, delegate) {
      this.context = context2;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name2 }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name2);
      }
    }
    tokenUnmatched({ element, content: name2 }) {
      this.disconnectTarget(element, name2);
    }
    connectTarget(element, name2) {
      var _a;
      if (!this.targetsByName.has(name2, element)) {
        this.targetsByName.add(name2, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name2));
      }
    }
    disconnectTarget(element, name2) {
      var _a;
      if (this.targetsByName.has(name2, element)) {
        this.targetsByName.delete(name2, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name2));
      }
    }
    disconnectAllTargets() {
      for (const name2 of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name2)) {
          this.disconnectTarget(element, name2);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name2) => values.add(name2));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context2, delegate) {
      this.context = context2;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (this.selectorObserverMap.size === 0) {
        this.outletDefinitions.forEach((outletName) => {
          const selector = this.selector(outletName);
          const details = { outletName };
          if (selector) {
            this.selectorObserverMap.set(outletName, new SelectorObserver(document.body, selector, this, details));
          }
        });
        this.selectorObserverMap.forEach((observer) => observer.start());
      }
      this.dependentContexts.forEach((context2) => context2.refresh());
    }
    stop() {
      if (this.selectorObserverMap.size > 0) {
        this.disconnectAllOutlets();
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      return this.hasOutlet(element, outletName) && element.matches(`[${this.context.application.schema.controllerAttribute}~=${outletName}]`);
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    get outletDependencies() {
      const dependencies2 = new Multimap();
      this.router.modules.forEach((module2) => {
        const constructor = module2.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies2.add(outlet, module2.identifier));
      });
      return dependencies2;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context2) => identifiers.includes(context2.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module2, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module2;
      this.scope = scope;
      this.controller = new module2.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error3) {
        this.handleError(error3, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error3) {
        this.handleError(error3, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error3) {
        this.handleError(error3, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error3, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error3, `Error ${message}`, detail);
    }
    targetConnected(element, name2) {
      this.invokeControllerMethod(`${name2}TargetConnected`, element);
    }
    targetDisconnected(element, name2) {
      this.invokeControllerMethod(`${name2}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name2) {
      this.invokeControllerMethod(`${namespaceCamelize(name2)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name2) {
      this.invokeControllerMethod(`${namespaceCamelize(name2)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a5 = function() {
        this.a.call(this);
      };
      const b5 = extendWithReflect(a5);
      b5.prototype.a = function() {
      };
      return new b5();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error3) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context2 = this.fetchContextForScope(scope);
      this.connectedContexts.add(context2);
      context2.connect();
    }
    disconnectContextForScope(scope) {
      const context2 = this.contextsByScope.get(scope);
      if (context2) {
        this.connectedContexts.delete(context2);
        context2.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context2 = this.contextsByScope.get(scope);
      if (!context2) {
        context2 = new Context(this, scope);
        this.contextsByScope.set(scope, context2);
      }
      return context2;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name2) {
      return this.data.has(this.getDataKey(name2));
    }
    get(name2) {
      return this.getAll(name2)[0];
    }
    getAll(name2) {
      const tokenString = this.data.get(this.getDataKey(name2)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name2) {
      return this.data.getAttributeNameForKey(this.getDataKey(name2));
    }
    getDataKey(name2) {
      return `${name2}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name2 = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name2);
    }
    set(key, value) {
      const name2 = this.getAttributeNameForKey(key);
      this.element.setAttribute(name2, value);
      return this.get(key);
    }
    has(key) {
      const name2 = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name2);
    }
    delete(key) {
      if (this.has(key)) {
        const name2 = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name2);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements2 = this.scope.queryElements(selector);
      return elements2.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements2 = this.scope.queryElements(selector);
      return elements2.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module2) => contexts.concat(module2.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module2 = new Module(this.application, definition);
      this.connectModule(module2);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad(definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module2 = this.modulesByIdentifier.get(identifier);
      if (module2) {
        this.disconnectModule(module2);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module2 = this.modulesByIdentifier.get(identifier);
      if (module2) {
        return module2.contexts.find((context2) => context2.element == element);
      }
    }
    handleError(error3, message, detail) {
      this.application.handleError(error3, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module2 = this.modulesByIdentifier.get(scope.identifier);
      if (module2) {
        module2.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module2 = this.modulesByIdentifier.get(scope.identifier);
      if (module2) {
        module2.disconnectContextForScope(scope);
      }
    }
    connectModule(module2) {
      this.modulesByIdentifier.set(module2.identifier, module2);
      const scopes = this.scopesByIdentifier.getValuesForKey(module2.identifier);
      scopes.forEach((scope) => module2.connectContextForScope(scope));
    }
    disconnectModule(module2) {
      this.modulesByIdentifier.delete(module2.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module2.identifier);
      scopes.forEach((scope) => module2.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c4) => [c4, c4]))), objectFromEntries("0123456789".split("").map((n3) => [n3, n3])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo, [k4, v4]) => Object.assign(Object.assign({}, memo), { [k4]: v4 }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name2, filter) {
      this.actionDescriptorFilters[name2] = filter;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context2) => context2.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context2 = this.router.getContextForElementAndIdentifier(element, identifier);
      return context2 ? context2.controller : null;
    }
    handleError(error3, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error3, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error3);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve2) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve2());
      } else {
        resolve2();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function propertiesForOutletDefinition(name2) {
    const camelizedName = namespaceCamelize(name2);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outlet = this.outlets.find(name2);
          if (outlet) {
            const outletController = this.application.getControllerForElementAndIdentifier(outlet, name2);
            if (outletController) {
              return outletController;
            } else {
              throw new Error(`Missing "data-controller=${name2}" attribute on outlet element for "${this.identifier}" controller`);
            }
          }
          throw new Error(`Missing outlet element "${name2}" for "${this.identifier}" controller`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name2);
          if (outlets.length > 0) {
            return outlets.map((outlet) => {
              const controller = this.application.getControllerForElementAndIdentifier(outlet, name2);
              if (controller) {
                return controller;
              } else {
                console.warn(`The provided outlet element is missing the outlet controller "${name2}" for "${this.identifier}"`, outlet);
              }
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outlet = this.outlets.find(name2);
          if (outlet) {
            return outlet;
          } else {
            throw new Error(`Missing outlet element "${name2}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name2);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name2);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name2) {
    return {
      [`${name2}Target`]: {
        get() {
          const target = this.targets.find(name2);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name2}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name2}Targets`]: {
        get() {
          return this.targets.findAll(name2);
        }
      },
      [`has${capitalize(name2)}Target`]: {
        get() {
          return this.targets.has(name2);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name: name2, reader: read2, writer: write2 } = definition;
    return {
      [name2]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write2(value));
          }
        }
      },
      [`has${capitalize(name2)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const typeFromObject = parseValueTypeConstant(payload.typeObject.type);
    if (!typeFromObject)
      return;
    const defaultValueType = parseValueTypeDefault(payload.typeObject.default);
    if (typeFromObject !== defaultValueType) {
      const propertyPath = payload.controller ? `${payload.controller}.${payload.token}` : payload.token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${payload.typeObject.default}" is of type "${defaultValueType}".`);
    }
    return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const typeFromObject = parseValueTypeObject({
      controller: payload.controller,
      token: payload.token,
      typeObject: payload.typeDefinition
    });
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeDefinition);
    const typeFromConstant = parseValueTypeConstant(payload.typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = payload.controller ? `${payload.controller}.${payload.typeDefinition}` : payload.token;
    throw new Error(`Unknown value type "${propertyPath}" for "${payload.token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const defaultValue = typeDefinition.default;
    if (defaultValue !== void 0)
      return defaultValue;
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const key = `${dasherize(payload.token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(payload.typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(payload.typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value);
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context2) {
      this.context = context2;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix: prefix2 = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix2 ? `${prefix2}:${eventName}` : eventName;
      const event2 = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event2);
      return event2;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // app/javascript/controllers/alert_controller.js
  init_define_process();
  init_jquery();

  // app/javascript/controllers/application_controller.js
  init_define_process();
  init_jquery();
  var application_controller_default = class extends Controller {
    constructor() {
      super(...arguments);
      __publicField(this, "handleError", (error3, message, detail) => {
        const context2 = {
          controller: this.identifier,
          ...detail
        };
        this.application.handleError(error3, message, context2);
      });
    }
  };

  // app/javascript/controllers/alert_controller.js
  var alert_controller_default = class extends application_controller_default {
    connect() {
      this.alert();
    }
    alert() {
      this.fadeInCurrentAlert();
      this.fadeOutCurrentAlert();
    }
    fadeInCurrentAlert() {
      const fadeIn = this.spread() + parseInt(this.fadeInValue);
      $(this.element).fadeIn(fadeIn);
    }
    fadeOutCurrentAlert() {
      const delay = this.spread() + parseInt(this.delayValue);
      $(this.element).delay(delay).fadeOut(this.fadeOutValue, () => {
        this.remove();
      });
    }
    spread() {
      let spread = 0;
      if (this.domAlertsLength() > 1) {
        spread = this.alertIndex() * 300;
      }
      return spread;
    }
    previousAlert() {
      return $(this.allAlerts()[this.alertIndex() - 1]);
    }
    nextAlert() {
      return $(this.allAlerts()[this.alertIndex() + 1]);
    }
    allAlerts() {
      return $("[data-controller='alert']");
    }
    domAlertsLength() {
      return this.allAlerts().length;
    }
    alertIndex() {
      return this.allAlerts().index(this.element);
    }
    remove() {
      this.element.remove();
    }
    close(event2) {
      event2.preventDefault();
      $(this.element).hide();
      this.remove();
    }
  };
  __publicField(alert_controller_default, "values", {
    fadeIn: String,
    delay: String,
    fadeOut: String
  });

  // app/javascript/controllers/auto_enable_controller.js
  init_define_process();
  init_jquery();
  var auto_enable_controller_default = class extends Controller {
    connect() {
      setTimeout(() => {
        this.groupTarget.dataset.disabled = false;
      }, this.delayValue);
    }
  };
  __publicField(auto_enable_controller_default, "targets", ["group"]);
  __publicField(auto_enable_controller_default, "values", {
    delay: { type: Number, default: 2e4 }
  });

  // app/javascript/controllers/autofocus_controller.js
  init_define_process();
  init_jquery();
  var autofocus_controller_default = class extends application_controller_default {
    connect() {
      if (typeof this.element.updateComplete !== "undefined") {
        this.element.updateComplete.then(() => {
          this.element.focus();
        });
      } else {
        this.element.focus();
      }
    }
  };

  // app/javascript/controllers/classlist_controller.js
  init_define_process();
  init_jquery();
  var classlist_controller_default = class extends application_controller_default {
    /*
      A controller that makes it simple to add, remove, replace, or toggle classes.
    */
    connect() {
      this.htmlElements = this.hasDomElementTarget ? this.domElementTargets : [this.element];
    }
    add() {
      this.htmlElements.forEach((element) => element.classList.add(...this.addClasses));
    }
    remove() {
      this.htmlElements.forEach((element) => element.classList.remove(...this.removeClasses));
    }
    toggle() {
      this.htmlElements.forEach((element) => {
        this.toggleClasses.forEach((className) => element.classList.toggle(className));
      });
    }
    // Methods to interact with outlet controllers
    addToOutlets() {
      this.classlistOutlets.forEach((outlet) => outlet.add());
    }
    removeFromOutlets() {
      this.classlistOutlets.forEach((outlet) => outlet.remove());
    }
    toggleOutlets() {
      this.classlistOutlets.forEach((outlet) => outlet.toggle());
    }
  };
  __publicField(classlist_controller_default, "targets", ["domElement"]);
  __publicField(classlist_controller_default, "classes", ["add", "remove", "toggle"]);
  __publicField(classlist_controller_default, "outlets", ["classlist"]);

  // app/javascript/controllers/clipboard_copy_controller.js
  init_define_process();
  init_jquery();

  // node_modules/@github/clipboard-copy-element/dist/index.esm.js
  init_define_process();
  init_jquery();
  function createNode(text) {
    const node = document.createElement("pre");
    node.style.width = "1px";
    node.style.height = "1px";
    node.style.position = "fixed";
    node.style.top = "5px";
    node.textContent = text;
    return node;
  }
  function copyNode(node) {
    if ("clipboard" in navigator) {
      return navigator.clipboard.writeText(node.textContent);
    }
    const selection = getSelection();
    if (selection == null) {
      return Promise.reject(new Error());
    }
    selection.removeAllRanges();
    const range2 = document.createRange();
    range2.selectNodeContents(node);
    selection.addRange(range2);
    document.execCommand("copy");
    selection.removeAllRanges();
    return Promise.resolve();
  }
  function copyText(text) {
    if ("clipboard" in navigator) {
      return navigator.clipboard.writeText(text);
    }
    const body = document.body;
    if (!body) {
      return Promise.reject(new Error());
    }
    const node = createNode(text);
    body.appendChild(node);
    copyNode(node);
    body.removeChild(node);
    return Promise.resolve();
  }
  function copy(button) {
    const id = button.getAttribute("for");
    const text = button.getAttribute("value");
    function trigger() {
      button.dispatchEvent(new CustomEvent("clipboard-copy", {
        bubbles: true
      }));
    }
    if (text) {
      copyText(text).then(trigger);
    } else if (id) {
      const root = "getRootNode" in Element.prototype ? button.getRootNode() : button.ownerDocument;
      if (!(root instanceof Document || "ShadowRoot" in window && root instanceof ShadowRoot)) return;
      const node = root.getElementById(id);
      if (node) copyTarget(node).then(trigger);
    }
  }
  function copyTarget(content) {
    if (content instanceof HTMLInputElement || content instanceof HTMLTextAreaElement) {
      return copyText(content.value);
    } else if (content instanceof HTMLAnchorElement && content.hasAttribute("href")) {
      return copyText(content.href);
    } else {
      return copyNode(content);
    }
  }
  function clicked(event2) {
    const button = event2.currentTarget;
    if (button instanceof HTMLElement) {
      copy(button);
    }
  }
  function keydown(event2) {
    if (event2.key === " " || event2.key === "Enter") {
      const button = event2.currentTarget;
      if (button instanceof HTMLElement) {
        event2.preventDefault();
        copy(button);
      }
    }
  }
  function focused(event2) {
    event2.currentTarget.addEventListener("keydown", keydown);
  }
  function blurred(event2) {
    event2.currentTarget.removeEventListener("keydown", keydown);
  }
  var ClipboardCopyElement = class extends HTMLElement {
    constructor() {
      super();
      this.addEventListener("click", clicked);
      this.addEventListener("focus", focused);
      this.addEventListener("blur", blurred);
    }
    connectedCallback() {
      if (!this.hasAttribute("tabindex")) {
        this.setAttribute("tabindex", "0");
      }
      if (!this.hasAttribute("role")) {
        this.setAttribute("role", "button");
      }
    }
    get value() {
      return this.getAttribute("value") || "";
    }
    set value(text) {
      this.setAttribute("value", text);
    }
  };
  if (!window.customElements.get("clipboard-copy")) {
    window.ClipboardCopyElement = ClipboardCopyElement;
    window.customElements.define("clipboard-copy", ClipboardCopyElement);
  }

  // node_modules/tippy.js/dist/tippy.esm.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/index.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/enums.js
  init_define_process();
  init_jquery();
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start3 = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start3, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start3, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main2 = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main2, afterMain, beforeWrite, write, afterWrite];

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/index.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  init_define_process();
  init_jquery();
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  init_define_process();
  init_jquery();
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name2) {
      var style = state.styles[name2] || {};
      var attributes = state.attributes[name2] || {};
      var element = state.elements[name2];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name3) {
        var value = attributes[name3];
        if (value === false) {
          element.removeAttribute(name3);
        } else {
          element.setAttribute(name3, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name2) {
        var element = state.elements[name2];
        var attributes = state.attributes[name2] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/arrow.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  init_define_process();
  init_jquery();
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  init_define_process();
  init_jquery();
  var round = Math.round;
  function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (isHTMLElement(element) && includeScale) {
      scaleX = rect.width / element.offsetWidth || 1;
      scaleY = rect.height / element.offsetHeight || 1;
    }
    return {
      width: round(rect.width / scaleX),
      height: round(rect.height / scaleY),
      top: round(rect.top / scaleY),
      right: round(rect.right / scaleX),
      bottom: round(rect.bottom / scaleY),
      left: round(rect.left / scaleX),
      x: round(rect.left / scaleX),
      y: round(rect.top / scaleY)
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/contains.js
  init_define_process();
  init_jquery();
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  init_define_process();
  init_jquery();
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  init_define_process();
  init_jquery();
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  init_define_process();
  init_jquery();
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE2 = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE2 && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  init_define_process();
  init_jquery();
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/within.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/math.js
  init_define_process();
  init_jquery();
  var max = Math.max;
  var min = Math.min;
  var round2 = Math.round;

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/within.js
  function within(min3, value, max3) {
    return max(min3, min(value, max3));
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  init_define_process();
  init_jquery();
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  init_define_process();
  init_jquery();
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name2 = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min3 = paddingObject[minProp];
    var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset3 = within(min3, center, max3);
    var axisProp = axis;
    state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (define_process_default.env.NODE_ENV !== "production") {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (define_process_default.env.NODE_ENV !== "production") {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  init_define_process();
  init_jquery();
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x4 = _ref.x, y6 = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round2(round2(x4 * dpr) / dpr) || 0,
      y: round2(round2(y6 * dpr) / dpr) || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x4 = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y6 = _ref3$y === void 0 ? 0 : _ref3$y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top) {
        sideY = bottom;
        y6 -= offsetParent[heightProp] - popperRect.height;
        y6 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left) {
        sideX = right;
        x4 -= offsetParent[widthProp] - popperRect.width;
        x4 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x4 + "px, " + y6 + "px)" : "translate3d(" + x4 + "px, " + y6 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y6 + "px" : "", _Object$assign2[sideX] = hasX ? x4 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref4) {
    var state = _ref4.state, options = _ref4.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (define_process_default.env.NODE_ENV !== "production") {
      var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  init_define_process();
  init_jquery();
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/flip.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  init_define_process();
  init_jquery();
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  init_define_process();
  init_jquery();
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/detectOverflow.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  init_define_process();
  init_jquery();
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x4 = 0;
    var y6 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x4 = visualViewport.offsetLeft;
        y6 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x4 + getWindowScrollBarX(element),
      y: y6
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  init_define_process();
  init_jquery();
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x4 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y6 = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x4 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x: x4,
      y: y6
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  init_define_process();
  init_jquery();
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  init_define_process();
  init_jquery();
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeOffsets.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getVariation.js
  init_define_process();
  init_jquery();
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start3:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var referenceElement = state.elements.reference;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(referenceElement);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset3 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset3[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  init_define_process();
  init_jquery();
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements3 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements3.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements3;
      if (define_process_default.env.NODE_ENV !== "production") {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a5, b5) {
      return overflows[a5] - overflows[b5];
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name2 = _ref.name;
    if (state.modifiersData[name2]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements3 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements3[0];
    for (var i3 = 0; i3 < placements3.length; i3++) {
      var placement = placements3[i3];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start3;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i3) {
        var fittingPlacement = placements3.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i3).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
        var _ret = _loop(_i2);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name2]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/hide.js
  init_define_process();
  init_jquery();
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name2 = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name2] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/offset.js
  init_define_process();
  init_jquery();
  function distanceAndSkiddingToXY(placement, rects, offset3) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
      placement
    })) : offset3, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
    var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x4 = _data$state$placement.x, y6 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x4;
      state.modifiersData.popperOffsets.y += y6;
    }
    state.modifiersData[name2] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  init_define_process();
  init_jquery();
  function popperOffsets(_ref) {
    var state = _ref.state, name2 = _ref.name;
    state.modifiersData[name2] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getAltAxis.js
  init_define_process();
  init_jquery();
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name2 = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis || checkAltAxis) {
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset3 = popperOffsets2[mainAxis];
      var min3 = popperOffsets2[mainAxis] + overflow[mainSide];
      var max3 = popperOffsets2[mainAxis] - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start3 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start3 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
      var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
      if (checkMainAxis) {
        var preventedOffset = within(tether ? min(min3, tetherMin) : min3, offset3, tether ? max(max3, tetherMax) : max3);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset3;
      }
      if (checkAltAxis) {
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
    }
    state.modifiersData[name2] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/createPopper.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  init_define_process();
  init_jquery();
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = rect.width / element.offsetWidth || 1;
    var scaleY = rect.height / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/orderModifiers.js
  init_define_process();
  init_jquery();
  function order(modifiers) {
    var map3 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map3.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map3.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/debounce.js
  init_define_process();
  init_jquery();
  function debounce3(fn3) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve2) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve2(fn3());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/validateModifiers.js
  init_define_process();
  init_jquery();

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/format.js
  init_define_process();
  init_jquery();
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p4, c4) {
      return p4.replace(/%s/, c4);
    }, str);
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      Object.keys(modifier).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (!Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s4) {
              return '"' + s4 + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/uniqueBy.js
  init_define_process();
  init_jquery();
  function uniqueBy(arr, fn3) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn3(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergeByName.js
  init_define_process();
  init_jquery();
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS2 = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions3 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS2 : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions3;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS2, defaultOptions3),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(options2) {
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions3, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m4) {
            return m4.enabled;
          });
          if (define_process_default.env.NODE_ENV !== "production") {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name2 = _ref.name;
              return name2;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name2 = _ref2.name;
                return name2 === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (define_process_default.env.NODE_ENV !== "production") {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
            if (define_process_default.env.NODE_ENV !== "production") {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index2 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
            if (typeof fn3 === "function") {
              state = fn3({
                state,
                options: _options,
                name: name2,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce3(function() {
          return new Promise(function(resolve2) {
            instance.forceUpdate();
            resolve2(state);
          });
        }),
        destroy: function destroy2() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (define_process_default.env.NODE_ENV !== "production") {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect5 = _ref3.effect;
          if (typeof effect5 === "function") {
            var cleanupFn = effect5({
              state,
              name: name2,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn3) {
          return fn3();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // node_modules/tippy.js/node_modules/@popperjs/core/lib/popper.js
  init_define_process();
  init_jquery();
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/tippy.js/dist/tippy.esm.js
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  function hasOwnProperty(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getValueAtIndexOrReturn(value, index2, defaultValue) {
    if (Array.isArray(value)) {
      var v4 = value[index2];
      return v4 == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v4;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce4(fn3, ms) {
    if (ms === 0) {
      return fn3;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn3(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys) {
    var clone2 = Object.assign({}, obj);
    keys.forEach(function(key) {
      delete clone2[key];
    });
    return clone2;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index2) {
      return arr.indexOf(item) === index2;
    });
  }
  function getBasePlacement2(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
      if (obj[key] !== void 0) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement2(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement2(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return (element == null ? void 0 : (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body) ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event2) {
    var clientX = event2.clientX, clientY = event2.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement2(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event2) {
      box[method](event2, listener);
    });
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now3 = performance.now();
    if (now3 - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now3;
  }
  function onWindowBlur() {
    var activeElement2 = document.activeElement;
    if (isReferenceElement(activeElement2)) {
      var instance = activeElement2._tippy;
      if (activeElement2.blur && !instance.state.isVisible) {
        activeElement2.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var ua = isBrowser ? navigator.userAgent : "";
  var isIE = /MSIE |Trident\//.test(ua);
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      // title
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      // message
      "line-height: 1.5",
      // footer
      "color: #a6a095;"
    ];
  }
  var visitedMessages;
  if (define_process_default.env.NODE_ENV !== "production") {
    resetVisitedMessages();
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: function appendTo() {
      return document.body;
    },
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {
    },
    onBeforeUpdate: function onBeforeUpdate() {
    },
    onCreate: function onCreate() {
    },
    onDestroy: function onDestroy() {
    },
    onHidden: function onHidden() {
    },
    onHide: function onHide() {
    },
    onMount: function onMount() {
    },
    onShow: function onShow() {
    },
    onShown: function onShown() {
    },
    onTrigger: function onTrigger() {
    },
    onUntrigger: function onUntrigger() {
    },
    onClickOutside: function onClickOutside() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, pluginProps, {}, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps2(partialProps) {
    if (define_process_default.env.NODE_ENV !== "production") {
      validateProps(partialProps, []);
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins2 = passedProps.plugins || [];
    var pluginProps2 = plugins2.reduce(function(acc, plugin) {
      var name2 = plugin.name, defaultValue = plugin.defaultValue;
      if (name2) {
        acc[name2] = passedProps[name2] !== void 0 ? passedProps[name2] : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, {}, pluginProps2);
  }
  function getDataAttributeProps(reference2, plugins2) {
    var propKeys = plugins2 ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins: plugins2
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
      var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e2) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference2, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference2])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins2) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins2 === void 0) {
      plugins2 = [];
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins2.filter(function(plugin) {
          return plugin.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var innerHTML = function innerHTML2() {
    return "innerHTML";
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow3 = div();
    if (value === true) {
      arrow3.className = ARROW_CLASS;
    } else {
      arrow3.className = SVG_ARROW_CLASS;
      if (isElement2(value)) {
        arrow3.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow3, value);
      }
    }
    return arrow3;
  }
  function setContent(content, props) {
    if (isElement2(props.content)) {
      dangerouslySetInnerHTML(content, "");
      content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper2) {
    var box = popper2.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper2 = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent(content, instance.props);
    popper2.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content2, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow3) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow3);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow3) {
        box2.removeChild(arrow3);
      }
    }
    return {
      popper: popper2,
      onUpdate
    };
  }
  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = [];
  var mountedInstances = [];
  function createTippy(reference2, passedProps) {
    var props = evaluateProps(reference2, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce4(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id = idCounter++;
    var popperInstance = null;
    var plugins2 = unique(props.plugins);
    var state = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id,
      reference: reference2,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins: plugins2,
      // methods
      clearDelayTimeouts,
      setProps,
      setContent: setContent2,
      show,
      hide: hide3,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy: destroy2
    };
    if (!props.render) {
      if (define_process_default.env.NODE_ENV !== "production") {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper2.setAttribute("data-tippy-root", "");
    popper2.id = "tippy-" + instance.id;
    instance.popper = popper2;
    reference2._tippy = instance;
    popper2._tippy = instance;
    var pluginsHooks = plugins2.map(function(plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper2.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper2.addEventListener("mouseleave", function(event2) {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
        debouncedOnMouseMove(event2);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference2;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper2);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles() {
      popper2.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? "" : "none";
      popper2.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(void 0, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id2 = popper2.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
        } else {
          var nextValue = currentValue && currentValue.replace(id2, "").trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        if (instance.props.interactive) {
          node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
        } else {
          node.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event2) {
      if (currentInput.isTouch) {
        if (didTouchMove || event2.type === "mousedown") {
          return;
        }
      }
      if (instance.props.interactive && popper2.contains(event2.target)) {
        return;
      }
      if (getCurrentTarget().contains(event2.target)) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event2]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc2 = getDocument();
      doc2.addEventListener("mousedown", onDocumentPress, true);
      doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc2 = getDocument();
      doc2.removeEventListener("mousedown", onDocumentPress, true);
      doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback2) {
      onTransitionEnd(duration, function() {
        if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
          callback2();
        }
      });
    }
    function onTransitionedIn(duration, callback2) {
      onTransitionEnd(duration, callback2);
    }
    function onTransitionEnd(duration, callback2) {
      var box = getDefaultTemplateChildren().box;
      function listener(event2) {
        if (event2.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback2();
        }
      }
      if (duration === 0) {
        return callback2();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on2(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node,
          eventType,
          handler,
          options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on2("touchstart", onTrigger2, {
          passive: true
        });
        on2("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on2(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on2("mouseleave", onMouseLeave);
            break;
          case "focus":
            on2(isIE ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on2("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger2(event2) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event2) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event2;
      currentTarget = event2.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event2)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event2);
        });
      }
      if (event2.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event2);
      }
      if (event2.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event2);
      }
    }
    function onMouseMove(event2) {
      var target = event2.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
      if (event2.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
        var _instance$popperInsta;
        var instance2 = popper3._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper3.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event2)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event2);
      }
    }
    function onMouseLeave(event2) {
      var shouldBail = isEventListenerStopped(event2) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event2);
        return;
      }
      scheduleHide(event2);
    }
    function onBlurOrFocusOut(event2) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event2.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event2.relatedTarget && popper2.contains(event2.relatedTarget)) {
        return;
      }
      scheduleHide(event2);
    }
    function isEventListenerStopped(event2) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event2.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset3 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow3 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference2;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn3(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers = [{
        name: "offset",
        options: {
          offset: offset3
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow3) {
        modifiers.push({
          name: "arrow",
          options: {
            element: arrow3,
            padding: 3
          }
        });
      }
      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo2 = instance.props.appendTo;
      var parentNode;
      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo2 === defaultProps.appendTo || appendTo2 === "parent") {
        parentNode = node.parentNode;
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo2, [node]);
      }
      if (!parentNode.contains(popper2)) {
        parentNode.appendChild(popper2);
      }
      createPopperInstance();
      if (define_process_default.env.NODE_ENV !== "production") {
        warnWhen(instance.props.interactive && appendTo2 === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event2) {
      instance.clearDelayTimeouts();
      if (event2) {
        invokeHook("onTrigger", [instance, event2]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event2) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event2]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event2.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (define_process_default.env.NODE_ENV !== "production") {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference2, Object.assign({}, instance.props, {}, partialProps, {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce4(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
          node.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference2.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent2(content) {
      instance.setProps({
        content
      });
    }
    function show() {
      if (define_process_default.env.NODE_ENV !== "production") {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper2.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper2.offsetHeight;
        popper2.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        instance.state.isMounted = true;
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount();
    }
    function hide3() {
      if (define_process_default.env.NODE_ENV !== "production") {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles();
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event2) {
      if (define_process_default.env.NODE_ENV !== "production") {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event2);
    }
    function unmount() {
      if (define_process_default.env.NODE_ENV !== "production") {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper2.parentNode) {
        popper2.parentNode.removeChild(popper2);
      }
      mountedInstances = mountedInstances.filter(function(i3) {
        return i3 !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy2() {
      if (define_process_default.env.NODE_ENV !== "production") {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference2._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins2 = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (define_process_default.env.NODE_ENV !== "production") {
      validateTargets(targets);
      validateProps(optionalProps, plugins2);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins: plugins2
    });
    var elements2 = getArrayOfElements(targets);
    if (define_process_default.env.NODE_ENV !== "production") {
      var isSingleContentElement = isElement2(passedProps.content);
      var isMoreThanOneReferenceElement = elements2.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances2 = elements2.reduce(function(acc, reference2) {
      var instance = reference2 && createTippy(reference2, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement2(targets) ? instances2[0] : instances2;
  }
  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;
  var applyStylesModifier = Object.assign({}, applyStyles_default, {
    effect: function effect4(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
    }
  });
  tippy.setDefaultProps({
    render
  });
  var tippy_esm_default = tippy;

  // app/javascript/i18n-js/config.js
  init_define_process();
  init_jquery();

  // node_modules/i18next/dist/esm/i18next.js
  init_define_process();
  init_jquery();

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  init_define_process();
  init_jquery();
  function _typeof(o3) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
      return typeof o4;
    } : function(o4) {
      return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
    }, _typeof(o3);
  }

  // node_modules/@babel/runtime/helpers/esm/objectSpread.js
  init_define_process();
  init_jquery();

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  init_define_process();
  init_jquery();

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  init_define_process();
  init_jquery();

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  init_define_process();
  init_jquery();
  function toPrimitive(t4, r3) {
    if ("object" != _typeof(t4) || !t4) return t4;
    var e2 = t4[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i3 = e2.call(t4, r3 || "default");
      if ("object" != _typeof(i3)) return i3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r3 ? String : Number)(t4);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function toPropertyKey(t4) {
    var i3 = toPrimitive(t4, "string");
    return "symbol" == _typeof(i3) ? i3 : i3 + "";
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(e2, r3, t4) {
    return (r3 = toPropertyKey(r3)) in e2 ? Object.defineProperty(e2, r3, {
      value: t4,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e2[r3] = t4, e2;
  }

  // node_modules/@babel/runtime/helpers/esm/objectSpread.js
  function _objectSpread(e2) {
    for (var r3 = 1; r3 < arguments.length; r3++) {
      var t4 = null != arguments[r3] ? Object(arguments[r3]) : {}, o3 = Object.keys(t4);
      "function" == typeof Object.getOwnPropertySymbols && o3.push.apply(o3, Object.getOwnPropertySymbols(t4).filter(function(e3) {
        return Object.getOwnPropertyDescriptor(t4, e3).enumerable;
      })), o3.forEach(function(r4) {
        _defineProperty(e2, r4, t4[r4]);
      });
    }
    return e2;
  }

  // node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  init_define_process();
  init_jquery();
  function _classCallCheck(a5, n3) {
    if (!(a5 instanceof n3)) throw new TypeError("Cannot call a class as a function");
  }

  // node_modules/@babel/runtime/helpers/esm/createClass.js
  init_define_process();
  init_jquery();
  function _defineProperties(e2, r3) {
    for (var t4 = 0; t4 < r3.length; t4++) {
      var o3 = r3[t4];
      o3.enumerable = o3.enumerable || false, o3.configurable = true, "value" in o3 && (o3.writable = true), Object.defineProperty(e2, toPropertyKey(o3.key), o3);
    }
  }
  function _createClass(e2, r3, t4) {
    return r3 && _defineProperties(e2.prototype, r3), t4 && _defineProperties(e2, t4), Object.defineProperty(e2, "prototype", {
      writable: false
    }), e2;
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  init_define_process();
  init_jquery();

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  init_define_process();
  init_jquery();
  function _assertThisInitialized(e2) {
    if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e2;
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  function _possibleConstructorReturn(t4, e2) {
    if (e2 && ("object" == _typeof(e2) || "function" == typeof e2)) return e2;
    if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t4);
  }

  // node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
  init_define_process();
  init_jquery();
  function _getPrototypeOf(t4) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
      return t5.__proto__ || Object.getPrototypeOf(t5);
    }, _getPrototypeOf(t4);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  init_define_process();
  init_jquery();

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  init_define_process();
  init_jquery();
  function _setPrototypeOf(t4, e2) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e3) {
      return t5.__proto__ = e3, t5;
    }, _setPrototypeOf(t4, e2);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  function _inherits(t4, e2) {
    if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
    t4.prototype = Object.create(e2 && e2.prototype, {
      constructor: {
        value: t4,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t4, "prototype", {
      writable: false
    }), e2 && _setPrototypeOf(t4, e2);
  }

  // node_modules/i18next/dist/esm/i18next.js
  var consoleLogger = {
    type: "logger",
    log: function log(args) {
      this.output("log", args);
    },
    warn: function warn(args) {
      this.output("warn", args);
    },
    error: function error2(args) {
      this.output("error", args);
    },
    output: function output(type, args) {
      if (console && console[type]) console[type].apply(console, args);
    }
  };
  var Logger2 = function() {
    function Logger3(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Logger3);
      this.init(concreteLogger, options);
    }
    _createClass(Logger3, [{
      key: "init",
      value: function init2(concreteLogger) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.prefix = options.prefix || "i18next:";
        this.logger = concreteLogger || consoleLogger;
        this.options = options;
        this.debug = options.debug;
      }
    }, {
      key: "setDebug",
      value: function setDebug(bool) {
        this.debug = bool;
      }
    }, {
      key: "log",
      value: function log2() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return this.forward(args, "log", "", true);
      }
    }, {
      key: "warn",
      value: function warn2() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this.forward(args, "warn", "", true);
      }
    }, {
      key: "error",
      value: function error3() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return this.forward(args, "error", "");
      }
    }, {
      key: "deprecate",
      value: function deprecate() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
      }
    }, {
      key: "forward",
      value: function forward(args, lvl, prefix2, debugOnly) {
        if (debugOnly && !this.debug) return null;
        if (typeof args[0] === "string") args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
        return this.logger[lvl](args);
      }
    }, {
      key: "create",
      value: function create(moduleName) {
        return new Logger3(this.logger, _objectSpread({}, {
          prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
        }, this.options));
      }
    }]);
    return Logger3;
  }();
  var baseLogger = new Logger2();
  var EventEmitter = function() {
    function EventEmitter2() {
      _classCallCheck(this, EventEmitter2);
      this.observers = {};
    }
    _createClass(EventEmitter2, [{
      key: "on",
      value: function on2(events, listener) {
        var _this = this;
        events.split(" ").forEach(function(event2) {
          _this.observers[event2] = _this.observers[event2] || [];
          _this.observers[event2].push(listener);
        });
        return this;
      }
    }, {
      key: "off",
      value: function off(event2, listener) {
        if (!this.observers[event2]) return;
        if (!listener) {
          delete this.observers[event2];
          return;
        }
        this.observers[event2] = this.observers[event2].filter(function(l5) {
          return l5 !== listener;
        });
      }
    }, {
      key: "emit",
      value: function emit(event2) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        if (this.observers[event2]) {
          var cloned = [].concat(this.observers[event2]);
          cloned.forEach(function(observer) {
            observer.apply(void 0, args);
          });
        }
        if (this.observers["*"]) {
          var _cloned = [].concat(this.observers["*"]);
          _cloned.forEach(function(observer) {
            observer.apply(observer, [event2].concat(args));
          });
        }
      }
    }]);
    return EventEmitter2;
  }();
  function defer() {
    var res;
    var rej;
    var promise = new Promise(function(resolve2, reject) {
      res = resolve2;
      rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
  }
  function makeString(object) {
    if (object == null) return "";
    return "" + object;
  }
  function copy2(a5, s4, t4) {
    a5.forEach(function(m4) {
      if (s4[m4]) t4[m4] = s4[m4];
    });
  }
  function getLastOfPath(object, path, Empty) {
    function cleanKey(key2) {
      return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
    }
    function canNotTraverseDeeper() {
      return !object || typeof object === "string";
    }
    var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
    while (stack.length > 1) {
      if (canNotTraverseDeeper()) return {};
      var key = cleanKey(stack.shift());
      if (!object[key] && Empty) object[key] = new Empty();
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        object = object[key];
      } else {
        object = {};
      }
    }
    if (canNotTraverseDeeper()) return {};
    return {
      obj: object,
      k: cleanKey(stack.shift())
    };
  }
  function setPath(object, path, newValue) {
    var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k4 = _getLastOfPath.k;
    obj[k4] = newValue;
  }
  function pushPath(object, path, newValue, concat) {
    var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k4 = _getLastOfPath2.k;
    obj[k4] = obj[k4] || [];
    if (concat) obj[k4] = obj[k4].concat(newValue);
    if (!concat) obj[k4].push(newValue);
  }
  function getPath(object, path) {
    var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k4 = _getLastOfPath3.k;
    if (!obj) return void 0;
    return obj[k4];
  }
  function getPathWithDefaults(data, defaultData, key) {
    var value = getPath(data, key);
    if (value !== void 0) {
      return value;
    }
    return getPath(defaultData, key);
  }
  function deepExtend(target, source, overwrite) {
    for (var prop in source) {
      if (prop !== "__proto__" && prop !== "constructor") {
        if (prop in target) {
          if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
            if (overwrite) target[prop] = source[prop];
          } else {
            deepExtend(target[prop], source[prop], overwrite);
          }
        } else {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }
  function regexEscape(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }
  var _entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
  };
  function escape2(data) {
    if (typeof data === "string") {
      return data.replace(/[&<>"'\/]/g, function(s4) {
        return _entityMap[s4];
      });
    }
    return data;
  }
  var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
  var ResourceStore = function(_EventEmitter) {
    _inherits(ResourceStore2, _EventEmitter);
    function ResourceStore2(data) {
      var _this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        ns: ["translation"],
        defaultNS: "translation"
      };
      _classCallCheck(this, ResourceStore2);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore2).call(this));
      if (isIE10) {
        EventEmitter.call(_assertThisInitialized(_this));
      }
      _this.data = data || {};
      _this.options = options;
      if (_this.options.keySeparator === void 0) {
        _this.options.keySeparator = ".";
      }
      return _this;
    }
    _createClass(ResourceStore2, [{
      key: "addNamespaces",
      value: function addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
          this.options.ns.push(ns);
        }
      }
    }, {
      key: "removeNamespaces",
      value: function removeNamespaces(ns) {
        var index2 = this.options.ns.indexOf(ns);
        if (index2 > -1) {
          this.options.ns.splice(index2, 1);
        }
      }
    }, {
      key: "getResource",
      value: function getResource(lng, ns, key) {
        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        var path = [lng, ns];
        if (key && typeof key !== "string") path = path.concat(key);
        if (key && typeof key === "string") path = path.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf(".") > -1) {
          path = lng.split(".");
        }
        return getPath(this.data, path);
      }
    }, {
      key: "addResource",
      value: function addResource(lng, ns, key, value) {
        var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
          silent: false
        };
        var keySeparator = this.options.keySeparator;
        if (keySeparator === void 0) keySeparator = ".";
        var path = [lng, ns];
        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
        if (lng.indexOf(".") > -1) {
          path = lng.split(".");
          value = ns;
          ns = path[1];
        }
        this.addNamespaces(ns);
        setPath(this.data, path, value);
        if (!options.silent) this.emit("added", lng, ns, key, value);
      }
    }, {
      key: "addResources",
      value: function addResources(lng, ns, resources) {
        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
          silent: false
        };
        for (var m4 in resources) {
          if (typeof resources[m4] === "string" || Object.prototype.toString.apply(resources[m4]) === "[object Array]") this.addResource(lng, ns, m4, resources[m4], {
            silent: true
          });
        }
        if (!options.silent) this.emit("added", lng, ns, resources);
      }
    }, {
      key: "addResourceBundle",
      value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
        var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
          silent: false
        };
        var path = [lng, ns];
        if (lng.indexOf(".") > -1) {
          path = lng.split(".");
          deep = resources;
          resources = ns;
          ns = path[1];
        }
        this.addNamespaces(ns);
        var pack = getPath(this.data, path) || {};
        if (deep) {
          deepExtend(pack, resources, overwrite);
        } else {
          pack = _objectSpread({}, pack, resources);
        }
        setPath(this.data, path, pack);
        if (!options.silent) this.emit("added", lng, ns, resources);
      }
    }, {
      key: "removeResourceBundle",
      value: function removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
          delete this.data[lng][ns];
        }
        this.removeNamespaces(ns);
        this.emit("removed", lng, ns);
      }
    }, {
      key: "hasResourceBundle",
      value: function hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== void 0;
      }
    }, {
      key: "getResourceBundle",
      value: function getResourceBundle(lng, ns) {
        if (!ns) ns = this.options.defaultNS;
        if (this.options.compatibilityAPI === "v1") return _objectSpread({}, {}, this.getResource(lng, ns));
        return this.getResource(lng, ns);
      }
    }, {
      key: "getDataByLanguage",
      value: function getDataByLanguage(lng) {
        return this.data[lng];
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.data;
      }
    }]);
    return ResourceStore2;
  }(EventEmitter);
  var postProcessor = {
    processors: {},
    addPostProcessor: function addPostProcessor(module2) {
      this.processors[module2.name] = module2;
    },
    handle: function handle(processors, value, key, options, translator) {
      var _this = this;
      processors.forEach(function(processor) {
        if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
      });
      return value;
    }
  };
  var checkedLoadedFor = {};
  var Translator = function(_EventEmitter) {
    _inherits(Translator2, _EventEmitter);
    function Translator2(services) {
      var _this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, Translator2);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator2).call(this));
      if (isIE10) {
        EventEmitter.call(_assertThisInitialized(_this));
      }
      copy2(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
      _this.options = options;
      if (_this.options.keySeparator === void 0) {
        _this.options.keySeparator = ".";
      }
      _this.logger = baseLogger.create("translator");
      return _this;
    }
    _createClass(Translator2, [{
      key: "changeLanguage",
      value: function changeLanguage(lng) {
        if (lng) this.language = lng;
      }
    }, {
      key: "exists",
      value: function exists(key) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
        };
        var resolved = this.resolve(key, options);
        return resolved && resolved.res !== void 0;
      }
    }, {
      key: "extractFromKey",
      value: function extractFromKey(key, options) {
        var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === void 0) nsSeparator = ":";
        var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        var namespaces = options.ns || this.options.defaultNS;
        if (nsSeparator && key.indexOf(nsSeparator) > -1) {
          var m4 = key.match(this.interpolator.nestingRegexp);
          if (m4 && m4.length > 0) {
            return {
              key,
              namespaces
            };
          }
          var parts = key.split(nsSeparator);
          if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
          key = parts.join(keySeparator);
        }
        if (typeof namespaces === "string") namespaces = [namespaces];
        return {
          key,
          namespaces
        };
      }
    }, {
      key: "translate",
      value: function translate(keys, options, lastKey) {
        var _this2 = this;
        if (_typeof(options) !== "object" && this.options.overloadTranslationOptionHandler) {
          options = this.options.overloadTranslationOptionHandler(arguments);
        }
        if (!options) options = {};
        if (keys === void 0 || keys === null) return "";
        if (!Array.isArray(keys)) keys = [String(keys)];
        var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
        var namespace = namespaces[namespaces.length - 1];
        var lng = options.lng || this.language;
        var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (lng && lng.toLowerCase() === "cimode") {
          if (appendNamespaceToCIMode) {
            var nsSeparator = options.nsSeparator || this.options.nsSeparator;
            return namespace + nsSeparator + key;
          }
          return key;
        }
        var resolved = this.resolve(keys, options);
        var res = resolved && resolved.res;
        var resUsedKey = resolved && resolved.usedKey || key;
        var resExactUsedKey = resolved && resolved.exactUsedKey || key;
        var resType = Object.prototype.toString.apply(res);
        var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
        var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
        var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
          if (!options.returnObjects && !this.options.returnObjects) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
            return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          }
          if (keySeparator) {
            var resTypeIsArray = resType === "[object Array]";
            var copy3 = resTypeIsArray ? [] : {};
            var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
            for (var m4 in res) {
              if (Object.prototype.hasOwnProperty.call(res, m4)) {
                var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m4);
                copy3[m4] = this.translate(deepKey, _objectSpread({}, options, {
                  joinArrays: false,
                  ns: namespaces
                }));
                if (copy3[m4] === deepKey) copy3[m4] = res[m4];
              }
            }
            res = copy3;
          }
        } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
          res = res.join(joinArrays);
          if (res) res = this.extendTranslation(res, keys, options, lastKey);
        } else {
          var usedDefault = false;
          var usedKey = false;
          var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
          var hasDefaultValue = Translator2.hasDefaultValue(options);
          var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count) : "";
          var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
          if (!this.isValidLookup(res) && hasDefaultValue) {
            usedDefault = true;
            res = defaultValue;
          }
          if (!this.isValidLookup(res)) {
            usedKey = true;
            res = key;
          }
          var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
          if (usedKey || usedDefault || updateMissing) {
            this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
            if (keySeparator) {
              var fk = this.resolve(key, _objectSpread({}, options, {
                keySeparator: false
              }));
              if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
            }
            var lngs = [];
            var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
            if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
              for (var i3 = 0; i3 < fallbackLngs.length; i3++) {
                lngs.push(fallbackLngs[i3]);
              }
            } else if (this.options.saveMissingTo === "all") {
              lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
            } else {
              lngs.push(options.lng || this.language);
            }
            var send = function send2(l5, k4, fallbackValue) {
              if (_this2.options.missingKeyHandler) {
                _this2.options.missingKeyHandler(l5, namespace, k4, updateMissing ? fallbackValue : res, updateMissing, options);
              } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
                _this2.backendConnector.saveMissing(l5, namespace, k4, updateMissing ? fallbackValue : res, updateMissing, options);
              }
              _this2.emit("missingKey", l5, namespace, k4, res);
            };
            if (this.options.saveMissing) {
              if (this.options.saveMissingPlurals && needsPluralHandling) {
                lngs.forEach(function(language) {
                  _this2.pluralResolver.getSuffixes(language).forEach(function(suffix) {
                    send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                  });
                });
              } else {
                send(lngs, key, defaultValue);
              }
            }
          }
          res = this.extendTranslation(res, keys, options, resolved, lastKey);
          if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
          if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
        }
        return res;
      }
    }, {
      key: "extendTranslation",
      value: function extendTranslation(res, key, options, resolved, lastKey) {
        var _this3 = this;
        if (this.i18nFormat && this.i18nFormat.parse) {
          res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
            resolved
          });
        } else if (!options.skipInterpolation) {
          if (options.interpolation) this.interpolator.init(_objectSpread({}, options, {
            interpolation: _objectSpread({}, this.options.interpolation, options.interpolation)
          }));
          var skipOnVariables = options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
          var nestBef;
          if (skipOnVariables) {
            var nb = res.match(this.interpolator.nestingRegexp);
            nestBef = nb && nb.length;
          }
          var data = options.replace && typeof options.replace !== "string" ? options.replace : options;
          if (this.options.interpolation.defaultVariables) data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
          res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
          if (skipOnVariables) {
            var na = res.match(this.interpolator.nestingRegexp);
            var nestAft = na && na.length;
            if (nestBef < nestAft) options.nest = false;
          }
          if (options.nest !== false) res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
          if (options.interpolation) this.interpolator.reset();
        }
        var postProcess = options.postProcess || this.options.postProcess;
        var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
        if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
          res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
            i18nResolved: resolved
          }, options) : options, this);
        }
        return res;
      }
    }, {
      key: "resolve",
      value: function resolve2(keys) {
        var _this4 = this;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var found;
        var usedKey;
        var exactUsedKey;
        var usedLng;
        var usedNS;
        if (typeof keys === "string") keys = [keys];
        keys.forEach(function(k4) {
          if (_this4.isValidLookup(found)) return;
          var extracted = _this4.extractFromKey(k4, options);
          var key = extracted.key;
          usedKey = key;
          var namespaces = extracted.namespaces;
          if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
          var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
          var needsContextHandling = options.context !== void 0 && typeof options.context === "string" && options.context !== "";
          var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
          namespaces.forEach(function(ns) {
            if (_this4.isValidLookup(found)) return;
            usedNS = ns;
            if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
              checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
              _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            }
            codes.forEach(function(code) {
              if (_this4.isValidLookup(found)) return;
              usedLng = code;
              var finalKey = key;
              var finalKeys = [finalKey];
              if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
                _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
              } else {
                var pluralSuffix;
                if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count);
                if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);
                if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context));
                if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
              }
              var possibleKey;
              while (possibleKey = finalKeys.pop()) {
                if (!_this4.isValidLookup(found)) {
                  exactUsedKey = possibleKey;
                  found = _this4.getResource(code, ns, possibleKey, options);
                }
              }
            });
          });
        });
        return {
          res: found,
          usedKey,
          exactUsedKey,
          usedLng,
          usedNS
        };
      }
    }, {
      key: "isValidLookup",
      value: function isValidLookup(res) {
        return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
      }
    }, {
      key: "getResource",
      value: function getResource(code, ns, key) {
        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
        return this.resourceStore.getResource(code, ns, key, options);
      }
    }], [{
      key: "hasDefaultValue",
      value: function hasDefaultValue(options) {
        var prefix2 = "defaultValue";
        for (var option in options) {
          if (Object.prototype.hasOwnProperty.call(options, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options[option]) {
            return true;
          }
        }
        return false;
      }
    }]);
    return Translator2;
  }(EventEmitter);
  function capitalize2(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  var LanguageUtil = function() {
    function LanguageUtil2(options) {
      _classCallCheck(this, LanguageUtil2);
      this.options = options;
      this.whitelist = this.options.supportedLngs || false;
      this.supportedLngs = this.options.supportedLngs || false;
      this.logger = baseLogger.create("languageUtils");
    }
    _createClass(LanguageUtil2, [{
      key: "getScriptPartFromCode",
      value: function getScriptPartFromCode(code) {
        if (!code || code.indexOf("-") < 0) return null;
        var p4 = code.split("-");
        if (p4.length === 2) return null;
        p4.pop();
        if (p4[p4.length - 1].toLowerCase() === "x") return null;
        return this.formatLanguageCode(p4.join("-"));
      }
    }, {
      key: "getLanguagePartFromCode",
      value: function getLanguagePartFromCode(code) {
        if (!code || code.indexOf("-") < 0) return code;
        var p4 = code.split("-");
        return this.formatLanguageCode(p4[0]);
      }
    }, {
      key: "formatLanguageCode",
      value: function formatLanguageCode(code) {
        if (typeof code === "string" && code.indexOf("-") > -1) {
          var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
          var p4 = code.split("-");
          if (this.options.lowerCaseLng) {
            p4 = p4.map(function(part) {
              return part.toLowerCase();
            });
          } else if (p4.length === 2) {
            p4[0] = p4[0].toLowerCase();
            p4[1] = p4[1].toUpperCase();
            if (specialCases.indexOf(p4[1].toLowerCase()) > -1) p4[1] = capitalize2(p4[1].toLowerCase());
          } else if (p4.length === 3) {
            p4[0] = p4[0].toLowerCase();
            if (p4[1].length === 2) p4[1] = p4[1].toUpperCase();
            if (p4[0] !== "sgn" && p4[2].length === 2) p4[2] = p4[2].toUpperCase();
            if (specialCases.indexOf(p4[1].toLowerCase()) > -1) p4[1] = capitalize2(p4[1].toLowerCase());
            if (specialCases.indexOf(p4[2].toLowerCase()) > -1) p4[2] = capitalize2(p4[2].toLowerCase());
          }
          return p4.join("-");
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
      }
    }, {
      key: "isWhitelisted",
      value: function isWhitelisted(code) {
        this.logger.deprecate("languageUtils.isWhitelisted", `function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it's usage asap.`);
        return this.isSupportedCode(code);
      }
    }, {
      key: "isSupportedCode",
      value: function isSupportedCode(code) {
        if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
          code = this.getLanguagePartFromCode(code);
        }
        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
      }
    }, {
      key: "getBestMatchFromCodes",
      value: function getBestMatchFromCodes(codes) {
        var _this = this;
        if (!codes) return null;
        var found;
        codes.forEach(function(code) {
          if (found) return;
          var cleanedLng = _this.formatLanguageCode(code);
          if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
        });
        if (!found && this.options.supportedLngs) {
          codes.forEach(function(code) {
            if (found) return;
            var lngOnly = _this.getLanguagePartFromCode(code);
            if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
            found = _this.options.supportedLngs.find(function(supportedLng) {
              if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
            });
          });
        }
        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
        return found;
      }
    }, {
      key: "getFallbackCodes",
      value: function getFallbackCodes(fallbacks, code) {
        if (!fallbacks) return [];
        if (typeof fallbacks === "function") fallbacks = fallbacks(code);
        if (typeof fallbacks === "string") fallbacks = [fallbacks];
        if (Object.prototype.toString.apply(fallbacks) === "[object Array]") return fallbacks;
        if (!code) return fallbacks["default"] || [];
        var found = fallbacks[code];
        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found) found = fallbacks[this.formatLanguageCode(code)];
        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
        if (!found) found = fallbacks["default"];
        return found || [];
      }
    }, {
      key: "toResolveHierarchy",
      value: function toResolveHierarchy(code, fallbackCode) {
        var _this2 = this;
        var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
        var codes = [];
        var addCode = function addCode2(c4) {
          if (!c4) return;
          if (_this2.isSupportedCode(c4)) {
            codes.push(c4);
          } else {
            _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c4));
          }
        };
        if (typeof code === "string" && code.indexOf("-") > -1) {
          if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
          if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
          if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
        } else if (typeof code === "string") {
          addCode(this.formatLanguageCode(code));
        }
        fallbackCodes.forEach(function(fc) {
          if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
        });
        return codes;
      }
    }]);
    return LanguageUtil2;
  }();
  var sets = [{
    lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
    nr: [1, 2],
    fc: 1
  }, {
    lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
    nr: [1, 2],
    fc: 2
  }, {
    lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
    nr: [1],
    fc: 3
  }, {
    lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
    nr: [1, 2, 5],
    fc: 4
  }, {
    lngs: ["ar"],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
  }, {
    lngs: ["cs", "sk"],
    nr: [1, 2, 5],
    fc: 6
  }, {
    lngs: ["csb", "pl"],
    nr: [1, 2, 5],
    fc: 7
  }, {
    lngs: ["cy"],
    nr: [1, 2, 3, 8],
    fc: 8
  }, {
    lngs: ["fr"],
    nr: [1, 2],
    fc: 9
  }, {
    lngs: ["ga"],
    nr: [1, 2, 3, 7, 11],
    fc: 10
  }, {
    lngs: ["gd"],
    nr: [1, 2, 3, 20],
    fc: 11
  }, {
    lngs: ["is"],
    nr: [1, 2],
    fc: 12
  }, {
    lngs: ["jv"],
    nr: [0, 1],
    fc: 13
  }, {
    lngs: ["kw"],
    nr: [1, 2, 3, 4],
    fc: 14
  }, {
    lngs: ["lt"],
    nr: [1, 2, 10],
    fc: 15
  }, {
    lngs: ["lv"],
    nr: [1, 2, 0],
    fc: 16
  }, {
    lngs: ["mk"],
    nr: [1, 2],
    fc: 17
  }, {
    lngs: ["mnk"],
    nr: [0, 1, 2],
    fc: 18
  }, {
    lngs: ["mt"],
    nr: [1, 2, 11, 20],
    fc: 19
  }, {
    lngs: ["or"],
    nr: [2, 1],
    fc: 2
  }, {
    lngs: ["ro"],
    nr: [1, 2, 20],
    fc: 20
  }, {
    lngs: ["sl"],
    nr: [5, 1, 2, 3],
    fc: 21
  }, {
    lngs: ["he", "iw"],
    nr: [1, 2, 20, 21],
    fc: 22
  }];
  var _rulesPluralsTypes = {
    1: function _(n3) {
      return Number(n3 > 1);
    },
    2: function _2(n3) {
      return Number(n3 != 1);
    },
    3: function _3(n3) {
      return 0;
    },
    4: function _4(n3) {
      return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
    },
    5: function _5(n3) {
      return Number(n3 == 0 ? 0 : n3 == 1 ? 1 : n3 == 2 ? 2 : n3 % 100 >= 3 && n3 % 100 <= 10 ? 3 : n3 % 100 >= 11 ? 4 : 5);
    },
    6: function _6(n3) {
      return Number(n3 == 1 ? 0 : n3 >= 2 && n3 <= 4 ? 1 : 2);
    },
    7: function _7(n3) {
      return Number(n3 == 1 ? 0 : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
    },
    8: function _8(n3) {
      return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 != 8 && n3 != 11 ? 2 : 3);
    },
    9: function _9(n3) {
      return Number(n3 >= 2);
    },
    10: function _10(n3) {
      return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 < 7 ? 2 : n3 < 11 ? 3 : 4);
    },
    11: function _11(n3) {
      return Number(n3 == 1 || n3 == 11 ? 0 : n3 == 2 || n3 == 12 ? 1 : n3 > 2 && n3 < 20 ? 2 : 3);
    },
    12: function _12(n3) {
      return Number(n3 % 10 != 1 || n3 % 100 == 11);
    },
    13: function _13(n3) {
      return Number(n3 !== 0);
    },
    14: function _14(n3) {
      return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 == 3 ? 2 : 3);
    },
    15: function _15(n3) {
      return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 % 10 >= 2 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
    },
    16: function _16(n3) {
      return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 !== 0 ? 1 : 2);
    },
    17: function _17(n3) {
      return Number(n3 == 1 || n3 % 10 == 1 && n3 % 100 != 11 ? 0 : 1);
    },
    18: function _18(n3) {
      return Number(n3 == 0 ? 0 : n3 == 1 ? 1 : 2);
    },
    19: function _19(n3) {
      return Number(n3 == 1 ? 0 : n3 == 0 || n3 % 100 > 1 && n3 % 100 < 11 ? 1 : n3 % 100 > 10 && n3 % 100 < 20 ? 2 : 3);
    },
    20: function _20(n3) {
      return Number(n3 == 1 ? 0 : n3 == 0 || n3 % 100 > 0 && n3 % 100 < 20 ? 1 : 2);
    },
    21: function _21(n3) {
      return Number(n3 % 100 == 1 ? 1 : n3 % 100 == 2 ? 2 : n3 % 100 == 3 || n3 % 100 == 4 ? 3 : 0);
    },
    22: function _22(n3) {
      return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : (n3 < 0 || n3 > 10) && n3 % 10 == 0 ? 2 : 3);
    }
  };
  function createRules() {
    var rules = {};
    sets.forEach(function(set2) {
      set2.lngs.forEach(function(l5) {
        rules[l5] = {
          numbers: set2.nr,
          plurals: _rulesPluralsTypes[set2.fc]
        };
      });
    });
    return rules;
  }
  var PluralResolver = function() {
    function PluralResolver2(languageUtils) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck(this, PluralResolver2);
      this.languageUtils = languageUtils;
      this.options = options;
      this.logger = baseLogger.create("pluralResolver");
      this.rules = createRules();
    }
    _createClass(PluralResolver2, [{
      key: "addRule",
      value: function addRule(lng, obj) {
        this.rules[lng] = obj;
      }
    }, {
      key: "getRule",
      value: function getRule(code) {
        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
      }
    }, {
      key: "needsPlural",
      value: function needsPlural(code) {
        var rule = this.getRule(code);
        return rule && rule.numbers.length > 1;
      }
    }, {
      key: "getPluralFormsOfKey",
      value: function getPluralFormsOfKey(code, key) {
        return this.getSuffixes(code).map(function(suffix) {
          return key + suffix;
        });
      }
    }, {
      key: "getSuffixes",
      value: function getSuffixes(code) {
        var _this = this;
        var rule = this.getRule(code);
        if (!rule) {
          return [];
        }
        return rule.numbers.map(function(number) {
          return _this.getSuffix(code, number);
        });
      }
    }, {
      key: "getSuffix",
      value: function getSuffix(code, count) {
        var _this2 = this;
        var rule = this.getRule(code);
        if (rule) {
          var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
          var suffix = rule.numbers[idx];
          if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            if (suffix === 2) {
              suffix = "plural";
            } else if (suffix === 1) {
              suffix = "";
            }
          }
          var returnSuffix = function returnSuffix2() {
            return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
          };
          if (this.options.compatibilityJSON === "v1") {
            if (suffix === 1) return "";
            if (typeof suffix === "number") return "_plural_".concat(suffix.toString());
            return returnSuffix();
          } else if (this.options.compatibilityJSON === "v2") {
            return returnSuffix();
          } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
            return returnSuffix();
          }
          return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
        }
        this.logger.warn("no plural rule found for: ".concat(code));
        return "";
      }
    }]);
    return PluralResolver2;
  }();
  var Interpolator = function() {
    function Interpolator2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Interpolator2);
      this.logger = baseLogger.create("interpolator");
      this.options = options;
      this.format = options.interpolation && options.interpolation.format || function(value) {
        return value;
      };
      this.init(options);
    }
    _createClass(Interpolator2, [{
      key: "init",
      value: function init2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!options.interpolation) options.interpolation = {
          escapeValue: true
        };
        var iOpts = options.interpolation;
        this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape2;
        this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
        this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
        this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
        this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
        this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
        this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
        this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
        this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
        this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
        this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
        this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
        this.resetRegExp();
      }
    }, {
      key: "reset",
      value: function reset() {
        if (this.options) this.init(this.options);
      }
    }, {
      key: "resetRegExp",
      value: function resetRegExp() {
        var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
        this.regexp = new RegExp(regexpStr, "g");
        var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
        this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
        var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
        this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
      }
    }, {
      key: "interpolate",
      value: function interpolate4(str, data, lng, options) {
        var _this = this;
        var match;
        var value;
        var replaces;
        var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
        function regexSafe(val) {
          return val.replace(/\$/g, "$$$$");
        }
        var handleFormat = function handleFormat2(key) {
          if (key.indexOf(_this.formatSeparator) < 0) {
            var path = getPathWithDefaults(data, defaultData, key);
            return _this.alwaysFormat ? _this.format(path, void 0, lng) : path;
          }
          var p4 = key.split(_this.formatSeparator);
          var k4 = p4.shift().trim();
          var f4 = p4.join(_this.formatSeparator).trim();
          return _this.format(getPathWithDefaults(data, defaultData, k4), f4, lng, options);
        };
        this.resetRegExp();
        var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
        var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
        var todos = [{
          regex: this.regexpUnescape,
          safeValue: function safeValue(val) {
            return regexSafe(val);
          }
        }, {
          regex: this.regexp,
          safeValue: function safeValue(val) {
            return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
          }
        }];
        todos.forEach(function(todo) {
          replaces = 0;
          while (match = todo.regex.exec(str)) {
            value = handleFormat(match[1].trim());
            if (value === void 0) {
              if (typeof missingInterpolationHandler === "function") {
                var temp = missingInterpolationHandler(str, match, options);
                value = typeof temp === "string" ? temp : "";
              } else if (skipOnVariables) {
                value = match[0];
                continue;
              } else {
                _this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
                value = "";
              }
            } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
              value = makeString(value);
            }
            str = str.replace(match[0], todo.safeValue(value));
            todo.regex.lastIndex = 0;
            replaces++;
            if (replaces >= _this.maxReplaces) {
              break;
            }
          }
        });
        return str;
      }
    }, {
      key: "nest",
      value: function nest(str, fc) {
        var _this2 = this;
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var match;
        var value;
        var clonedOptions = _objectSpread({}, options);
        clonedOptions.applyPostProcessor = false;
        delete clonedOptions.defaultValue;
        function handleHasOptions(key, inheritedOptions) {
          var sep = this.nestingOptionsSeparator;
          if (key.indexOf(sep) < 0) return key;
          var c4 = key.split(new RegExp("".concat(sep, "[ ]*{")));
          var optionsString = "{".concat(c4[1]);
          key = c4[0];
          optionsString = this.interpolate(optionsString, clonedOptions);
          optionsString = optionsString.replace(/'/g, '"');
          try {
            clonedOptions = JSON.parse(optionsString);
            if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
          } catch (e2) {
            this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2);
            return "".concat(key).concat(sep).concat(optionsString);
          }
          delete clonedOptions.defaultValue;
          return key;
        }
        while (match = this.nestingRegexp.exec(str)) {
          var formatters2 = [];
          var doReduce = false;
          if (match[0].includes(this.formatSeparator) && !/{.*}/.test(match[1])) {
            var r3 = match[1].split(this.formatSeparator).map(function(elem) {
              return elem.trim();
            });
            match[1] = r3.shift();
            formatters2 = r3;
            doReduce = true;
          }
          value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
          if (value && match[0] === str && typeof value !== "string") return value;
          if (typeof value !== "string") value = makeString(value);
          if (!value) {
            this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
            value = "";
          }
          if (doReduce) {
            value = formatters2.reduce(function(v4, f4) {
              return _this2.format(v4, f4, options.lng, options);
            }, value.trim());
          }
          str = str.replace(match[0], value);
          this.regexp.lastIndex = 0;
        }
        return str;
      }
    }]);
    return Interpolator2;
  }();
  function remove(arr, what) {
    var found = arr.indexOf(what);
    while (found !== -1) {
      arr.splice(found, 1);
      found = arr.indexOf(what);
    }
  }
  var Connector = function(_EventEmitter) {
    _inherits(Connector2, _EventEmitter);
    function Connector2(backend, store, services) {
      var _this;
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      _classCallCheck(this, Connector2);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector2).call(this));
      if (isIE10) {
        EventEmitter.call(_assertThisInitialized(_this));
      }
      _this.backend = backend;
      _this.store = store;
      _this.services = services;
      _this.languageUtils = services.languageUtils;
      _this.options = options;
      _this.logger = baseLogger.create("backendConnector");
      _this.state = {};
      _this.queue = [];
      if (_this.backend && _this.backend.init) {
        _this.backend.init(services, options.backend, options);
      }
      return _this;
    }
    _createClass(Connector2, [{
      key: "queueLoad",
      value: function queueLoad(languages, namespaces, options, callback2) {
        var _this2 = this;
        var toLoad = [];
        var pending = [];
        var toLoadLanguages = [];
        var toLoadNamespaces = [];
        languages.forEach(function(lng) {
          var hasAllNamespaces = true;
          namespaces.forEach(function(ns) {
            var name2 = "".concat(lng, "|").concat(ns);
            if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
              _this2.state[name2] = 2;
            } else if (_this2.state[name2] < 0) ;
            else if (_this2.state[name2] === 1) {
              if (pending.indexOf(name2) < 0) pending.push(name2);
            } else {
              _this2.state[name2] = 1;
              hasAllNamespaces = false;
              if (pending.indexOf(name2) < 0) pending.push(name2);
              if (toLoad.indexOf(name2) < 0) toLoad.push(name2);
              if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
            }
          });
          if (!hasAllNamespaces) toLoadLanguages.push(lng);
        });
        if (toLoad.length || pending.length) {
          this.queue.push({
            pending,
            loaded: {},
            errors: [],
            callback: callback2
          });
        }
        return {
          toLoad,
          pending,
          toLoadLanguages,
          toLoadNamespaces
        };
      }
    }, {
      key: "loaded",
      value: function loaded(name2, err, data) {
        var s4 = name2.split("|");
        var lng = s4[0];
        var ns = s4[1];
        if (err) this.emit("failedLoading", lng, ns, err);
        if (data) {
          this.store.addResourceBundle(lng, ns, data);
        }
        this.state[name2] = err ? -1 : 2;
        var loaded2 = {};
        this.queue.forEach(function(q4) {
          pushPath(q4.loaded, [lng], ns);
          remove(q4.pending, name2);
          if (err) q4.errors.push(err);
          if (q4.pending.length === 0 && !q4.done) {
            Object.keys(q4.loaded).forEach(function(l5) {
              if (!loaded2[l5]) loaded2[l5] = [];
              if (q4.loaded[l5].length) {
                q4.loaded[l5].forEach(function(ns2) {
                  if (loaded2[l5].indexOf(ns2) < 0) loaded2[l5].push(ns2);
                });
              }
            });
            q4.done = true;
            if (q4.errors.length) {
              q4.callback(q4.errors);
            } else {
              q4.callback();
            }
          }
        });
        this.emit("loaded", loaded2);
        this.queue = this.queue.filter(function(q4) {
          return !q4.done;
        });
      }
    }, {
      key: "read",
      value: function read2(lng, ns, fcName) {
        var _this3 = this;
        var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var wait3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
        var callback2 = arguments.length > 5 ? arguments[5] : void 0;
        if (!lng.length) return callback2(null, {});
        return this.backend[fcName](lng, ns, function(err, data) {
          if (err && data && tried < 5) {
            setTimeout(function() {
              _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait3 * 2, callback2);
            }, wait3);
            return;
          }
          callback2(err, data);
        });
      }
    }, {
      key: "prepareLoading",
      value: function prepareLoading(languages, namespaces) {
        var _this4 = this;
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var callback2 = arguments.length > 3 ? arguments[3] : void 0;
        if (!this.backend) {
          this.logger.warn("No backend was added via i18next.use. Will not load resources.");
          return callback2 && callback2();
        }
        if (typeof languages === "string") languages = this.languageUtils.toResolveHierarchy(languages);
        if (typeof namespaces === "string") namespaces = [namespaces];
        var toLoad = this.queueLoad(languages, namespaces, options, callback2);
        if (!toLoad.toLoad.length) {
          if (!toLoad.pending.length) callback2();
          return null;
        }
        toLoad.toLoad.forEach(function(name2) {
          _this4.loadOne(name2);
        });
      }
    }, {
      key: "load",
      value: function load(languages, namespaces, callback2) {
        this.prepareLoading(languages, namespaces, {}, callback2);
      }
    }, {
      key: "reload",
      value: function reload(languages, namespaces, callback2) {
        this.prepareLoading(languages, namespaces, {
          reload: true
        }, callback2);
      }
    }, {
      key: "loadOne",
      value: function loadOne(name2) {
        var _this5 = this;
        var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        var s4 = name2.split("|");
        var lng = s4[0];
        var ns = s4[1];
        this.read(lng, ns, "read", void 0, void 0, function(err, data) {
          if (err) _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
          if (!err && data) _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
          _this5.loaded(name2, err, data);
        });
      }
    }, {
      key: "saveMissing",
      value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
        var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
          this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          return;
        }
        if (key === void 0 || key === null || key === "") return;
        if (this.backend && this.backend.create) {
          this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread({}, options, {
            isUpdate
          }));
        }
        if (!languages || !languages[0]) return;
        this.store.addResource(languages[0], namespace, key, fallbackValue);
      }
    }]);
    return Connector2;
  }(EventEmitter);
  function get() {
    return {
      debug: false,
      initImmediate: true,
      ns: ["translation"],
      defaultNS: ["translation"],
      fallbackLng: ["dev"],
      fallbackNS: false,
      whitelist: false,
      nonExplicitWhitelist: false,
      supportedLngs: false,
      nonExplicitSupportedLngs: false,
      load: "all",
      preload: false,
      simplifyPluralSuffix: true,
      keySeparator: ".",
      nsSeparator: ":",
      pluralSeparator: "_",
      contextSeparator: "_",
      partialBundledLanguages: false,
      saveMissing: false,
      updateMissing: false,
      saveMissingTo: "fallback",
      saveMissingPlurals: true,
      missingKeyHandler: false,
      missingInterpolationHandler: false,
      postProcess: false,
      postProcessPassResolved: false,
      returnNull: true,
      returnEmptyString: true,
      returnObjects: false,
      joinArrays: false,
      returnedObjectHandler: false,
      parseMissingKeyHandler: false,
      appendNamespaceToMissingKey: false,
      appendNamespaceToCIMode: false,
      overloadTranslationOptionHandler: function handle2(args) {
        var ret = {};
        if (_typeof(args[1]) === "object") ret = args[1];
        if (typeof args[1] === "string") ret.defaultValue = args[1];
        if (typeof args[2] === "string") ret.tDescription = args[2];
        if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
          var options = args[3] || args[2];
          Object.keys(options).forEach(function(key) {
            ret[key] = options[key];
          });
        }
        return ret;
      },
      interpolation: {
        escapeValue: true,
        format: function format2(value, _format, lng, options) {
          return value;
        },
        prefix: "{{",
        suffix: "}}",
        formatSeparator: ",",
        unescapePrefix: "-",
        nestingPrefix: "$t(",
        nestingSuffix: ")",
        nestingOptionsSeparator: ",",
        maxReplaces: 1e3,
        skipOnVariables: false
      }
    };
  }
  function transformOptions(options) {
    if (typeof options.ns === "string") options.ns = [options.ns];
    if (typeof options.fallbackLng === "string") options.fallbackLng = [options.fallbackLng];
    if (typeof options.fallbackNS === "string") options.fallbackNS = [options.fallbackNS];
    if (options.whitelist) {
      if (options.whitelist && options.whitelist.indexOf("cimode") < 0) {
        options.whitelist = options.whitelist.concat(["cimode"]);
      }
      options.supportedLngs = options.whitelist;
    }
    if (options.nonExplicitWhitelist) {
      options.nonExplicitSupportedLngs = options.nonExplicitWhitelist;
    }
    if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
      options.supportedLngs = options.supportedLngs.concat(["cimode"]);
    }
    return options;
  }
  function noop2() {
  }
  var I18n = function(_EventEmitter) {
    _inherits(I18n2, _EventEmitter);
    function I18n2() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback2 = arguments.length > 1 ? arguments[1] : void 0;
      _classCallCheck(this, I18n2);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n2).call(this));
      if (isIE10) {
        EventEmitter.call(_assertThisInitialized(_this));
      }
      _this.options = transformOptions(options);
      _this.services = {};
      _this.logger = baseLogger;
      _this.modules = {
        external: []
      };
      if (callback2 && !_this.isInitialized && !options.isClone) {
        if (!_this.options.initImmediate) {
          _this.init(options, callback2);
          return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
        }
        setTimeout(function() {
          _this.init(options, callback2);
        }, 0);
      }
      return _this;
    }
    _createClass(I18n2, [{
      key: "init",
      value: function init2() {
        var _this2 = this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var callback2 = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof options === "function") {
          callback2 = options;
          options = {};
        }
        if (options.whitelist && !options.supportedLngs) {
          this.logger.deprecate("whitelist", 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.');
        }
        if (options.nonExplicitWhitelist && !options.nonExplicitSupportedLngs) {
          this.logger.deprecate("whitelist", 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.');
        }
        this.options = _objectSpread({}, get(), this.options, transformOptions(options));
        this.format = this.options.interpolation.format;
        if (!callback2) callback2 = noop2;
        function createClassOnDemand(ClassOrObject) {
          if (!ClassOrObject) return null;
          if (typeof ClassOrObject === "function") return new ClassOrObject();
          return ClassOrObject;
        }
        if (!this.options.isClone) {
          if (this.modules.logger) {
            baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
          } else {
            baseLogger.init(null, this.options);
          }
          var lu = new LanguageUtil(this.options);
          this.store = new ResourceStore(this.options.resources, this.options);
          var s4 = this.services;
          s4.logger = baseLogger;
          s4.resourceStore = this.store;
          s4.languageUtils = lu;
          s4.pluralResolver = new PluralResolver(lu, {
            prepend: this.options.pluralSeparator,
            compatibilityJSON: this.options.compatibilityJSON,
            simplifyPluralSuffix: this.options.simplifyPluralSuffix
          });
          s4.interpolator = new Interpolator(this.options);
          s4.utils = {
            hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
          };
          s4.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s4.resourceStore, s4, this.options);
          s4.backendConnector.on("*", function(event2) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            _this2.emit.apply(_this2, [event2].concat(args));
          });
          if (this.modules.languageDetector) {
            s4.languageDetector = createClassOnDemand(this.modules.languageDetector);
            s4.languageDetector.init(s4, this.options.detection, this.options);
          }
          if (this.modules.i18nFormat) {
            s4.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
            if (s4.i18nFormat.init) s4.i18nFormat.init(this);
          }
          this.translator = new Translator(this.services, this.options);
          this.translator.on("*", function(event2) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            _this2.emit.apply(_this2, [event2].concat(args));
          });
          this.modules.external.forEach(function(m4) {
            if (m4.init) m4.init(_this2);
          });
        }
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
          var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
        }
        if (!this.services.languageDetector && !this.options.lng) {
          this.logger.warn("init: no languageDetector is used and no lng is defined");
        }
        var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
        storeApi.forEach(function(fcName) {
          _this2[fcName] = function() {
            var _this2$store;
            return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
          };
        });
        var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
        storeApiChained.forEach(function(fcName) {
          _this2[fcName] = function() {
            var _this2$store2;
            (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
            return _this2;
          };
        });
        var deferred = defer();
        var load = function load2() {
          var finish = function finish2(err, t4) {
            if (_this2.isInitialized) _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
            _this2.isInitialized = true;
            if (!_this2.options.isClone) _this2.logger.log("initialized", _this2.options);
            _this2.emit("initialized", _this2.options);
            deferred.resolve(t4);
            callback2(err, t4);
          };
          if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));
          _this2.changeLanguage(_this2.options.lng, finish);
        };
        if (this.options.resources || !this.options.initImmediate) {
          load();
        } else {
          setTimeout(load, 0);
        }
        return deferred;
      }
    }, {
      key: "loadResources",
      value: function loadResources(language) {
        var _this3 = this;
        var callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
        var usedCallback = callback2;
        var usedLng = typeof language === "string" ? language : this.language;
        if (typeof language === "function") usedCallback = language;
        if (!this.options.resources || this.options.partialBundledLanguages) {
          if (usedLng && usedLng.toLowerCase() === "cimode") return usedCallback();
          var toLoad = [];
          var append = function append2(lng) {
            if (!lng) return;
            var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
            lngs.forEach(function(l5) {
              if (toLoad.indexOf(l5) < 0) toLoad.push(l5);
            });
          };
          if (!usedLng) {
            var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            fallbacks.forEach(function(l5) {
              return append(l5);
            });
          } else {
            append(usedLng);
          }
          if (this.options.preload) {
            this.options.preload.forEach(function(l5) {
              return append(l5);
            });
          }
          this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
        } else {
          usedCallback(null);
        }
      }
    }, {
      key: "reloadResources",
      value: function reloadResources(lngs, ns, callback2) {
        var deferred = defer();
        if (!lngs) lngs = this.languages;
        if (!ns) ns = this.options.ns;
        if (!callback2) callback2 = noop2;
        this.services.backendConnector.reload(lngs, ns, function(err) {
          deferred.resolve();
          callback2(err);
        });
        return deferred;
      }
    }, {
      key: "use",
      value: function use(module2) {
        if (!module2) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!module2.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        if (module2.type === "backend") {
          this.modules.backend = module2;
        }
        if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
          this.modules.logger = module2;
        }
        if (module2.type === "languageDetector") {
          this.modules.languageDetector = module2;
        }
        if (module2.type === "i18nFormat") {
          this.modules.i18nFormat = module2;
        }
        if (module2.type === "postProcessor") {
          postProcessor.addPostProcessor(module2);
        }
        if (module2.type === "3rdParty") {
          this.modules.external.push(module2);
        }
        return this;
      }
    }, {
      key: "changeLanguage",
      value: function changeLanguage(lng, callback2) {
        var _this4 = this;
        this.isLanguageChangingTo = lng;
        var deferred = defer();
        this.emit("languageChanging", lng);
        var done = function done2(err, l5) {
          if (l5) {
            _this4.language = l5;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l5);
            _this4.translator.changeLanguage(l5);
            _this4.isLanguageChangingTo = void 0;
            _this4.emit("languageChanged", l5);
            _this4.logger.log("languageChanged", l5);
          } else {
            _this4.isLanguageChangingTo = void 0;
          }
          deferred.resolve(function() {
            return _this4.t.apply(_this4, arguments);
          });
          if (callback2) callback2(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
        };
        var setLng = function setLng2(lngs) {
          var l5 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
          if (l5) {
            if (!_this4.language) {
              _this4.language = l5;
              _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l5);
            }
            if (!_this4.translator.language) _this4.translator.changeLanguage(l5);
            if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l5);
          }
          _this4.loadResources(l5, function(err) {
            done(err, l5);
          });
        };
        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
          setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
          this.services.languageDetector.detect(setLng);
        } else {
          setLng(lng);
        }
        return deferred;
      }
    }, {
      key: "getFixedT",
      value: function getFixedT(lng, ns) {
        var _this5 = this;
        var fixedT = function fixedT2(key, opts) {
          var options;
          if (_typeof(opts) !== "object") {
            for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
              rest[_key3 - 2] = arguments[_key3];
            }
            options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
          } else {
            options = _objectSpread({}, opts);
          }
          options.lng = options.lng || fixedT2.lng;
          options.lngs = options.lngs || fixedT2.lngs;
          options.ns = options.ns || fixedT2.ns;
          return _this5.t(key, options);
        };
        if (typeof lng === "string") {
          fixedT.lng = lng;
        } else {
          fixedT.lngs = lng;
        }
        fixedT.ns = ns;
        return fixedT;
      }
    }, {
      key: "t",
      value: function t4() {
        var _this$translator;
        return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
      }
    }, {
      key: "exists",
      value: function exists() {
        var _this$translator2;
        return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
      }
    }, {
      key: "setDefaultNamespace",
      value: function setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
      }
    }, {
      key: "hasLoadedNamespace",
      value: function hasLoadedNamespace(ns) {
        var _this6 = this;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!this.isInitialized) {
          this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
          return false;
        }
        if (!this.languages || !this.languages.length) {
          this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
          return false;
        }
        var lng = this.languages[0];
        var fallbackLng = this.options ? this.options.fallbackLng : false;
        var lastLng = this.languages[this.languages.length - 1];
        if (lng.toLowerCase() === "cimode") return true;
        var loadNotPending = function loadNotPending2(l5, n3) {
          var loadState = _this6.services.backendConnector.state["".concat(l5, "|").concat(n3)];
          return loadState === -1 || loadState === 2;
        };
        if (options.precheck) {
          var preResult = options.precheck(this, loadNotPending);
          if (preResult !== void 0) return preResult;
        }
        if (this.hasResourceBundle(lng, ns)) return true;
        if (!this.services.backendConnector.backend) return true;
        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
        return false;
      }
    }, {
      key: "loadNamespaces",
      value: function loadNamespaces(ns, callback2) {
        var _this7 = this;
        var deferred = defer();
        if (!this.options.ns) {
          callback2 && callback2();
          return Promise.resolve();
        }
        if (typeof ns === "string") ns = [ns];
        ns.forEach(function(n3) {
          if (_this7.options.ns.indexOf(n3) < 0) _this7.options.ns.push(n3);
        });
        this.loadResources(function(err) {
          deferred.resolve();
          if (callback2) callback2(err);
        });
        return deferred;
      }
    }, {
      key: "loadLanguages",
      value: function loadLanguages(lngs, callback2) {
        var deferred = defer();
        if (typeof lngs === "string") lngs = [lngs];
        var preloaded = this.options.preload || [];
        var newLngs = lngs.filter(function(lng) {
          return preloaded.indexOf(lng) < 0;
        });
        if (!newLngs.length) {
          if (callback2) callback2();
          return Promise.resolve();
        }
        this.options.preload = preloaded.concat(newLngs);
        this.loadResources(function(err) {
          deferred.resolve();
          if (callback2) callback2(err);
        });
        return deferred;
      }
    }, {
      key: "dir",
      value: function dir(lng) {
        if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
        if (!lng) return "rtl";
        var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
        return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
      }
    }, {
      key: "createInstance",
      value: function createInstance() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var callback2 = arguments.length > 1 ? arguments[1] : void 0;
        return new I18n2(options, callback2);
      }
    }, {
      key: "cloneInstance",
      value: function cloneInstance() {
        var _this8 = this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
        var mergedOptions = _objectSpread({}, this.options, options, {
          isClone: true
        });
        var clone2 = new I18n2(mergedOptions);
        var membersToCopy = ["store", "services", "language"];
        membersToCopy.forEach(function(m4) {
          clone2[m4] = _this8[m4];
        });
        clone2.services = _objectSpread({}, this.services);
        clone2.services.utils = {
          hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
        };
        clone2.translator = new Translator(clone2.services, clone2.options);
        clone2.translator.on("*", function(event2) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }
          clone2.emit.apply(clone2, [event2].concat(args));
        });
        clone2.init(mergedOptions, callback2);
        clone2.translator.options = clone2.options;
        clone2.translator.backendConnector.services.utils = {
          hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
        };
        return clone2;
      }
    }]);
    return I18n2;
  }(EventEmitter);
  var i18next = new I18n();
  var i18next_default = i18next;

  // app/javascript/i18n-js/locales/locales.json
  var locales_default = {
    en: {
      stimulus: {
        application: null,
        admin_editor: {
          confirm_message: "You have made changes to this blog post, are you sure you want to proceed? This can't be undone.",
          save_button_text: "Save Changes",
          save_reload_button_text: "Save & Reload"
        },
        clipboard_copy: {
          click_to_copy: "Click To Copy"
        },
        sortable: {
          sort_order_saved: "Sort order saved",
          failed_to_save: "Failed to save sort order"
        },
        commons: null,
        index_sort: {
          a_to_z: "A-Z",
          false_first: "false first",
          high_to_low: "high to low",
          low_to_high: "low to high",
          newest_first: "newest first",
          oldest_first: "oldest first",
          true_fist: "true first",
          z_to_a: "Z-A"
        },
        shoelace: {
          confirm: {
            cancel: "Cancel",
            submit: "Proceed",
            title: "Are you sure?",
            type_to_confirm: "Type %{word} to confirm"
          }
        },
        simonwep_pickr: {
          "aria:btncancel": "cancel and close",
          "aria:btnclear": "clear and close",
          "aria:btnsave": "save and close",
          "aria:hue": "hue selection slider",
          "aria:input": "color input field",
          "aria:opacity": "selection slider",
          "aria:palette": "color selection area",
          "btn:cancel": "Cancel",
          "btn:clear": "Clear",
          "btn:lastcolor": "use previous color",
          "btn:save": "Save",
          "btn:swatch": "color swatch",
          "btn:toggle": "toggle color picker dialog",
          "ui:dialog": "color picker dialog"
        },
        strength_meter: {
          quality: "Quality",
          very_weak: "Very Weak",
          weak: "Weak",
          good: "Good",
          excellent: "Excellent"
        },
        password_validation: {
          min_length: "Must be at least 12 characters long",
          uppercase: "Must contain at least one uppercase letter",
          lowercase: "Must contain at least one lowercase letter",
          number: "Must contain at least one number",
          special: "Must contain at least one special character"
        },
        shrine_image_uploads: {
          limit_exceeded: "You can only upload up to %{limit} images",
          file_too_large: "File size must be less than 10 MB",
          invalid_file_type: "Only JPEG, PNG, WebP, and GIF images are allowed",
          upload_failed: "Failed to upload image"
        }
      },
      domains: {
        wizard: {
          continue_button: "Continue with %{domain}"
        }
      },
      trix: {
        GB: "GB",
        KB: "KB",
        MB: "MB",
        PB: "PB",
        TB: "TB",
        attachFiles: "Attach Files",
        bold: "Bold",
        bullets: "Bullets",
        byte: "Byte",
        bytes: "Bytes",
        captionPlaceholder: "Add a caption\u2026",
        code: "Code",
        heading1: "Heading",
        indent: "Increase Level",
        italic: "Italic",
        link: "Link",
        numbers: "Numbers",
        outdent: "Decrease Level",
        quote: "Quote",
        redo: "Redo",
        remove: "Remove",
        strike: "Strikethrough",
        undo: "Undo",
        unlink: "Unlink",
        url: "URL",
        urlPlaceholder: "Enter a URL\u2026"
      },
      activity_chart_controller: {
        commissions: "Commissions",
        pageviews: "Pageviews",
        trial_starts: "Trial Starts",
        conversions: "Conversions"
      },
      unsaved_changes_controller: {
        haveChanges: "You've made changes that haven't been saved. Clicking 'OK' will discard them. Do you want to continue?",
        noChanges: "No Unsaved Changes"
      },
      direct_image_uploads_controller: {
        limit_exceeded: "You can only upload up to %{limit} files",
        too_large: "File size must be less than 10 MB"
      },
      discounts: {
        amount_required: "Amount is required",
        percent_required: "Percent is required"
      }
    },
    es: {
      stimulus: {
        admin_editor: {
          confirm_message: "Has realizado cambios en esta publicaci\xF3n del blog, \xBFest\xE1s seguro de que deseas continuar? Esto no se puede deshacer.",
          save_button_text: "Guardar Cambios",
          save_reload_button_text: "Guardar y Recargar"
        },
        clipboard_copy: {
          click_to_copy: "Haz clic para copiar"
        },
        sortable: {
          sort_order_saved: "Orden de clasificaci\xF3n guardado",
          failed_to_save: "Error al guardar el orden de clasificaci\xF3n"
        },
        index_sort: {
          a_to_z: "A-Z",
          false_first: "falso primero",
          high_to_low: "de alto a bajo",
          low_to_high: "bajo a alto",
          newest_first: "el m\xE1s reciente primero",
          oldest_first: "los m\xE1s antiguos primeros",
          true_fist: "verdadero primero",
          z_to_a: "Z-A"
        },
        shoelace: {
          confirm: {
            cancel: "Cancelar",
            submit: "Proceder",
            title: "\xBFEst\xE1s seguro?",
            type_to_confirm: "Escribe %{word} para confirmar"
          }
        },
        simonwep_pickr: {
          "aria:btncancel": "cancelar y cerrar",
          "aria:btnclear": "limpiar y cerrar",
          "aria:btnsave": "guardar y cerrar",
          "aria:hue": "control de selecci\xF3n de tono",
          "aria:input": "campo de entrada de color",
          "aria:opacity": "control de selecci\xF3n",
          "aria:palette": "\xE1rea de selecci\xF3n de color",
          "btn:cancel": "Cancelar",
          "btn:clear": "Borrar",
          "btn:lastcolor": "usar el color anterior",
          "btn:save": "Guardar",
          "btn:swatch": "muestra de color",
          "btn:toggle": "cambiar al cuadro de di\xE1logo del selector de color",
          "ui:dialog": "cuadro de di\xE1logo selector de color"
        },
        strength_meter: {
          quality: "Calidad",
          very_weak: "Muy D\xE9bil",
          weak: "D\xE9bil",
          good: "Bueno",
          excellent: "Excelente"
        },
        password_validation: {
          min_length: "Debe tener al menos 12 caracteres",
          uppercase: "Debe contener al menos una letra may\xFAscula",
          lowercase: "Debe contener al menos una letra min\xFAscula",
          number: "Debe contener al menos un n\xFAmero",
          special: "Debe contener al menos un car\xE1cter especial"
        }
      },
      domains: {
        wizard: {
          continue_button: "Continuar con %{domain}"
        }
      },
      trix: {
        GB: "GB",
        KB: "KB",
        MB: "MB",
        PB: "PB",
        TB: "TB",
        attachFiles: "Adjuntar archivos",
        bold: "Oscuro",
        bullets: "Vi\xF1etas",
        byte: "Byte",
        bytes: "Bytes",
        captionPlaceholder: "Agrega un subt\xEDtulo\u2026",
        code: "C\xF3digo",
        heading1: "T\xEDtulo",
        indent: "Aumentar nivel",
        italic: "It\xE1licas",
        link: "Enlace",
        numbers: "N\xFAmeros",
        outdent: "Reducir nivel",
        quote: "Citar",
        redo: "Rehacer",
        remove: "Quitar",
        strike: "Tachado",
        undo: "Deshacer",
        unlink: "Desconectar",
        url: "URL",
        urlPlaceholder: "Introducir URL..."
      },
      activity_chart_controller: {
        commissions: "Comisiones",
        pageviews: "Vistas de p\xE1gina",
        trial_starts: "Inicios de prueba",
        conversions: "Conversiones"
      },
      unsaved_changes_controller: {
        haveChanges: "Tiene cambios no guardados, por favor confirme.",
        noChanges: "Sin cambios no guardados"
      },
      direct_image_uploads_controller: {
        limit_exceeded: "Solo puede subir hasta %{limit} archivos",
        too_large: "El tama\xF1o del archivo debe ser menor a 10 MB"
      },
      discounts: {
        amount_required: "El monto es requerido",
        percent_required: "El porcentaje es requerido"
      }
    },
    ja: {
      stimulus: {
        admin_editor: {
          confirm_message: "\u30D6\u30ED\u30B0\u6295\u7A3F\u306B\u5909\u66F4\u3092\u52A0\u3048\u307E\u3057\u305F\u3002\u7D9A\u884C\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F\u3053\u306E\u64CD\u4F5C\u306F\u5143\u306B\u623B\u305B\u307E\u305B\u3093\u3002",
          save_button_text: "\u5909\u66F4\u3092\u4FDD\u5B58",
          save_reload_button_text: "\u4FDD\u5B58\u3057\u3066\u518D\u8AAD\u307F\u8FBC\u307F"
        },
        clipboard_copy: {
          click_to_copy: "\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30B3\u30D4\u30FC"
        },
        sortable: {
          sort_order_saved: "\u4E26\u3073\u9806\u3092\u4FDD\u5B58\u3057\u307E\u3057\u305F",
          failed_to_save: "\u4E26\u3073\u9806\u306E\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F"
        },
        index_sort: {
          a_to_z: "A-Z",
          false_first: "false\u512A\u5148",
          high_to_low: "\u9AD8\u3044\u9806",
          low_to_high: "\u4F4E\u3044\u9806",
          newest_first: "\u65B0\u3057\u3044\u9806",
          oldest_first: "\u53E4\u3044\u9806",
          true_fist: "true\u512A\u5148",
          z_to_a: "Z-A"
        },
        shoelace: {
          confirm: {
            cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
            submit: "\u7D9A\u884C",
            title: "\u78BA\u8A8D",
            type_to_confirm: "\u78BA\u8A8D\u3059\u308B\u306B\u306F%{word}\u3068\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044"
          }
        },
        simonwep_pickr: {
          "aria:btncancel": "\u30AD\u30E3\u30F3\u30BB\u30EB\u3057\u3066\u9589\u3058\u308B",
          "aria:btnclear": "\u30AF\u30EA\u30A2\u3057\u3066\u9589\u3058\u308B",
          "aria:btnsave": "\u4FDD\u5B58\u3057\u3066\u9589\u3058\u308B",
          "aria:hue": "\u8272\u76F8\u9078\u629E\u30B9\u30E9\u30A4\u30C0\u30FC",
          "aria:input": "\u8272\u5165\u529B\u30D5\u30A3\u30FC\u30EB\u30C9",
          "aria:opacity": "\u9078\u629E\u30B9\u30E9\u30A4\u30C0\u30FC",
          "aria:palette": "\u8272\u9078\u629E\u30A8\u30EA\u30A2",
          "btn:cancel": "\u30AD\u30E3\u30F3\u30BB\u30EB",
          "btn:clear": "\u30AF\u30EA\u30A2",
          "btn:lastcolor": "\u524D\u56DE\u306E\u8272\u3092\u4F7F\u7528",
          "btn:save": "\u4FDD\u5B58",
          "btn:swatch": "\u30AB\u30E9\u30FC\u30B9\u30A6\u30A9\u30C3\u30C1",
          "btn:toggle": "\u30AB\u30E9\u30FC\u30D4\u30C3\u30AB\u30FC\u30C0\u30A4\u30A2\u30ED\u30B0\u306E\u5207\u308A\u66FF\u3048",
          "ui:dialog": "\u30AB\u30E9\u30FC\u30D4\u30C3\u30AB\u30FC\u30C0\u30A4\u30A2\u30ED\u30B0"
        },
        strength_meter: {
          quality: "\u54C1\u8CEA",
          very_weak: "\u3068\u3066\u3082\u5F31\u3044",
          weak: "\u5F31\u3044",
          good: "\u826F\u3044",
          excellent: "\u512A\u308C\u3066\u3044\u308B"
        },
        password_validation: {
          min_length: "12\u6587\u5B57\u4EE5\u4E0A\u3067\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044",
          uppercase: "\u5C11\u306A\u304F\u3068\u30821\u3064\u306E\u5927\u6587\u5B57\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
          lowercase: "\u5C11\u306A\u304F\u3068\u30821\u3064\u306E\u5C0F\u6587\u5B57\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
          number: "\u5C11\u306A\u304F\u3068\u30821\u3064\u306E\u6570\u5B57\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
          special: "\u5C11\u306A\u304F\u3068\u30821\u3064\u306E\u7279\u6B8A\u6587\u5B57\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059"
        },
        shrine_image_uploads: {
          limit_exceeded: "\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u3067\u304D\u308B\u753B\u50CF\u306F\u6700\u5927%{limit}\u679A\u3067\u3059",
          file_too_large: "\u30D5\u30A1\u30A4\u30EB\u30B5\u30A4\u30BA\u306F10MB\u672A\u6E80\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
          invalid_file_type: "JPEG\u3001PNG\u3001WebP\u3001GIF\u753B\u50CF\u306E\u307F\u8A31\u53EF\u3055\u308C\u3066\u3044\u307E\u3059",
          upload_failed: "\u753B\u50CF\u306E\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u306B\u5931\u6557\u3057\u307E\u3057\u305F"
        }
      },
      domains: {
        wizard: {
          continue_button: "%{domain}\u3067\u7D9A\u884C"
        }
      },
      trix: {
        GB: "GB",
        KB: "KB",
        MB: "MB",
        PB: "PB",
        TB: "TB",
        attachFiles: "\u30D5\u30A1\u30A4\u30EB\u3092\u6DFB\u4ED8",
        bold: "\u592A\u5B57",
        bullets: "\u7B87\u6761\u66F8\u304D",
        byte: "\u30D0\u30A4\u30C8",
        bytes: "\u30D0\u30A4\u30C8",
        captionPlaceholder: "\u30AD\u30E3\u30D7\u30B7\u30E7\u30F3\u3092\u8FFD\u52A0...",
        code: "\u30B3\u30FC\u30C9",
        heading1: "\u898B\u51FA\u3057",
        indent: "\u30A4\u30F3\u30C7\u30F3\u30C8\u3092\u5897\u3084\u3059",
        italic: "\u659C\u4F53",
        link: "\u30EA\u30F3\u30AF",
        numbers: "\u756A\u53F7\u4ED8\u304D\u30EA\u30B9\u30C8",
        outdent: "\u30A4\u30F3\u30C7\u30F3\u30C8\u3092\u6E1B\u3089\u3059",
        quote: "\u5F15\u7528",
        redo: "\u3084\u308A\u76F4\u3057",
        remove: "\u524A\u9664",
        strike: "\u53D6\u308A\u6D88\u3057\u7DDA",
        undo: "\u5143\u306B\u623B\u3059",
        unlink: "\u30EA\u30F3\u30AF\u89E3\u9664",
        url: "URL",
        urlPlaceholder: "URL\u3092\u5165\u529B..."
      },
      activity_chart_controller: {
        commissions: "\u30B3\u30DF\u30C3\u30B7\u30E7\u30F3",
        pageviews: "\u30DA\u30FC\u30B8\u30D3\u30E5\u30FC",
        trial_starts: "\u30C8\u30E9\u30A4\u30A2\u30EB\u958B\u59CB",
        conversions: "\u30B3\u30F3\u30D0\u30FC\u30B8\u30E7\u30F3"
      },
      unsaved_changes_controller: {
        haveChanges: "\u4FDD\u5B58\u3055\u308C\u3066\u3044\u306A\u3044\u5909\u66F4\u304C\u3042\u308A\u307E\u3059\u3002'OK'\u3092\u30AF\u30EA\u30C3\u30AF\u3059\u308B\u3068\u7834\u68C4\u3055\u308C\u307E\u3059\u3002\u7D9A\u884C\u3057\u307E\u3059\u304B\uFF1F",
        noChanges: "\u672A\u4FDD\u5B58\u306E\u5909\u66F4\u306F\u3042\u308A\u307E\u305B\u3093"
      },
      direct_image_uploads_controller: {
        limit_exceeded: "\u6700\u5927%{limit}\u30D5\u30A1\u30A4\u30EB\u307E\u3067\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u3067\u304D\u307E\u3059",
        too_large: "\u30D5\u30A1\u30A4\u30EB\u30B5\u30A4\u30BA\u306F10MB\u672A\u6E80\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059"
      },
      discounts: {
        amount_required: "\u91D1\u984D\u306F\u5FC5\u9808\u3067\u3059",
        percent_required: "\u30D1\u30FC\u30BB\u30F3\u30C8\u306F\u5FC5\u9808\u3067\u3059"
      }
    },
    pt: {
      stimulus: {
        admin_editor: {
          confirm_message: "Voc\xEA fez altera\xE7\xF5es nesta postagem do blog, tem certeza de que deseja continuar? Isso n\xE3o pode ser desfeito.",
          save_button_text: "Salvar Altera\xE7\xF5es",
          save_reload_button_text: "Salvar e Recarregar"
        },
        clipboard_copy: {
          click_to_copy: "Clique para copiar"
        },
        sortable: {
          sort_order_saved: "Ordem de classifica\xE7\xE3o salva",
          failed_to_save: "Falha ao salvar a ordem de classifica\xE7\xE3o"
        },
        index_sort: {
          a_to_z: "A-Z",
          false_first: "falso primeiro",
          high_to_low: "maior para menor",
          low_to_high: "menor para maior",
          newest_first: "mais recente primeiro",
          oldest_first: "mais antigo primeiro",
          true_fist: "verdadeiro primeiro",
          z_to_a: "Z-A"
        },
        shoelace: {
          confirm: {
            cancel: "Cancelar",
            submit: "Continuar",
            title: "Tem certeza?",
            type_to_confirm: "Digite %{word} para confirmar"
          }
        },
        simonwep_pickr: {
          "aria:btncancel": "cancelar e fechar",
          "aria:btnclear": "limpar e fechar",
          "aria:btnsave": "salvar e fechar",
          "aria:hue": "controle deslizante de sele\xE7\xE3o de matiz",
          "aria:input": "campo de entrada de cor",
          "aria:opacity": "controle deslizante de sele\xE7\xE3o",
          "aria:palette": "\xE1rea de sele\xE7\xE3o de cor",
          "btn:cancel": "Cancelar",
          "btn:clear": "Limpar",
          "btn:lastcolor": "usar cor anterior",
          "btn:save": "Salvar",
          "btn:swatch": "amostra de cor",
          "btn:toggle": "alternar di\xE1logo do seletor de cor",
          "ui:dialog": "di\xE1logo do seletor de cor"
        },
        strength_meter: {
          quality: "Qualidade",
          very_weak: "Muito Fraco",
          weak: "Fraco",
          good: "Bom",
          excellent: "Excelente"
        }
      },
      domains: {
        wizard: {
          continue_button: "Continuar com %{domain}"
        }
      },
      trix: {
        GB: "GB",
        KB: "KB",
        MB: "MB",
        PB: "PB",
        TB: "TB",
        attachFiles: "Anexar arquivos",
        bold: "Negrito",
        bullets: "Marcadores",
        byte: "Byte",
        bytes: "Bytes",
        captionPlaceholder: "Adicione uma legenda...",
        code: "C\xF3digo",
        heading1: "T\xEDtulo",
        indent: "Aumentar recuo",
        italic: "It\xE1lico",
        link: "Link",
        numbers: "N\xFAmeros",
        outdent: "Diminuir recuo",
        quote: "Cita\xE7\xE3o",
        redo: "Refazer",
        remove: "Remover",
        strike: "Tachado",
        undo: "Desfazer",
        unlink: "Remover link",
        url: "URL",
        urlPlaceholder: "Digite uma URL..."
      },
      activity_chart_controller: {
        commissions: "Comiss\xF5es",
        pageviews: "Visualiza\xE7\xF5es",
        trial_starts: "In\xEDcios de teste",
        conversions: "Convers\xF5es"
      },
      unsaved_changes_controller: {
        haveChanges: "Voc\xEA tem altera\xE7\xF5es n\xE3o salvas. Clicar em 'OK' ir\xE1 descart\xE1-las. Deseja continuar?",
        noChanges: "Sem altera\xE7\xF5es n\xE3o salvas"
      },
      direct_image_uploads_controller: {
        limit_exceeded: "Voc\xEA s\xF3 pode fazer upload de at\xE9 %{limit} arquivos",
        too_large: "O tamanho do arquivo deve ser menor que 10 MB"
      },
      discounts: {
        amount_required: "O valor \xE9 obrigat\xF3rio",
        percent_required: "A porcentagem \xE9 obrigat\xF3ria"
      }
    }
  };

  // app/javascript/i18n-js/config.js
  Object.keys(locales_default).forEach((key) => locales_default[key] = { translation: locales_default[key] });
  var availableLocales = ["en", "es", "ja", "pt"];
  i18next_default.init({
    lng: "en",
    fallbackLng: "en",
    whitelist: availableLocales,
    preload: availableLocales,
    resources: locales_default,
    interpolation: {
      escapeValue: false,
      // React already escapes values
      prefix: "%{",
      suffix: "}"
    }
  });

  // node_modules/js-cookie/dist/js.cookie.mjs
  init_define_process();
  init_jquery();
  function assign(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target;
  }
  var defaultConverter = {
    read: function(value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
    },
    write: function(value) {
      return encodeURIComponent(value).replace(
        /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
        decodeURIComponent
      );
    }
  };
  function init(converter, defaultAttributes) {
    function set2(name2, value, attributes) {
      if (typeof document === "undefined") {
        return;
      }
      attributes = assign({}, defaultAttributes, attributes);
      if (typeof attributes.expires === "number") {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }
      name2 = encodeURIComponent(name2).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var stringifiedAttributes = "";
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue;
        }
        stringifiedAttributes += "; " + attributeName;
        if (attributes[attributeName] === true) {
          continue;
        }
        stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
      }
      return document.cookie = name2 + "=" + converter.write(value, name2) + stringifiedAttributes;
    }
    function get3(name2) {
      if (typeof document === "undefined" || arguments.length && !name2) {
        return;
      }
      var cookies = document.cookie ? document.cookie.split("; ") : [];
      var jar = {};
      for (var i3 = 0; i3 < cookies.length; i3++) {
        var parts = cookies[i3].split("=");
        var value = parts.slice(1).join("=");
        try {
          var found = decodeURIComponent(parts[0]);
          jar[found] = converter.read(value, found);
          if (name2 === found) {
            break;
          }
        } catch (e2) {
        }
      }
      return name2 ? jar[name2] : jar;
    }
    return Object.create(
      {
        set: set2,
        get: get3,
        remove: function(name2, attributes) {
          set2(
            name2,
            "",
            assign({}, attributes, {
              expires: -1
            })
          );
        },
        withAttributes: function(attributes) {
          return init(this.converter, assign({}, this.attributes, attributes));
        },
        withConverter: function(converter2) {
          return init(assign({}, this.converter, converter2), this.attributes);
        }
      },
      {
        attributes: { value: Object.freeze(defaultAttributes) },
        converter: { value: Object.freeze(converter) }
      }
    );
  }
  var api = init(defaultConverter, { path: "/" });

  // app/javascript/controllers/clipboard_copy_controller.js
  var clipboard_copy_controller_default = class extends application_controller_default {
    connect() {
      const locale = api.get("locale") || "en";
      tippy_esm_default(this.element, {
        content: this.tooltipMessageValue == "Click to Copy" ? i18next_default.t("stimulus.clipboard_copy.click_to_copy", { lng: locale }) : this.tooltipMessageValue
      });
    }
    handleCopy() {
      const copyBtnTargetClasses = [...this.copyBtnTarget.classList];
      const isCopiedClasses = (this.copiedClassValue || "far fa-check text-green-500").split(" ");
      copyBtnTargetClasses.forEach((c4) => this.copyBtnTarget.classList.remove(c4));
      isCopiedClasses.forEach((c4) => this.copyBtnTarget.classList.add(c4));
      setTimeout(() => {
        isCopiedClasses.forEach((c4) => this.copyBtnTarget.classList.remove(c4));
        copyBtnTargetClasses.forEach((c4) => this.copyBtnTarget.classList.add(c4));
        this.element.blur();
      }, 1500);
    }
  };
  __publicField(clipboard_copy_controller_default, "targets", ["copyBtn"]);
  __publicField(clipboard_copy_controller_default, "values", {
    copiedClass: String,
    tooltipMessage: { type: String, default: "Click to Copy" }
  });

  // app/javascript/controllers/affiliates/code_controller.js
  init_define_process();
  init_jquery();
  var code_controller_default = class extends application_controller_default {
    /**
     * Updates the view when the controller is first loaded, primarily to set the
     * display of the assetUrlTarget button.
     */
    initialize() {
      this.updateUrl();
    }
    /**
     * Updates the URL based on the selected campaign and affiliate code.
     * Sets the full URL input value, updates social share URLs, and shows or
     * hides the asset URL link.
     */
    updateUrl() {
      const affiliateCode = this.codeTarget.value;
      const selectedCampaign = this.campaignTarget.value;
      const campaignUrl = this.campaignUrlsValue[selectedCampaign];
      const assetUrl = this.assetUrlsValue[selectedCampaign];
      if (campaignUrl) {
        const resultingUrl = `${campaignUrl}?aff=${affiliateCode}`;
        this.fullUrlTarget.setAttribute("value", resultingUrl);
        this.previewUrlTarget.textContent = resultingUrl;
        this.socialsTargets.forEach((social) => {
          social.setAttribute("data-share-url-param", resultingUrl);
        });
      }
      if (assetUrl) {
        this.assetUrlTarget.href = assetUrl;
        this.assetUrlTarget.classList.remove("hidden");
      } else {
        this.assetUrlTarget.classList.add("hidden");
      }
    }
  };
  /**
   * Static values to hold campaign URLs and asset URLs.
   * @type {Object}
   */
  __publicField(code_controller_default, "values", {
    campaignUrls: Object,
    assetUrls: Object
  });
  /**
   * Static targets to reference HTML elements within the controller's scope.
   * @type {string[]}
   */
  __publicField(code_controller_default, "targets", ["code", "campaign", "fullUrl", "socials", "assetUrl", "previewUrl"]);

  // app/javascript/controllers/commandbar_controller.js
  init_define_process();
  init_jquery();
  var commandbar_controller_default = class extends application_controller_default {
    toggleCommandBar() {
      if (window.CommandBar !== void 0) {
        window.CommandBar.toggleHelpHub();
      }
    }
  };

  // app/javascript/controllers/country_and_region_select_controller.js
  init_define_process();
  init_jquery();
  var country_and_region_select_controller_default = class extends application_controller_default {
    updateRegionUrlValue(event2) {
      const countryId = event2.target.value;
      $(this.regionTarget).val(null).trigger("change");
      const superSelectController = this.application.getControllerForElementAndIdentifier(
        this.regionTarget.parentElement,
        "fields--super-select"
      );
      superSelectController.searchUrlValue = this.searchUrlValue.replace(/\d+/g, countryId);
    }
    updateRegionUrlValueWithIso2(event2) {
      const countryId = event2.target.options[event2.target.selectedIndex].dataset.id;
      $(this.regionTarget).val(null).trigger("change");
      const superSelectController = this.application.getControllerForElementAndIdentifier(
        this.regionTarget.parentElement,
        "fields--super-select"
      );
      superSelectController.searchUrlValue = this.searchUrlValue.replace(/\d+/g, countryId);
    }
  };
  __publicField(country_and_region_select_controller_default, "targets", ["country", "region"]);
  __publicField(country_and_region_select_controller_default, "values", { searchUrl: String });

  // app/javascript/controllers/fields/phone_controller.js
  init_define_process();
  init_jquery();
  var import_intl_tel_input = __toESM(require_intl_tel_input());
  var phone_controller_default = class extends application_controller_default {
    connect() {
      this.initPluginInstance();
    }
    disconnect() {
      this.teardownPluginInstance();
    }
    initPluginInstance() {
      let options = {
        hiddenInput: this.fieldTarget.dataset.method,
        customContainer: "w-full"
      };
      const utilsScriptPath = metaContent("intl_tel_input_utils_path");
      if (utilsScriptPath) {
        options["utilsScript"] = utilsScriptPath;
      }
      options["localizedCountries"] = this.localizedCountriesValue;
      if (this.separateDialCodeValue) {
        options["separateDialCode"] = true;
      }
      this.plugin = (0, import_intl_tel_input.default)(this.fieldTarget, options);
    }
    teardownPluginInstance() {
      if (this.plugin === void 0) {
        return;
      }
      this.plugin.destroy();
    }
  };
  __publicField(phone_controller_default, "targets", ["field"]);
  __publicField(phone_controller_default, "values", {
    localizedCountries: { type: Object, default: {} },
    separateDialCode: { type: Boolean, default: false }
  });
  function metaContent(name2) {
    const element = document.head.querySelector(`meta[name="${name2}"]`);
    return element && element.content;
  }

  // app/javascript/controllers/fields/phone_verification_controller.js
  init_define_process();
  init_jquery();
  var phone_verification_controller_default = class extends application_controller_default {
    connect() {
      this.intlTel = window.intlTelInputGlobals.getInstance(this.fieldTarget);
      this.initialFieldValue = stripNonNumeric(this.fieldTarget.value);
      this.updateUI();
      this.fieldTarget.addEventListener("input", () => this.handleFieldVerification());
    }
    handleFieldVerification() {
      const currentFieldValue = stripNonNumeric(this.fieldTarget.value);
      const isVerifiedValue = this.verifiedValue && currentFieldValue === this.initialFieldValue;
      this.verifiedValue = isVerifiedValue;
      this.updateUI();
    }
    updateVerifyLink(event2) {
      event2.preventDefault();
      this.initialFieldValue = stripNonNumeric(this.fieldTarget.value);
      const url = new URL(this.linkTarget.href);
      this.fieldTarget.classList.add("rounded-r-none");
      url.searchParams.set(this.phoneParamNameValue, this.intlTel.getNumber());
      Turbo.visit(url.toString(), { frame: "dialog" });
    }
    updateUI() {
      const currentFieldValue = stripNonNumeric(this.fieldTarget.value);
      const isVerifiedValue = this.verifiedValue && currentFieldValue === this.initialFieldValue;
      this.badgeTarget.classList.toggle("hidden", !isVerifiedValue);
      this.fieldTarget.classList.toggle("rounded-r-none", !this.badgeTarget.classList.contains("hidden"));
      this.actionsTarget.classList.toggle("hidden", isVerifiedValue || !currentFieldValue);
    }
  };
  __publicField(phone_verification_controller_default, "targets", ["field", "link", "actions", "badge"]);
  __publicField(phone_verification_controller_default, "values", {
    verified: { type: Boolean, default: false },
    phoneParamName: String
  });
  function stripNonNumeric(value) {
    return value ? value.replace(/\D/g, "").trim() : "";
  }

  // app/javascript/controllers/iframe_message_relay_controller.js
  init_define_process();
  init_jquery();
  var iframe_message_relay_controller_default = class extends application_controller_default {
    /**
     * Sets up the bound handler to properly reference for the event listener.
     */
    initialize() {
      this._iframeMessageHandler = this.iframeMessageHandler.bind(this);
    }
    /**
     * Setup the handler listener
     */
    connect() {
      window.addEventListener("message", this._iframeMessageHandler);
    }
    /**
     * Removes the handler
     */
    disconnect() {
      window.removeEventListener("message", this._iframeMessageHandler);
    }
    /**
     * Handles the iframe message. If a key is present and its value matches one of the events
     * in eventsValue, it'll dispatch the event as iframe-message-relay:EVENT-NAME.
     * If object.data contains both a `path` value and `followLink: true` value, it'll navigate to the path
     * instead of redispatching the event.
     * @private
     * @param {object} obj - The message object containing data from the iframe postMessage
     * @param {object} obj.data - The data object within the message.
     */
    iframeMessageHandler({ data }) {
      if (!this.eventMatched(data)) return;
      if (this.shouldFollowLink(data)) {
        Turbo.visit(data.path);
      } else {
        this.redispatchEvent(data);
      }
    }
    /**
     * Checks if the event matches one of the passed in controller event values.
     * @private
     * @param {Object} data - The data object.
     * @returns {boolean} - True if the event matches, false otherwise.
     */
    eventMatched(data) {
      return this.eventsValue.includes(data[this.eventNameKeyValue]);
    }
    /**
     * Checks if the event should follow the link by looking for a followLink key in the data object.
     * @private
     * @param {object} data - The data object.
     * @returns {boolean} - True if the event should follow the link, false otherwise.
     */
    shouldFollowLink(data) {
      return data.followLink;
    }
    /**
     * Re-dispatches the event to the controller, prepending iframe-message-relay: to the event name.
     * @private
     * @param {object} data - The data object.
     */
    redispatchEvent(data) {
      this.dispatch(data[this.eventNameKeyValue], {
        detail: data,
        bubbles: true
      });
    }
  };
  __publicField(iframe_message_relay_controller_default, "values", {
    eventNameKey: { type: String, default: "eventName" },
    events: Array
  });

  // app/javascript/controllers/components/image_loader_controller.js
  init_define_process();
  init_jquery();
  var image_loader_controller_default = class extends application_controller_default {
    initialize() {
      this.controller = new AbortController();
      this.imageLoadedBound = this.imageLoaded.bind(this);
    }
    connect() {
      this.imageTarget.complete ? this.removeLoadingIndicator() : this.setupListener();
    }
    setupListener() {
      this.imageTarget.addEventListener("load", this.imageLoadedBound, { signal: this.controller.signal });
    }
    removeLoadingIndicator() {
      if (!this.hasLoadingIndicatorTarget) return;
      this.loadingIndicatorTarget.remove();
    }
    destroyListener() {
      this.controller.abort();
    }
    imageLoaded() {
      this.destroyListener();
      this.removeLoadingIndicator();
    }
    disconnect() {
      this.destroyListener();
    }
  };
  __publicField(image_loader_controller_default, "targets", ["image", "loadingIndicator"]);

  // app/javascript/controllers/image_file_field_preview_controller.js
  init_define_process();
  init_jquery();
  var _instances, insertHiddenRemoveImageField_fn;
  var image_file_field_preview_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      __privateAdd(this, _instances);
    }
    handleFileSelected(event2) {
      const file = Array.from(event2.target.files)[0];
      if (file) {
        this.previewTarget.src = URL.createObjectURL(file);
        if (this.hasRemoveImageTarget) {
          this.removeImageTarget.remove();
        }
      }
    }
    removeAndShowDefaultImage() {
      this.fileFieldTarget.value = null;
      this.previewTarget.src = this.defaultImageUrlValue;
      __privateMethod(this, _instances, insertHiddenRemoveImageField_fn).call(this);
      this.fileFieldTarget.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    }
  };
  _instances = new WeakSet();
  insertHiddenRemoveImageField_fn = function() {
    const removeImageField = document.createElement("input");
    removeImageField.type = "hidden";
    removeImageField.name = this.destroyImageParamNameValue;
    removeImageField.value = "1";
    removeImageField.dataset.imageFileFieldPreviewTarget = "removeImage";
    this.fileFieldTarget.after(removeImageField);
  };
  __publicField(image_file_field_preview_controller_default, "targets", ["fileField", "preview", "removeImage"]);
  __publicField(image_file_field_preview_controller_default, "values", {
    defaultImageUrl: String,
    destroyImageParamName: { type: String, default: "_destroy" }
  });

  // app/javascript/controllers/orders/payment_methods_controller.js
  init_define_process();
  init_jquery();

  // node_modules/@rails/request.js/src/index.js
  init_define_process();
  init_jquery();

  // node_modules/@rails/request.js/src/fetch_request.js
  init_define_process();
  init_jquery();

  // node_modules/@rails/request.js/src/fetch_response.js
  init_define_process();
  init_jquery();
  var FetchResponse2 = class {
    constructor(response2) {
      this.response = response2;
    }
    get statusCode() {
      return this.response.status;
    }
    get redirected() {
      return this.response.redirected;
    }
    get ok() {
      return this.response.ok;
    }
    get unauthenticated() {
      return this.statusCode === 401;
    }
    get unprocessableEntity() {
      return this.statusCode === 422;
    }
    get authenticationURL() {
      return this.response.headers.get("WWW-Authenticate");
    }
    get contentType() {
      const contentType = this.response.headers.get("Content-Type") || "";
      return contentType.replace(/;.*$/, "");
    }
    get headers() {
      return this.response.headers;
    }
    get html() {
      if (this.contentType.match(/^(application|text)\/(html|xhtml\+xml)$/)) {
        return this.text;
      }
      return Promise.reject(new Error(`Expected an HTML response but got "${this.contentType}" instead`));
    }
    get json() {
      if (this.contentType.match(/^application\/.*json$/)) {
        return this.responseJson || (this.responseJson = this.response.json());
      }
      return Promise.reject(new Error(`Expected a JSON response but got "${this.contentType}" instead`));
    }
    get text() {
      return this.responseText || (this.responseText = this.response.text());
    }
    get isTurboStream() {
      return this.contentType.match(/^text\/vnd\.turbo-stream\.html/);
    }
    async renderTurboStream() {
      if (this.isTurboStream) {
        if (window.Turbo) {
          await window.Turbo.renderStreamMessage(await this.text);
        } else {
          console.warn("You must set `window.Turbo = Turbo` to automatically process Turbo Stream events with request.js");
        }
      } else {
        return Promise.reject(new Error(`Expected a Turbo Stream response but got "${this.contentType}" instead`));
      }
    }
  };

  // node_modules/@rails/request.js/src/request_interceptor.js
  init_define_process();
  init_jquery();
  var RequestInterceptor = class {
    static register(interceptor) {
      this.interceptor = interceptor;
    }
    static get() {
      return this.interceptor;
    }
    static reset() {
      this.interceptor = void 0;
    }
  };

  // node_modules/@rails/request.js/src/lib/utils.js
  init_define_process();
  init_jquery();
  function getCookie(name2) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const prefix2 = `${encodeURIComponent(name2)}=`;
    const cookie = cookies.find((cookie2) => cookie2.startsWith(prefix2));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      if (value) {
        return decodeURIComponent(value);
      }
    }
  }
  function compact(object) {
    const result = {};
    for (const key in object) {
      const value = object[key];
      if (value !== void 0) {
        result[key] = value;
      }
    }
    return result;
  }
  function metaContent2(name2) {
    const element = document.head.querySelector(`meta[name="${name2}"]`);
    return element && element.content;
  }
  function stringEntriesFromFormData(formData) {
    return [...formData].reduce((entries, [name2, value]) => {
      return entries.concat(typeof value === "string" ? [[name2, value]] : []);
    }, []);
  }
  function mergeEntries(searchParams, entries) {
    for (const [name2, value] of entries) {
      if (value instanceof window.File) continue;
      if (searchParams.has(name2) && !name2.includes("[]")) {
        searchParams.delete(name2);
        searchParams.set(name2, value);
      } else {
        searchParams.append(name2, value);
      }
    }
  }

  // node_modules/@rails/request.js/src/fetch_request.js
  var FetchRequest2 = class {
    constructor(method, url, options = {}) {
      this.method = method;
      this.options = options;
      this.originalUrl = url.toString();
    }
    async perform() {
      try {
        const requestInterceptor = RequestInterceptor.get();
        if (requestInterceptor) {
          await requestInterceptor(this);
        }
      } catch (error3) {
        console.error(error3);
      }
      const response2 = new FetchResponse2(await window.fetch(this.url, this.fetchOptions));
      if (response2.unauthenticated && response2.authenticationURL) {
        return Promise.reject(window.location.href = response2.authenticationURL);
      }
      const responseStatusIsTurboStreamable = response2.ok || response2.unprocessableEntity;
      if (responseStatusIsTurboStreamable && response2.isTurboStream) {
        await response2.renderTurboStream();
      }
      return response2;
    }
    addHeader(key, value) {
      const headers = this.additionalHeaders;
      headers[key] = value;
      this.options.headers = headers;
    }
    sameHostname() {
      if (!this.originalUrl.startsWith("http:")) {
        return true;
      }
      try {
        return new URL(this.originalUrl).hostname === window.location.hostname;
      } catch (_26) {
        return true;
      }
    }
    get fetchOptions() {
      return {
        method: this.method.toUpperCase(),
        headers: this.headers,
        body: this.formattedBody,
        signal: this.signal,
        credentials: this.credentials,
        redirect: this.redirect
      };
    }
    get headers() {
      const baseHeaders = {
        "X-Requested-With": "XMLHttpRequest",
        "Content-Type": this.contentType,
        Accept: this.accept
      };
      if (this.sameHostname()) {
        baseHeaders["X-CSRF-Token"] = this.csrfToken;
      }
      return compact(
        Object.assign(baseHeaders, this.additionalHeaders)
      );
    }
    get csrfToken() {
      return getCookie(metaContent2("csrf-param")) || metaContent2("csrf-token");
    }
    get contentType() {
      if (this.options.contentType) {
        return this.options.contentType;
      } else if (this.body == null || this.body instanceof window.FormData) {
        return void 0;
      } else if (this.body instanceof window.File) {
        return this.body.type;
      }
      return "application/json";
    }
    get accept() {
      switch (this.responseKind) {
        case "html":
          return "text/html, application/xhtml+xml";
        case "turbo-stream":
          return "text/vnd.turbo-stream.html, text/html, application/xhtml+xml";
        case "json":
          return "application/json, application/vnd.api+json";
        default:
          return "*/*";
      }
    }
    get body() {
      return this.options.body;
    }
    get query() {
      const originalQuery = (this.originalUrl.split("?")[1] || "").split("#")[0];
      const params = new URLSearchParams(originalQuery);
      let requestQuery = this.options.query;
      if (requestQuery instanceof window.FormData) {
        requestQuery = stringEntriesFromFormData(requestQuery);
      } else if (requestQuery instanceof window.URLSearchParams) {
        requestQuery = requestQuery.entries();
      } else {
        requestQuery = Object.entries(requestQuery || {});
      }
      mergeEntries(params, requestQuery);
      const query = params.toString();
      return query.length > 0 ? `?${query}` : "";
    }
    get url() {
      return this.originalUrl.split("?")[0].split("#")[0] + this.query;
    }
    get responseKind() {
      return this.options.responseKind || "html";
    }
    get signal() {
      return this.options.signal;
    }
    get redirect() {
      return this.options.redirect || "follow";
    }
    get credentials() {
      return this.options.credentials || "same-origin";
    }
    get additionalHeaders() {
      return this.options.headers || {};
    }
    get formattedBody() {
      const bodyIsAString = Object.prototype.toString.call(this.body) === "[object String]";
      const contentTypeIsJson = this.headers["Content-Type"] === "application/json";
      if (contentTypeIsJson && !bodyIsAString) {
        return JSON.stringify(this.body);
      }
      return this.body;
    }
  };

  // node_modules/@rails/request.js/src/verbs.js
  init_define_process();
  init_jquery();
  async function get2(url, options) {
    const request2 = new FetchRequest2("get", url, options);
    return request2.perform();
  }
  async function post(url, options) {
    const request2 = new FetchRequest2("post", url, options);
    return request2.perform();
  }

  // app/javascript/utils/toast.js
  init_define_process();
  init_jquery();
  function toast(type, message, toasterFrameId = "toaster", duration = 0) {
    let toastContent = document.querySelector(`template[data-id='toast-template'][data-type=${type}]`).content.cloneNode(true);
    if (duration > 0) {
      toastContent.querySelector("sl-alert").setAttribute("duration", duration);
    }
    toastContent.getElementById("alert-message").innerText = message;
    document.getElementById(toasterFrameId).appendChild(toastContent);
  }

  // app/javascript/controllers/orders/payment_methods_controller.js
  var payment_methods_controller_default = class extends application_controller_default {
    connect() {
      if (!Rebilly.initialized) {
        var config = {
          organizationId: this.organizationIdValue,
          publishableKey: this.publishableKeyValue,
          kountAccountId: "700000"
          // This is for capturing kount fraud sessions
        };
        Rebilly.initialize(config);
      }
      Rebilly.on("ready", () => {
        this.card = Rebilly.card.mount(this.cardMountElementTarget);
      });
    }
    async submit(event2) {
      event2.preventDefault();
      event2.stopPropagation();
      const form = this.cardFormTarget;
      const address = {
        firstName: this.rebillyFirstNameValue,
        lastName: this.rebillyLastNameValue,
        address: this.rebillyAddressValue,
        address2: this.rebillyAddress2Value,
        city: this.rebillyCityValue,
        country: this.rebillyCountryValue,
        region: this.rebillyRegionValue,
        postalCode: this.rebillyPostalCodeValue
      };
      const extraData = {
        billingAddress: address,
        method: "payment-card"
      };
      this.submitButtonTarget.setAttribute("disabled", "");
      try {
        const paymentToken = await Rebilly.createToken(form, extraData);
        const data = {
          billing_payment_method: {
            live_mode: this.liveModeValue,
            rebilly_token: paymentToken.id,
            order_id: this.orderIdValue
          }
        };
        const action = this.formActionValue;
        const response2 = await post(action, {
          body: JSON.stringify(data),
          responseKind: "turbo-stream"
        });
        if (response2.ok) {
          console.log("Response was successful");
        }
      } catch (error3) {
        console.log("Create token error:", error3);
        toast("alert", error3.message);
        this.submitButtonTarget.removeAttribute("disabled", "");
      }
    }
    disconnect() {
      if (this.card) {
        this.card.unmount();
      }
    }
  };
  __publicField(payment_methods_controller_default, "targets", [
    "cardForm",
    "cardMountElement",
    "paymentMethodForm",
    "rebillyToken",
    "paymentMethod",
    "submitButton"
  ]);
  __publicField(payment_methods_controller_default, "values", {
    organizationId: String,
    publishableKey: String,
    liveMode: String,
    orderId: String,
    formAction: String,
    rebillyFirstName: String,
    rebillyLastName: String,
    rebillyAddress: String,
    rebillyAddress2: String,
    rebillyCity: String,
    rebillyCountry: String,
    rebillyRegion: String,
    rebillyPostalCode: String
  });

  // app/javascript/controllers/orders/stripe_payment_controller.js
  init_define_process();
  init_jquery();
  var stripe_payment_controller_default = class extends application_controller_default {
    connect() {
      this.initializeOutofBandElements();
      this.initializePaymentMethodGroups();
      if (this.allowCreditCardFieldEntryValue) {
        this.paymentElementReady = false;
        this.initializeStripe();
        this.selectedMethod = "stripe";
      } else {
        this.selectedMethod = "existing-payment-method";
      }
    }
    async handleSubmit(e2) {
      if (e2.offsetX === 0) {
        e2.preventDefault();
        return;
      }
      this.selectedMethodTarget.value = this.selectedMethod;
      if (this.stripeSelected()) {
        this.submitStripe(e2);
      } else if (this.outOfBandSelected()) {
        this.submitOutOfBand(e2);
      }
    }
    async submitOutOfBand() {
      this.setLoading(true);
    }
    async submitStripe(e2) {
      e2.preventDefault();
      this.setLoading(true);
      this.hideErrorMessage();
      if (this.hideTimeoutId) {
        clearTimeout(this.hideTimeoutId);
      }
      const { error: submitError } = await this.elements.submit();
      if (submitError) {
        this.setLoading(false);
        return;
      }
      const { error: error3, confirmationToken } = await this.stripe.createConfirmationToken({
        elements: this.elements,
        params: {
          payment_method_data: {
            billing_details: this.billingDetailsValue,
            allow_redisplay: "always"
          }
        }
      });
      if (error3) {
        this.showErrorMessage(error3.message);
        this.setLoading(false);
        return;
      }
      if (confirmationToken) {
        const formData = new FormData(this.formTarget);
        this.appendNestedObjectToFormData(formData, "confirmation_token", confirmationToken);
        const request2 = new FetchRequest2("PUT", this.confirmationTokenPathValue, {
          responseKind: "json",
          body: formData
        });
        request2.perform().then((response2) => response2.json).then((response2) => {
          if (response2.status === "succeeded") {
            this.redirectToFinalUrl(response2);
          } else if (response2.status === "processing") {
            this.redirectToFinalUrl(response2);
          } else if (response2.status === "requires_action") {
            this.stripe.handleNextAction({
              clientSecret: response2.client_secret
            }).then(({ error: error4 }) => {
              if (error4) {
                this.showErrorMessage(error4.message);
                this.setLoading(false);
              } else {
                this.redirectToFinalUrl(response2);
              }
            });
          } else {
            if (response2.error) {
              this.showErrorMessage(response2.error.message);
            }
            this.setLoading(false);
          }
        }).catch(() => {
          this.showErrorMessage(this.systemErrorMessageValue);
          this.setLoading(false);
        });
      }
    }
    redirectToFinalUrl(response2) {
      const url = new URL(this.returnUrlValue);
      url.searchParams.append(response2.object, response2.id);
      Turbo.visit(url.toString());
    }
    setLoading(isLoading) {
      this.isLoading = isLoading;
      if (isLoading) {
        this.submitPaymentButtonTarget.querySelector("#spinner").classList.remove("hidden");
        this.submitPaymentButtonTarget.querySelector("#button-text").classList.add("hidden");
        setTimeout(() => this.submitPaymentButtonTarget.setAttribute("disabled", ""), 1);
      } else {
        this.setSubmitButtonState();
        this.submitPaymentButtonTarget.querySelector("#spinner").classList.add("hidden");
        this.submitPaymentButtonTarget.querySelector("#button-text").classList.remove("hidden");
      }
    }
    showErrorMessage(messageText, isPermanent = false) {
      this.messageContainer.classList.remove("hidden");
      this.messageContainer.textContent = messageText;
      if (!isPermanent) {
        this.hideTimeoutId = setTimeout(() => {
          this.hideErrorMessage();
        }, 5e3);
      }
    }
    hideErrorMessage() {
      this.messageContainer.classList.add("hidden");
      this.messageContainer.textContent = "";
    }
    hasBillingDetails() {
      return this.billingDetailsValue.address?.country?.trim() && this.billingDetailsValue.address?.postal_code?.trim();
    }
    initializePaymentMethodGroups() {
      const container = document.querySelector(".payment-method-details-group");
      container.addEventListener("sl-show", (event2) => {
        if (this.isLoading) {
          event2.preventDefault();
          return;
        }
        ;
        [...container.querySelectorAll("sl-details")].map((details) => {
          details.open = event2.target === details;
          if (details.open) {
            this.selectedMethod = details.dataset["paymentMethodType"];
          }
          this.setSubmitButtonState();
        });
      });
    }
    initializeOutofBandElements() {
      this.outOfBandElementTargets.forEach((item) => {
        item.addEventListener("change", (e2) => {
          this.setSubmitButtonState();
          const outOfBandElementValue = e2.target.value;
          if (outOfBandElementValue == "cash") {
            this.cashTarget.classList.remove("hidden");
            this.checkTarget.classList.add("hidden");
          }
          if (outOfBandElementValue == "check") {
            this.checkTarget.classList.remove("hidden");
            this.cashTarget.classList.add("hidden");
          }
          if (outOfBandElementValue == "miscellaneous") {
            this.cashTarget.classList.add("hidden");
            this.checkTarget.classList.add("hidden");
          }
        });
      });
    }
    initializeStripe() {
      this.stripe = Stripe(this.publicKeyValue, {
        stripeAccount: this.stripeAccountIdValue,
        betas: ["disable_link_passthrough_beta_1", "disable_deferred_intent_client_validation_beta_1"]
      });
      const options = {
        currency: this.currencyValue,
        customerSessionClientSecret: this.clientSecretValue,
        // Fully customizable with appearance API.
        appearance: {
          /*...*/
        }
      };
      if (this.totalAmountValue > 0) {
        options.amount = this.totalAmountValue;
        options.mode = this.modeValue;
      } else {
        options.mode = "setup";
      }
      if (this.useDynamicPaymentMethodsValue) {
        if (this.modeValue === "subscription") {
          options.setup_future_usage = "off_session";
        }
      } else {
        options.payment_method_types = ["card"];
        options.setup_future_usage = "off_session";
      }
      const paymentElementOptions = {
        layout: "tabs",
        fields: {
          billingDetails: this.hasBillingDetails() ? "never" : "auto"
        }
      };
      this.elements = this.stripe.elements(options);
      this.paymentElement = this.elements.create("payment", paymentElementOptions);
      this.paymentElement.on("loaderror", (event2) => {
        this.showErrorMessage(event2.error.message, true);
        this.setLoading(false);
      });
      this.paymentElement.on("ready", () => {
        this.paymentElementReady = true;
        this.setSubmitButtonState();
      });
      try {
        this.paymentElement.mount("#payment-element");
      } catch (error3) {
        this.showErrorMessage(error3.message, true);
        this.setLoading(false);
      }
      this.messageContainer = document.querySelector("#payment-message");
    }
    stripeSelected() {
      return this.selectedMethod === "stripe";
    }
    outOfBandSelected() {
      return this.selectedMethod === "out-of-band";
    }
    setSubmitButtonState() {
      if (this.isLoading) {
        return;
      }
      this.submitPaymentButtonTarget.setAttribute("disabled", "");
      if (this.stripeSelected()) {
        if (this.paymentElementReady) {
          this.submitPaymentButtonTarget.removeAttribute("disabled");
        }
      } else if (this.outOfBandSelected() && this.outOfBandElementTargets.find((e2) => e2.checked)) {
        this.submitPaymentButtonTarget.removeAttribute("disabled");
      }
    }
    appendNestedObjectToFormData(formData, key, value) {
      if (typeof value === "object" && value !== null) {
        for (const [nestedKey, nestedValue] of Object.entries(value)) {
          this.appendNestedObjectToFormData(formData, `${key}[${nestedKey}]`, nestedValue);
        }
      } else {
        formData.append(key, value !== null ? value : "");
      }
    }
  };
  __publicField(stripe_payment_controller_default, "values", {
    publicKey: String,
    clientSecret: String,
    stripeAccountId: String,
    returnUrl: String,
    billingDetails: Object,
    totalAmount: Number,
    mode: String,
    currency: String,
    confirmationTokenPath: String,
    systemErrorMessage: String,
    allowCreditCardFieldEntry: { type: Boolean, default: true },
    useDynamicPaymentMethods: { type: Boolean, default: false }
  });
  __publicField(stripe_payment_controller_default, "targets", ["outOfBandElement", "cash", "check", "submitPaymentButton", "selectedMethod", "form"]);

  // app/javascript/controllers/orders/plan_preview_controller.js
  init_define_process();
  init_jquery();
  var plan_preview_controller_default = class extends application_controller_default {
    connect() {
      this.fetchPreview();
    }
    async fetchPreview() {
      this.loadingTarget.classList.remove("hidden");
      this.tableTarget.classList.add("hidden");
      const formData = new FormData();
      formData.append("orders_line_item[variant_id]", this.variantIdValue);
      formData.append("orders_line_item[products_price_id]", this.priceIdValue);
      formData.append("orders_line_item[prorated]", 0);
      formData.append("orders_line_item[charge_now]", 1);
      const response2 = await post(this.urlValue, { body: formData, responseKind: "turbo-stream" });
      this.loadingTarget.classList.add("hidden");
      this.tableTarget.classList.remove("hidden");
    }
  };
  __publicField(plan_preview_controller_default, "targets", ["loading", "table"]);
  __publicField(plan_preview_controller_default, "values", {
    url: String,
    variantId: String,
    priceId: String
  });

  // app/javascript/controllers/payment_method_form_controller.js
  init_define_process();
  init_jquery();
  var payment_method_form_controller_default = class extends application_controller_default {
    showNotification(detail) {
      toast("alert", detail.message);
    }
    submit(form, data) {
      form.submit();
    }
    paymentForm() {
      return this.paymentMethodFormTarget;
    }
    hideOptions() {
      this.cardFormTarget.classList.add("hidden");
      this.achFormTarget.classList.add("hidden");
    }
    toggleForm() {
      this.hideOptions();
      if (this.selectedMethodTarget.value == "ach") {
        this.achFormTarget.classList.remove("hidden");
      }
      if (this.selectedMethodTarget.value == "payment-card") {
        this.cardFormTarget.classList.remove("hidden");
      }
    }
    unmountUnusedOption() {
      if (this.selectedMethodTarget.value == "ach") {
        this.mountedFrames.cardElements.forEach((item) => item.unmount());
      } else if (this.selectedMethodTarget.value == "payment-card") {
        this.mountedFrames.achElements.forEach((item) => item.unmount());
      }
    }
    mountUnusedOption() {
      if (this.selectedMethodTarget.value == "ach") {
        this.mountedFrames.cardElements.forEach((item) => item.mount());
      } else if (this.selectedMethodTarget.value == "payment-card") {
        this.mountedFrames.achElements.forEach((item) => item.mount());
      }
    }
    initRebilly() {
      console.debug("PaymentMethodForm Stimulus Controller initRebilly");
      if (!Rebilly.initialized) {
        var config = {
          publishableKey: this.publishableKeyValue,
          organizationId: this.organizationIdValue,
          kountAccountId: "700000"
          // This is for capturing kount fraud sessions
        };
        Rebilly.initialize(config);
      }
      const that = this;
      const form = this.paymentForm();
      const rebillyToken = this.rebillyTokenTarget;
      const paymentMethodSubmitted = { value: false };
      const paymentOptions = this.paymentOptionTargets;
      const cardNumberElement = this.cardNumberMountElementTarget;
      const cardExpElement = this.cardExpMountElementTarget;
      const cardCvvElement = this.cardCvvMountElementTarget;
      const bankTypeElement = this.bankTypeMountElementTarget;
      const bankNumberElement = this.bankNumberMountElementTarget;
      const bankRoutingElement = this.bankRoutingMountElementTarget;
      const submitPaymentButton = this.submitPaymentButtonTarget;
      const countrySelect = this.countrySelectTarget;
      const regionSelect = this.regionSelectTarget;
      this.mountedFrames = { achElements: [], cardElements: [] };
      paymentOptions.forEach((option) => {
        option.addEventListener("click", (event2) => {
          this.selectedMethodTarget.value = event2.target.dataset.value;
          this.toggleForm();
        });
      });
      Rebilly.on("ready", () => {
        this.card = Rebilly.card.mount(cardNumberElement, "cardNumber");
        this.exp = Rebilly.card.mount(cardExpElement, "cardExpiration");
        this.cvv = Rebilly.card.mount(cardCvvElement, "cardCvv");
        this.type = Rebilly.bankAccount.mount(bankTypeElement, "bankAccountType");
        this.number = Rebilly.bankAccount.mount(bankNumberElement, "bankAccountNumber");
        this.routing = Rebilly.bankAccount.mount(bankRoutingElement, "bankRoutingNumber");
        this.mountedFrames.achElements = [this.type, this.number, this.routing];
        this.mountedFrames.cardElements = [this.card, this.exp, this.cvv];
      });
      form.onsubmit = (e2) => {
        paymentMethodSubmitted.value = true;
        submitPaymentButton.setAttribute("disabled", "");
        e2.preventDefault();
        e2.stopPropagation();
        this.unmountUnusedOption();
        const extraData = {
          method: this.selectedMethodTarget.value,
          billingAddress: {
            country: countrySelect.options[countrySelect.selectedIndex].dataset.iso2,
            region: regionSelect.options[regionSelect.selectedIndex].text
          }
        };
        Rebilly.createToken(form, extraData).then((result) => {
          window.parent.postMessage("success", "*");
          rebillyToken.value = result.id;
          const data = {
            payment_method: {
              live_mode: form.elements.live_mode.value,
              rebilly_token: rebillyToken.value,
              description: form.elements["billing/payment_method_description"].value
            }
          };
          that.submit(form, data);
        }).catch((error3) => {
          paymentMethodSubmitted.value = false;
          submitPaymentButton.removeAttribute("disabled");
          this.mountUnusedOption();
          console.error("Framepay error", error3);
          error3.details.forEach(that.showNotification(error3));
          window.parent.postMessage("error", "*");
        });
      };
    }
    connect() {
      console.debug("PaymentMethodForm Stimulus Controller connect");
      this.selectedMethodTarget.value = "payment-card";
      if (typeof Rebilly !== "undefined") {
        console.debug("PaymentMethodForm Stimulus Controller rebilly is defined");
        this.initRebilly();
      } else {
        setTimeout(() => {
          this.initRebilly();
        }, 500);
      }
    }
    disconnect() {
      if (this.card) {
        this.card.unmount();
        this.exp.unmount();
        this.cvv.unmount();
      }
      if (this.type) {
        this.type.unmount();
        this.number.unmount();
        this.routing.unmount();
      }
    }
  };
  __publicField(payment_method_form_controller_default, "targets", [
    "paymentMethodForm",
    "rebillyToken",
    "selectedMethod",
    "paymentOption",
    "cardForm",
    "achForm",
    "cardNumberMountElement",
    "cardExpMountElement",
    "cardCvvMountElement",
    "bankTypeMountElement",
    "bankNumberMountElement",
    "bankRoutingMountElement",
    "submitPaymentButton",
    "countrySelect",
    "regionSelect"
  ]);
  __publicField(payment_method_form_controller_default, "values", {
    organizationId: String,
    publishableKey: String
  });

  // app/javascript/controllers/prefetch_handler_controller.js
  init_define_process();
  init_jquery();
  var prefetch_handler_controller_default = class extends application_controller_default {
    handlePrefetch(event2) {
      const lastPrefetchedAt = event2.target.dataset.turboLastPrefetchAt;
      if (this.eventInPrefetchCacheWindow(lastPrefetchedAt)) {
        event2.preventDefault();
        return;
      }
      this.setLastPrefetchedAt(event2.target);
    }
    getTimeDifference(startTime, endTime) {
      return parseInt(startTime) - parseInt(endTime);
    }
    eventInPrefetchCacheWindow(lastPrefetchedAt) {
      return this.getTimeDifference(this.now, lastPrefetchedAt) < this.cacheTtlValue;
    }
    setLastPrefetchedAt(element) {
      element.dataset.turboLastPrefetchAt = this.now;
    }
    get now() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  };
  __publicField(prefetch_handler_controller_default, "values", {
    cacheTtl: { type: Number, default: 1e4 }
  });

  // app/javascript/controllers/scroll_to_controller.js
  init_define_process();
  init_jquery();
  var ScrollController = class extends application_controller_default {
    connect() {
      if (this.runOnConnectValue) {
        this.scrollToElement();
      }
      if (this.highlightValue) {
        this.highlightTarget();
      }
    }
    /**
     * Scrolls to the target element with a short timeout to ensure DOM readiness.
     * Uses either mainContent.scrollTo or element.scrollIntoView depending on page structure.
     */
    scrollToElement() {
      setTimeout(() => {
        const target = this.getTarget();
        if (!target) return;
        this.performScroll(target);
      }, 0);
    }
    /**
     * Public action method that can be triggered from HTML or other controllers.
     * @example <button data-action="scroll-to#scroll">Scroll to Element</button>
     */
    scroll() {
      this.scrollToElement();
    }
    /**
     * Adds a highlight effect to the target element by adding the 'highlight-pulse' class.
     * The actual animation should be defined in CSS.
     */
    highlightTarget() {
      const target = this.getTarget();
      if (target) {
        target.classList.add("highlight-pulse");
      }
    }
    /**
     * Returns the DOM element to scroll to - either the controller element itself,
     * or a child element matching the selectorTarget value.
     *
     * @returns {HTMLElement|null} The target element, or null if not found
     */
    getTarget() {
      return this.hasSelectorTargetValue ? this.element.querySelector(this.selectorTargetValue) : this.element;
    }
    /**
     * Performs the actual scrolling operation on the target element.
     * Uses different scrolling strategies based on page structure.
     *
     * @param {HTMLElement} target - The element to scroll to
     */
    performScroll(target) {
      const mainContent = document.getElementById("main-content");
      if (mainContent) {
        mainContent.scrollTo({
          top: target.offsetTop - this.offsetValue,
          behavior: this.behaviorValue
        });
      } else {
        target.scrollIntoView({
          behavior: this.behaviorValue,
          block: this.blockValue,
          inline: this.inlineValue
        });
      }
    }
  };
  __publicField(ScrollController, "values", {
    /** @type {String} Scrolling behavior - 'auto' or 'smooth' */
    behavior: { type: String, default: "smooth" },
    /** @type {String} Vertical alignment - 'start', 'center', 'end', or 'nearest' */
    block: { type: String, default: "center" },
    /** @type {String} Horizontal alignment - 'start', 'center', 'end', or 'nearest' */
    inline: { type: String, default: "nearest" },
    /** @type {String} CSS selector for finding target element within controller element */
    selectorTarget: String,
    /** @type {Boolean} Whether to automatically scroll when controller connects */
    runOnConnect: { type: Boolean, default: true },
    /** @type {Boolean} Whether to add a highlight effect to the target element */
    highlight: { type: Boolean, default: false },
    /** @type {Number} Pixel offset to apply when scrolling (e.g., for fixed headers) */
    offset: { type: Number, default: 55 }
  });

  // app/javascript/controllers/mixpanel_controller.js
  init_define_process();
  init_jquery();
  var mixpanel_controller_default = class extends application_controller_default {
    /**
     * Initializes the controller. If mixpanel is not defined, it disconnects the controller.
     * Otherwise, it initializes mixpanel tracking.
     */
    connect() {
      if (typeof mixpanel === "undefined") {
        this.element.dataset.controller.replace("mixpanel", "");
        return;
      }
      this.initMixpanel();
    }
    /**
     * Tracks the click event on a specified element.
     * @param {Event} event - The event object containing parameters for tracking.
     * @param {Object} event.params - The parameters passed with the event.
     * @param {string} event.params.element - The element being tracked.
     * @param {string} event.params.label - The label for the tracked event.
     */
    track(event2) {
      if (typeof mixpanel === "undefined") {
        return;
      }
      this.trackClick(event2);
    }
    initMixpanel() {
      if (this.userIdValue) mixpanel.identify(this.userIdValue);
      if (this.teamIdValue) mixpanel.set_group("group_id", this.teamIdValue);
      this.trackPageView();
    }
    trackClick(event2) {
      const { element, label } = event2.params;
      const userId = this.userIdValue;
      const path = this.pathValue;
      const pageTitle = this.pageTitleValue;
      const groupId = this.teamIdValue;
      mixpanel.track("Element Clicked", {
        userId,
        element,
        label,
        path,
        pageTitle,
        group_id: groupId,
        $user_id: userId
      });
    }
    trackPageView() {
      mixpanel.track("Page Visited", {
        page: this.pageTitleValue,
        path: this.pathValue,
        userId: this.userIdValue,
        group_id: this.teamIdValue,
        $user_id: this.userIdValue
      });
    }
  };
  __publicField(mixpanel_controller_default, "values", {
    path: String,
    pageTitle: String,
    userId: String,
    teamId: String
  });

  // app/javascript/controllers/share_controller.js
  init_define_process();
  init_jquery();
  var share_controller_default = class extends application_controller_default {
    shareOnFacebook(event2) {
      const url = encodeURIComponent(event2.params.url);
      const quote = encodeURIComponent(event2.params.title);
      let hashtag = event2.params.hashtags ? event2.params.hashtags.split(",")[0].trim() : "";
      hashtag = hashtag ? encodeURIComponent(`#${hashtag}`) : "";
      const shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${url}&hashtag=${hashtag}&quote=${quote}`;
      this.openShareWindow(shareUrl);
    }
    shareOnTwitter(event2) {
      const url = encodeURIComponent(event2.params.url);
      const text = encodeURIComponent(event2.params.title);
      const hashtags = event2.params.hashtags ? encodeURIComponent(event2.params.hashtags.split(",").join(",")) : "";
      const shareUrl = `https://twitter.com/intent/tweet/?text=${text}&url=${url}&hashtags=${hashtags}`;
      this.openShareWindow(shareUrl);
    }
    shareOnLinkedIn(event2) {
      const url = encodeURIComponent(event2.params.url);
      const title = encodeURIComponent(event2.params.title);
      const shareUrl = `https://www.linkedin.com/shareArticle?mini=true&url=${url}&text=${title}`;
      this.openShareWindow(shareUrl);
    }
    shareByEmail(event2) {
      const url = encodeURIComponent(event2.params.url);
      const subject = encodeURIComponent(event2.params.subject || event2.params.title);
      const body = encodeURIComponent(`${event2.params.title} ${url}`);
      const shareUrl = `mailto:?subject=${subject}&body=${body}`;
      window.location.href = shareUrl;
    }
    shareBySms(event2) {
      const body = `${event2.params.title} ${event2.params.url}`;
      window.location.href = `sms:?&body=${body}`;
    }
    openShareWindow(url) {
      window.open(
        url,
        "_blank",
        "height=450, width=550, top=" + (window.innerHeight / 2 - 275) + ", left=" + (window.innerWidth / 2 - 225) + ", toolbar=0, location=0, menubar=0, directories=0, scrollbars=0"
      );
    }
  };

  // app/javascript/controllers/short_token_controller.js
  init_define_process();
  init_jquery();
  var short_token_controller_default = class extends application_controller_default {
    connect() {
      this.abortController = new AbortController();
      this.setupEventListeners();
    }
    disconnect() {
      this.abortController.abort();
    }
    setupEventListeners() {
      const target = this.hasOtpFieldContainerTarget ? this.otpFieldContainerTarget : this.otpFormTarget;
      target.addEventListener("paste", this.handlePaste.bind(this), {
        signal: this.abortController.signal
      });
      target.addEventListener("input", this.handleInput.bind(this), {
        signal: this.abortController.signal
      });
      target.addEventListener("keydown", this.handleBackspace.bind(this), {
        signal: this.abortController.signal
      });
    }
    handlePaste(event2) {
      const pastedValue = (event2.clipboardData || window.clipboardData).getData("text").trim();
      if (pastedValue.length !== this.otpLength) return;
      this.fillOtpFields(pastedValue);
      this.otpFieldTargets[this.otpLength - 1].focus();
    }
    handleInput(event2) {
      const currentInput2 = event2.target;
      const index2 = this.otpFieldTargets.indexOf(currentInput2);
      if (currentInput2.value.length === 1 && index2 < this.otpLength - 1) {
        this.otpFieldTargets[index2 + 1].focus();
      }
      setTimeout(() => this.syncHiddenInput());
    }
    handleBackspace(event2) {
      if (event2.key !== "Backspace") return;
      const currentInput2 = event2.target;
      const index2 = this.otpFieldTargets.indexOf(currentInput2);
      if (index2 > 0 && !currentInput2.value) {
        this.otpFieldTargets[index2 - 1].focus();
      }
      setTimeout(() => this.syncHiddenInput());
    }
    syncHiddenInput() {
      if (this.otpFieldTargets.some((input) => !input.value)) {
        return;
      }
      const otpValue = this.otpFieldTargets.map((input) => input.value).join("");
      this.hiddenInputTarget.value = otpValue;
      if (this.autoSubmitValue) {
        this.submitForm();
      }
    }
    fillOtpFields(value) {
      this.otpFieldTargets.forEach((input, index2) => {
        input.value = value[index2] || "";
      });
    }
    handleRecoveryCodeInput() {
      this.hiddenInputTarget.value = this.recoveryCodeInputTarget.value;
    }
    submitForm() {
      if (this.emulateSubmitValue && this.hasSubmitButtonTarget) {
        this.otpFormTarget.requestSubmit(this.submitButtonTarget);
      } else {
        this.otpFormTarget.requestSubmit();
      }
    }
    get otpLength() {
      return this.otpFieldTargets.length;
    }
  };
  __publicField(short_token_controller_default, "targets", ["otpField", "submitButton", "otpForm", "hiddenInput", "recoveryCodeInput", "otpFieldContainer"]);
  __publicField(short_token_controller_default, "values", {
    autoSubmit: { type: Boolean, default: true },
    emulateSubmit: Boolean
  });

  // app/javascript/controllers/fields/super_select_add_option_controller.js
  init_define_process();
  init_jquery();
  var super_select_add_option_controller_default = class extends application_controller_default {
    connect() {
      this.selectedIndex = this.nameSelectTarget.selectedIndex;
    }
    newValueIsSelected() {
      return this.nameSelectTarget.options[this.nameSelectTarget.selectedIndex].value === "_new";
    }
    selectOption(e2) {
      if (this.newValueIsSelected()) {
        this.toggleTargets.forEach((el) => el.classList.toggle("hidden"));
        this.nameInputTarget.focus();
        this.nameInputTarget.value = "";
      } else {
        this.selectedIndex = this.nameSelectTarget.selectedIndex;
      }
    }
    toggle(e2) {
      e2.preventDefault();
      this.toggleTargets.forEach((el) => el.classList.toggle("hidden"));
      if (this.newValueIsSelected()) {
        this.nameSelectTarget.selectedIndex = 0;
      } else {
        this.nameSelectTarget.selectedIndex = this.selectedIndex;
      }
      this.nameSelectTarget.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      this.nameInputTarget.value = "";
    }
    updateNameField(e2) {
      if (this.newValueIsSelected()) {
        this.nameInputTarget.value = "";
      } else {
        this.nameInputTarget.value = e2.target.value;
      }
    }
    updateCollapsedFormOption() {
      this.collapsedOptionNameTarget.innerHTML = this.nameInputTarget.value + ":";
    }
  };
  __publicField(super_select_add_option_controller_default, "targets", ["toggle", "nameSelectWrapper", "nameSelect", "nameInput", "collapsedOptionName"]);

  // app/javascript/controllers/fields/super_select_controller.js
  init_define_process();
  init_jquery();
  var import_jquery145 = __toESM(require_jquery());
  require_select2()();
  require_en();
  require_es();
  require_pt();
  require_ja();
  var super_select_controller_default = class extends application_controller_default {
    connect() {
      this.dispatchNativeEventBoundFn = this.dispatchNativeEvent.bind(this);
      this.initPluginInstance();
      this.closeSelectDropdownAfterClearing();
    }
    disconnect() {
      this.teardownPluginInstance();
    }
    // TODO may want to re-evaluate
    // This is called when going from initial undefined value to a blank string
    // when the controller is connected
    searchUrlValueChanged(newValue, prevValue) {
      if (newValue === prevValue) return;
      this.initPluginInstance();
    }
    cleanupBeforeInit() {
      (0, import_jquery145.default)(this.element).find(".select2-container--default").remove();
    }
    initPluginInstance() {
      const locale = api.get("locale") || "en";
      let $select2;
      let options = {
        dropdownParent: (0, import_jquery145.default)(this.element),
        language: locale
      };
      if (this.hasDataValue) {
        options.data = this.dataValue;
      }
      if (!this.enableSearchValue) {
        options.minimumResultsForSearch = -1;
      }
      if (this.maximumSelectionLengthValue > 0) {
        options.maximumSelectionLength = this.maximumSelectionLengthValue;
      }
      if (this.maximumInputLengthValue > 0) {
        options.maximumInputLength = this.maximumInputLengthValue;
      }
      if (this.noResultsMessageValue) {
        options.language = {
          noResults: () => this.noResultsMessageValue
        };
      }
      options.allowClear = this.allowClearValue;
      options.placeholder = this.placeholderValue;
      options.tags = this.acceptsNewValue;
      options.templateResult = this.formatState;
      options.templateSelection = this.formatState;
      options.tokenSeparators = [","];
      options.width = this.containerWidthValue || "style";
      options.menuAsCheckboxes = this.menuAsCheckboxesValue;
      options.closeOnSelect = this.closeOnSelectValue;
      if (this.createPrefixValue.length > 0) {
        options.createTag = (params) => {
          var term = import_jquery145.default.trim(params.term);
          if (term === "") {
            return null;
          }
          return {
            id: term,
            text: `${this.createPrefixValue}: ${term}`,
            newTag: true
            // Add this property to indicate it's a new tag
          };
        };
        options.templateSelection = (selection) => {
          if (selection.id && selection.newTag) {
            selection.text = selection.text.replace(`${this.createPrefixValue}:`, "");
            return selection.text;
          }
          return selection.text;
        };
      }
      if (this.searchUrlValue) {
        options.ajax = {
          url: this.searchUrlValue,
          dataType: "json",
          // We enable pagination by default here
          data: function(params) {
            var query = {
              search: params.term,
              page: params.page || 1
            };
            return query;
          }
          // Any additional params go here...
        };
      }
      if (this.displaySelectionSummaryValue == true) {
        options.allowClear = true;
        options.templateSelection = (selected, total) => {
          if (selected.length == 0) {
            return options.placeholder;
          }
          return this.updateSelectionText(selected, options.maximumSelectionLength);
        };
      }
      this.cleanupBeforeInit();
      this.pluginMainEl = this.selectTarget;
      var $sidepanel = (0, import_jquery145.default)(this.pluginMainEl).parents("#side_panel");
      if ($sidepanel.length > 0) {
        options.dropdownParent = (0, import_jquery145.default)("#side_panel");
        (0, import_jquery145.default)(this.pluginMainEl).on("select2:unselect", function() {
          event.cancelBubble = true;
          return;
        });
      }
      if (this.displaySelectionSummaryValue == true) {
        (0, import_jquery145.default)(this.pluginMainEl).select2MultiCheckboxes(options);
      } else {
        $select2 = (0, import_jquery145.default)(this.pluginMainEl)?.select2(options);
        if (this.menuAsCheckboxesValue && $select2) {
          $select2.data("select2").$dropdown.addClass("select2--checkbox");
        }
      }
      this.initReissuePluginEventsAsNativeEvents();
      if (this.hasSelectedValue) {
        var newOption = new Option(this.selectedValue.text, this.selectedValue.id, true, true);
        (0, import_jquery145.default)(this.pluginMainEl).append(newOption).trigger("change");
      }
    }
    closeSelectDropdownAfterClearing() {
      (0, import_jquery145.default)("select").on("select2:clear", function() {
        (0, import_jquery145.default)(this).on("select2:opening.cancelOpen", function(evt) {
          evt.preventDefault();
          (0, import_jquery145.default)(this).off("select2:opening.cancelOpen");
        });
      });
    }
    updateSelectionText(selection, total) {
      let template2 = this.selectedMessageTemplateValue;
      template2 = template2.replace(this.selectedMessageTemplateCountKeyValue, selection.length);
      template2 = template2.replace(this.selectedMessageTemplateTotalKeyValue, total);
      template2 = template2.replace(this.selectedMessageTemplateDescriptorKeyValue, this.selectDescriptorValue);
      return template2.trim();
    }
    teardownPluginInstance() {
      if (this.pluginMainEl === void 0) {
        return;
      }
      this.teardownPluginEventsAsNativeEvents();
      (0, import_jquery145.default)(this.pluginMainEl)?.select2("destroy");
    }
    // select2 does not re-trigger native events.
    // this tread details the issue: https://github.com/select2/select2/issues/1908
    // Direct link to the recommended fix: https://github.com/select2/select2/issues/1908#issuecomment-871095578
    // note one(...), not on(...), which triggers once and detaches. Otherwise you get stackoverflow as
    // this triggers more on(change) events.
    initReissuePluginEventsAsNativeEvents() {
      this.constructor.jQueryEventsToReissue.forEach((eventName) => {
        (0, import_jquery145.default)(this.pluginMainEl).one(eventName, this.dispatchNativeEventBoundFn);
      });
    }
    teardownPluginEventsAsNativeEvents() {
      this.constructor.jQueryEventsToReissue.forEach((eventName) => {
        (0, import_jquery145.default)(this.pluginMainEl).off(eventName);
      });
    }
    // BT deviation
    // we've opted to not prepend $ to reissued event names.
    dispatchNativeEvent(event2) {
      this.pluginMainEl.dispatchEvent(
        new CustomEvent(event2.type, {
          detail: { event: event2 },
          bubbles: true,
          cancelable: false
        })
      );
      (0, import_jquery145.default)(this.pluginMainEl).one(event2.type, this.dispatchNativeEventBoundFn);
    }
    // https://stackoverflow.com/questions/29290389/select2-add-image-icon-to-option-dynamically
    formatState(opt) {
      var imageUrl = (0, import_jquery145.default)(opt.element).attr("data-image");
      var imageStyle = (0, import_jquery145.default)(opt.element).attr("data-image-style");
      if (imageStyle) {
      } else {
        imageStyle = "default";
      }
      var imageHtml = "";
      if (imageUrl) {
        imageHtml = '<img src="' + imageUrl + '" class="' + imageStyle + '" /> ';
        return (0, import_jquery145.default)(
          '<span class="flex items-center">' + imageHtml + '<span class="block truncate">' + sanitizeHTML(opt.text) + "</span></span>"
        );
      }
      var iconClass = (0, import_jquery145.default)(opt.element).attr("data-icon-class");
      if (iconClass) {
        return (0, import_jquery145.default)(`<span><i class="${iconClass}"></i>` + sanitizeHTML(opt.text) + "</span>");
      }
      return (0, import_jquery145.default)("<span>" + sanitizeHTML(opt.text) + "</span>");
    }
  };
  __publicField(super_select_controller_default, "targets", ["select"]);
  __publicField(super_select_controller_default, "values", {
    acceptsNew: Boolean,
    allowClear: Boolean,
    menuAsCheckboxes: { type: Boolean, default: false },
    closeOnSelect: { type: Boolean, default: true },
    containerWidth: String,
    data: Array,
    displaySelectionSummary: { type: Boolean, default: false },
    enableSearch: Boolean,
    maximumInputLength: Number,
    maximumSelectionLength: Number,
    noResultsMessage: String,
    selectedMessageTemplate: String,
    placeholder: { type: String, default: "" },
    searchUrl: String,
    selected: Object,
    selectDescriptor: String,
    selectedMessageTemplateCountKey: { type: String, default: "{{count}}" },
    selectedMessageTemplateTotalKey: { type: String, default: "{{total}}" },
    selectedMessageTemplateDescriptorKey: { type: String, default: "{{descriptor}}" },
    createPrefix: { type: String, default: "" }
  });
  // select2 does not re-trigger native events.
  // These events are what will be retriggered by this controller.
  __publicField(super_select_controller_default, "jQueryEventsToReissue", [
    "change",
    "select2:closing",
    "select2:close",
    "select2:opening",
    "select2:open",
    "select2:selecting",
    "select2:select",
    "select2:unselecting",
    "select2:unselect",
    "select2:clearing",
    "select2:clear"
  ]);
  function sanitizeHTML(str) {
    if (!str) return "";
    return str.replace(/[&<>"']/g, function(match) {
      return {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }[match];
    });
  }

  // app/javascript/controllers/toggle_controller.js
  init_define_process();
  init_jquery();

  // node_modules/stimulus-use/dist/index.js
  init_define_process();
  init_jquery();

  // node_modules/stimulus-use/dist/support/index.js
  init_define_process();
  init_jquery();
  var composeEventName = (name2, controller, eventPrefix) => {
    let composedName = name2;
    if (eventPrefix === true) {
      composedName = `${controller.identifier}:${name2}`;
    } else if (typeof eventPrefix === "string") {
      composedName = `${eventPrefix}:${name2}`;
    }
    return composedName;
  };
  var extendedEvent = (type, event2, detail) => {
    const { bubbles, cancelable, composed } = event2 || { bubbles: true, cancelable: true, composed: true };
    if (event2) {
      Object.assign(detail, { originalEvent: event2 });
    }
    const customEvent = new CustomEvent(type, {
      bubbles,
      cancelable,
      composed,
      detail
    });
    return customEvent;
  };
  function isElementInViewport(el) {
    const rect = el.getBoundingClientRect();
    const windowHeight = window.innerHeight || document.documentElement.clientHeight;
    const windowWidth = window.innerWidth || document.documentElement.clientWidth;
    const vertInView = rect.top <= windowHeight && rect.top + rect.height >= 0;
    const horInView = rect.left <= windowWidth && rect.left + rect.width >= 0;
    return vertInView && horInView;
  }

  // node_modules/stimulus-use/dist/use-click-outside/index.js
  init_define_process();
  init_jquery();

  // node_modules/stimulus-use/dist/use-click-outside/use-click-outside.js
  init_define_process();
  init_jquery();
  var defaultOptions2 = {
    events: ["click", "touchend"],
    onlyVisible: true,
    dispatchEvent: true,
    eventPrefix: true
  };
  var useClickOutside = (controller, options = {}) => {
    const { onlyVisible, dispatchEvent: dispatchEvent2, events, eventPrefix } = Object.assign({}, defaultOptions2, options);
    const onEvent = (event2) => {
      const targetElement = (options === null || options === void 0 ? void 0 : options.element) || controller.element;
      if (targetElement.contains(event2.target) || !isElementInViewport(targetElement) && onlyVisible) {
        return;
      }
      if (controller.clickOutside) {
        controller.clickOutside(event2);
      }
      if (dispatchEvent2) {
        const eventName = composeEventName("click:outside", controller, eventPrefix);
        const clickOutsideEvent = extendedEvent(eventName, event2, { controller });
        targetElement.dispatchEvent(clickOutsideEvent);
      }
    };
    const observe = () => {
      events === null || events === void 0 ? void 0 : events.forEach((event2) => {
        window.addEventListener(event2, onEvent, false);
      });
    };
    const unobserve = () => {
      events === null || events === void 0 ? void 0 : events.forEach((event2) => {
        window.removeEventListener(event2, onEvent, false);
      });
    };
    const controllerDisconnect = controller.disconnect.bind(controller);
    Object.assign(controller, {
      disconnect() {
        unobserve();
        controllerDisconnect();
      }
    });
    observe();
    return [observe, unobserve];
  };

  // app/javascript/controllers/toggle_controller.js
  var toggle_controller_default = class extends application_controller_default {
    connect() {
      useClickOutside(this);
    }
    hideAllContent() {
      this.toggleContentTargets.forEach((el) => el.classList.add("hidden"));
    }
    showAllContent() {
      this.toggleContentTargets.forEach((el) => el.classList.remove("hidden"));
    }
    toggleAllContent() {
      this.toggleContentTargets.forEach((el) => el.classList.toggle("hidden"));
      this.dispatch("toggled", { detail: { sourceEl: this.element } });
    }
    toggleHiddenElements() {
      this.toggleAllContent();
    }
    toggleSpecificContent(event2) {
      const selector = event2.currentTarget.dataset.contentSelector;
      const specificContent = Array.from(this.element.querySelectorAll(selector));
      this.toggleContentTargets.filter((el) => !specificContent.includes(el)).forEach((el) => el.classList.add("hidden"));
      specificContent.forEach((el) => el.classList.toggle("hidden"));
      this.dispatch("toggled", { detail: { sourceEl: this.element } });
    }
    toggleByValue(event2) {
      this.multiTargets.forEach((el) => el.classList.add("hidden"));
      $(`#${event2.currentTarget.value}`).removeClass("hidden");
      this.dispatch("toggled", { detail: { sourceEl: this.element } });
    }
  };
  __publicField(toggle_controller_default, "targets", ["toggleContent", "multi"]);

  // app/javascript/controllers/fields/tom_select_controller.js
  init_define_process();
  init_jquery();
  var import_tom_select = __toESM(require_tom_select_complete());

  // node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  init_define_process();
  init_jquery();

  // node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  init_define_process();
  init_jquery();

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
  init_define_process();
  init_jquery();
  var min2 = Math.min;
  var max2 = Math.max;
  var round3 = Math.round;
  var floor = Math.floor;
  var createCoords = (v4) => ({
    x: v4,
    y: v4
  });
  var oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  var oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function evaluate(value, param2) {
    return typeof value === "function" ? value(param2) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement2(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement2(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement2(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr2 = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt3 = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rl : lr2;
        return isStart ? lr2 : rl;
      case "left":
      case "right":
        return isStart ? tb : bt3;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement2(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect2(rect) {
    const {
      x: x4,
      y: y6,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y6,
      left: x4,
      right: x4 + width,
      bottom: y6 + height,
      x: x4,
      y: y6
    };
  }

  // node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference: reference2,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
    const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
    const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference2.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case "right":
        coords = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference2.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference2.x,
          y: reference2.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  var computePosition = async (reference2, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference: reference2,
      floating,
      strategy
    });
    let {
      x: x4,
      y: y6
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i3 = 0; i3 < validMiddleware.length; i3++) {
      const {
        name: name2,
        fn: fn3
      } = validMiddleware[i3];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn3({
        x: x4,
        y: y6,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference: reference2,
          floating
        }
      });
      x4 = nextX != null ? nextX : x4;
      y6 = nextY != null ? nextY : y6;
      middlewareData = {
        ...middlewareData,
        [name2]: {
          ...middlewareData[name2],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference: reference2,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x: x4,
            y: y6
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i3 = -1;
      }
    }
    return {
      x: x4,
      y: y6,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow2(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x4,
      y: y6,
      platform: platform2,
      rects,
      elements: elements2,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements2[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect2(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements2.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x4,
      y: y6,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements2.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect2(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: elements2,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  var flip2 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements: elements2
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement2(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements3 = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow2(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements3[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d5) => d5.overflows[0] <= 0).sort((a5, b5) => a5.overflows[1] - b5.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d5) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d5.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d5) => [d5.placement, d5.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a5, b5) => a5[1] - b5[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  var size = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "size",
      options,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements: elements2
        } = state;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const overflow = await detectOverflow2(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max2(overflow.left, 0);
          const xMax = max2(overflow.right, 0);
          const yMin = max2(overflow.top, 0);
          const yMax = max2(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements2.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
  init_define_process();
  init_jquery();
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName2(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow2(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement2(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow2(value).Node;
  }
  function isElement3(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow2(value).Element;
  }
  function isHTMLElement2(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
  }
  function isShadowRoot2(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle3(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement2(element) {
    return ["table", "td", "th"].includes(getNodeName2(element));
  }
  function isTopLayer(element) {
    return [":popover-open", ":modal"].some((selector) => {
      try {
        return element.matches(selector);
      } catch (e2) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement3(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
    return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock2(element) {
    let currentNode = getParentNode2(element);
    while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode2(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName2(node));
  }
  function getComputedStyle3(element) {
    return getWindow2(element).getComputedStyle(element);
  }
  function getNodeScroll2(element) {
    if (isElement3(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode2(node) {
    if (getNodeName2(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot2(node) && node.host || // Fallback.
      getDocumentElement2(node)
    );
    return isShadowRoot2(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode2(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow2(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }

  // node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  function getCssDimensions(element) {
    const css = getComputedStyle3(element);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement2(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round3(width) !== offsetWidth || round3(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement3(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement2(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $: $7
    } = getCssDimensions(domElement);
    let x4 = ($7 ? round3(rect.width) : rect.width) / width;
    let y6 = ($7 ? round3(rect.height) : rect.height) / height;
    if (!x4 || !Number.isFinite(x4)) {
      x4 = 1;
    }
    if (!y6 || !Number.isFinite(y6)) {
      y6 = 1;
    }
    return {
      x: x4,
      y: y6
    };
  }
  var noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow2(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect2(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement3(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x4 = (clientRect.left + visualOffsets.x) / scale.x;
    let y6 = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow2(domElement);
      const offsetWin = offsetParent && isElement3(offsetParent) ? getWindow2(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle3(currentIFrame);
        const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x4 *= iframeScale.x;
        y6 *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x4 += left2;
        y6 += top2;
        currentWin = getWindow2(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect2({
      width,
      height,
      x: x4,
      y: y6
    });
  }
  function getWindowScrollBarX2(element, rect) {
    const leftScroll = getNodeScroll2(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect2(getDocumentElement2(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x4 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
      // RTL <body> scrollbar.
      getWindowScrollBarX2(documentElement, htmlRect)
    ));
    const y6 = htmlRect.top + scroll.scrollTop;
    return {
      x: x4,
      y: y6
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements: elements2,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement2(offsetParent);
    const topLayer = elements2 ? isTopLayer(elements2.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement2(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName2(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll2(offsetParent);
      }
      if (isHTMLElement2(offsetParent)) {
        const offsetRect = getBoundingClientRect2(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect2(element) {
    const html = getDocumentElement2(element);
    const scroll = getNodeScroll2(element);
    const body = element.ownerDocument.body;
    const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x4 = -scroll.scrollLeft + getWindowScrollBarX2(element);
    const y6 = -scroll.scrollTop;
    if (getComputedStyle3(body).direction === "rtl") {
      x4 += max2(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x4,
      y: y6
    };
  }
  function getViewportRect2(element, strategy) {
    const win = getWindow2(element);
    const html = getDocumentElement2(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x4 = 0;
    let y6 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x4 = visualViewport.offsetLeft;
        y6 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x4,
      y: y6
    };
  }
  function getInnerBoundingClientRect2(element, strategy) {
    const clientRect = getBoundingClientRect2(element, true, strategy === "fixed");
    const top2 = clientRect.top + element.clientTop;
    const left2 = clientRect.left + element.clientLeft;
    const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x4 = left2 * scale.x;
    const y6 = top2 * scale.y;
    return {
      width,
      height,
      x: x4,
      y: y6
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect2(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect2(getDocumentElement2(element));
    } else if (isElement3(clippingAncestor)) {
      rect = getInnerBoundingClientRect2(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect2(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode2(element);
    if (parentNode === stopNode || !isElement3(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache2) {
    const cachedResult = cache2.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement3(el) && getNodeName2(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle3(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode2(element) : element;
    while (isElement3(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle3(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode2(currentNode);
    }
    cache2.set(element, result);
    return result;
  }
  function getClippingRect2(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max2(rect.top, accRect.top);
      accRect.right = min2(rect.right, accRect.right);
      accRect.bottom = min2(rect.bottom, accRect.bottom);
      accRect.left = max2(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement2(offsetParent);
    const documentElement = getDocumentElement2(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect2(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName2(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll2(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect2(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX2(documentElement);
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x4 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y6 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x: x4,
      y: y6,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle3(element).position === "static";
  }
  function getTrueOffsetParent2(element, polyfill) {
    if (!isHTMLElement2(element) || getComputedStyle3(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement2(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent2(element, polyfill) {
    const win = getWindow2(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement2(element)) {
      let svgOffsetParent = getParentNode2(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement3(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode2(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent2(element, polyfill);
    while (offsetParent && isTableElement2(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent2(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock2(element) || win;
  }
  var getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent2;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle3(element).direction === "rtl";
  }
  var platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement: getDocumentElement2,
    getClippingRect: getClippingRect2,
    getOffsetParent: getOffsetParent2,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement: isElement3,
    isRTL
  };
  function observeMove(element, onMove) {
    let io2 = null;
    let timeoutId;
    const root = getDocumentElement2(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io2) == null || _io.disconnect();
      io2 = null;
    }
    function refresh(skip2, threshold) {
      if (skip2 === void 0) {
        skip2 = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const {
        left: left2,
        top: top2,
        width,
        height
      } = element.getBoundingClientRect();
      if (!skip2) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top2);
      const insetRight = floor(root.clientWidth - (left2 + width));
      const insetBottom = floor(root.clientHeight - (top2 + height));
      const insetLeft = floor(left2);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max2(0, min2(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        isFirstUpdate = false;
      }
      try {
        io2 = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root.ownerDocument
        });
      } catch (e2) {
        io2 = new IntersectionObserver(handleObserve, options);
      }
      io2.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference2, floating, update, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference2);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect2(reference2) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect2(reference2);
      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  var flip3 = flip2;
  var size2 = size;
  var computePosition2 = (reference2, floating, options) => {
    const cache2 = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache2
    };
    return computePosition(reference2, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };

  // app/javascript/controllers/fields/tom_select_controller.js
  var renderConfigs = {
    // Customize any of the HTML rendered by passing in a custom render object.
    // Must conform to the shape defined here:
    // https://github.com/orchidjs/tom-select/blob/master/doc_src/pages/docs/index.md#render-templates
    codes: {
      render: {
        option: function(data, escape3) {
          return `
          <div class="py-2 px-3">
            <sl-tooltip class="sl-tooltip" content="${escape3(data.code)}">
              <div class="truncate">${escape3(data.text)}</div>
            </sl-tooltip>
          </div>
        `;
        }
      }
    },
    contacts: {
      render: {
        option: function(data, escape3) {
          return `
          <div class="py-2 px-3 flex items-center space-x-3">
            <div class="flex-shrink-0">
              <img class="h-6 w-6 rounded-full" src="${escape3(data.avatar_url)}" alt="">
            </div>
            <div class="flex flex-col min-w-0">
              <div class="font-medium">
                ${escape3(data.full_name)}
              </div>
              <div class="truncate text-xs">
                ${escape3(data.email_address)}
              </div>
            </div>
          </div>
        `;
        },
        item: function(data, escape3) {
          return `
          <div class="flex items-center space-x-2 rounded-lg min-w-0">
          ${data.avatar_url ? `<img class="h-4 w-4 rounded-full" src="${escape3(data.avatar_url)}" alt="">` : ""}
            <span class="truncate text-sm">
              ${escape3(data.full_name || data.email_address || data.text)}
            </span>
          </div>
        `;
        }
      }
    },
    prices: {
      render: {
        option: function(data, escape3) {
          return `
          <div class="py-2 px-3">
            <div class="flex items-center justify-between space-x-1">
              <span class="font-medium">${escape3(data.price)}</span>
              <span class="inline-block shrink-0 h-2 w-2 rounded-full ${data.visible === "true" ? "bg-green-600" : "bg-coolGray-400"}"></span>
            </div>
            ${data.name && `<div class="truncate text-xs">${escape3(data.name)}</div>`}
          </div>
        `;
        },
        item: function(data, escape3) {
          return `
          <div class="pr-7">${escape3(data.text)}</div>
        `;
        },
        optgroup_header: function(data, escape3) {
          const translations = this.settings.translations;
          return `
          <div class="flex items-center justify-between px-3 pt-2 pb-1 border-b border-coolGray-100">
            <div class="text-coolGray font-semibold text-xs">
              ${escape3(data.label)}
            </div>
            <div class="text-coolGray font-semibold text-xs text-right">
              ${translations.visible}
            </div>
           </div>
        `;
        }
      }
    },
    pages: {
      render: {
        option: function(data, escape3) {
          return `
          <div class="py-2 px-3 flex items-center space-x-3">
            <div class="flex flex-col min-w-0">
              <div class="font-medium">
                ${escape3(data.name)}
              </div>
              <div class="truncate text-xs font-light">
                ${escape3(data.path)}
              </div>
            </div>
          </div>
        `;
        },
        item: function(data, escape3) {
          return `
          <div class="flex items-center space-x-2 rounded-lg min-w-0">
            <span class="truncate text-sm">
              ${escape3(data.name)}
            </span>
          </div>
        `;
        }
      }
    },
    tags: {
      render: {
        option: function(data, escape3) {
          const color2 = data.color || "#D7E0E5";
          return `
          <div>
            <div class="flex items-center space-x-2">
              <div class="h-3 w-3 rounded-full" style="background-color: ${color2}"></div>
              <div class="truncate">${escape3(data.text)}</div>
            </div>
          </div>
        `;
        },
        item: function(data, escape3) {
          const color2 = data.color || "#D7E0E5";
          return `
          <div>
            <div class="flex items-center space-x-2">
              <div class="h-3 w-3 rounded-full ring-1 ring-coolGray-200" style="background-color: ${color2}"></div>
              <div class="truncate">${escape3(data.text)}</div>
            </div>
          </div>
        `;
        }
      }
    },
    themes: {
      render: {
        option: function(data, escape3) {
          const translations = this.settings.translations;
          return `
          <div class="py-2 px-3">
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                ${data.imgSrc ? `<img src="${escape3(data.imgSrc)}" class="w-8 h-6">` : ""}
                <div class="truncate">${escape3(data.text)}</div>
              </div>
              <div class="flex items gap-2">
              ${data.new === "true" ? `<span class="inline-flex items-center font-medium px-2.5 text-button bg-green-100 text-green-800 rounded capitalize">${translations.new}</span>` : ""}
                <button
                  type="button"
                  data-controller="tooltip"
                  data-tooltip-content-value="${translations.preview_theme_pages}"
                  data-turbo-command="Themes::ViewThemePages"
                  data-theme-id="${escape3(data.themeId)}"
                >
                  <i class="fa-solid fa-eye text-coolGray-400"></i>
                </button>
              </div>
            </div
          </div>
        `;
        },
        item: function(data, escape3) {
          return `
          <div>
            <div class="flex items-center space-x-3">
              ${data.imgSrc ? `<img src="${escape3(data.imgSrc)}" class="w-8 h-6">` : ""}
              <div class="truncate">${escape3(data.text)}</div>
              <div class="flex items gap-2">
              ${data.new === "true" ? `<span class="inline-flex items-center font-medium px-2.5 text-button bg-green-100 text-green-800 rounded capitalize">${this.settings.translations.new}</span>` : ""}
              </div>
            </div>
          </div>
        `;
        },
        dropdown: function() {
          const translations = this.settings.translations;
          return `
          <div>
            <div class="flex items-center py-2 px-3 border border-b border-coolGray-150">
             <span class="text-coolGray-900 mr-1">${translations.dont_see_one}</span>
             <button
              type="button"
              class="link"
              data-turbo-command="Marketplaces::Themes::OpenGallery"
              >
                ${translations.explore_new_themes}
              </button>
             </div>
          </div>
        `;
        }
      }
    },
    mergeTags: {
      render: {
        option: function(data, escape3) {
          return `
          <div class="py-2 px-3 flex items-center space-x-3">
            <div class="flex flex-col min-w-0">
              <div class="font-medium">
                ${escape3(data.name)}
              </div>
              <div class="truncate text-xs font-light">
                ${escape3(data.tag)}
              </div>
            </div>
          </div>
        `;
        },
        item: function(data, escape3) {
          return `
          <div class="flex items-center space-x-2 rounded-lg min-w-0">
            <span class="truncate text-sm">
              ${escape3(data.name)}
            </span>
          </div>
        `;
        }
      }
    },
    urls: {
      render: {
        option: function(data, escape3) {
          return `
          <div class="py-2 px-3">
            <div class="flex items-center space-x-2">
              <i class="far fa-link text-gray-400"></i>
              <div class="truncate">${escape3(data.text)}</div>
            </div>
          </div>
        `;
        },
        item: function(data, escape3) {
          return `
          <div class="flex items-center space-x-2">
            <i class="far fa-link text-gray-400"></i>
            <div class="truncate">${escape3(data.text)}</div>
          </div>
        `;
        }
      }
    }
  };
  var loadConfigs = {
    // uses `fetch` to access external urls
    external: function(baseUrl, queryParam, pathToData) {
      return {
        load: async function(query, callback2) {
          var url = `${baseUrl}?${queryParam}=` + encodeURIComponent(query);
          fetch(url).then((response2) => response2.json()).then((json) => {
            callback2(getValueByKeys(json, pathToData));
          }).catch(() => {
            callback2();
          });
        }
      };
    },
    // uses `@rails/requestjs` to access internal application
    internal: function(baseUrl, queryParam, pathToData) {
      return {
        load: async function(query, callback2) {
          const url = `${baseUrl}?${queryParam}=` + encodeURIComponent(query);
          const response2 = await get2(url, { responseKind: "json" });
          if (response2.ok) {
            const data = await response2.json;
            callback2(getValueByKeys(data, pathToData));
          } else {
            callback2();
          }
        }
      };
    }
  };
  var getValueByKeys = (data, keys) => {
    let result = data;
    for (let key of keys) {
      if (result[key] === void 0) {
        return void 0;
      }
      result = result[key];
    }
    return result;
  };
  var tom_select_controller_default = class extends application_controller_default {
    connect() {
      const settings = this.initOptions();
      this.tomSelect = new import_tom_select.default(this.selectTarget, settings);
      if (this.focusOnLoadValue) {
        this.focus();
      }
    }
    initOptions() {
      let defaultOptions3 = {
        plugins: {},
        create: true,
        copyClassesToDropdown: false,
        render: {},
        hidePlaceholder: true,
        maxOptions: null,
        onDropdownOpen: this.onDropdownOpen.bind(this),
        onDropdownClose: this.onDropdownClose.bind(this)
      };
      if (this.multipleValue) {
        defaultOptions3.plugins["remove_button"] = {};
        defaultOptions3.plugins["clear_button"] = {
          title: this.clearButtonTitleValue,
          html: (data) => {
            return `
            <div
              class="${data.className}"
              title="${data.title}"
              data-controller="tooltip"
              data-tooltip-content-value="${data.title}"
            >
              <i class="fa fa-circle-x"></i>
            </div>
          `;
          }
        };
      }
      if (this.checkboxOptionsValue) {
        defaultOptions3.plugins["checkbox_options"] = {};
      }
      if (!this.multipleValue && !this.onDeleteValue) {
        defaultOptions3["onDelete"] = function() {
          return false;
        };
      }
      let combinedOptions = {
        ...defaultOptions3,
        ...this.settingsValue,
        ...this.hasRenderConfigNameValue && renderConfigs[this.renderConfigNameValue],
        ...this.hasRenderConfigTranslationsValue && { translations: this.renderConfigTranslationsValue },
        ...this.hasLoadConfigNameValue && loadConfigs[this.loadConfigNameValue](this.remoteUrlValue, this.queryParamValue, this.remoteDataPathValue)
      };
      combinedOptions.render.loading = function() {
        return `
        <div class="flex items-center justify-center p-3 text-blue-50">
          <l-dot-pulse
            size="40"
            speed="1.3" 
            color="rgb(var(--eva-color-blue-100))" 
          ></l-dot-pulse>
        </div>
      `;
      };
      return combinedOptions;
    }
    onDropdownOpen(dropdownElement) {
      if (!this.hoistValue) return;
      this.anchorElement = dropdownElement.parentElement;
      this.dropdownElement = dropdownElement;
      this.cleanUpHoistedDropdown = autoUpdate(this.anchorElement, this.dropdownElement, this.reposition.bind(this));
    }
    onDropdownClose() {
      if (!this.hoistValue) return;
      this.cleanUpHoistedDropdown();
      this.cleanUpHoistedDropdown = null;
      this.anchorElement = null;
      this.dropdownElement = null;
    }
    reposition() {
      const middleware = [
        size2({
          apply: ({ rects }) => {
            this.dropdownElement.style.width = `${rects.reference.width}px`;
          }
        }),
        flip3({
          flipAlignment: false
        })
      ];
      computePosition2(this.anchorElement, this.dropdownElement, {
        placement: "bottom-start",
        middleware,
        strategy: "fixed"
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
      }).then(({ x: x4, y: y6, middlewareData, placement }) => {
        if (placement.startsWith("top")) {
          y6 -= 8;
        }
        Object.assign(this.dropdownElement.style, {
          position: "fixed",
          left: `${x4}px`,
          top: `${y6}px`
        });
      });
    }
    // Tom Select API Actions
    // Add more as needed: https://tom-select.js.org/docs/api/
    open() {
      this.tomSelect.open();
    }
    close() {
      this.tomSelect.close();
    }
    focus() {
      this.tomSelect.focus();
    }
    enable() {
      this.tomSelect.enable();
    }
    disable() {
      this.tomSelect.disable();
    }
  };
  __publicField(tom_select_controller_default, "targets", ["select"]);
  __publicField(tom_select_controller_default, "values", {
    checkboxOptions: { type: Boolean, default: false },
    clearButtonTitle: { type: String, default: "Clear All" },
    loadConfigName: { type: String, default: "external" },
    multiple: { type: Boolean, default: false },
    queryParam: { type: String, default: "q" },
    remoteUrl: { type: String, default: "" },
    remoteDataPath: { type: Array, default: ["items"] },
    renderConfigName: { type: String, default: "" },
    renderConfigTranslations: { type: Object, default: {} },
    settings: { type: Object, default: {} },
    focusOnLoad: { type: Boolean, default: false },
    onDelete: { type: Boolean, default: false },
    hoist: Boolean
  });

  // app/javascript/controllers/tooltip_controller.js
  init_define_process();
  init_jquery();
  var tooltip_controller_default = class extends application_controller_default {
    connect() {
      this.initTippy();
    }
    disconnect() {
      this.teardownTippy();
    }
    initTippy() {
      const minContentLength = this.minCharCountValue;
      const charCount = this.contentValue.length;
      return charCount > minContentLength ? this.setTippy() : false;
    }
    setTippy() {
      this.tippy = tippy_esm_default(this.element, {
        content: this.contentValue,
        placement: this.placementValue,
        // This allows interactive: true to not cut off the tooltip.
        // https://atomiks.github.io/tippyjs/v5/faq/#my-tooltip-appears-cut-off-or-is-not-showing-at-all
        appendTo: document.body,
        ...this.otherOptionsValue
      });
    }
    contentValueChanged(value, previousValue) {
      if (value !== previousValue && previousValue !== "") {
        if (this.tippy === void 0) {
          return;
        }
        this.tippy.destroy();
        this.initTippy();
      }
    }
    teardownTippy() {
      if (this.tippy === void 0) {
        return;
      }
      this.tippy.destroy();
    }
  };
  __publicField(tooltip_controller_default, "values", {
    content: String,
    placement: { type: String, default: "bottom" },
    otherOptions: { type: Object, default: {} },
    minCharCount: { type: String, default: "0" }
  });

  // app/javascript/customer_center/controllers/trix_code_block_controller.js
  init_define_process();
  init_jquery();
  var trix_code_block_controller_default = class extends application_controller_default {
    connect() {
      this.editor = this.element.editor;
      this.abortController = new AbortController();
      this.element.addEventListener("keyup", this.handleKeyUp.bind(this), { signal: this.abortController.signal });
    }
    disconnect() {
      this.abortController.abort();
    }
    handleKeyUp(event2) {
      const editorDocument = this.editor.getDocument();
      const text = editorDocument.toString();
      const position = this.editor.getSelectedRange()[0];
      if (text.slice(position - 3, position) !== "```") return;
      event2.preventDefault();
      this.editor.setSelectedRange([position - 3, position]);
      this.editor.deleteInDirection("backward");
      this.editor.recordUndoEntry("Insert Code Block");
      this.editor.activateAttribute("code");
    }
  };

  // app/javascript/controllers/trix_content_links_target_blank_controller.js
  init_define_process();
  init_jquery();
  var trix_content_links_target_blank_controller_default = class extends application_controller_default {
    /* Grab all links within the rendered trix content area, excluding turbo frame links,
       setting their target attribute to _blank.
    */
    connect() {
      let trixWrapper = this.element.querySelector(".trix-content");
      [...trixWrapper.querySelectorAll("a:not([data-turbo-frame])")].forEach((link) => {
        link.setAttribute("target", "_blank");
      });
    }
    // TODO: When old community is deprecated, we can remove this function
    setTrixContentLinkTargetBlank(event2) {
      const el = event2.target;
      if (el.tagName.toLowerCase() !== "a:not([data-turbo-frame])") return;
      if (el.closest('[class="trix-content"]')) el.target = "_blank";
    }
  };

  // app/javascript/controllers/trix_editor_controller.js
  init_define_process();
  init_jquery();
  var trix_editor_controller_default = class extends application_controller_default {
    connect() {
      if (!this.attachmentsValue) this.disableAttachments();
      if (!this.headingsValue) this.disableHeadings();
    }
    // disable the trix editor's attachment(s) feature
    // see: https://github.com/basecamp/trix#storing-attached-files
    disableAttachments() {
      this.toolbarFileToolsElement?.remove();
      this.element.addEventListener("trix-file-accept", (event2) => event2.preventDefault(), true);
    }
    // disable the trix editor's heading(s) feature
    disableHeadings() {
      this.heading1Element?.remove();
    }
    // returns the trix editor attached to the trix-editor element
    get editor() {
      return this.element.editor;
    }
    // returns the trix toolbar element
    get toolbarElement() {
      let sibling;
      while (sibling = this.element.previousElementSibling) if (sibling.tagName.match(/trix-toolbar/i)) return sibling;
      return null;
    }
    // returns the toolbar file-tools button group element
    get toolbarFileToolsElement() {
      return this.toolbarElement?.querySelector("[data-trix-button-group=file-tools]");
    }
    // returns the toolbar heading1 button element
    get heading1Element() {
      return this.toolbarElement?.querySelector("[data-trix-attribute=heading1]");
    }
  };
  __publicField(trix_editor_controller_default, "values", {
    attachments: { type: Boolean, default: true },
    headings: { type: Boolean, default: true }
  });

  // app/javascript/controllers/truncated_tooltip_controller.js
  init_define_process();
  init_jquery();
  var STRATEGIES = {
    multiline: "multiline",
    singleline: "singleline",
    both: "both"
  };
  var _instances2, buildStyleOptions_fn;
  var truncated_tooltip_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      __privateAdd(this, _instances2);
      __publicField(this, "strategyMethods", {});
    }
    initialize() {
      this.strategyMethods = {
        [STRATEGIES.multiline]: () => this.checkForMultilineTruncation(),
        [STRATEGIES.singleline]: () => this.checkForSingleLineTruncation(),
        [STRATEGIES.both]: () => this.checkForMultilineTruncation() || this.checkForSingleLineTruncation()
      };
    }
    connect() {
      requestAnimationFrame(() => {
        this.checkIfTruncated();
      });
    }
    checkIfTruncated() {
      const strategyCheck = this.strategyMethods[this.strategyValue];
      if (!strategyCheck || !strategyCheck()) return;
      this.applyTooltip();
    }
    checkForMultilineTruncation() {
      return this.textTarget.scrollHeight > this.textTarget.clientHeight;
    }
    checkForSingleLineTruncation() {
      const textWidth = this.textTarget.scrollWidth;
      const containerWidth = this.textTarget.getBoundingClientRect().width;
      return textWidth >= containerWidth;
    }
    applyTooltip() {
      const fragment = document.createDocumentFragment();
      const tooltip = document.createElement("sl-tooltip");
      tooltip.content = this.hasMessageValue ? this.messageValue : this.textTarget.textContent;
      tooltip.setAttribute("placement", this.placementValue);
      const styles = __privateMethod(this, _instances2, buildStyleOptions_fn).call(this);
      if (styles.length) {
        tooltip.setAttribute("style", styles);
      }
      if (this.hasClassesValue) {
        tooltip.setAttribute("class", this.classesValue);
      }
      fragment.appendChild(tooltip);
      this.textTarget.parentNode.insertBefore(fragment, this.textTarget);
      tooltip.appendChild(this.textTarget);
    }
  };
  _instances2 = new WeakSet();
  buildStyleOptions_fn = function() {
    const options = [
      this.hasShowDelayValue && `--show-delay: ${this.showDelayValue}`,
      this.hasHideDelayValue && `--hide-delay: ${this.hideDelayValue}`,
      this.hasMaxWidthValue && `--max-width: ${this.maxWidthValue}`
    ].filter(Boolean).join("; ");
    return options;
  };
  __publicField(truncated_tooltip_controller_default, "targets", ["text"]);
  __publicField(truncated_tooltip_controller_default, "values", {
    strategy: { type: String, default: STRATEGIES.multiline },
    placement: { type: String, default: "top" },
    message: String,
    // override the target's textContent if desired
    showDelay: String,
    hideDelay: String,
    maxWidth: String,
    classes: String
  });

  // app/javascript/controllers/unsaved_changes_controller.js
  init_define_process();
  init_jquery();
  var unsaved_changes_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      __publicField(this, "isDirty", false);
      __publicField(this, "subscribedEvents", "change input select2:select select2:unselecting cancel.daterangepicker dragula.drop sortable:drop");
    }
    connect() {
      this.element.classList.add("unsaved-changes-root");
      this.serializeForm();
      $(this.element).on(this.subscribedEvents, this.handleChange.bind(this));
    }
    disconnect() {
      $(this.element).off(this.subscribedEvents, this.handleChange.bind(this));
    }
    serializeForm() {
      this.originalForm = $(this.element).serialize();
    }
    initialize() {
      this.reset();
    }
    handleChange(event2) {
      if (event2.target.dataset?.unsavedChangesIgnore) return;
      this.isDirty = $(this.element).serialize() !== this.originalForm;
      if (this.isDirty) {
        this.enableSubmit();
        this.enableRestrictedTargets();
        this.dispatch("has-changes");
      } else {
        this.reset();
        this.dispatch("no-changes");
      }
      this.dispatch("change", { detail: { dirty: this.isDirty } });
    }
    enableSubmit() {
      this.submitTargets.forEach((target) => {
        target.classList.remove(this.disabledClassName);
        target.disabled = false;
        target.title = "";
      });
    }
    enableRestrictedTargets() {
      this.restrictWithSubmitTargets.forEach((target) => {
        target.classList.remove(this.disabledClassName);
        target.disabled = false;
        target.title = "";
      });
    }
    reset(event2) {
      const { formSubmission } = event2?.detail || {};
      const formElement = formSubmission?.formElement;
      if (formElement && formElement !== this.element) return;
      const locale = api.get("locale") || "en";
      const title = i18next_default.t("unsaved_changes_controller.noChanges", { lng: locale });
      this.isDirty = this.dirtyValue || false;
      this.submitTargets.forEach((target) => {
        target.classList.add(this.disabledClassName);
        target.disabled = true;
        target.title = title;
      });
      this.restrictWithSubmitTargets.forEach((target) => {
        target.classList.add(this.disabledClassName);
        target.disabled = true;
        target.title = title;
      });
      this.serializeForm();
      this.dispatch("reset");
    }
    confirmChanges(event2) {
      if (this.isDirty) {
        if (event2.type == "turbo:before-visit" || event2.type == "click") {
          if (!window.confirm(this.confirmMsg)) {
            event2.preventDefault();
          }
        } else {
          event2.returnValue = this.confirmMsg;
          return event2.returnValue;
        }
      }
    }
    discard(event2) {
      if (this.isDirty && !window.confirm(this.confirmMsg)) {
        event2.preventDefault();
      } else {
        this.element.reset();
        this.reset();
        this.dispatch("discard");
      }
    }
    get disabledClassName() {
      return this.disabledClassValue === "" ? "disabled" : this.disabledClassValue;
    }
    get confirmMsg() {
      const locale = api.get("locale") || "en";
      const msg = i18next_default.t("unsaved_changes_controller.haveChanges", { lng: locale });
      return this.confirmMsgValue === "" ? msg : this.confirmMsgValue;
    }
  };
  __publicField(unsaved_changes_controller_default, "targets", ["submit", "restrictWithSubmit"]);
  __publicField(unsaved_changes_controller_default, "values", {
    disabledClass: String,
    confirmMsg: String,
    dirty: { type: Boolean, default: false }
  });

  // app/javascript/trix/index.js
  init_define_process();
  init_jquery();

  // node_modules/@rails/actiontext/app/javascript/actiontext/index.js
  init_define_process();
  init_jquery();

  // node_modules/@rails/actiontext/app/javascript/actiontext/attachment_upload.js
  init_define_process();
  init_jquery();
  var import_activestorage = __toESM(require_activestorage());
  var AttachmentUpload = class {
    constructor(attachment, element) {
      this.attachment = attachment;
      this.element = element;
      this.directUpload = new import_activestorage.DirectUpload(attachment.file, this.directUploadUrl, this);
    }
    start() {
      this.directUpload.create(this.directUploadDidComplete.bind(this));
    }
    directUploadWillStoreFileWithXHR(xhr) {
      xhr.upload.addEventListener("progress", (event2) => {
        const progress = event2.loaded / event2.total * 100;
        this.attachment.setUploadProgress(progress);
      });
    }
    directUploadDidComplete(error3, attributes) {
      if (error3) {
        throw new Error(`Direct upload failed: ${error3}`);
      }
      this.attachment.setAttributes({
        sgid: attributes.attachable_sgid,
        url: this.createBlobUrl(attributes.signed_id, attributes.filename)
      });
    }
    createBlobUrl(signedId, filename) {
      return this.blobUrlTemplate.replace(":signed_id", signedId).replace(":filename", encodeURIComponent(filename));
    }
    get directUploadUrl() {
      return this.element.dataset.directUploadUrl;
    }
    get blobUrlTemplate() {
      return this.element.dataset.blobUrlTemplate;
    }
  };

  // node_modules/@rails/actiontext/app/javascript/actiontext/index.js
  addEventListener("trix-attachment-add", (event2) => {
    const { attachment, target } = event2;
    if (attachment.file) {
      const upload = new AttachmentUpload(attachment, target);
      upload.start();
    }
  });

  // node_modules/trix/dist/trix.esm.min.js
  init_define_process();
  init_jquery();
  var t2 = "2.1.15";
  var e = "[data-trix-attachment]";
  var i2 = { preview: { presentation: "gallery", caption: { name: true, size: true } }, file: { caption: { size: true } } };
  var n2 = { default: { tagName: "div", parse: false }, quote: { tagName: "blockquote", nestable: true }, heading1: { tagName: "h1", terminal: true, breakOnReturn: true, group: false }, code: { tagName: "pre", terminal: true, htmlAttributes: ["language"], text: { plaintext: true } }, bulletList: { tagName: "ul", parse: false }, bullet: { tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test(t4) {
    return r2(t4.parentNode) === n2[this.listAttribute].tagName;
  } }, numberList: { tagName: "ol", parse: false }, number: { tagName: "li", listAttribute: "numberList", group: false, nestable: true, test(t4) {
    return r2(t4.parentNode) === n2[this.listAttribute].tagName;
  } }, attachmentGallery: { tagName: "div", exclusive: true, terminal: true, parse: false, group: false } };
  var r2 = (t4) => {
    var e2;
    return null == t4 || null === (e2 = t4.tagName) || void 0 === e2 ? void 0 : e2.toLowerCase();
  };
  var o2 = navigator.userAgent.match(/android\s([0-9]+.*Chrome)/i);
  var s2 = o2 && parseInt(o2[1]);
  var a2 = { composesExistingText: /Android.*Chrome/.test(navigator.userAgent), recentAndroid: s2 && s2 > 12, samsungAndroid: s2 && navigator.userAgent.match(/Android.*SM-/), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: "undefined" != typeof InputEvent && ["data", "getTargetRanges", "inputType"].every((t4) => t4 in InputEvent.prototype) };
  var l2 = { ADD_ATTR: ["language"], SAFE_FOR_XML: false, RETURN_DOM: true };
  var c2 = { attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", byte: "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption\u2026", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL\u2026", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB" };
  var u2 = [c2.bytes, c2.KB, c2.MB, c2.GB, c2.TB, c2.PB];
  var h = { prefix: "IEC", precision: 2, formatter(t4) {
    switch (t4) {
      case 0:
        return "0 ".concat(c2.bytes);
      case 1:
        return "1 ".concat(c2.byte);
      default:
        let e2;
        "SI" === this.prefix ? e2 = 1e3 : "IEC" === this.prefix && (e2 = 1024);
        const i3 = Math.floor(Math.log(t4) / Math.log(e2)), n3 = (t4 / Math.pow(e2, i3)).toFixed(this.precision).replace(/0*$/, "").replace(/\.$/, "");
        return "".concat(n3, " ").concat(u2[i3]);
    }
  } };
  var d2 = "\uFEFF";
  var g = "\xA0";
  var m2 = function(t4) {
    for (const e2 in t4) {
      const i3 = t4[e2];
      this[e2] = i3;
    }
    return this;
  };
  var p = document.documentElement;
  var f = p.matches;
  var b2 = function(t4) {
    let { onElement: e2, matchingSelector: i3, withCallback: n3, inPhase: r3, preventDefault: o3, times: s4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const a5 = e2 || p, l5 = i3, c4 = "capturing" === r3, u5 = function(t5) {
      null != s4 && 0 == --s4 && u5.destroy();
      const e3 = y(t5.target, { matchingSelector: l5 });
      null != e3 && (null == n3 || n3.call(e3, t5, e3), o3 && t5.preventDefault());
    };
    return u5.destroy = () => a5.removeEventListener(t4, u5, c4), a5.addEventListener(t4, u5, c4), u5;
  };
  var v = function(t4) {
    let { onElement: e2, bubbles: i3, cancelable: n3, attributes: r3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const o3 = null != e2 ? e2 : p;
    i3 = false !== i3, n3 = false !== n3;
    const s4 = document.createEvent("Events");
    return s4.initEvent(t4, i3, n3), null != r3 && m2.call(s4, r3), o3.dispatchEvent(s4);
  };
  var A = function(t4, e2) {
    if (1 === (null == t4 ? void 0 : t4.nodeType)) return f.call(t4, e2);
  };
  var y = function(t4) {
    let { matchingSelector: e2, untilNode: i3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    for (; t4 && t4.nodeType !== Node.ELEMENT_NODE; ) t4 = t4.parentNode;
    if (null != t4) {
      if (null == e2) return t4;
      if (t4.closest && null == i3) return t4.closest(e2);
      for (; t4 && t4 !== i3; ) {
        if (A(t4, e2)) return t4;
        t4 = t4.parentNode;
      }
    }
  };
  var x = (t4) => document.activeElement !== t4 && C(t4, document.activeElement);
  var C = function(t4, e2) {
    if (t4 && e2) for (; e2; ) {
      if (e2 === t4) return true;
      e2 = e2.parentNode;
    }
  };
  var E = function(t4) {
    var e2;
    if (null === (e2 = t4) || void 0 === e2 || !e2.parentNode) return;
    let i3 = 0;
    for (t4 = t4.previousSibling; t4; ) i3++, t4 = t4.previousSibling;
    return i3;
  };
  var S = (t4) => {
    var e2;
    return null == t4 || null === (e2 = t4.parentNode) || void 0 === e2 ? void 0 : e2.removeChild(t4);
  };
  var R = function(t4) {
    let { onlyNodesOfType: e2, usingFilter: i3, expandEntityReferences: n3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = (() => {
      switch (e2) {
        case "element":
          return NodeFilter.SHOW_ELEMENT;
        case "text":
          return NodeFilter.SHOW_TEXT;
        case "comment":
          return NodeFilter.SHOW_COMMENT;
        default:
          return NodeFilter.SHOW_ALL;
      }
    })();
    return document.createTreeWalker(t4, r3, null != i3 ? i3 : null, true === n3);
  };
  var k = (t4) => {
    var e2;
    return null == t4 || null === (e2 = t4.tagName) || void 0 === e2 ? void 0 : e2.toLowerCase();
  };
  var T = function(t4) {
    let e2, i3, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    "object" == typeof t4 ? (n3 = t4, t4 = n3.tagName) : n3 = { attributes: n3 };
    const r3 = document.createElement(t4);
    if (null != n3.editable && (null == n3.attributes && (n3.attributes = {}), n3.attributes.contenteditable = n3.editable), n3.attributes) for (e2 in n3.attributes) i3 = n3.attributes[e2], r3.setAttribute(e2, i3);
    if (n3.style) for (e2 in n3.style) i3 = n3.style[e2], r3.style[e2] = i3;
    if (n3.data) for (e2 in n3.data) i3 = n3.data[e2], r3.dataset[e2] = i3;
    return n3.className && n3.className.split(" ").forEach((t5) => {
      r3.classList.add(t5);
    }), n3.textContent && (r3.textContent = n3.textContent), n3.childNodes && [].concat(n3.childNodes).forEach((t5) => {
      r3.appendChild(t5);
    }), r3;
  };
  var w;
  var L = function() {
    if (null != w) return w;
    w = [];
    for (const t4 in n2) {
      const e2 = n2[t4];
      e2.tagName && w.push(e2.tagName);
    }
    return w;
  };
  var D = (t4) => I(null == t4 ? void 0 : t4.firstChild);
  var N = function(t4) {
    let { strict: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { strict: true };
    return e2 ? I(t4) : I(t4) || !I(t4.firstChild) && function(t5) {
      return L().includes(k(t5)) && !L().includes(k(t5.firstChild));
    }(t4);
  };
  var I = (t4) => O(t4) && "block" === (null == t4 ? void 0 : t4.data);
  var O = (t4) => (null == t4 ? void 0 : t4.nodeType) === Node.COMMENT_NODE;
  var F = function(t4) {
    let { name: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (t4) return B(t4) ? t4.data === d2 ? !e2 || t4.parentNode.dataset.trixCursorTarget === e2 : void 0 : F(t4.firstChild);
  };
  var P = (t4) => A(t4, e);
  var M = (t4) => B(t4) && "" === (null == t4 ? void 0 : t4.data);
  var B = (t4) => (null == t4 ? void 0 : t4.nodeType) === Node.TEXT_NODE;
  var _23 = { level2Enabled: true, getLevel() {
    return this.level2Enabled && a2.supportsInputEvents ? 2 : 0;
  }, pickFiles(t4) {
    const e2 = T("input", { type: "file", multiple: true, hidden: true, id: this.fileInputId });
    e2.addEventListener("change", () => {
      t4(e2.files), S(e2);
    }), S(document.getElementById(this.fileInputId)), document.body.appendChild(e2), e2.click();
  } };
  var j = { removeBlankTableCells: false, tableCellSeparator: " | ", tableRowSeparator: "\n" };
  var W = { bold: { tagName: "strong", inheritable: true, parser(t4) {
    const e2 = window.getComputedStyle(t4);
    return "bold" === e2.fontWeight || e2.fontWeight >= 600;
  } }, italic: { tagName: "em", inheritable: true, parser: (t4) => "italic" === window.getComputedStyle(t4).fontStyle }, href: { groupTagName: "a", parser(t4) {
    const i3 = "a:not(".concat(e, ")"), n3 = t4.closest(i3);
    if (n3) return n3.getAttribute("href");
  } }, strike: { tagName: "del", inheritable: true }, frozen: { style: { backgroundColor: "highlight" } } };
  var U = { getDefaultHTML: () => '<div class="trix-button-row">\n      <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="'.concat(c2.bold, '" tabindex="-1">').concat(c2.bold, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="').concat(c2.italic, '" tabindex="-1">').concat(c2.italic, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="').concat(c2.strike, '" tabindex="-1">').concat(c2.strike, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="').concat(c2.link, '" tabindex="-1">').concat(c2.link, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="').concat(c2.heading1, '" tabindex="-1">').concat(c2.heading1, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="').concat(c2.quote, '" tabindex="-1">').concat(c2.quote, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="').concat(c2.code, '" tabindex="-1">').concat(c2.code, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="').concat(c2.bullets, '" tabindex="-1">').concat(c2.bullets, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="').concat(c2.numbers, '" tabindex="-1">').concat(c2.numbers, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="').concat(c2.outdent, '" tabindex="-1">').concat(c2.outdent, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="').concat(c2.indent, '" tabindex="-1">').concat(c2.indent, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="').concat(c2.attachFiles, '" tabindex="-1">').concat(c2.attachFiles, '</button>\n      </span>\n\n      <span class="trix-button-group-spacer"></span>\n\n      <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="').concat(c2.undo, '" tabindex="-1">').concat(c2.undo, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="').concat(c2.redo, '" tabindex="-1">').concat(c2.redo, '</button>\n      </span>\n    </div>\n\n    <div class="trix-dialogs" data-trix-dialogs>\n      <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">\n        <div class="trix-dialog__link-fields">\n          <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="').concat(c2.urlPlaceholder, '" aria-label="').concat(c2.url, '" data-trix-validate-href required data-trix-input>\n          <div class="trix-button-group">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(c2.link, '" data-trix-method="setAttribute">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(c2.unlink, '" data-trix-method="removeAttribute">\n          </div>\n        </div>\n      </div>\n    </div>') };
  var V = { interval: 5e3 };
  var z = Object.freeze({ __proto__: null, attachments: i2, blockAttributes: n2, browser: a2, css: { attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery" }, dompurify: l2, fileSize: h, input: _23, keyNames: { 8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o" }, lang: c2, parser: j, textAttributes: W, toolbar: U, undo: V });
  var q = class {
    static proxyMethod(t4) {
      const { name: e2, toMethod: i3, toProperty: n3, optional: r3 } = H(t4);
      this.prototype[e2] = function() {
        let t5, o3;
        var s4, a5;
        i3 ? o3 = r3 ? null === (s4 = this[i3]) || void 0 === s4 ? void 0 : s4.call(this) : this[i3]() : n3 && (o3 = this[n3]);
        return r3 ? (t5 = null === (a5 = o3) || void 0 === a5 ? void 0 : a5[e2], t5 ? J.call(t5, o3, arguments) : void 0) : (t5 = o3[e2], J.call(t5, o3, arguments));
      };
    }
  };
  var H = function(t4) {
    const e2 = t4.match(K);
    if (!e2) throw new Error("can't parse @proxyMethod expression: ".concat(t4));
    const i3 = { name: e2[4] };
    return null != e2[2] ? i3.toMethod = e2[1] : i3.toProperty = e2[1], null != e2[3] && (i3.optional = true), i3;
  };
  var { apply: J } = Function.prototype;
  var K = new RegExp("^(.+?)(\\(\\))?(\\?)?\\.(.+?)$");
  var G;
  var Y;
  var X;
  var $3 = class extends q {
    static box() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      return t4 instanceof this ? t4 : this.fromUCS2String(null == t4 ? void 0 : t4.toString());
    }
    static fromUCS2String(t4) {
      return new this(t4, et(t4));
    }
    static fromCodepoints(t4) {
      return new this(it(t4), t4);
    }
    constructor(t4, e2) {
      super(...arguments), this.ucs2String = t4, this.codepoints = e2, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
    }
    offsetToUCS2Offset(t4) {
      return it(this.codepoints.slice(0, Math.max(0, t4))).length;
    }
    offsetFromUCS2Offset(t4) {
      return et(this.ucs2String.slice(0, Math.max(0, t4))).length;
    }
    slice() {
      return this.constructor.fromCodepoints(this.codepoints.slice(...arguments));
    }
    charAt(t4) {
      return this.slice(t4, t4 + 1);
    }
    isEqualTo(t4) {
      return this.constructor.box(t4).ucs2String === this.ucs2String;
    }
    toJSON() {
      return this.ucs2String;
    }
    getCacheKey() {
      return this.ucs2String;
    }
    toString() {
      return this.ucs2String;
    }
  };
  var Z = 1 === (null === (G = Array.from) || void 0 === G ? void 0 : G.call(Array, "\u{1F47C}").length);
  var Q = null != (null === (Y = " ".codePointAt) || void 0 === Y ? void 0 : Y.call(" ", 0));
  var tt = " \u{1F47C}" === (null === (X = String.fromCodePoint) || void 0 === X ? void 0 : X.call(String, 32, 128124));
  var et;
  var it;
  et = Z && Q ? (t4) => Array.from(t4).map((t5) => t5.codePointAt(0)) : function(t4) {
    const e2 = [];
    let i3 = 0;
    const { length: n3 } = t4;
    for (; i3 < n3; ) {
      let r3 = t4.charCodeAt(i3++);
      if (55296 <= r3 && r3 <= 56319 && i3 < n3) {
        const e3 = t4.charCodeAt(i3++);
        56320 == (64512 & e3) ? r3 = ((1023 & r3) << 10) + (1023 & e3) + 65536 : i3--;
      }
      e2.push(r3);
    }
    return e2;
  }, it = tt ? (t4) => String.fromCodePoint(...Array.from(t4 || [])) : function(t4) {
    return (() => {
      const e2 = [];
      return Array.from(t4).forEach((t5) => {
        let i3 = "";
        t5 > 65535 && (t5 -= 65536, i3 += String.fromCharCode(t5 >>> 10 & 1023 | 55296), t5 = 56320 | 1023 & t5), e2.push(i3 + String.fromCharCode(t5));
      }), e2;
    })().join("");
  };
  var nt = 0;
  var rt = class extends q {
    static fromJSONString(t4) {
      return this.fromJSON(JSON.parse(t4));
    }
    constructor() {
      super(...arguments), this.id = ++nt;
    }
    hasSameConstructorAs(t4) {
      return this.constructor === (null == t4 ? void 0 : t4.constructor);
    }
    isEqualTo(t4) {
      return this === t4;
    }
    inspect() {
      const t4 = [], e2 = this.contentsForInspection() || {};
      for (const i3 in e2) {
        const n3 = e2[i3];
        t4.push("".concat(i3, "=").concat(n3));
      }
      return "#<".concat(this.constructor.name, ":").concat(this.id).concat(t4.length ? " ".concat(t4.join(", ")) : "", ">");
    }
    contentsForInspection() {
    }
    toJSONString() {
      return JSON.stringify(this);
    }
    toUTF16String() {
      return $3.box(this);
    }
    getCacheKey() {
      return this.id.toString();
    }
  };
  var ot = function() {
    let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (t4.length !== e2.length) return false;
    for (let i3 = 0; i3 < t4.length; i3++) {
      if (t4[i3] !== e2[i3]) return false;
    }
    return true;
  };
  var st = function(t4) {
    const e2 = t4.slice(0);
    for (var i3 = arguments.length, n3 = new Array(i3 > 1 ? i3 - 1 : 0), r3 = 1; r3 < i3; r3++) n3[r3 - 1] = arguments[r3];
    return e2.splice(...n3), e2;
  };
  var at = /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/;
  var lt = function() {
    const t4 = T("input", { dir: "auto", name: "x", dirName: "x.dir" }), e2 = T("textarea", { dir: "auto", name: "y", dirName: "y.dir" }), i3 = T("form");
    i3.appendChild(t4), i3.appendChild(e2);
    const n3 = function() {
      try {
        return new FormData(i3).has(e2.dirName);
      } catch (t5) {
        return false;
      }
    }(), r3 = function() {
      try {
        return t4.matches(":dir(ltr),:dir(rtl)");
      } catch (t5) {
        return false;
      }
    }();
    return n3 ? function(t5) {
      return e2.value = t5, new FormData(i3).get(e2.dirName);
    } : r3 ? function(e3) {
      return t4.value = e3, t4.matches(":dir(rtl)") ? "rtl" : "ltr";
    } : function(t5) {
      const e3 = t5.trim().charAt(0);
      return at.test(e3) ? "rtl" : "ltr";
    };
  }();
  var ct = null;
  var ut = null;
  var ht = null;
  var dt = null;
  var gt = () => (ct || (ct = bt().concat(pt())), ct);
  var mt = (t4) => n2[t4];
  var pt = () => (ut || (ut = Object.keys(n2)), ut);
  var ft = (t4) => W[t4];
  var bt = () => (ht || (ht = Object.keys(W)), ht);
  var vt = function(t4, e2) {
    At(t4).textContent = e2.replace(/%t/g, t4);
  };
  var At = function(t4) {
    const e2 = document.createElement("style");
    e2.setAttribute("type", "text/css"), e2.setAttribute("data-tag-name", t4.toLowerCase());
    const i3 = yt();
    return i3 && e2.setAttribute("nonce", i3), document.head.insertBefore(e2, document.head.firstChild), e2;
  };
  var yt = function() {
    const t4 = xt("trix-csp-nonce") || xt("csp-nonce");
    if (t4) {
      const { nonce: e2, content: i3 } = t4;
      return "" == e2 ? i3 : e2;
    }
  };
  var xt = (t4) => document.head.querySelector("meta[name=".concat(t4, "]"));
  var Ct = { "application/x-trix-feature-detection": "test" };
  var Et = function(t4) {
    const e2 = t4.getData("text/plain"), i3 = t4.getData("text/html");
    if (!e2 || !i3) return null == e2 ? void 0 : e2.length;
    {
      const { body: t5 } = new DOMParser().parseFromString(i3, "text/html");
      if (t5.textContent === e2) return !t5.querySelector("*");
    }
  };
  var St = /Mac|^iP/.test(navigator.platform) ? (t4) => t4.metaKey : (t4) => t4.ctrlKey;
  var Rt = (t4) => setTimeout(t4, 1);
  var kt = function() {
    let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const e2 = {};
    for (const i3 in t4) {
      const n3 = t4[i3];
      e2[i3] = n3;
    }
    return e2;
  };
  var Tt = function() {
    let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (Object.keys(t4).length !== Object.keys(e2).length) return false;
    for (const i3 in t4) {
      if (t4[i3] !== e2[i3]) return false;
    }
    return true;
  };
  var wt = function(t4) {
    if (null != t4) return Array.isArray(t4) || (t4 = [t4, t4]), [Nt(t4[0]), Nt(null != t4[1] ? t4[1] : t4[0])];
  };
  var Lt = function(t4) {
    if (null == t4) return;
    const [e2, i3] = wt(t4);
    return It(e2, i3);
  };
  var Dt = function(t4, e2) {
    if (null == t4 || null == e2) return;
    const [i3, n3] = wt(t4), [r3, o3] = wt(e2);
    return It(i3, r3) && It(n3, o3);
  };
  var Nt = function(t4) {
    return "number" == typeof t4 ? t4 : kt(t4);
  };
  var It = function(t4, e2) {
    return "number" == typeof t4 ? t4 === e2 : Tt(t4, e2);
  };
  var Ot = class extends q {
    constructor() {
      super(...arguments), this.update = this.update.bind(this), this.selectionManagers = [];
    }
    start() {
      this.started || (this.started = true, document.addEventListener("selectionchange", this.update, true));
    }
    stop() {
      if (this.started) return this.started = false, document.removeEventListener("selectionchange", this.update, true);
    }
    registerSelectionManager(t4) {
      if (!this.selectionManagers.includes(t4)) return this.selectionManagers.push(t4), this.start();
    }
    unregisterSelectionManager(t4) {
      if (this.selectionManagers = this.selectionManagers.filter((e2) => e2 !== t4), 0 === this.selectionManagers.length) return this.stop();
    }
    notifySelectionManagersOfSelectionChange() {
      return this.selectionManagers.map((t4) => t4.selectionDidChange());
    }
    update() {
      this.notifySelectionManagersOfSelectionChange();
    }
    reset() {
      this.update();
    }
  };
  var Ft = new Ot();
  var Pt = function() {
    const t4 = window.getSelection();
    if (t4.rangeCount > 0) return t4;
  };
  var Mt = function() {
    var t4;
    const e2 = null === (t4 = Pt()) || void 0 === t4 ? void 0 : t4.getRangeAt(0);
    if (e2 && !_t(e2)) return e2;
  };
  var Bt = function(t4) {
    const e2 = window.getSelection();
    return e2.removeAllRanges(), e2.addRange(t4), Ft.update();
  };
  var _t = (t4) => jt(t4.startContainer) || jt(t4.endContainer);
  var jt = (t4) => !Object.getPrototypeOf(t4);
  var Wt = (t4) => t4.replace(new RegExp("".concat(d2), "g"), "").replace(new RegExp("".concat(g), "g"), " ");
  var Ut = new RegExp("[^\\S".concat(g, "]"));
  var Vt = (t4) => t4.replace(new RegExp("".concat(Ut.source), "g"), " ").replace(/\ {2,}/g, " ");
  var zt = function(t4, e2) {
    if (t4.isEqualTo(e2)) return ["", ""];
    const i3 = qt(t4, e2), { length: n3 } = i3.utf16String;
    let r3;
    if (n3) {
      const { offset: o3 } = i3, s4 = t4.codepoints.slice(0, o3).concat(t4.codepoints.slice(o3 + n3));
      r3 = qt(e2, $3.fromCodepoints(s4));
    } else r3 = qt(e2, t4);
    return [i3.utf16String.toString(), r3.utf16String.toString()];
  };
  var qt = function(t4, e2) {
    let i3 = 0, n3 = t4.length, r3 = e2.length;
    for (; i3 < n3 && t4.charAt(i3).isEqualTo(e2.charAt(i3)); ) i3++;
    for (; n3 > i3 + 1 && t4.charAt(n3 - 1).isEqualTo(e2.charAt(r3 - 1)); ) n3--, r3--;
    return { utf16String: t4.slice(i3, n3), offset: i3 };
  };
  var Ht = class _Ht extends rt {
    static fromCommonAttributesOfObjects() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      if (!t4.length) return new this();
      let e2 = Yt(t4[0]), i3 = e2.getKeys();
      return t4.slice(1).forEach((t5) => {
        i3 = e2.getKeysCommonToHash(Yt(t5)), e2 = e2.slice(i3);
      }), e2;
    }
    static box(t4) {
      return Yt(t4);
    }
    constructor() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      super(...arguments), this.values = Gt(t4);
    }
    add(t4, e2) {
      return this.merge(Jt(t4, e2));
    }
    remove(t4) {
      return new _Ht(Gt(this.values, t4));
    }
    get(t4) {
      return this.values[t4];
    }
    has(t4) {
      return t4 in this.values;
    }
    merge(t4) {
      return new _Ht(Kt(this.values, Xt(t4)));
    }
    slice(t4) {
      const e2 = {};
      return Array.from(t4).forEach((t5) => {
        this.has(t5) && (e2[t5] = this.values[t5]);
      }), new _Ht(e2);
    }
    getKeys() {
      return Object.keys(this.values);
    }
    getKeysCommonToHash(t4) {
      return t4 = Yt(t4), this.getKeys().filter((e2) => this.values[e2] === t4.values[e2]);
    }
    isEqualTo(t4) {
      return ot(this.toArray(), Yt(t4).toArray());
    }
    isEmpty() {
      return 0 === this.getKeys().length;
    }
    toArray() {
      if (!this.array) {
        const t4 = [];
        for (const e2 in this.values) {
          const i3 = this.values[e2];
          t4.push(t4.push(e2, i3));
        }
        this.array = t4.slice(0);
      }
      return this.array;
    }
    toObject() {
      return Gt(this.values);
    }
    toJSON() {
      return this.toObject();
    }
    contentsForInspection() {
      return { values: JSON.stringify(this.values) };
    }
  };
  var Jt = function(t4, e2) {
    const i3 = {};
    return i3[t4] = e2, i3;
  };
  var Kt = function(t4, e2) {
    const i3 = Gt(t4);
    for (const t5 in e2) {
      const n3 = e2[t5];
      i3[t5] = n3;
    }
    return i3;
  };
  var Gt = function(t4, e2) {
    const i3 = {};
    return Object.keys(t4).sort().forEach((n3) => {
      n3 !== e2 && (i3[n3] = t4[n3]);
    }), i3;
  };
  var Yt = function(t4) {
    return t4 instanceof Ht ? t4 : new Ht(t4);
  };
  var Xt = function(t4) {
    return t4 instanceof Ht ? t4.values : t4;
  };
  var $t = class {
    static groupObjects() {
      let t4, e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: i3, asTree: n3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      n3 && null == i3 && (i3 = 0);
      const r3 = [];
      return Array.from(e2).forEach((e3) => {
        var o3;
        if (t4) {
          var s4, a5, l5;
          if (null !== (s4 = e3.canBeGrouped) && void 0 !== s4 && s4.call(e3, i3) && null !== (a5 = (l5 = t4[t4.length - 1]).canBeGroupedWith) && void 0 !== a5 && a5.call(l5, e3, i3)) return void t4.push(e3);
          r3.push(new this(t4, { depth: i3, asTree: n3 })), t4 = null;
        }
        null !== (o3 = e3.canBeGrouped) && void 0 !== o3 && o3.call(e3, i3) ? t4 = [e3] : r3.push(e3);
      }), t4 && r3.push(new this(t4, { depth: i3, asTree: n3 })), r3;
    }
    constructor() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: e2, asTree: i3 } = arguments.length > 1 ? arguments[1] : void 0;
      this.objects = t4, i3 && (this.depth = e2, this.objects = this.constructor.groupObjects(this.objects, { asTree: i3, depth: this.depth + 1 }));
    }
    getObjects() {
      return this.objects;
    }
    getDepth() {
      return this.depth;
    }
    getCacheKey() {
      const t4 = ["objectGroup"];
      return Array.from(this.getObjects()).forEach((e2) => {
        t4.push(e2.getCacheKey());
      }), t4.join("/");
    }
  };
  var Zt = class extends q {
    constructor() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.objects = {}, Array.from(t4).forEach((t5) => {
        const e2 = JSON.stringify(t5);
        null == this.objects[e2] && (this.objects[e2] = t5);
      });
    }
    find(t4) {
      const e2 = JSON.stringify(t4);
      return this.objects[e2];
    }
  };
  var Qt = class {
    constructor(t4) {
      this.reset(t4);
    }
    add(t4) {
      const e2 = te(t4);
      this.elements[e2] = t4;
    }
    remove(t4) {
      const e2 = te(t4), i3 = this.elements[e2];
      if (i3) return delete this.elements[e2], i3;
    }
    reset() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      return this.elements = {}, Array.from(t4).forEach((t5) => {
        this.add(t5);
      }), t4;
    }
  };
  var te = (t4) => t4.dataset.trixStoreKey;
  var ee = class extends q {
    isPerforming() {
      return true === this.performing;
    }
    hasPerformed() {
      return true === this.performed;
    }
    hasSucceeded() {
      return this.performed && this.succeeded;
    }
    hasFailed() {
      return this.performed && !this.succeeded;
    }
    getPromise() {
      return this.promise || (this.promise = new Promise((t4, e2) => (this.performing = true, this.perform((i3, n3) => {
        this.succeeded = i3, this.performing = false, this.performed = true, this.succeeded ? t4(n3) : e2(n3);
      })))), this.promise;
    }
    perform(t4) {
      return t4(false);
    }
    release() {
      var t4, e2;
      null === (t4 = this.promise) || void 0 === t4 || null === (e2 = t4.cancel) || void 0 === e2 || e2.call(t4), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
    }
  };
  ee.proxyMethod("getPromise().then"), ee.proxyMethod("getPromise().catch");
  var ie = class extends q {
    constructor(t4) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.object = t4, this.options = e2, this.childViews = [], this.rootView = this;
    }
    getNodes() {
      return this.nodes || (this.nodes = this.createNodes()), this.nodes.map((t4) => t4.cloneNode(true));
    }
    invalidate() {
      var t4;
      return this.nodes = null, this.childViews = [], null === (t4 = this.parentView) || void 0 === t4 ? void 0 : t4.invalidate();
    }
    invalidateViewForObject(t4) {
      var e2;
      return null === (e2 = this.findViewForObject(t4)) || void 0 === e2 ? void 0 : e2.invalidate();
    }
    findOrCreateCachedChildView(t4, e2, i3) {
      let n3 = this.getCachedViewForObject(e2);
      return n3 ? this.recordChildView(n3) : (n3 = this.createChildView(...arguments), this.cacheViewForObject(n3, e2)), n3;
    }
    createChildView(t4, e2) {
      let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      e2 instanceof $t && (i3.viewClass = t4, t4 = ne);
      const n3 = new t4(e2, i3);
      return this.recordChildView(n3);
    }
    recordChildView(t4) {
      return t4.parentView = this, t4.rootView = this.rootView, this.childViews.push(t4), t4;
    }
    getAllChildViews() {
      let t4 = [];
      return this.childViews.forEach((e2) => {
        t4.push(e2), t4 = t4.concat(e2.getAllChildViews());
      }), t4;
    }
    findElement() {
      return this.findElementForObject(this.object);
    }
    findElementForObject(t4) {
      const e2 = null == t4 ? void 0 : t4.id;
      if (e2) return this.rootView.element.querySelector("[data-trix-id='".concat(e2, "']"));
    }
    findViewForObject(t4) {
      for (const e2 of this.getAllChildViews()) if (e2.object === t4) return e2;
    }
    getViewCache() {
      return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? (this.viewCache || (this.viewCache = {}), this.viewCache) : void 0;
    }
    isViewCachingEnabled() {
      return false !== this.shouldCacheViews;
    }
    enableViewCaching() {
      this.shouldCacheViews = true;
    }
    disableViewCaching() {
      this.shouldCacheViews = false;
    }
    getCachedViewForObject(t4) {
      var e2;
      return null === (e2 = this.getViewCache()) || void 0 === e2 ? void 0 : e2[t4.getCacheKey()];
    }
    cacheViewForObject(t4, e2) {
      const i3 = this.getViewCache();
      i3 && (i3[e2.getCacheKey()] = t4);
    }
    garbageCollectCachedViews() {
      const t4 = this.getViewCache();
      if (t4) {
        const e2 = this.getAllChildViews().concat(this).map((t5) => t5.object.getCacheKey());
        for (const i3 in t4) e2.includes(i3) || delete t4[i3];
      }
    }
  };
  var ne = class extends ie {
    constructor() {
      super(...arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
    }
    getChildViews() {
      return this.childViews.length || Array.from(this.objectGroup.getObjects()).forEach((t4) => {
        this.findOrCreateCachedChildView(this.viewClass, t4, this.options);
      }), this.childViews;
    }
    createNodes() {
      const t4 = this.createContainerElement();
      return this.getChildViews().forEach((e2) => {
        Array.from(e2.getNodes()).forEach((e3) => {
          t4.appendChild(e3);
        });
      }), [t4];
    }
    createContainerElement() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.objectGroup.getDepth();
      return this.getChildViews()[0].createContainerElement(t4);
    }
  };
  var { entries: re, setPrototypeOf: oe, isFrozen: se, getPrototypeOf: ae, getOwnPropertyDescriptor: le } = Object;
  var { freeze: ce, seal: ue, create: he } = Object;
  var { apply: de, construct: ge } = "undefined" != typeof Reflect && Reflect;
  ce || (ce = function(t4) {
    return t4;
  }), ue || (ue = function(t4) {
    return t4;
  }), de || (de = function(t4, e2, i3) {
    return t4.apply(e2, i3);
  }), ge || (ge = function(t4, e2) {
    return new t4(...e2);
  });
  var me = Le(Array.prototype.forEach);
  var pe = Le(Array.prototype.lastIndexOf);
  var fe = Le(Array.prototype.pop);
  var be = Le(Array.prototype.push);
  var ve = Le(Array.prototype.splice);
  var Ae = Le(String.prototype.toLowerCase);
  var ye = Le(String.prototype.toString);
  var xe = Le(String.prototype.match);
  var Ce = Le(String.prototype.replace);
  var Ee = Le(String.prototype.indexOf);
  var Se = Le(String.prototype.trim);
  var Re = Le(Object.prototype.hasOwnProperty);
  var ke = Le(RegExp.prototype.test);
  var Te = (we = TypeError, function() {
    for (var t4 = arguments.length, e2 = new Array(t4), i3 = 0; i3 < t4; i3++) e2[i3] = arguments[i3];
    return ge(we, e2);
  });
  var we;
  function Le(t4) {
    return function(e2) {
      e2 instanceof RegExp && (e2.lastIndex = 0);
      for (var i3 = arguments.length, n3 = new Array(i3 > 1 ? i3 - 1 : 0), r3 = 1; r3 < i3; r3++) n3[r3 - 1] = arguments[r3];
      return de(t4, e2, n3);
    };
  }
  function De(t4, e2) {
    let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ae;
    oe && oe(t4, null);
    let n3 = e2.length;
    for (; n3--; ) {
      let r3 = e2[n3];
      if ("string" == typeof r3) {
        const t5 = i3(r3);
        t5 !== r3 && (se(e2) || (e2[n3] = t5), r3 = t5);
      }
      t4[r3] = true;
    }
    return t4;
  }
  function Ne(t4) {
    for (let e2 = 0; e2 < t4.length; e2++) {
      Re(t4, e2) || (t4[e2] = null);
    }
    return t4;
  }
  function Ie(t4) {
    const e2 = he(null);
    for (const [i3, n3] of re(t4)) {
      Re(t4, i3) && (Array.isArray(n3) ? e2[i3] = Ne(n3) : n3 && "object" == typeof n3 && n3.constructor === Object ? e2[i3] = Ie(n3) : e2[i3] = n3);
    }
    return e2;
  }
  function Oe(t4, e2) {
    for (; null !== t4; ) {
      const i3 = le(t4, e2);
      if (i3) {
        if (i3.get) return Le(i3.get);
        if ("function" == typeof i3.value) return Le(i3.value);
      }
      t4 = ae(t4);
    }
    return function() {
      return null;
    };
  }
  var Fe = ce(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var Pe = ce(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var Me = ce(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var Be = ce(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var _e = ce(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  var je = ce(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var We = ce(["#text"]);
  var Ue = ce(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  var Ve = ce(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var ze = ce(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var qe = ce(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var He = ue(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var Je = ue(/<%[\w\W]*|[\w\W]*%>/gm);
  var Ke = ue(/\$\{[\w\W]*/gm);
  var Ge = ue(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  var Ye = ue(/^aria-[\-\w]+$/);
  var Xe = ue(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
  var $e = ue(/^(?:\w+script|data):/i);
  var Ze = ue(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
  var Qe = ue(/^html$/i);
  var ti = ue(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var ei = Object.freeze({ __proto__: null, ARIA_ATTR: Ye, ATTR_WHITESPACE: Ze, CUSTOM_ELEMENT: ti, DATA_ATTR: Ge, DOCTYPE_NAME: Qe, ERB_EXPR: Je, IS_ALLOWED_URI: Xe, IS_SCRIPT_OR_DATA: $e, MUSTACHE_EXPR: He, TMPLIT_EXPR: Ke });
  var ii = 1;
  var ni = 3;
  var ri = 7;
  var oi = 8;
  var si = 9;
  var ai = function() {
    return "undefined" == typeof window ? null : window;
  };
  var li = function t3() {
    let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ai();
    const i3 = (e3) => t3(e3);
    if (i3.version = "3.2.5", i3.removed = [], !e2 || !e2.document || e2.document.nodeType !== si || !e2.Element) return i3.isSupported = false, i3;
    let { document: n3 } = e2;
    const r3 = n3, o3 = r3.currentScript, { DocumentFragment: s4, HTMLTemplateElement: a5, Node: l5, Element: c4, NodeFilter: u5, NamedNodeMap: h4 = e2.NamedNodeMap || e2.MozNamedAttrMap, HTMLFormElement: d5, DOMParser: g4, trustedTypes: m4 } = e2, p4 = c4.prototype, f4 = Oe(p4, "cloneNode"), b5 = Oe(p4, "remove"), v4 = Oe(p4, "nextSibling"), A4 = Oe(p4, "childNodes"), y6 = Oe(p4, "parentNode");
    if ("function" == typeof a5) {
      const t4 = n3.createElement("template");
      t4.content && t4.content.ownerDocument && (n3 = t4.content.ownerDocument);
    }
    let x4, C4 = "";
    const { implementation: E5, createNodeIterator: S5, createDocumentFragment: R6, getElementsByTagName: k4 } = n3, { importNode: T5 } = r3;
    let w5 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
    i3.isSupported = "function" == typeof re && "function" == typeof y6 && E5 && void 0 !== E5.createHTMLDocument;
    const { MUSTACHE_EXPR: L6, ERB_EXPR: D6, TMPLIT_EXPR: N5, DATA_ATTR: I4, ARIA_ATTR: O6, IS_SCRIPT_OR_DATA: F5, ATTR_WHITESPACE: P6, CUSTOM_ELEMENT: M5 } = ei;
    let { IS_ALLOWED_URI: B4 } = ei, _26 = null;
    const j6 = De({}, [...Fe, ...Pe, ...Me, ..._e, ...We]);
    let W5 = null;
    const U5 = De({}, [...Ue, ...Ve, ...ze, ...qe]);
    let V5 = Object.seal(he(null, { tagNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, allowCustomizedBuiltInElements: { writable: true, configurable: false, enumerable: true, value: false } })), z5 = null, q4 = null, H5 = true, J4 = true, K4 = false, G6 = true, Y6 = false, X6 = true, $7 = false, Z5 = false, Q5 = false, tt3 = false, et3 = false, it3 = false, nt3 = true, rt3 = false, ot3 = true, st3 = false, at3 = {}, lt3 = null;
    const ct3 = De({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let ut3 = null;
    const ht3 = De({}, ["audio", "video", "img", "source", "image", "track"]);
    let dt3 = null;
    const gt3 = De({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), mt3 = "http://www.w3.org/1998/Math/MathML", pt3 = "http://www.w3.org/2000/svg", ft3 = "http://www.w3.org/1999/xhtml";
    let bt3 = ft3, vt3 = false, At3 = null;
    const yt3 = De({}, [mt3, pt3, ft3], ye);
    let xt3 = De({}, ["mi", "mo", "mn", "ms", "mtext"]), Ct3 = De({}, ["annotation-xml"]);
    const Et3 = De({}, ["title", "style", "font", "a", "script"]);
    let St4 = null;
    const Rt3 = ["application/xhtml+xml", "text/html"];
    let kt3 = null, Tt3 = null;
    const wt3 = n3.createElement("form"), Lt3 = function(t4) {
      return t4 instanceof RegExp || t4 instanceof Function;
    }, Dt3 = function() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (!Tt3 || Tt3 !== t4) {
        if (t4 && "object" == typeof t4 || (t4 = {}), t4 = Ie(t4), St4 = -1 === Rt3.indexOf(t4.PARSER_MEDIA_TYPE) ? "text/html" : t4.PARSER_MEDIA_TYPE, kt3 = "application/xhtml+xml" === St4 ? ye : Ae, _26 = Re(t4, "ALLOWED_TAGS") ? De({}, t4.ALLOWED_TAGS, kt3) : j6, W5 = Re(t4, "ALLOWED_ATTR") ? De({}, t4.ALLOWED_ATTR, kt3) : U5, At3 = Re(t4, "ALLOWED_NAMESPACES") ? De({}, t4.ALLOWED_NAMESPACES, ye) : yt3, dt3 = Re(t4, "ADD_URI_SAFE_ATTR") ? De(Ie(gt3), t4.ADD_URI_SAFE_ATTR, kt3) : gt3, ut3 = Re(t4, "ADD_DATA_URI_TAGS") ? De(Ie(ht3), t4.ADD_DATA_URI_TAGS, kt3) : ht3, lt3 = Re(t4, "FORBID_CONTENTS") ? De({}, t4.FORBID_CONTENTS, kt3) : ct3, z5 = Re(t4, "FORBID_TAGS") ? De({}, t4.FORBID_TAGS, kt3) : {}, q4 = Re(t4, "FORBID_ATTR") ? De({}, t4.FORBID_ATTR, kt3) : {}, at3 = !!Re(t4, "USE_PROFILES") && t4.USE_PROFILES, H5 = false !== t4.ALLOW_ARIA_ATTR, J4 = false !== t4.ALLOW_DATA_ATTR, K4 = t4.ALLOW_UNKNOWN_PROTOCOLS || false, G6 = false !== t4.ALLOW_SELF_CLOSE_IN_ATTR, Y6 = t4.SAFE_FOR_TEMPLATES || false, X6 = false !== t4.SAFE_FOR_XML, $7 = t4.WHOLE_DOCUMENT || false, tt3 = t4.RETURN_DOM || false, et3 = t4.RETURN_DOM_FRAGMENT || false, it3 = t4.RETURN_TRUSTED_TYPE || false, Q5 = t4.FORCE_BODY || false, nt3 = false !== t4.SANITIZE_DOM, rt3 = t4.SANITIZE_NAMED_PROPS || false, ot3 = false !== t4.KEEP_CONTENT, st3 = t4.IN_PLACE || false, B4 = t4.ALLOWED_URI_REGEXP || Xe, bt3 = t4.NAMESPACE || ft3, xt3 = t4.MATHML_TEXT_INTEGRATION_POINTS || xt3, Ct3 = t4.HTML_INTEGRATION_POINTS || Ct3, V5 = t4.CUSTOM_ELEMENT_HANDLING || {}, t4.CUSTOM_ELEMENT_HANDLING && Lt3(t4.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (V5.tagNameCheck = t4.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t4.CUSTOM_ELEMENT_HANDLING && Lt3(t4.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (V5.attributeNameCheck = t4.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t4.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof t4.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (V5.allowCustomizedBuiltInElements = t4.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Y6 && (J4 = false), et3 && (tt3 = true), at3 && (_26 = De({}, We), W5 = [], true === at3.html && (De(_26, Fe), De(W5, Ue)), true === at3.svg && (De(_26, Pe), De(W5, Ve), De(W5, qe)), true === at3.svgFilters && (De(_26, Me), De(W5, Ve), De(W5, qe)), true === at3.mathMl && (De(_26, _e), De(W5, ze), De(W5, qe))), t4.ADD_TAGS && (_26 === j6 && (_26 = Ie(_26)), De(_26, t4.ADD_TAGS, kt3)), t4.ADD_ATTR && (W5 === U5 && (W5 = Ie(W5)), De(W5, t4.ADD_ATTR, kt3)), t4.ADD_URI_SAFE_ATTR && De(dt3, t4.ADD_URI_SAFE_ATTR, kt3), t4.FORBID_CONTENTS && (lt3 === ct3 && (lt3 = Ie(lt3)), De(lt3, t4.FORBID_CONTENTS, kt3)), ot3 && (_26["#text"] = true), $7 && De(_26, ["html", "head", "body"]), _26.table && (De(_26, ["tbody"]), delete z5.tbody), t4.TRUSTED_TYPES_POLICY) {
          if ("function" != typeof t4.TRUSTED_TYPES_POLICY.createHTML) throw Te('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if ("function" != typeof t4.TRUSTED_TYPES_POLICY.createScriptURL) throw Te('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          x4 = t4.TRUSTED_TYPES_POLICY, C4 = x4.createHTML("");
        } else void 0 === x4 && (x4 = function(t5, e3) {
          if ("object" != typeof t5 || "function" != typeof t5.createPolicy) return null;
          let i4 = null;
          const n4 = "data-tt-policy-suffix";
          e3 && e3.hasAttribute(n4) && (i4 = e3.getAttribute(n4));
          const r4 = "dompurify" + (i4 ? "#" + i4 : "");
          try {
            return t5.createPolicy(r4, { createHTML: (t6) => t6, createScriptURL: (t6) => t6 });
          } catch (t6) {
            return console.warn("TrustedTypes policy " + r4 + " could not be created."), null;
          }
        }(m4, o3)), null !== x4 && "string" == typeof C4 && (C4 = x4.createHTML(""));
        ce && ce(t4), Tt3 = t4;
      }
    }, Nt3 = De({}, [...Pe, ...Me, ...Be]), It3 = De({}, [..._e, ...je]), Ot3 = function(t4) {
      be(i3.removed, { element: t4 });
      try {
        y6(t4).removeChild(t4);
      } catch (e3) {
        b5(t4);
      }
    }, Ft3 = function(t4, e3) {
      try {
        be(i3.removed, { attribute: e3.getAttributeNode(t4), from: e3 });
      } catch (t5) {
        be(i3.removed, { attribute: null, from: e3 });
      }
      if (e3.removeAttribute(t4), "is" === t4) if (tt3 || et3) try {
        Ot3(e3);
      } catch (t5) {
      }
      else try {
        e3.setAttribute(t4, "");
      } catch (t5) {
      }
    }, Pt3 = function(t4) {
      let e3 = null, i4 = null;
      if (Q5) t4 = "<remove></remove>" + t4;
      else {
        const e4 = xe(t4, /^[\r\n\t ]+/);
        i4 = e4 && e4[0];
      }
      "application/xhtml+xml" === St4 && bt3 === ft3 && (t4 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + t4 + "</body></html>");
      const r4 = x4 ? x4.createHTML(t4) : t4;
      if (bt3 === ft3) try {
        e3 = new g4().parseFromString(r4, St4);
      } catch (t5) {
      }
      if (!e3 || !e3.documentElement) {
        e3 = E5.createDocument(bt3, "template", null);
        try {
          e3.documentElement.innerHTML = vt3 ? C4 : r4;
        } catch (t5) {
        }
      }
      const o4 = e3.body || e3.documentElement;
      return t4 && i4 && o4.insertBefore(n3.createTextNode(i4), o4.childNodes[0] || null), bt3 === ft3 ? k4.call(e3, $7 ? "html" : "body")[0] : $7 ? e3.documentElement : o4;
    }, Mt3 = function(t4) {
      return S5.call(t4.ownerDocument || t4, t4, u5.SHOW_ELEMENT | u5.SHOW_COMMENT | u5.SHOW_TEXT | u5.SHOW_PROCESSING_INSTRUCTION | u5.SHOW_CDATA_SECTION, null);
    }, Bt3 = function(t4) {
      return t4 instanceof d5 && ("string" != typeof t4.nodeName || "string" != typeof t4.textContent || "function" != typeof t4.removeChild || !(t4.attributes instanceof h4) || "function" != typeof t4.removeAttribute || "function" != typeof t4.setAttribute || "string" != typeof t4.namespaceURI || "function" != typeof t4.insertBefore || "function" != typeof t4.hasChildNodes);
    }, _t3 = function(t4) {
      return "function" == typeof l5 && t4 instanceof l5;
    };
    function jt3(t4, e3, n4) {
      me(t4, (t5) => {
        t5.call(i3, e3, n4, Tt3);
      });
    }
    const Wt3 = function(t4) {
      let e3 = null;
      if (jt3(w5.beforeSanitizeElements, t4, null), Bt3(t4)) return Ot3(t4), true;
      const n4 = kt3(t4.nodeName);
      if (jt3(w5.uponSanitizeElement, t4, { tagName: n4, allowedTags: _26 }), t4.hasChildNodes() && !_t3(t4.firstElementChild) && ke(/<[/\w!]/g, t4.innerHTML) && ke(/<[/\w!]/g, t4.textContent)) return Ot3(t4), true;
      if (t4.nodeType === ri) return Ot3(t4), true;
      if (X6 && t4.nodeType === oi && ke(/<[/\w]/g, t4.data)) return Ot3(t4), true;
      if (!_26[n4] || z5[n4]) {
        if (!z5[n4] && Vt3(n4)) {
          if (V5.tagNameCheck instanceof RegExp && ke(V5.tagNameCheck, n4)) return false;
          if (V5.tagNameCheck instanceof Function && V5.tagNameCheck(n4)) return false;
        }
        if (ot3 && !lt3[n4]) {
          const e4 = y6(t4) || t4.parentNode, i4 = A4(t4) || t4.childNodes;
          if (i4 && e4) {
            for (let n5 = i4.length - 1; n5 >= 0; --n5) {
              const r4 = f4(i4[n5], true);
              r4.__removalCount = (t4.__removalCount || 0) + 1, e4.insertBefore(r4, v4(t4));
            }
          }
        }
        return Ot3(t4), true;
      }
      return t4 instanceof c4 && !function(t5) {
        let e4 = y6(t5);
        e4 && e4.tagName || (e4 = { namespaceURI: bt3, tagName: "template" });
        const i4 = Ae(t5.tagName), n5 = Ae(e4.tagName);
        return !!At3[t5.namespaceURI] && (t5.namespaceURI === pt3 ? e4.namespaceURI === ft3 ? "svg" === i4 : e4.namespaceURI === mt3 ? "svg" === i4 && ("annotation-xml" === n5 || xt3[n5]) : Boolean(Nt3[i4]) : t5.namespaceURI === mt3 ? e4.namespaceURI === ft3 ? "math" === i4 : e4.namespaceURI === pt3 ? "math" === i4 && Ct3[n5] : Boolean(It3[i4]) : t5.namespaceURI === ft3 ? !(e4.namespaceURI === pt3 && !Ct3[n5]) && !(e4.namespaceURI === mt3 && !xt3[n5]) && !It3[i4] && (Et3[i4] || !Nt3[i4]) : !("application/xhtml+xml" !== St4 || !At3[t5.namespaceURI]));
      }(t4) ? (Ot3(t4), true) : "noscript" !== n4 && "noembed" !== n4 && "noframes" !== n4 || !ke(/<\/no(script|embed|frames)/i, t4.innerHTML) ? (Y6 && t4.nodeType === ni && (e3 = t4.textContent, me([L6, D6, N5], (t5) => {
        e3 = Ce(e3, t5, " ");
      }), t4.textContent !== e3 && (be(i3.removed, { element: t4.cloneNode() }), t4.textContent = e3)), jt3(w5.afterSanitizeElements, t4, null), false) : (Ot3(t4), true);
    }, Ut3 = function(t4, e3, i4) {
      if (nt3 && ("id" === e3 || "name" === e3) && (i4 in n3 || i4 in wt3)) return false;
      if (J4 && !q4[e3] && ke(I4, e3)) ;
      else if (H5 && ke(O6, e3)) ;
      else if (!W5[e3] || q4[e3]) {
        if (!(Vt3(t4) && (V5.tagNameCheck instanceof RegExp && ke(V5.tagNameCheck, t4) || V5.tagNameCheck instanceof Function && V5.tagNameCheck(t4)) && (V5.attributeNameCheck instanceof RegExp && ke(V5.attributeNameCheck, e3) || V5.attributeNameCheck instanceof Function && V5.attributeNameCheck(e3)) || "is" === e3 && V5.allowCustomizedBuiltInElements && (V5.tagNameCheck instanceof RegExp && ke(V5.tagNameCheck, i4) || V5.tagNameCheck instanceof Function && V5.tagNameCheck(i4)))) return false;
      } else if (dt3[e3]) ;
      else if (ke(B4, Ce(i4, P6, ""))) ;
      else if ("src" !== e3 && "xlink:href" !== e3 && "href" !== e3 || "script" === t4 || 0 !== Ee(i4, "data:") || !ut3[t4]) {
        if (K4 && !ke(F5, Ce(i4, P6, ""))) ;
        else if (i4) return false;
      } else ;
      return true;
    }, Vt3 = function(t4) {
      return "annotation-xml" !== t4 && xe(t4, M5);
    }, zt3 = function(t4) {
      jt3(w5.beforeSanitizeAttributes, t4, null);
      const { attributes: e3 } = t4;
      if (!e3 || Bt3(t4)) return;
      const n4 = { attrName: "", attrValue: "", keepAttr: true, allowedAttributes: W5, forceKeepAttr: void 0 };
      let r4 = e3.length;
      for (; r4--; ) {
        const o4 = e3[r4], { name: s5, namespaceURI: a6, value: l6 } = o4, c5 = kt3(s5);
        let u6 = "value" === s5 ? l6 : Se(l6);
        if (n4.attrName = c5, n4.attrValue = u6, n4.keepAttr = true, n4.forceKeepAttr = void 0, jt3(w5.uponSanitizeAttribute, t4, n4), u6 = n4.attrValue, !rt3 || "id" !== c5 && "name" !== c5 || (Ft3(s5, t4), u6 = "user-content-" + u6), X6 && ke(/((--!?|])>)|<\/(style|title)/i, u6)) {
          Ft3(s5, t4);
          continue;
        }
        if (n4.forceKeepAttr) continue;
        if (Ft3(s5, t4), !n4.keepAttr) continue;
        if (!G6 && ke(/\/>/i, u6)) {
          Ft3(s5, t4);
          continue;
        }
        Y6 && me([L6, D6, N5], (t5) => {
          u6 = Ce(u6, t5, " ");
        });
        const h5 = kt3(t4.nodeName);
        if (Ut3(h5, c5, u6)) {
          if (x4 && "object" == typeof m4 && "function" == typeof m4.getAttributeType) if (a6) ;
          else switch (m4.getAttributeType(h5, c5)) {
            case "TrustedHTML":
              u6 = x4.createHTML(u6);
              break;
            case "TrustedScriptURL":
              u6 = x4.createScriptURL(u6);
          }
          try {
            a6 ? t4.setAttributeNS(a6, s5, u6) : t4.setAttribute(s5, u6), Bt3(t4) ? Ot3(t4) : fe(i3.removed);
          } catch (t5) {
          }
        }
      }
      jt3(w5.afterSanitizeAttributes, t4, null);
    }, qt3 = function t4(e3) {
      let i4 = null;
      const n4 = Mt3(e3);
      for (jt3(w5.beforeSanitizeShadowDOM, e3, null); i4 = n4.nextNode(); ) jt3(w5.uponSanitizeShadowNode, i4, null), Wt3(i4), zt3(i4), i4.content instanceof s4 && t4(i4.content);
      jt3(w5.afterSanitizeShadowDOM, e3, null);
    };
    return i3.sanitize = function(t4) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n4 = null, o4 = null, a6 = null, c5 = null;
      if (vt3 = !t4, vt3 && (t4 = "<!-->"), "string" != typeof t4 && !_t3(t4)) {
        if ("function" != typeof t4.toString) throw Te("toString is not a function");
        if ("string" != typeof (t4 = t4.toString())) throw Te("dirty is not a string, aborting");
      }
      if (!i3.isSupported) return t4;
      if (Z5 || Dt3(e3), i3.removed = [], "string" == typeof t4 && (st3 = false), st3) {
        if (t4.nodeName) {
          const e4 = kt3(t4.nodeName);
          if (!_26[e4] || z5[e4]) throw Te("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (t4 instanceof l5) n4 = Pt3("<!---->"), o4 = n4.ownerDocument.importNode(t4, true), o4.nodeType === ii && "BODY" === o4.nodeName || "HTML" === o4.nodeName ? n4 = o4 : n4.appendChild(o4);
      else {
        if (!tt3 && !Y6 && !$7 && -1 === t4.indexOf("<")) return x4 && it3 ? x4.createHTML(t4) : t4;
        if (n4 = Pt3(t4), !n4) return tt3 ? null : it3 ? C4 : "";
      }
      n4 && Q5 && Ot3(n4.firstChild);
      const u6 = Mt3(st3 ? t4 : n4);
      for (; a6 = u6.nextNode(); ) Wt3(a6), zt3(a6), a6.content instanceof s4 && qt3(a6.content);
      if (st3) return t4;
      if (tt3) {
        if (et3) for (c5 = R6.call(n4.ownerDocument); n4.firstChild; ) c5.appendChild(n4.firstChild);
        else c5 = n4;
        return (W5.shadowroot || W5.shadowrootmode) && (c5 = T5.call(r3, c5, true)), c5;
      }
      let h5 = $7 ? n4.outerHTML : n4.innerHTML;
      return $7 && _26["!doctype"] && n4.ownerDocument && n4.ownerDocument.doctype && n4.ownerDocument.doctype.name && ke(Qe, n4.ownerDocument.doctype.name) && (h5 = "<!DOCTYPE " + n4.ownerDocument.doctype.name + ">\n" + h5), Y6 && me([L6, D6, N5], (t5) => {
        h5 = Ce(h5, t5, " ");
      }), x4 && it3 ? x4.createHTML(h5) : h5;
    }, i3.setConfig = function() {
      Dt3(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), Z5 = true;
    }, i3.clearConfig = function() {
      Tt3 = null, Z5 = false;
    }, i3.isValidAttribute = function(t4, e3, i4) {
      Tt3 || Dt3({});
      const n4 = kt3(t4), r4 = kt3(e3);
      return Ut3(n4, r4, i4);
    }, i3.addHook = function(t4, e3) {
      "function" == typeof e3 && be(w5[t4], e3);
    }, i3.removeHook = function(t4, e3) {
      if (void 0 !== e3) {
        const i4 = pe(w5[t4], e3);
        return -1 === i4 ? void 0 : ve(w5[t4], i4, 1)[0];
      }
      return fe(w5[t4]);
    }, i3.removeHooks = function(t4) {
      w5[t4] = [];
    }, i3.removeAllHooks = function() {
      w5 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
    }, i3;
  }();
  li.addHook("uponSanitizeAttribute", function(t4, e2) {
    /^data-trix-/.test(e2.attrName) && (e2.forceKeepAttr = true);
  });
  var ci = "style href src width height language class".split(" ");
  var ui = "javascript:".split(" ");
  var hi = "script iframe form noscript".split(" ");
  var di = class extends q {
    static setHTML(t4, e2, i3) {
      const n3 = new this(e2, i3).sanitize(), r3 = n3.getHTML ? n3.getHTML() : n3.outerHTML;
      t4.innerHTML = r3;
    }
    static sanitize(t4, e2) {
      const i3 = new this(t4, e2);
      return i3.sanitize(), i3;
    }
    constructor(t4) {
      let { allowedAttributes: e2, forbiddenProtocols: i3, forbiddenElements: n3, purifyOptions: r3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.allowedAttributes = e2 || ci, this.forbiddenProtocols = i3 || ui, this.forbiddenElements = n3 || hi, this.purifyOptions = r3 || {}, this.body = gi(t4);
    }
    sanitize() {
      this.sanitizeElements(), this.normalizeListElementNesting();
      const t4 = Object.assign({}, l2, this.purifyOptions);
      return li.setConfig(t4), this.body = li.sanitize(this.body), this.body;
    }
    getHTML() {
      return this.body.innerHTML;
    }
    getBody() {
      return this.body;
    }
    sanitizeElements() {
      const t4 = R(this.body), e2 = [];
      for (; t4.nextNode(); ) {
        const i3 = t4.currentNode;
        switch (i3.nodeType) {
          case Node.ELEMENT_NODE:
            this.elementIsRemovable(i3) ? e2.push(i3) : this.sanitizeElement(i3);
            break;
          case Node.COMMENT_NODE:
            e2.push(i3);
        }
      }
      return e2.forEach((t5) => S(t5)), this.body;
    }
    sanitizeElement(t4) {
      return t4.hasAttribute("href") && this.forbiddenProtocols.includes(t4.protocol) && t4.removeAttribute("href"), Array.from(t4.attributes).forEach((e2) => {
        let { name: i3 } = e2;
        this.allowedAttributes.includes(i3) || 0 === i3.indexOf("data-trix") || t4.removeAttribute(i3);
      }), t4;
    }
    normalizeListElementNesting() {
      return Array.from(this.body.querySelectorAll("ul,ol")).forEach((t4) => {
        const e2 = t4.previousElementSibling;
        e2 && "li" === k(e2) && e2.appendChild(t4);
      }), this.body;
    }
    elementIsRemovable(t4) {
      if ((null == t4 ? void 0 : t4.nodeType) === Node.ELEMENT_NODE) return this.elementIsForbidden(t4) || this.elementIsntSerializable(t4);
    }
    elementIsForbidden(t4) {
      return this.forbiddenElements.includes(k(t4));
    }
    elementIsntSerializable(t4) {
      return "false" === t4.getAttribute("data-trix-serialize") && !P(t4);
    }
  };
  var gi = function() {
    let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    t4 = t4.replace(/<\/html[^>]*>[^]*$/i, "</html>");
    const e2 = document.implementation.createHTMLDocument("");
    return e2.documentElement.innerHTML = t4, Array.from(e2.head.querySelectorAll("style")).forEach((t5) => {
      e2.body.appendChild(t5);
    }), e2.body;
  };
  var { css: mi } = z;
  var pi = class extends ie {
    constructor() {
      super(...arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
    }
    createContentNodes() {
      return [];
    }
    createNodes() {
      let t4;
      const e2 = t4 = T({ tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false }), i3 = this.getHref();
      return i3 && (t4 = T({ tagName: "a", editable: false, attributes: { href: i3, tabindex: -1 } }), e2.appendChild(t4)), this.attachment.hasContent() ? di.setHTML(t4, this.attachment.getContent()) : this.createContentNodes().forEach((e3) => {
        t4.appendChild(e3);
      }), t4.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = T({ tagName: "progress", attributes: { class: mi.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100 }, data: { trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/") } }), e2.appendChild(this.progressElement)), [fi("left"), e2, fi("right")];
    }
    createCaptionElement() {
      const t4 = T({ tagName: "figcaption", className: mi.attachmentCaption }), e2 = this.attachmentPiece.getCaption();
      if (e2) t4.classList.add("".concat(mi.attachmentCaption, "--edited")), t4.textContent = e2;
      else {
        let e3, i3;
        const n3 = this.getCaptionConfig();
        if (n3.name && (e3 = this.attachment.getFilename()), n3.size && (i3 = this.attachment.getFormattedFilesize()), e3) {
          const i4 = T({ tagName: "span", className: mi.attachmentName, textContent: e3 });
          t4.appendChild(i4);
        }
        if (i3) {
          e3 && t4.appendChild(document.createTextNode(" "));
          const n4 = T({ tagName: "span", className: mi.attachmentSize, textContent: i3 });
          t4.appendChild(n4);
        }
      }
      return t4;
    }
    getClassName() {
      const t4 = [mi.attachment, "".concat(mi.attachment, "--").concat(this.attachment.getType())], e2 = this.attachment.getExtension();
      return e2 && t4.push("".concat(mi.attachment, "--").concat(e2)), t4.join(" ");
    }
    getData() {
      const t4 = { trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id }, { attributes: e2 } = this.attachmentPiece;
      return e2.isEmpty() || (t4.trixAttributes = JSON.stringify(e2)), this.attachment.isPending() && (t4.trixSerialize = false), t4;
    }
    getHref() {
      if (!bi(this.attachment.getContent(), "a")) return this.attachment.getHref();
    }
    getCaptionConfig() {
      var t4;
      const e2 = this.attachment.getType(), n3 = kt(null === (t4 = i2[e2]) || void 0 === t4 ? void 0 : t4.caption);
      return "file" === e2 && (n3.name = true), n3;
    }
    findProgressElement() {
      var t4;
      return null === (t4 = this.findElement()) || void 0 === t4 ? void 0 : t4.querySelector("progress");
    }
    attachmentDidChangeUploadProgress() {
      const t4 = this.attachment.getUploadProgress(), e2 = this.findProgressElement();
      e2 && (e2.value = t4);
    }
  };
  var fi = (t4) => T({ tagName: "span", textContent: d2, data: { trixCursorTarget: t4, trixSerialize: false } });
  var bi = function(t4, e2) {
    const i3 = T("div");
    return di.setHTML(i3, t4 || ""), i3.querySelector(e2);
  };
  var vi = class extends pi {
    constructor() {
      super(...arguments), this.attachment.previewDelegate = this;
    }
    createContentNodes() {
      return this.image = T({ tagName: "img", attributes: { src: "" }, data: { trixMutable: true } }), this.refresh(this.image), [this.image];
    }
    createCaptionElement() {
      const t4 = super.createCaptionElement(...arguments);
      return t4.textContent || t4.setAttribute("data-trix-placeholder", c2.captionPlaceholder), t4;
    }
    refresh(t4) {
      var e2;
      t4 || (t4 = null === (e2 = this.findElement()) || void 0 === e2 ? void 0 : e2.querySelector("img"));
      if (t4) return this.updateAttributesForImage(t4);
    }
    updateAttributesForImage(t4) {
      const e2 = this.attachment.getURL(), i3 = this.attachment.getPreviewURL();
      if (t4.src = i3 || e2, i3 === e2) t4.removeAttribute("data-trix-serialized-attributes");
      else {
        const i4 = JSON.stringify({ src: e2 });
        t4.setAttribute("data-trix-serialized-attributes", i4);
      }
      const n3 = this.attachment.getWidth(), r3 = this.attachment.getHeight();
      null != n3 && (t4.width = n3), null != r3 && (t4.height = r3);
      const o3 = ["imageElement", this.attachment.id, t4.src, t4.width, t4.height].join("/");
      t4.dataset.trixStoreKey = o3;
    }
    attachmentDidChangeAttributes() {
      return this.refresh(this.image), this.refresh();
    }
  };
  var Ai = class extends ie {
    constructor() {
      super(...arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), this.textConfig = this.options.textConfig, this.context = this.options.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
    }
    createNodes() {
      let t4 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes();
      const e2 = this.createElement();
      if (e2) {
        const i3 = function(t5) {
          for (; null !== (e3 = t5) && void 0 !== e3 && e3.firstElementChild; ) {
            var e3;
            t5 = t5.firstElementChild;
          }
          return t5;
        }(e2);
        Array.from(t4).forEach((t5) => {
          i3.appendChild(t5);
        }), t4 = [e2];
      }
      return t4;
    }
    createAttachmentNodes() {
      const t4 = this.attachment.isPreviewable() ? vi : pi;
      return this.createChildView(t4, this.piece.attachment, { piece: this.piece }).getNodes();
    }
    createStringNodes() {
      var t4;
      if (null !== (t4 = this.textConfig) && void 0 !== t4 && t4.plaintext) return [document.createTextNode(this.string)];
      {
        const t5 = [], e2 = this.string.split("\n");
        for (let i3 = 0; i3 < e2.length; i3++) {
          const n3 = e2[i3];
          if (i3 > 0) {
            const e3 = T("br");
            t5.push(e3);
          }
          if (n3.length) {
            const e3 = document.createTextNode(this.preserveSpaces(n3));
            t5.push(e3);
          }
        }
        return t5;
      }
    }
    createElement() {
      let t4, e2, i3;
      const n3 = {};
      for (e2 in this.attributes) {
        i3 = this.attributes[e2];
        const o3 = ft(e2);
        if (o3) {
          if (o3.tagName) {
            var r3;
            const e3 = T(o3.tagName);
            r3 ? (r3.appendChild(e3), r3 = e3) : t4 = r3 = e3;
          }
          if (o3.styleProperty && (n3[o3.styleProperty] = i3), o3.style) for (e2 in o3.style) i3 = o3.style[e2], n3[e2] = i3;
        }
      }
      if (Object.keys(n3).length) for (e2 in t4 || (t4 = T("span")), n3) i3 = n3[e2], t4.style[e2] = i3;
      return t4;
    }
    createContainerElement() {
      for (const t4 in this.attributes) {
        const e2 = this.attributes[t4], i3 = ft(t4);
        if (i3 && i3.groupTagName) {
          const n3 = {};
          return n3[t4] = e2, T(i3.groupTagName, n3);
        }
      }
    }
    preserveSpaces(t4) {
      return this.context.isLast && (t4 = t4.replace(/\ $/, g)), t4 = t4.replace(/(\S)\ {3}(\S)/g, "$1 ".concat(g, " $2")).replace(/\ {2}/g, "".concat(g, " ")).replace(/\ {2}/g, " ".concat(g)), (this.context.isFirst || this.context.followsWhitespace) && (t4 = t4.replace(/^\ /, g)), t4;
    }
  };
  var yi = class extends ie {
    constructor() {
      super(...arguments), this.text = this.object, this.textConfig = this.options.textConfig;
    }
    createNodes() {
      const t4 = [], e2 = $t.groupObjects(this.getPieces()), i3 = e2.length - 1;
      for (let r3 = 0; r3 < e2.length; r3++) {
        const o3 = e2[r3], s4 = {};
        0 === r3 && (s4.isFirst = true), r3 === i3 && (s4.isLast = true), xi(n3) && (s4.followsWhitespace = true);
        const a5 = this.findOrCreateCachedChildView(Ai, o3, { textConfig: this.textConfig, context: s4 });
        t4.push(...Array.from(a5.getNodes() || []));
        var n3 = o3;
      }
      return t4;
    }
    getPieces() {
      return Array.from(this.text.getPieces()).filter((t4) => !t4.hasAttribute("blockBreak"));
    }
  };
  var xi = (t4) => /\s$/.test(null == t4 ? void 0 : t4.toString());
  var { css: Ci } = z;
  var Ei = class extends ie {
    constructor() {
      super(...arguments), this.block = this.object, this.attributes = this.block.getAttributes();
    }
    createNodes() {
      const t4 = [document.createComment("block")];
      if (this.block.isEmpty()) t4.push(T("br"));
      else {
        var e2;
        const i3 = null === (e2 = mt(this.block.getLastAttribute())) || void 0 === e2 ? void 0 : e2.text, n3 = this.findOrCreateCachedChildView(yi, this.block.text, { textConfig: i3 });
        t4.push(...Array.from(n3.getNodes() || [])), this.shouldAddExtraNewlineElement() && t4.push(T("br"));
      }
      if (this.attributes.length) return t4;
      {
        let e3;
        const { tagName: i3 } = n2.default;
        this.block.isRTL() && (e3 = { dir: "rtl" });
        const r3 = T({ tagName: i3, attributes: e3 });
        return t4.forEach((t5) => r3.appendChild(t5)), [r3];
      }
    }
    createContainerElement(t4) {
      const e2 = {};
      let i3;
      const n3 = this.attributes[t4], { tagName: r3, htmlAttributes: o3 = [] } = mt(n3);
      if (0 === t4 && this.block.isRTL() && Object.assign(e2, { dir: "rtl" }), "attachmentGallery" === n3) {
        const t5 = this.block.getBlockBreakPosition();
        i3 = "".concat(Ci.attachmentGallery, " ").concat(Ci.attachmentGallery, "--").concat(t5);
      }
      return Object.entries(this.block.htmlAttributes).forEach((t5) => {
        let [i4, n4] = t5;
        o3.includes(i4) && (e2[i4] = n4);
      }), T({ tagName: r3, className: i3, attributes: e2 });
    }
    shouldAddExtraNewlineElement() {
      return /\n\n$/.test(this.block.toString());
    }
  };
  var Si = class extends ie {
    static render(t4) {
      const e2 = T("div"), i3 = new this(t4, { element: e2 });
      return i3.render(), i3.sync(), e2;
    }
    constructor() {
      super(...arguments), this.element = this.options.element, this.elementStore = new Qt(), this.setDocument(this.object);
    }
    setDocument(t4) {
      t4.isEqualTo(this.document) || (this.document = this.object = t4);
    }
    render() {
      if (this.childViews = [], this.shadowElement = T("div"), !this.document.isEmpty()) {
        const t4 = $t.groupObjects(this.document.getBlocks(), { asTree: true });
        Array.from(t4).forEach((t5) => {
          const e2 = this.findOrCreateCachedChildView(Ei, t5);
          Array.from(e2.getNodes()).map((t6) => this.shadowElement.appendChild(t6));
        });
      }
    }
    isSynced() {
      return ki(this.shadowElement, this.element);
    }
    sync() {
      const t4 = this.createDocumentFragmentForSync();
      for (; this.element.lastChild; ) this.element.removeChild(this.element.lastChild);
      return this.element.appendChild(t4), this.didSync();
    }
    didSync() {
      return this.elementStore.reset(Ri(this.element)), Rt(() => this.garbageCollectCachedViews());
    }
    createDocumentFragmentForSync() {
      const t4 = document.createDocumentFragment();
      return Array.from(this.shadowElement.childNodes).forEach((e2) => {
        t4.appendChild(e2.cloneNode(true));
      }), Array.from(Ri(t4)).forEach((t5) => {
        const e2 = this.elementStore.remove(t5);
        e2 && t5.parentNode.replaceChild(e2, t5);
      }), t4;
    }
  };
  var Ri = (t4) => t4.querySelectorAll("[data-trix-store-key]");
  var ki = (t4, e2) => Ti(t4.innerHTML) === Ti(e2.innerHTML);
  var Ti = (t4) => t4.replace(/&nbsp;/g, " ");
  function wi(t4) {
    var e2, i3;
    function n3(e3, i4) {
      try {
        var o3 = t4[e3](i4), s4 = o3.value, a5 = s4 instanceof Li;
        Promise.resolve(a5 ? s4.v : s4).then(function(i5) {
          if (a5) {
            var l5 = "return" === e3 ? "return" : "next";
            if (!s4.k || i5.done) return n3(l5, i5);
            i5 = t4[l5](i5).value;
          }
          r3(o3.done ? "return" : "normal", i5);
        }, function(t5) {
          n3("throw", t5);
        });
      } catch (t5) {
        r3("throw", t5);
      }
    }
    function r3(t5, r4) {
      switch (t5) {
        case "return":
          e2.resolve({ value: r4, done: true });
          break;
        case "throw":
          e2.reject(r4);
          break;
        default:
          e2.resolve({ value: r4, done: false });
      }
      (e2 = e2.next) ? n3(e2.key, e2.arg) : i3 = null;
    }
    this._invoke = function(t5, r4) {
      return new Promise(function(o3, s4) {
        var a5 = { key: t5, arg: r4, resolve: o3, reject: s4, next: null };
        i3 ? i3 = i3.next = a5 : (e2 = i3 = a5, n3(t5, r4));
      });
    }, "function" != typeof t4.return && (this.return = void 0);
  }
  function Li(t4, e2) {
    this.v = t4, this.k = e2;
  }
  function Di(t4, e2, i3) {
    return (e2 = Ni(e2)) in t4 ? Object.defineProperty(t4, e2, { value: i3, enumerable: true, configurable: true, writable: true }) : t4[e2] = i3, t4;
  }
  function Ni(t4) {
    var e2 = function(t5, e3) {
      if ("object" != typeof t5 || null === t5) return t5;
      var i3 = t5[Symbol.toPrimitive];
      if (void 0 !== i3) {
        var n3 = i3.call(t5, e3 || "default");
        if ("object" != typeof n3) return n3;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === e3 ? String : Number)(t5);
    }(t4, "string");
    return "symbol" == typeof e2 ? e2 : String(e2);
  }
  wi.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
    return this;
  }, wi.prototype.next = function(t4) {
    return this._invoke("next", t4);
  }, wi.prototype.throw = function(t4) {
    return this._invoke("throw", t4);
  }, wi.prototype.return = function(t4) {
    return this._invoke("return", t4);
  };
  function Ii(t4, e2) {
    return Pi(t4, Fi(t4, e2, "get"));
  }
  function Oi(t4, e2, i3) {
    return Mi(t4, Fi(t4, e2, "set"), i3), i3;
  }
  function Fi(t4, e2, i3) {
    if (!e2.has(t4)) throw new TypeError("attempted to " + i3 + " private field on non-instance");
    return e2.get(t4);
  }
  function Pi(t4, e2) {
    return e2.get ? e2.get.call(t4) : e2.value;
  }
  function Mi(t4, e2, i3) {
    if (e2.set) e2.set.call(t4, i3);
    else {
      if (!e2.writable) throw new TypeError("attempted to set read only private field");
      e2.value = i3;
    }
  }
  function Bi(t4, e2, i3) {
    if (!e2.has(t4)) throw new TypeError("attempted to get private field on non-instance");
    return i3;
  }
  function _i(t4, e2) {
    if (e2.has(t4)) throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
  function ji(t4, e2, i3) {
    _i(t4, e2), e2.set(t4, i3);
  }
  var Wi = class extends rt {
    static registerType(t4, e2) {
      e2.type = t4, this.types[t4] = e2;
    }
    static fromJSON(t4) {
      const e2 = this.types[t4.type];
      if (e2) return e2.fromJSON(t4);
    }
    constructor(t4) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.attributes = Ht.box(e2);
    }
    copyWithAttributes(t4) {
      return new this.constructor(this.getValue(), t4);
    }
    copyWithAdditionalAttributes(t4) {
      return this.copyWithAttributes(this.attributes.merge(t4));
    }
    copyWithoutAttribute(t4) {
      return this.copyWithAttributes(this.attributes.remove(t4));
    }
    copy() {
      return this.copyWithAttributes(this.attributes);
    }
    getAttribute(t4) {
      return this.attributes.get(t4);
    }
    getAttributesHash() {
      return this.attributes;
    }
    getAttributes() {
      return this.attributes.toObject();
    }
    hasAttribute(t4) {
      return this.attributes.has(t4);
    }
    hasSameStringValueAsPiece(t4) {
      return t4 && this.toString() === t4.toString();
    }
    hasSameAttributesAsPiece(t4) {
      return t4 && (this.attributes === t4.attributes || this.attributes.isEqualTo(t4.attributes));
    }
    isBlockBreak() {
      return false;
    }
    isEqualTo(t4) {
      return super.isEqualTo(...arguments) || this.hasSameConstructorAs(t4) && this.hasSameStringValueAsPiece(t4) && this.hasSameAttributesAsPiece(t4);
    }
    isEmpty() {
      return 0 === this.length;
    }
    isSerializable() {
      return true;
    }
    toJSON() {
      return { type: this.constructor.type, attributes: this.getAttributes() };
    }
    contentsForInspection() {
      return { type: this.constructor.type, attributes: this.attributes.inspect() };
    }
    canBeGrouped() {
      return this.hasAttribute("href");
    }
    canBeGroupedWith(t4) {
      return this.getAttribute("href") === t4.getAttribute("href");
    }
    getLength() {
      return this.length;
    }
    canBeConsolidatedWith(t4) {
      return false;
    }
  };
  Di(Wi, "types", {});
  var Ui = class extends ee {
    constructor(t4) {
      super(...arguments), this.url = t4;
    }
    perform(t4) {
      const e2 = new Image();
      e2.onload = () => (e2.width = this.width = e2.naturalWidth, e2.height = this.height = e2.naturalHeight, t4(true, e2)), e2.onerror = () => t4(false), e2.src = this.url;
    }
  };
  var Vi = class _Vi extends rt {
    static attachmentForFile(t4) {
      const e2 = new this(this.attributesForFile(t4));
      return e2.setFile(t4), e2;
    }
    static attributesForFile(t4) {
      return new Ht({ filename: t4.name, filesize: t4.size, contentType: t4.type });
    }
    static fromJSON(t4) {
      return new this(t4);
    }
    constructor() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      super(t4), this.releaseFile = this.releaseFile.bind(this), this.attributes = Ht.box(t4), this.didChangeAttributes();
    }
    getAttribute(t4) {
      return this.attributes.get(t4);
    }
    hasAttribute(t4) {
      return this.attributes.has(t4);
    }
    getAttributes() {
      return this.attributes.toObject();
    }
    setAttributes() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const e2 = this.attributes.merge(t4);
      var i3, n3, r3, o3;
      if (!this.attributes.isEqualTo(e2)) return this.attributes = e2, this.didChangeAttributes(), null === (i3 = this.previewDelegate) || void 0 === i3 || null === (n3 = i3.attachmentDidChangeAttributes) || void 0 === n3 || n3.call(i3, this), null === (r3 = this.delegate) || void 0 === r3 || null === (o3 = r3.attachmentDidChangeAttributes) || void 0 === o3 ? void 0 : o3.call(r3, this);
    }
    didChangeAttributes() {
      if (this.isPreviewable()) return this.preloadURL();
    }
    isPending() {
      return null != this.file && !(this.getURL() || this.getHref());
    }
    isPreviewable() {
      return this.attributes.has("previewable") ? this.attributes.get("previewable") : _Vi.previewablePattern.test(this.getContentType());
    }
    getType() {
      return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
    }
    getURL() {
      return this.attributes.get("url");
    }
    getHref() {
      return this.attributes.get("href");
    }
    getFilename() {
      return this.attributes.get("filename") || "";
    }
    getFilesize() {
      return this.attributes.get("filesize");
    }
    getFormattedFilesize() {
      const t4 = this.attributes.get("filesize");
      return "number" == typeof t4 ? h.formatter(t4) : "";
    }
    getExtension() {
      var t4;
      return null === (t4 = this.getFilename().match(/\.(\w+)$/)) || void 0 === t4 ? void 0 : t4[1].toLowerCase();
    }
    getContentType() {
      return this.attributes.get("contentType");
    }
    hasContent() {
      return this.attributes.has("content");
    }
    getContent() {
      return this.attributes.get("content");
    }
    getWidth() {
      return this.attributes.get("width");
    }
    getHeight() {
      return this.attributes.get("height");
    }
    getFile() {
      return this.file;
    }
    setFile(t4) {
      if (this.file = t4, this.isPreviewable()) return this.preloadFile();
    }
    releaseFile() {
      this.releasePreloadedFile(), this.file = null;
    }
    getUploadProgress() {
      return null != this.uploadProgress ? this.uploadProgress : 0;
    }
    setUploadProgress(t4) {
      var e2, i3;
      if (this.uploadProgress !== t4) return this.uploadProgress = t4, null === (e2 = this.uploadProgressDelegate) || void 0 === e2 || null === (i3 = e2.attachmentDidChangeUploadProgress) || void 0 === i3 ? void 0 : i3.call(e2, this);
    }
    toJSON() {
      return this.getAttributes();
    }
    getCacheKey() {
      return [super.getCacheKey(...arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
    }
    getPreviewURL() {
      return this.previewURL || this.preloadingURL;
    }
    setPreviewURL(t4) {
      var e2, i3, n3, r3;
      if (t4 !== this.getPreviewURL()) return this.previewURL = t4, null === (e2 = this.previewDelegate) || void 0 === e2 || null === (i3 = e2.attachmentDidChangeAttributes) || void 0 === i3 || i3.call(e2, this), null === (n3 = this.delegate) || void 0 === n3 || null === (r3 = n3.attachmentDidChangePreviewURL) || void 0 === r3 ? void 0 : r3.call(n3, this);
    }
    preloadURL() {
      return this.preload(this.getURL(), this.releaseFile);
    }
    preloadFile() {
      if (this.file) return this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL);
    }
    releasePreloadedFile() {
      this.fileObjectURL && (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null);
    }
    preload(t4, e2) {
      if (t4 && t4 !== this.getPreviewURL()) {
        this.preloadingURL = t4;
        return new Ui(t4).then((i3) => {
          let { width: n3, height: r3 } = i3;
          return this.getWidth() && this.getHeight() || this.setAttributes({ width: n3, height: r3 }), this.preloadingURL = null, this.setPreviewURL(t4), null == e2 ? void 0 : e2();
        }).catch(() => (this.preloadingURL = null, null == e2 ? void 0 : e2()));
      }
    }
  };
  Di(Vi, "previewablePattern", /^image(\/(gif|png|webp|jpe?g)|$)/);
  var zi = class _zi extends Wi {
    static fromJSON(t4) {
      return new this(Vi.fromJSON(t4.attachment), t4.attributes);
    }
    constructor(t4) {
      super(...arguments), this.attachment = t4, this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
    }
    ensureAttachmentExclusivelyHasAttribute(t4) {
      this.hasAttribute(t4) && (this.attachment.hasAttribute(t4) || this.attachment.setAttributes(this.attributes.slice([t4])), this.attributes = this.attributes.remove(t4));
    }
    removeProhibitedAttributes() {
      const t4 = this.attributes.slice(_zi.permittedAttributes);
      t4.isEqualTo(this.attributes) || (this.attributes = t4);
    }
    getValue() {
      return this.attachment;
    }
    isSerializable() {
      return !this.attachment.isPending();
    }
    getCaption() {
      return this.attributes.get("caption") || "";
    }
    isEqualTo(t4) {
      var e2;
      return super.isEqualTo(t4) && this.attachment.id === (null == t4 || null === (e2 = t4.attachment) || void 0 === e2 ? void 0 : e2.id);
    }
    toString() {
      return "\uFFFC";
    }
    toJSON() {
      const t4 = super.toJSON(...arguments);
      return t4.attachment = this.attachment, t4;
    }
    getCacheKey() {
      return [super.getCacheKey(...arguments), this.attachment.getCacheKey()].join("/");
    }
    toConsole() {
      return JSON.stringify(this.toString());
    }
  };
  Di(zi, "permittedAttributes", ["caption", "presentation"]), Wi.registerType("attachment", zi);
  var qi = class extends Wi {
    static fromJSON(t4) {
      return new this(t4.string, t4.attributes);
    }
    constructor(t4) {
      super(...arguments), this.string = ((t5) => t5.replace(/\r\n?/g, "\n"))(t4), this.length = this.string.length;
    }
    getValue() {
      return this.string;
    }
    toString() {
      return this.string.toString();
    }
    isBlockBreak() {
      return "\n" === this.toString() && true === this.getAttribute("blockBreak");
    }
    toJSON() {
      const t4 = super.toJSON(...arguments);
      return t4.string = this.string, t4;
    }
    canBeConsolidatedWith(t4) {
      return t4 && this.hasSameConstructorAs(t4) && this.hasSameAttributesAsPiece(t4);
    }
    consolidateWith(t4) {
      return new this.constructor(this.toString() + t4.toString(), this.attributes);
    }
    splitAtOffset(t4) {
      let e2, i3;
      return 0 === t4 ? (e2 = null, i3 = this) : t4 === this.length ? (e2 = this, i3 = null) : (e2 = new this.constructor(this.string.slice(0, t4), this.attributes), i3 = new this.constructor(this.string.slice(t4), this.attributes)), [e2, i3];
    }
    toConsole() {
      let { string: t4 } = this;
      return t4.length > 15 && (t4 = t4.slice(0, 14) + "\u2026"), JSON.stringify(t4.toString());
    }
  };
  Wi.registerType("string", qi);
  var Hi = class extends rt {
    static box(t4) {
      return t4 instanceof this ? t4 : new this(t4);
    }
    constructor() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.objects = t4.slice(0), this.length = this.objects.length;
    }
    indexOf(t4) {
      return this.objects.indexOf(t4);
    }
    splice() {
      for (var t4 = arguments.length, e2 = new Array(t4), i3 = 0; i3 < t4; i3++) e2[i3] = arguments[i3];
      return new this.constructor(st(this.objects, ...e2));
    }
    eachObject(t4) {
      return this.objects.map((e2, i3) => t4(e2, i3));
    }
    insertObjectAtIndex(t4, e2) {
      return this.splice(e2, 0, t4);
    }
    insertSplittableListAtIndex(t4, e2) {
      return this.splice(e2, 0, ...t4.objects);
    }
    insertSplittableListAtPosition(t4, e2) {
      const [i3, n3] = this.splitObjectAtPosition(e2);
      return new this.constructor(i3).insertSplittableListAtIndex(t4, n3);
    }
    editObjectAtIndex(t4, e2) {
      return this.replaceObjectAtIndex(e2(this.objects[t4]), t4);
    }
    replaceObjectAtIndex(t4, e2) {
      return this.splice(e2, 1, t4);
    }
    removeObjectAtIndex(t4) {
      return this.splice(t4, 1);
    }
    getObjectAtIndex(t4) {
      return this.objects[t4];
    }
    getSplittableListInRange(t4) {
      const [e2, i3, n3] = this.splitObjectsAtRange(t4);
      return new this.constructor(e2.slice(i3, n3 + 1));
    }
    selectSplittableList(t4) {
      const e2 = this.objects.filter((e3) => t4(e3));
      return new this.constructor(e2);
    }
    removeObjectsInRange(t4) {
      const [e2, i3, n3] = this.splitObjectsAtRange(t4);
      return new this.constructor(e2).splice(i3, n3 - i3 + 1);
    }
    transformObjectsInRange(t4, e2) {
      const [i3, n3, r3] = this.splitObjectsAtRange(t4), o3 = i3.map((t5, i4) => n3 <= i4 && i4 <= r3 ? e2(t5) : t5);
      return new this.constructor(o3);
    }
    splitObjectsAtRange(t4) {
      let e2, [i3, n3, r3] = this.splitObjectAtPosition(Ki(t4));
      return [i3, e2] = new this.constructor(i3).splitObjectAtPosition(Gi(t4) + r3), [i3, n3, e2 - 1];
    }
    getObjectAtPosition(t4) {
      const { index: e2 } = this.findIndexAndOffsetAtPosition(t4);
      return this.objects[e2];
    }
    splitObjectAtPosition(t4) {
      let e2, i3;
      const { index: n3, offset: r3 } = this.findIndexAndOffsetAtPosition(t4), o3 = this.objects.slice(0);
      if (null != n3) if (0 === r3) e2 = n3, i3 = 0;
      else {
        const t5 = this.getObjectAtIndex(n3), [s4, a5] = t5.splitAtOffset(r3);
        o3.splice(n3, 1, s4, a5), e2 = n3 + 1, i3 = s4.getLength() - r3;
      }
      else e2 = o3.length, i3 = 0;
      return [o3, e2, i3];
    }
    consolidate() {
      const t4 = [];
      let e2 = this.objects[0];
      return this.objects.slice(1).forEach((i3) => {
        var n3, r3;
        null !== (n3 = (r3 = e2).canBeConsolidatedWith) && void 0 !== n3 && n3.call(r3, i3) ? e2 = e2.consolidateWith(i3) : (t4.push(e2), e2 = i3);
      }), e2 && t4.push(e2), new this.constructor(t4);
    }
    consolidateFromIndexToIndex(t4, e2) {
      const i3 = this.objects.slice(0).slice(t4, e2 + 1), n3 = new this.constructor(i3).consolidate().toArray();
      return this.splice(t4, i3.length, ...n3);
    }
    findIndexAndOffsetAtPosition(t4) {
      let e2, i3 = 0;
      for (e2 = 0; e2 < this.objects.length; e2++) {
        const n3 = i3 + this.objects[e2].getLength();
        if (i3 <= t4 && t4 < n3) return { index: e2, offset: t4 - i3 };
        i3 = n3;
      }
      return { index: null, offset: null };
    }
    findPositionAtIndexAndOffset(t4, e2) {
      let i3 = 0;
      for (let n3 = 0; n3 < this.objects.length; n3++) {
        const r3 = this.objects[n3];
        if (n3 < t4) i3 += r3.getLength();
        else if (n3 === t4) {
          i3 += e2;
          break;
        }
      }
      return i3;
    }
    getEndPosition() {
      return null == this.endPosition && (this.endPosition = 0, this.objects.forEach((t4) => this.endPosition += t4.getLength())), this.endPosition;
    }
    toString() {
      return this.objects.join("");
    }
    toArray() {
      return this.objects.slice(0);
    }
    toJSON() {
      return this.toArray();
    }
    isEqualTo(t4) {
      return super.isEqualTo(...arguments) || Ji(this.objects, null == t4 ? void 0 : t4.objects);
    }
    contentsForInspection() {
      return { objects: "[".concat(this.objects.map((t4) => t4.inspect()).join(", "), "]") };
    }
  };
  var Ji = function(t4) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (t4.length !== e2.length) return false;
    let i3 = true;
    for (let n3 = 0; n3 < t4.length; n3++) {
      const r3 = t4[n3];
      i3 && !r3.isEqualTo(e2[n3]) && (i3 = false);
    }
    return i3;
  };
  var Ki = (t4) => t4[0];
  var Gi = (t4) => t4[1];
  var Yi = class extends rt {
    static textForAttachmentWithAttributes(t4, e2) {
      return new this([new zi(t4, e2)]);
    }
    static textForStringWithAttributes(t4, e2) {
      return new this([new qi(t4, e2)]);
    }
    static fromJSON(t4) {
      return new this(Array.from(t4).map((t5) => Wi.fromJSON(t5)));
    }
    constructor() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments);
      const e2 = t4.filter((t5) => !t5.isEmpty());
      this.pieceList = new Hi(e2);
    }
    copy() {
      return this.copyWithPieceList(this.pieceList);
    }
    copyWithPieceList(t4) {
      return new this.constructor(t4.consolidate().toArray());
    }
    copyUsingObjectMap(t4) {
      const e2 = this.getPieces().map((e3) => t4.find(e3) || e3);
      return new this.constructor(e2);
    }
    appendText(t4) {
      return this.insertTextAtPosition(t4, this.getLength());
    }
    insertTextAtPosition(t4, e2) {
      return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t4.pieceList, e2));
    }
    removeTextAtRange(t4) {
      return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t4));
    }
    replaceTextAtRange(t4, e2) {
      return this.removeTextAtRange(e2).insertTextAtPosition(t4, e2[0]);
    }
    moveTextFromRangeToPosition(t4, e2) {
      if (t4[0] <= e2 && e2 <= t4[1]) return;
      const i3 = this.getTextAtRange(t4), n3 = i3.getLength();
      return t4[0] < e2 && (e2 -= n3), this.removeTextAtRange(t4).insertTextAtPosition(i3, e2);
    }
    addAttributeAtRange(t4, e2, i3) {
      const n3 = {};
      return n3[t4] = e2, this.addAttributesAtRange(n3, i3);
    }
    addAttributesAtRange(t4, e2) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithAdditionalAttributes(t4)));
    }
    removeAttributeAtRange(t4, e2) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithoutAttribute(t4)));
    }
    setAttributesAtRange(t4, e2) {
      return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, (e3) => e3.copyWithAttributes(t4)));
    }
    getAttributesAtPosition(t4) {
      var e2;
      return (null === (e2 = this.pieceList.getObjectAtPosition(t4)) || void 0 === e2 ? void 0 : e2.getAttributes()) || {};
    }
    getCommonAttributes() {
      const t4 = Array.from(this.pieceList.toArray()).map((t5) => t5.getAttributes());
      return Ht.fromCommonAttributesOfObjects(t4).toObject();
    }
    getCommonAttributesAtRange(t4) {
      return this.getTextAtRange(t4).getCommonAttributes() || {};
    }
    getExpandedRangeForAttributeAtOffset(t4, e2) {
      let i3, n3 = i3 = e2;
      const r3 = this.getLength();
      for (; n3 > 0 && this.getCommonAttributesAtRange([n3 - 1, i3])[t4]; ) n3--;
      for (; i3 < r3 && this.getCommonAttributesAtRange([e2, i3 + 1])[t4]; ) i3++;
      return [n3, i3];
    }
    getTextAtRange(t4) {
      return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t4));
    }
    getStringAtRange(t4) {
      return this.pieceList.getSplittableListInRange(t4).toString();
    }
    getStringAtPosition(t4) {
      return this.getStringAtRange([t4, t4 + 1]);
    }
    startsWithString(t4) {
      return this.getStringAtRange([0, t4.length]) === t4;
    }
    endsWithString(t4) {
      const e2 = this.getLength();
      return this.getStringAtRange([e2 - t4.length, e2]) === t4;
    }
    getAttachmentPieces() {
      return this.pieceList.toArray().filter((t4) => !!t4.attachment);
    }
    getAttachments() {
      return this.getAttachmentPieces().map((t4) => t4.attachment);
    }
    getAttachmentAndPositionById(t4) {
      let e2 = 0;
      for (const n3 of this.pieceList.toArray()) {
        var i3;
        if ((null === (i3 = n3.attachment) || void 0 === i3 ? void 0 : i3.id) === t4) return { attachment: n3.attachment, position: e2 };
        e2 += n3.length;
      }
      return { attachment: null, position: null };
    }
    getAttachmentById(t4) {
      const { attachment: e2 } = this.getAttachmentAndPositionById(t4);
      return e2;
    }
    getRangeOfAttachment(t4) {
      const e2 = this.getAttachmentAndPositionById(t4.id), i3 = e2.position;
      if (t4 = e2.attachment) return [i3, i3 + 1];
    }
    updateAttributesForAttachment(t4, e2) {
      const i3 = this.getRangeOfAttachment(e2);
      return i3 ? this.addAttributesAtRange(t4, i3) : this;
    }
    getLength() {
      return this.pieceList.getEndPosition();
    }
    isEmpty() {
      return 0 === this.getLength();
    }
    isEqualTo(t4) {
      var e2;
      return super.isEqualTo(t4) || (null == t4 || null === (e2 = t4.pieceList) || void 0 === e2 ? void 0 : e2.isEqualTo(this.pieceList));
    }
    isBlockBreak() {
      return 1 === this.getLength() && this.pieceList.getObjectAtIndex(0).isBlockBreak();
    }
    eachPiece(t4) {
      return this.pieceList.eachObject(t4);
    }
    getPieces() {
      return this.pieceList.toArray();
    }
    getPieceAtPosition(t4) {
      return this.pieceList.getObjectAtPosition(t4);
    }
    contentsForInspection() {
      return { pieceList: this.pieceList.inspect() };
    }
    toSerializableText() {
      const t4 = this.pieceList.selectSplittableList((t5) => t5.isSerializable());
      return this.copyWithPieceList(t4);
    }
    toString() {
      return this.pieceList.toString();
    }
    toJSON() {
      return this.pieceList.toJSON();
    }
    toConsole() {
      return JSON.stringify(this.pieceList.toArray().map((t4) => JSON.parse(t4.toConsole())));
    }
    getDirection() {
      return lt(this.toString());
    }
    isRTL() {
      return "rtl" === this.getDirection();
    }
  };
  var Xi = class _Xi extends rt {
    static fromJSON(t4) {
      return new this(Yi.fromJSON(t4.text), t4.attributes, t4.htmlAttributes);
    }
    constructor(t4, e2, i3) {
      super(...arguments), this.text = $i(t4 || new Yi()), this.attributes = e2 || [], this.htmlAttributes = i3 || {};
    }
    isEmpty() {
      return this.text.isBlockBreak();
    }
    isEqualTo(t4) {
      return !!super.isEqualTo(t4) || this.text.isEqualTo(null == t4 ? void 0 : t4.text) && ot(this.attributes, null == t4 ? void 0 : t4.attributes) && Tt(this.htmlAttributes, null == t4 ? void 0 : t4.htmlAttributes);
    }
    copyWithText(t4) {
      return new _Xi(t4, this.attributes, this.htmlAttributes);
    }
    copyWithoutText() {
      return this.copyWithText(null);
    }
    copyWithAttributes(t4) {
      return new _Xi(this.text, t4, this.htmlAttributes);
    }
    copyWithoutAttributes() {
      return this.copyWithAttributes(null);
    }
    copyUsingObjectMap(t4) {
      const e2 = t4.find(this.text);
      return e2 ? this.copyWithText(e2) : this.copyWithText(this.text.copyUsingObjectMap(t4));
    }
    addAttribute(t4) {
      const e2 = this.attributes.concat(rn(t4));
      return this.copyWithAttributes(e2);
    }
    addHTMLAttribute(t4, e2) {
      const i3 = Object.assign({}, this.htmlAttributes, { [t4]: e2 });
      return new _Xi(this.text, this.attributes, i3);
    }
    removeAttribute(t4) {
      const { listAttribute: e2 } = mt(t4), i3 = sn(sn(this.attributes, t4), e2);
      return this.copyWithAttributes(i3);
    }
    removeLastAttribute() {
      return this.removeAttribute(this.getLastAttribute());
    }
    getLastAttribute() {
      return on(this.attributes);
    }
    getAttributes() {
      return this.attributes.slice(0);
    }
    getAttributeLevel() {
      return this.attributes.length;
    }
    getAttributeAtLevel(t4) {
      return this.attributes[t4 - 1];
    }
    hasAttribute(t4) {
      return this.attributes.includes(t4);
    }
    hasAttributes() {
      return this.getAttributeLevel() > 0;
    }
    getLastNestableAttribute() {
      return on(this.getNestableAttributes());
    }
    getNestableAttributes() {
      return this.attributes.filter((t4) => mt(t4).nestable);
    }
    getNestingLevel() {
      return this.getNestableAttributes().length;
    }
    decreaseNestingLevel() {
      const t4 = this.getLastNestableAttribute();
      return t4 ? this.removeAttribute(t4) : this;
    }
    increaseNestingLevel() {
      const t4 = this.getLastNestableAttribute();
      if (t4) {
        const e2 = this.attributes.lastIndexOf(t4), i3 = st(this.attributes, e2 + 1, 0, ...rn(t4));
        return this.copyWithAttributes(i3);
      }
      return this;
    }
    getListItemAttributes() {
      return this.attributes.filter((t4) => mt(t4).listAttribute);
    }
    isListItem() {
      var t4;
      return null === (t4 = mt(this.getLastAttribute())) || void 0 === t4 ? void 0 : t4.listAttribute;
    }
    isTerminalBlock() {
      var t4;
      return null === (t4 = mt(this.getLastAttribute())) || void 0 === t4 ? void 0 : t4.terminal;
    }
    breaksOnReturn() {
      var t4;
      return null === (t4 = mt(this.getLastAttribute())) || void 0 === t4 ? void 0 : t4.breakOnReturn;
    }
    findLineBreakInDirectionFromPosition(t4, e2) {
      const i3 = this.toString();
      let n3;
      switch (t4) {
        case "forward":
          n3 = i3.indexOf("\n", e2);
          break;
        case "backward":
          n3 = i3.slice(0, e2).lastIndexOf("\n");
      }
      if (-1 !== n3) return n3;
    }
    contentsForInspection() {
      return { text: this.text.inspect(), attributes: this.attributes };
    }
    toString() {
      return this.text.toString();
    }
    toJSON() {
      return { text: this.text, attributes: this.attributes, htmlAttributes: this.htmlAttributes };
    }
    getDirection() {
      return this.text.getDirection();
    }
    isRTL() {
      return this.text.isRTL();
    }
    getLength() {
      return this.text.getLength();
    }
    canBeConsolidatedWith(t4) {
      return !this.hasAttributes() && !t4.hasAttributes() && this.getDirection() === t4.getDirection();
    }
    consolidateWith(t4) {
      const e2 = Yi.textForStringWithAttributes("\n"), i3 = this.getTextWithoutBlockBreak().appendText(e2);
      return this.copyWithText(i3.appendText(t4.text));
    }
    splitAtOffset(t4) {
      let e2, i3;
      return 0 === t4 ? (e2 = null, i3 = this) : t4 === this.getLength() ? (e2 = this, i3 = null) : (e2 = this.copyWithText(this.text.getTextAtRange([0, t4])), i3 = this.copyWithText(this.text.getTextAtRange([t4, this.getLength()]))), [e2, i3];
    }
    getBlockBreakPosition() {
      return this.text.getLength() - 1;
    }
    getTextWithoutBlockBreak() {
      return en(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
    }
    canBeGrouped(t4) {
      return this.attributes[t4];
    }
    canBeGroupedWith(t4, e2) {
      const i3 = t4.getAttributes(), r3 = i3[e2], o3 = this.attributes[e2];
      return o3 === r3 && !(false === mt(o3).group && !(() => {
        if (!dt) {
          dt = [];
          for (const t5 in n2) {
            const { listAttribute: e3 } = n2[t5];
            null != e3 && dt.push(e3);
          }
        }
        return dt;
      })().includes(i3[e2 + 1])) && (this.getDirection() === t4.getDirection() || t4.isEmpty());
    }
  };
  var $i = function(t4) {
    return t4 = Zi(t4), t4 = tn(t4);
  };
  var Zi = function(t4) {
    let e2 = false;
    const i3 = t4.getPieces();
    let n3 = i3.slice(0, i3.length - 1);
    const r3 = i3[i3.length - 1];
    return r3 ? (n3 = n3.map((t5) => t5.isBlockBreak() ? (e2 = true, nn(t5)) : t5), e2 ? new Yi([...n3, r3]) : t4) : t4;
  };
  var Qi = Yi.textForStringWithAttributes("\n", { blockBreak: true });
  var tn = function(t4) {
    return en(t4) ? t4 : t4.appendText(Qi);
  };
  var en = function(t4) {
    const e2 = t4.getLength();
    if (0 === e2) return false;
    return t4.getTextAtRange([e2 - 1, e2]).isBlockBreak();
  };
  var nn = (t4) => t4.copyWithoutAttribute("blockBreak");
  var rn = function(t4) {
    const { listAttribute: e2 } = mt(t4);
    return e2 ? [e2, t4] : [t4];
  };
  var on = (t4) => t4.slice(-1)[0];
  var sn = function(t4, e2) {
    const i3 = t4.lastIndexOf(e2);
    return -1 === i3 ? t4 : st(t4, i3, 1);
  };
  var an = class extends rt {
    static fromJSON(t4) {
      return new this(Array.from(t4).map((t5) => Xi.fromJSON(t5)));
    }
    static fromString(t4, e2) {
      const i3 = Yi.textForStringWithAttributes(t4, e2);
      return new this([new Xi(i3)]);
    }
    constructor() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), 0 === t4.length && (t4 = [new Xi()]), this.blockList = Hi.box(t4);
    }
    isEmpty() {
      const t4 = this.getBlockAtIndex(0);
      return 1 === this.blockList.length && t4.isEmpty() && !t4.hasAttributes();
    }
    copy() {
      const t4 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray();
      return new this.constructor(t4);
    }
    copyUsingObjectsFromDocument(t4) {
      const e2 = new Zt(t4.getObjects());
      return this.copyUsingObjectMap(e2);
    }
    copyUsingObjectMap(t4) {
      const e2 = this.getBlocks().map((e3) => t4.find(e3) || e3.copyUsingObjectMap(t4));
      return new this.constructor(e2);
    }
    copyWithBaseBlockAttributes() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      const e2 = this.getBlocks().map((e3) => {
        const i3 = t4.concat(e3.getAttributes());
        return e3.copyWithAttributes(i3);
      });
      return new this.constructor(e2);
    }
    replaceBlock(t4, e2) {
      const i3 = this.blockList.indexOf(t4);
      return -1 === i3 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e2, i3));
    }
    insertDocumentAtRange(t4, e2) {
      const { blockList: i3 } = t4;
      e2 = wt(e2);
      let [n3] = e2;
      const { index: r3, offset: o3 } = this.locationFromPosition(n3);
      let s4 = this;
      const a5 = this.getBlockAtPosition(n3);
      return Lt(e2) && a5.isEmpty() && !a5.hasAttributes() ? s4 = new this.constructor(s4.blockList.removeObjectAtIndex(r3)) : a5.getBlockBreakPosition() === o3 && n3++, s4 = s4.removeTextAtRange(e2), new this.constructor(s4.blockList.insertSplittableListAtPosition(i3, n3));
    }
    mergeDocumentAtRange(t4, e2) {
      let i3, n3;
      e2 = wt(e2);
      const [r3] = e2, o3 = this.locationFromPosition(r3), s4 = this.getBlockAtIndex(o3.index).getAttributes(), a5 = t4.getBaseBlockAttributes(), l5 = s4.slice(-a5.length);
      if (ot(a5, l5)) {
        const e3 = s4.slice(0, -a5.length);
        i3 = t4.copyWithBaseBlockAttributes(e3);
      } else i3 = t4.copy({ consolidateBlocks: true }).copyWithBaseBlockAttributes(s4);
      const c4 = i3.getBlockCount(), u5 = i3.getBlockAtIndex(0);
      if (ot(s4, u5.getAttributes())) {
        const t5 = u5.getTextWithoutBlockBreak();
        if (n3 = this.insertTextAtRange(t5, e2), c4 > 1) {
          i3 = new this.constructor(i3.getBlocks().slice(1));
          const e3 = r3 + t5.getLength();
          n3 = n3.insertDocumentAtRange(i3, e3);
        }
      } else n3 = this.insertDocumentAtRange(i3, e2);
      return n3;
    }
    insertTextAtRange(t4, e2) {
      e2 = wt(e2);
      const [i3] = e2, { index: n3, offset: r3 } = this.locationFromPosition(i3), o3 = this.removeTextAtRange(e2);
      return new this.constructor(o3.blockList.editObjectAtIndex(n3, (e3) => e3.copyWithText(e3.text.insertTextAtPosition(t4, r3))));
    }
    removeTextAtRange(t4) {
      let e2;
      t4 = wt(t4);
      const [i3, n3] = t4;
      if (Lt(t4)) return this;
      const [r3, o3] = Array.from(this.locationRangeFromRange(t4)), s4 = r3.index, a5 = r3.offset, l5 = this.getBlockAtIndex(s4), c4 = o3.index, u5 = o3.offset, h4 = this.getBlockAtIndex(c4);
      if (n3 - i3 == 1 && l5.getBlockBreakPosition() === a5 && h4.getBlockBreakPosition() !== u5 && "\n" === h4.text.getStringAtPosition(u5)) e2 = this.blockList.editObjectAtIndex(c4, (t5) => t5.copyWithText(t5.text.removeTextAtRange([u5, u5 + 1])));
      else {
        let t5;
        const i4 = l5.text.getTextAtRange([0, a5]), n4 = h4.text.getTextAtRange([u5, h4.getLength()]), r4 = i4.appendText(n4);
        t5 = s4 !== c4 && 0 === a5 && l5.getAttributeLevel() >= h4.getAttributeLevel() ? h4.copyWithText(r4) : l5.copyWithText(r4);
        const o4 = c4 + 1 - s4;
        e2 = this.blockList.splice(s4, o4, t5);
      }
      return new this.constructor(e2);
    }
    moveTextFromRangeToPosition(t4, e2) {
      let i3;
      t4 = wt(t4);
      const [n3, r3] = t4;
      if (n3 <= e2 && e2 <= r3) return this;
      let o3 = this.getDocumentAtRange(t4), s4 = this.removeTextAtRange(t4);
      const a5 = n3 < e2;
      a5 && (e2 -= o3.getLength());
      const [l5, ...c4] = o3.getBlocks();
      return 0 === c4.length ? (i3 = l5.getTextWithoutBlockBreak(), a5 && (e2 += 1)) : i3 = l5.text, s4 = s4.insertTextAtRange(i3, e2), 0 === c4.length ? s4 : (o3 = new this.constructor(c4), e2 += i3.getLength(), s4.insertDocumentAtRange(o3, e2));
    }
    addAttributeAtRange(t4, e2, i3) {
      let { blockList: n3 } = this;
      return this.eachBlockAtRange(i3, (i4, r3, o3) => n3 = n3.editObjectAtIndex(o3, function() {
        return mt(t4) ? i4.addAttribute(t4, e2) : r3[0] === r3[1] ? i4 : i4.copyWithText(i4.text.addAttributeAtRange(t4, e2, r3));
      })), new this.constructor(n3);
    }
    addAttribute(t4, e2) {
      let { blockList: i3 } = this;
      return this.eachBlock((n3, r3) => i3 = i3.editObjectAtIndex(r3, () => n3.addAttribute(t4, e2))), new this.constructor(i3);
    }
    removeAttributeAtRange(t4, e2) {
      let { blockList: i3 } = this;
      return this.eachBlockAtRange(e2, function(e3, n3, r3) {
        mt(t4) ? i3 = i3.editObjectAtIndex(r3, () => e3.removeAttribute(t4)) : n3[0] !== n3[1] && (i3 = i3.editObjectAtIndex(r3, () => e3.copyWithText(e3.text.removeAttributeAtRange(t4, n3))));
      }), new this.constructor(i3);
    }
    updateAttributesForAttachment(t4, e2) {
      const i3 = this.getRangeOfAttachment(e2), [n3] = Array.from(i3), { index: r3 } = this.locationFromPosition(n3), o3 = this.getTextAtIndex(r3);
      return new this.constructor(this.blockList.editObjectAtIndex(r3, (i4) => i4.copyWithText(o3.updateAttributesForAttachment(t4, e2))));
    }
    removeAttributeForAttachment(t4, e2) {
      const i3 = this.getRangeOfAttachment(e2);
      return this.removeAttributeAtRange(t4, i3);
    }
    setHTMLAttributeAtPosition(t4, e2, i3) {
      const n3 = this.getBlockAtPosition(t4), r3 = n3.addHTMLAttribute(e2, i3);
      return this.replaceBlock(n3, r3);
    }
    insertBlockBreakAtRange(t4) {
      let e2;
      t4 = wt(t4);
      const [i3] = t4, { offset: n3 } = this.locationFromPosition(i3), r3 = this.removeTextAtRange(t4);
      return 0 === n3 && (e2 = [new Xi()]), new this.constructor(r3.blockList.insertSplittableListAtPosition(new Hi(e2), i3));
    }
    applyBlockAttributeAtRange(t4, e2, i3) {
      const n3 = this.expandRangeToLineBreaksAndSplitBlocks(i3);
      let r3 = n3.document;
      i3 = n3.range;
      const o3 = mt(t4);
      if (o3.listAttribute) {
        r3 = r3.removeLastListAttributeAtRange(i3, { exceptAttributeName: t4 });
        const e3 = r3.convertLineBreaksToBlockBreaksInRange(i3);
        r3 = e3.document, i3 = e3.range;
      } else r3 = o3.exclusive ? r3.removeBlockAttributesAtRange(i3) : o3.terminal ? r3.removeLastTerminalAttributeAtRange(i3) : r3.consolidateBlocksAtRange(i3);
      return r3.addAttributeAtRange(t4, e2, i3);
    }
    removeLastListAttributeAtRange(t4) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { blockList: i3 } = this;
      return this.eachBlockAtRange(t4, function(t5, n3, r3) {
        const o3 = t5.getLastAttribute();
        o3 && mt(o3).listAttribute && o3 !== e2.exceptAttributeName && (i3 = i3.editObjectAtIndex(r3, () => t5.removeAttribute(o3)));
      }), new this.constructor(i3);
    }
    removeLastTerminalAttributeAtRange(t4) {
      let { blockList: e2 } = this;
      return this.eachBlockAtRange(t4, function(t5, i3, n3) {
        const r3 = t5.getLastAttribute();
        r3 && mt(r3).terminal && (e2 = e2.editObjectAtIndex(n3, () => t5.removeAttribute(r3)));
      }), new this.constructor(e2);
    }
    removeBlockAttributesAtRange(t4) {
      let { blockList: e2 } = this;
      return this.eachBlockAtRange(t4, function(t5, i3, n3) {
        t5.hasAttributes() && (e2 = e2.editObjectAtIndex(n3, () => t5.copyWithoutAttributes()));
      }), new this.constructor(e2);
    }
    expandRangeToLineBreaksAndSplitBlocks(t4) {
      let e2;
      t4 = wt(t4);
      let [i3, n3] = t4;
      const r3 = this.locationFromPosition(i3), o3 = this.locationFromPosition(n3);
      let s4 = this;
      const a5 = s4.getBlockAtIndex(r3.index);
      if (r3.offset = a5.findLineBreakInDirectionFromPosition("backward", r3.offset), null != r3.offset && (e2 = s4.positionFromLocation(r3), s4 = s4.insertBlockBreakAtRange([e2, e2 + 1]), o3.index += 1, o3.offset -= s4.getBlockAtIndex(r3.index).getLength(), r3.index += 1), r3.offset = 0, 0 === o3.offset && o3.index > r3.index) o3.index -= 1, o3.offset = s4.getBlockAtIndex(o3.index).getBlockBreakPosition();
      else {
        const t5 = s4.getBlockAtIndex(o3.index);
        "\n" === t5.text.getStringAtRange([o3.offset - 1, o3.offset]) ? o3.offset -= 1 : o3.offset = t5.findLineBreakInDirectionFromPosition("forward", o3.offset), o3.offset !== t5.getBlockBreakPosition() && (e2 = s4.positionFromLocation(o3), s4 = s4.insertBlockBreakAtRange([e2, e2 + 1]));
      }
      return i3 = s4.positionFromLocation(r3), n3 = s4.positionFromLocation(o3), { document: s4, range: t4 = wt([i3, n3]) };
    }
    convertLineBreaksToBlockBreaksInRange(t4) {
      t4 = wt(t4);
      let [e2] = t4;
      const i3 = this.getStringAtRange(t4).slice(0, -1);
      let n3 = this;
      return i3.replace(/.*?\n/g, function(t5) {
        e2 += t5.length, n3 = n3.insertBlockBreakAtRange([e2 - 1, e2]);
      }), { document: n3, range: t4 };
    }
    consolidateBlocksAtRange(t4) {
      t4 = wt(t4);
      const [e2, i3] = t4, n3 = this.locationFromPosition(e2).index, r3 = this.locationFromPosition(i3).index;
      return new this.constructor(this.blockList.consolidateFromIndexToIndex(n3, r3));
    }
    getDocumentAtRange(t4) {
      t4 = wt(t4);
      const e2 = this.blockList.getSplittableListInRange(t4).toArray();
      return new this.constructor(e2);
    }
    getStringAtRange(t4) {
      let e2;
      const i3 = t4 = wt(t4);
      return i3[i3.length - 1] !== this.getLength() && (e2 = -1), this.getDocumentAtRange(t4).toString().slice(0, e2);
    }
    getBlockAtIndex(t4) {
      return this.blockList.getObjectAtIndex(t4);
    }
    getBlockAtPosition(t4) {
      const { index: e2 } = this.locationFromPosition(t4);
      return this.getBlockAtIndex(e2);
    }
    getTextAtIndex(t4) {
      var e2;
      return null === (e2 = this.getBlockAtIndex(t4)) || void 0 === e2 ? void 0 : e2.text;
    }
    getTextAtPosition(t4) {
      const { index: e2 } = this.locationFromPosition(t4);
      return this.getTextAtIndex(e2);
    }
    getPieceAtPosition(t4) {
      const { index: e2, offset: i3 } = this.locationFromPosition(t4);
      return this.getTextAtIndex(e2).getPieceAtPosition(i3);
    }
    getCharacterAtPosition(t4) {
      const { index: e2, offset: i3 } = this.locationFromPosition(t4);
      return this.getTextAtIndex(e2).getStringAtRange([i3, i3 + 1]);
    }
    getLength() {
      return this.blockList.getEndPosition();
    }
    getBlocks() {
      return this.blockList.toArray();
    }
    getBlockCount() {
      return this.blockList.length;
    }
    getEditCount() {
      return this.editCount;
    }
    eachBlock(t4) {
      return this.blockList.eachObject(t4);
    }
    eachBlockAtRange(t4, e2) {
      let i3, n3;
      t4 = wt(t4);
      const [r3, o3] = t4, s4 = this.locationFromPosition(r3), a5 = this.locationFromPosition(o3);
      if (s4.index === a5.index) return i3 = this.getBlockAtIndex(s4.index), n3 = [s4.offset, a5.offset], e2(i3, n3, s4.index);
      for (let t5 = s4.index; t5 <= a5.index; t5++) if (i3 = this.getBlockAtIndex(t5), i3) {
        switch (t5) {
          case s4.index:
            n3 = [s4.offset, i3.text.getLength()];
            break;
          case a5.index:
            n3 = [0, a5.offset];
            break;
          default:
            n3 = [0, i3.text.getLength()];
        }
        e2(i3, n3, t5);
      }
    }
    getCommonAttributesAtRange(t4) {
      t4 = wt(t4);
      const [e2] = t4;
      if (Lt(t4)) return this.getCommonAttributesAtPosition(e2);
      {
        const e3 = [], i3 = [];
        return this.eachBlockAtRange(t4, function(t5, n3) {
          if (n3[0] !== n3[1]) return e3.push(t5.text.getCommonAttributesAtRange(n3)), i3.push(ln(t5));
        }), Ht.fromCommonAttributesOfObjects(e3).merge(Ht.fromCommonAttributesOfObjects(i3)).toObject();
      }
    }
    getCommonAttributesAtPosition(t4) {
      let e2, i3;
      const { index: n3, offset: r3 } = this.locationFromPosition(t4), o3 = this.getBlockAtIndex(n3);
      if (!o3) return {};
      const s4 = ln(o3), a5 = o3.text.getAttributesAtPosition(r3), l5 = o3.text.getAttributesAtPosition(r3 - 1), c4 = Object.keys(W).filter((t5) => W[t5].inheritable);
      for (e2 in l5) i3 = l5[e2], (i3 === a5[e2] || c4.includes(e2)) && (s4[e2] = i3);
      return s4;
    }
    getRangeOfCommonAttributeAtPosition(t4, e2) {
      const { index: i3, offset: n3 } = this.locationFromPosition(e2), r3 = this.getTextAtIndex(i3), [o3, s4] = Array.from(r3.getExpandedRangeForAttributeAtOffset(t4, n3)), a5 = this.positionFromLocation({ index: i3, offset: o3 }), l5 = this.positionFromLocation({ index: i3, offset: s4 });
      return wt([a5, l5]);
    }
    getBaseBlockAttributes() {
      let t4 = this.getBlockAtIndex(0).getAttributes();
      for (let e2 = 1; e2 < this.getBlockCount(); e2++) {
        const i3 = this.getBlockAtIndex(e2).getAttributes(), n3 = Math.min(t4.length, i3.length);
        t4 = (() => {
          const e3 = [];
          for (let r3 = 0; r3 < n3 && i3[r3] === t4[r3]; r3++) e3.push(i3[r3]);
          return e3;
        })();
      }
      return t4;
    }
    getAttachmentById(t4) {
      for (const e2 of this.getAttachments()) if (e2.id === t4) return e2;
    }
    getAttachmentPieces() {
      let t4 = [];
      return this.blockList.eachObject((e2) => {
        let { text: i3 } = e2;
        return t4 = t4.concat(i3.getAttachmentPieces());
      }), t4;
    }
    getAttachments() {
      return this.getAttachmentPieces().map((t4) => t4.attachment);
    }
    getRangeOfAttachment(t4) {
      let e2 = 0;
      const i3 = this.blockList.toArray();
      for (let n3 = 0; n3 < i3.length; n3++) {
        const { text: r3 } = i3[n3], o3 = r3.getRangeOfAttachment(t4);
        if (o3) return wt([e2 + o3[0], e2 + o3[1]]);
        e2 += r3.getLength();
      }
    }
    getLocationRangeOfAttachment(t4) {
      const e2 = this.getRangeOfAttachment(t4);
      return this.locationRangeFromRange(e2);
    }
    getAttachmentPieceForAttachment(t4) {
      for (const e2 of this.getAttachmentPieces()) if (e2.attachment === t4) return e2;
    }
    findRangesForBlockAttribute(t4) {
      let e2 = 0;
      const i3 = [];
      return this.getBlocks().forEach((n3) => {
        const r3 = n3.getLength();
        n3.hasAttribute(t4) && i3.push([e2, e2 + r3]), e2 += r3;
      }), i3;
    }
    findRangesForTextAttribute(t4) {
      let { withValue: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = 0, n3 = [];
      const r3 = [];
      return this.getPieces().forEach((o3) => {
        const s4 = o3.getLength();
        (function(i4) {
          return e2 ? i4.getAttribute(t4) === e2 : i4.hasAttribute(t4);
        })(o3) && (n3[1] === i3 ? n3[1] = i3 + s4 : r3.push(n3 = [i3, i3 + s4])), i3 += s4;
      }), r3;
    }
    locationFromPosition(t4) {
      const e2 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t4));
      if (null != e2.index) return e2;
      {
        const t5 = this.getBlocks();
        return { index: t5.length - 1, offset: t5[t5.length - 1].getLength() };
      }
    }
    positionFromLocation(t4) {
      return this.blockList.findPositionAtIndexAndOffset(t4.index, t4.offset);
    }
    locationRangeFromPosition(t4) {
      return wt(this.locationFromPosition(t4));
    }
    locationRangeFromRange(t4) {
      if (!(t4 = wt(t4))) return;
      const [e2, i3] = Array.from(t4), n3 = this.locationFromPosition(e2), r3 = this.locationFromPosition(i3);
      return wt([n3, r3]);
    }
    rangeFromLocationRange(t4) {
      let e2;
      t4 = wt(t4);
      const i3 = this.positionFromLocation(t4[0]);
      return Lt(t4) || (e2 = this.positionFromLocation(t4[1])), wt([i3, e2]);
    }
    isEqualTo(t4) {
      return this.blockList.isEqualTo(null == t4 ? void 0 : t4.blockList);
    }
    getTexts() {
      return this.getBlocks().map((t4) => t4.text);
    }
    getPieces() {
      const t4 = [];
      return Array.from(this.getTexts()).forEach((e2) => {
        t4.push(...Array.from(e2.getPieces() || []));
      }), t4;
    }
    getObjects() {
      return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
    }
    toSerializableDocument() {
      const t4 = [];
      return this.blockList.eachObject((e2) => t4.push(e2.copyWithText(e2.text.toSerializableText()))), new this.constructor(t4);
    }
    toString() {
      return this.blockList.toString();
    }
    toJSON() {
      return this.blockList.toJSON();
    }
    toConsole() {
      return JSON.stringify(this.blockList.toArray().map((t4) => JSON.parse(t4.text.toConsole())));
    }
  };
  var ln = function(t4) {
    const e2 = {}, i3 = t4.getLastAttribute();
    return i3 && (e2[i3] = true), e2;
  };
  var cn = function(t4) {
    let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return { string: t4 = Wt(t4), attributes: e2, type: "string" };
  };
  var un = (t4, e2) => {
    try {
      return JSON.parse(t4.getAttribute("data-trix-".concat(e2)));
    } catch (t5) {
      return {};
    }
  };
  var hn = class extends q {
    static parse(t4, e2) {
      const i3 = new this(t4, e2);
      return i3.parse(), i3;
    }
    constructor(t4) {
      let { referenceElement: e2, purifyOptions: i3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      super(...arguments), this.html = t4, this.referenceElement = e2, this.purifyOptions = i3, this.blocks = [], this.blockElements = [], this.processedElements = [];
    }
    getDocument() {
      return an.fromJSON(this.blocks);
    }
    parse() {
      try {
        this.createHiddenContainer(), di.setHTML(this.containerElement, this.html, { purifyOptions: this.purifyOptions });
        const t4 = R(this.containerElement, { usingFilter: pn });
        for (; t4.nextNode(); ) this.processNode(t4.currentNode);
        return this.translateBlockElementMarginsToNewlines();
      } finally {
        this.removeHiddenContainer();
      }
    }
    createHiddenContainer() {
      return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = T({ tagName: "div", style: { display: "none" } }), document.body.appendChild(this.containerElement));
    }
    removeHiddenContainer() {
      return S(this.containerElement);
    }
    processNode(t4) {
      switch (t4.nodeType) {
        case Node.TEXT_NODE:
          if (!this.isInsignificantTextNode(t4)) return this.appendBlockForTextNode(t4), this.processTextNode(t4);
          break;
        case Node.ELEMENT_NODE:
          return this.appendBlockForElement(t4), this.processElement(t4);
      }
    }
    appendBlockForTextNode(t4) {
      const e2 = t4.parentNode;
      if (e2 === this.currentBlockElement && this.isBlockElement(t4.previousSibling)) return this.appendStringWithAttributes("\n");
      if (e2 === this.containerElement || this.isBlockElement(e2)) {
        var i3;
        const t5 = this.getBlockAttributes(e2), n3 = this.getBlockHTMLAttributes(e2);
        ot(t5, null === (i3 = this.currentBlock) || void 0 === i3 ? void 0 : i3.attributes) || (this.currentBlock = this.appendBlockForAttributesWithElement(t5, e2, n3), this.currentBlockElement = e2);
      }
    }
    appendBlockForElement(t4) {
      const e2 = this.isBlockElement(t4), i3 = C(this.currentBlockElement, t4);
      if (e2 && !this.isBlockElement(t4.firstChild)) {
        if (!this.isInsignificantTextNode(t4.firstChild) || !this.isBlockElement(t4.firstElementChild)) {
          const e3 = this.getBlockAttributes(t4), n3 = this.getBlockHTMLAttributes(t4);
          if (t4.firstChild) {
            if (i3 && ot(e3, this.currentBlock.attributes)) return this.appendStringWithAttributes("\n");
            this.currentBlock = this.appendBlockForAttributesWithElement(e3, t4, n3), this.currentBlockElement = t4;
          }
        }
      } else if (this.currentBlockElement && !i3 && !e2) {
        const e3 = this.findParentBlockElement(t4);
        if (e3) return this.appendBlockForElement(e3);
        this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null;
      }
    }
    findParentBlockElement(t4) {
      let { parentElement: e2 } = t4;
      for (; e2 && e2 !== this.containerElement; ) {
        if (this.isBlockElement(e2) && this.blockElements.includes(e2)) return e2;
        e2 = e2.parentElement;
      }
      return null;
    }
    processTextNode(t4) {
      let e2 = t4.data;
      var i3;
      dn(t4.parentNode) || (e2 = Vt(e2), vn(null === (i3 = t4.previousSibling) || void 0 === i3 ? void 0 : i3.textContent) && (e2 = fn2(e2)));
      return this.appendStringWithAttributes(e2, this.getTextAttributes(t4.parentNode));
    }
    processElement(t4) {
      let e2;
      if (P(t4)) {
        if (e2 = un(t4, "attachment"), Object.keys(e2).length) {
          const i3 = this.getTextAttributes(t4);
          this.appendAttachmentWithAttributes(e2, i3), t4.innerHTML = "";
        }
        return this.processedElements.push(t4);
      }
      switch (k(t4)) {
        case "br":
          return this.isExtraBR(t4) || this.isBlockElement(t4.nextSibling) || this.appendStringWithAttributes("\n", this.getTextAttributes(t4)), this.processedElements.push(t4);
        case "img":
          e2 = { url: t4.getAttribute("src"), contentType: "image" };
          const i3 = ((t5) => {
            const e3 = t5.getAttribute("width"), i4 = t5.getAttribute("height"), n3 = {};
            return e3 && (n3.width = parseInt(e3, 10)), i4 && (n3.height = parseInt(i4, 10)), n3;
          })(t4);
          for (const t5 in i3) {
            const n3 = i3[t5];
            e2[t5] = n3;
          }
          return this.appendAttachmentWithAttributes(e2, this.getTextAttributes(t4)), this.processedElements.push(t4);
        case "tr":
          if (this.needsTableSeparator(t4)) return this.appendStringWithAttributes(j.tableRowSeparator);
          break;
        case "td":
          if (this.needsTableSeparator(t4)) return this.appendStringWithAttributes(j.tableCellSeparator);
      }
    }
    appendBlockForAttributesWithElement(t4, e2) {
      let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      this.blockElements.push(e2);
      const n3 = function() {
        return { text: [], attributes: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, htmlAttributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {} };
      }(t4, i3);
      return this.blocks.push(n3), n3;
    }
    appendEmptyBlock() {
      return this.appendBlockForAttributesWithElement([], null);
    }
    appendStringWithAttributes(t4, e2) {
      return this.appendPiece(cn(t4, e2));
    }
    appendAttachmentWithAttributes(t4, e2) {
      return this.appendPiece(function(t5) {
        return { attachment: t5, attributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, type: "attachment" };
      }(t4, e2));
    }
    appendPiece(t4) {
      return 0 === this.blocks.length && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t4);
    }
    appendStringToTextAtIndex(t4, e2) {
      const { text: i3 } = this.blocks[e2], n3 = i3[i3.length - 1];
      if ("string" !== (null == n3 ? void 0 : n3.type)) return i3.push(cn(t4));
      n3.string += t4;
    }
    prependStringToTextAtIndex(t4, e2) {
      const { text: i3 } = this.blocks[e2], n3 = i3[0];
      if ("string" !== (null == n3 ? void 0 : n3.type)) return i3.unshift(cn(t4));
      n3.string = t4 + n3.string;
    }
    getTextAttributes(t4) {
      let e2;
      const i3 = {};
      for (const n3 in W) {
        const r3 = W[n3];
        if (r3.tagName && y(t4, { matchingSelector: r3.tagName, untilNode: this.containerElement })) i3[n3] = true;
        else if (r3.parser) {
          if (e2 = r3.parser(t4), e2) {
            let o3 = false;
            for (const i4 of this.findBlockElementAncestors(t4)) if (r3.parser(i4) === e2) {
              o3 = true;
              break;
            }
            o3 || (i3[n3] = e2);
          }
        } else r3.styleProperty && (e2 = t4.style[r3.styleProperty], e2 && (i3[n3] = e2));
      }
      if (P(t4)) {
        const n3 = un(t4, "attributes");
        for (const t5 in n3) e2 = n3[t5], i3[t5] = e2;
      }
      return i3;
    }
    getBlockAttributes(t4) {
      const e2 = [];
      for (; t4 && t4 !== this.containerElement; ) {
        for (const r3 in n2) {
          const o3 = n2[r3];
          var i3;
          if (false !== o3.parse) {
            if (k(t4) === o3.tagName) (null !== (i3 = o3.test) && void 0 !== i3 && i3.call(o3, t4) || !o3.test) && (e2.push(r3), o3.listAttribute && e2.push(o3.listAttribute));
          }
        }
        t4 = t4.parentNode;
      }
      return e2.reverse();
    }
    getBlockHTMLAttributes(t4) {
      const e2 = {}, i3 = Object.values(n2).find((e3) => e3.tagName === k(t4));
      return ((null == i3 ? void 0 : i3.htmlAttributes) || []).forEach((i4) => {
        t4.hasAttribute(i4) && (e2[i4] = t4.getAttribute(i4));
      }), e2;
    }
    findBlockElementAncestors(t4) {
      const e2 = [];
      for (; t4 && t4 !== this.containerElement; ) {
        const i3 = k(t4);
        L().includes(i3) && e2.push(t4), t4 = t4.parentNode;
      }
      return e2;
    }
    isBlockElement(t4) {
      if ((null == t4 ? void 0 : t4.nodeType) === Node.ELEMENT_NODE && !P(t4) && !y(t4, { matchingSelector: "td", untilNode: this.containerElement })) return L().includes(k(t4)) || "block" === window.getComputedStyle(t4).display;
    }
    isInsignificantTextNode(t4) {
      if ((null == t4 ? void 0 : t4.nodeType) !== Node.TEXT_NODE) return;
      if (!bn(t4.data)) return;
      const { parentNode: e2, previousSibling: i3, nextSibling: n3 } = t4;
      return gn(e2.previousSibling) && !this.isBlockElement(e2.previousSibling) || dn(e2) ? void 0 : !i3 || this.isBlockElement(i3) || !n3 || this.isBlockElement(n3);
    }
    isExtraBR(t4) {
      return "br" === k(t4) && this.isBlockElement(t4.parentNode) && t4.parentNode.lastChild === t4;
    }
    needsTableSeparator(t4) {
      if (j.removeBlankTableCells) {
        var e2;
        const i3 = null === (e2 = t4.previousSibling) || void 0 === e2 ? void 0 : e2.textContent;
        return i3 && /\S/.test(i3);
      }
      return t4.previousSibling;
    }
    translateBlockElementMarginsToNewlines() {
      const t4 = this.getMarginOfDefaultBlockElement();
      for (let e2 = 0; e2 < this.blocks.length; e2++) {
        const i3 = this.getMarginOfBlockElementAtIndex(e2);
        i3 && (i3.top > 2 * t4.top && this.prependStringToTextAtIndex("\n", e2), i3.bottom > 2 * t4.bottom && this.appendStringToTextAtIndex("\n", e2));
      }
    }
    getMarginOfBlockElementAtIndex(t4) {
      const e2 = this.blockElements[t4];
      if (e2 && e2.textContent && !L().includes(k(e2)) && !this.processedElements.includes(e2)) return mn(e2);
    }
    getMarginOfDefaultBlockElement() {
      const t4 = T(n2.default.tagName);
      return this.containerElement.appendChild(t4), mn(t4);
    }
  };
  var dn = function(t4) {
    const { whiteSpace: e2 } = window.getComputedStyle(t4);
    return ["pre", "pre-wrap", "pre-line"].includes(e2);
  };
  var gn = (t4) => t4 && !vn(t4.textContent);
  var mn = function(t4) {
    const e2 = window.getComputedStyle(t4);
    if ("block" === e2.display) return { top: parseInt(e2.marginTop), bottom: parseInt(e2.marginBottom) };
  };
  var pn = function(t4) {
    return "style" === k(t4) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var fn2 = (t4) => t4.replace(new RegExp("^".concat(Ut.source, "+")), "");
  var bn = (t4) => new RegExp("^".concat(Ut.source, "*$")).test(t4);
  var vn = (t4) => /\s$/.test(t4);
  var An = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"];
  var yn = "data-trix-serialized-attributes";
  var xn = "[".concat(yn, "]");
  var Cn = new RegExp("<!--block-->", "g");
  var En = { "application/json": function(t4) {
    let e2;
    if (t4 instanceof an) e2 = t4;
    else {
      if (!(t4 instanceof HTMLElement)) throw new Error("unserializable object");
      e2 = hn.parse(t4.innerHTML).getDocument();
    }
    return e2.toSerializableDocument().toJSONString();
  }, "text/html": function(t4) {
    let e2;
    if (t4 instanceof an) e2 = Si.render(t4);
    else {
      if (!(t4 instanceof HTMLElement)) throw new Error("unserializable object");
      e2 = t4.cloneNode(true);
    }
    return Array.from(e2.querySelectorAll("[data-trix-serialize=false]")).forEach((t5) => {
      S(t5);
    }), An.forEach((t5) => {
      Array.from(e2.querySelectorAll("[".concat(t5, "]"))).forEach((e3) => {
        e3.removeAttribute(t5);
      });
    }), Array.from(e2.querySelectorAll(xn)).forEach((t5) => {
      try {
        const e3 = JSON.parse(t5.getAttribute(yn));
        t5.removeAttribute(yn);
        for (const i3 in e3) {
          const n3 = e3[i3];
          t5.setAttribute(i3, n3);
        }
      } catch (t6) {
      }
    }), e2.innerHTML.replace(Cn, "");
  } };
  var Sn = Object.freeze({ __proto__: null });
  var Rn = class extends q {
    constructor(t4, e2) {
      super(...arguments), this.attachmentManager = t4, this.attachment = e2, this.id = this.attachment.id, this.file = this.attachment.file;
    }
    remove() {
      return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
    }
  };
  Rn.proxyMethod("attachment.getAttribute"), Rn.proxyMethod("attachment.hasAttribute"), Rn.proxyMethod("attachment.setAttribute"), Rn.proxyMethod("attachment.getAttributes"), Rn.proxyMethod("attachment.setAttributes"), Rn.proxyMethod("attachment.isPending"), Rn.proxyMethod("attachment.isPreviewable"), Rn.proxyMethod("attachment.getURL"), Rn.proxyMethod("attachment.getHref"), Rn.proxyMethod("attachment.getFilename"), Rn.proxyMethod("attachment.getFilesize"), Rn.proxyMethod("attachment.getFormattedFilesize"), Rn.proxyMethod("attachment.getExtension"), Rn.proxyMethod("attachment.getContentType"), Rn.proxyMethod("attachment.getFile"), Rn.proxyMethod("attachment.setFile"), Rn.proxyMethod("attachment.releaseFile"), Rn.proxyMethod("attachment.getUploadProgress"), Rn.proxyMethod("attachment.setUploadProgress");
  var kn = class extends q {
    constructor() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      super(...arguments), this.managedAttachments = {}, Array.from(t4).forEach((t5) => {
        this.manageAttachment(t5);
      });
    }
    getAttachments() {
      const t4 = [];
      for (const e2 in this.managedAttachments) {
        const i3 = this.managedAttachments[e2];
        t4.push(i3);
      }
      return t4;
    }
    manageAttachment(t4) {
      return this.managedAttachments[t4.id] || (this.managedAttachments[t4.id] = new Rn(this, t4)), this.managedAttachments[t4.id];
    }
    attachmentIsManaged(t4) {
      return t4.id in this.managedAttachments;
    }
    requestRemovalOfAttachment(t4) {
      var e2, i3;
      if (this.attachmentIsManaged(t4)) return null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.attachmentManagerDidRequestRemovalOfAttachment) || void 0 === i3 ? void 0 : i3.call(e2, t4);
    }
    unmanageAttachment(t4) {
      const e2 = this.managedAttachments[t4.id];
      return delete this.managedAttachments[t4.id], e2;
    }
  };
  var Tn = class {
    constructor(t4) {
      this.composition = t4, this.document = this.composition.document;
      const e2 = this.composition.getSelectedRange();
      this.startPosition = e2[0], this.endPosition = e2[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
    }
    shouldInsertBlockBreak() {
      return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? 0 !== this.startLocation.offset : this.breaksOnReturn && "\n" !== this.nextCharacter;
    }
    shouldBreakFormattedBlock() {
      return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && "\n" === this.nextCharacter || "\n" === this.previousCharacter);
    }
    shouldDecreaseListLevel() {
      return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
    }
    shouldPrependListItem() {
      return this.block.isListItem() && 0 === this.startLocation.offset && !this.block.isEmpty();
    }
    shouldRemoveLastBlockAttribute() {
      return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
    }
  };
  var wn = class extends q {
    constructor() {
      super(...arguments), this.document = new an(), this.attachments = [], this.currentAttributes = {}, this.revision = 0;
    }
    setDocument(t4) {
      var e2, i3;
      if (!t4.isEqualTo(this.document)) return this.document = t4, this.refreshAttachments(), this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.compositionDidChangeDocument) || void 0 === i3 ? void 0 : i3.call(e2, t4);
    }
    getSnapshot() {
      return { document: this.document, selectedRange: this.getSelectedRange() };
    }
    loadSnapshot(t4) {
      var e2, i3, n3, r3;
      let { document: o3, selectedRange: s4 } = t4;
      return null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.compositionWillLoadSnapshot) || void 0 === i3 || i3.call(e2), this.setDocument(null != o3 ? o3 : new an()), this.setSelection(null != s4 ? s4 : [0, 0]), null === (n3 = this.delegate) || void 0 === n3 || null === (r3 = n3.compositionDidLoadSnapshot) || void 0 === r3 ? void 0 : r3.call(n3);
    }
    insertText(t4) {
      let { updatePosition: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { updatePosition: true };
      const i3 = this.getSelectedRange();
      this.setDocument(this.document.insertTextAtRange(t4, i3));
      const n3 = i3[0], r3 = n3 + t4.getLength();
      return e2 && this.setSelection(r3), this.notifyDelegateOfInsertionAtRange([n3, r3]);
    }
    insertBlock() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Xi();
      const e2 = new an([t4]);
      return this.insertDocument(e2);
    }
    insertDocument() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new an();
      const e2 = this.getSelectedRange();
      this.setDocument(this.document.insertDocumentAtRange(t4, e2));
      const i3 = e2[0], n3 = i3 + t4.getLength();
      return this.setSelection(n3), this.notifyDelegateOfInsertionAtRange([i3, n3]);
    }
    insertString(t4, e2) {
      const i3 = this.getCurrentTextAttributes(), n3 = Yi.textForStringWithAttributes(t4, i3);
      return this.insertText(n3, e2);
    }
    insertBlockBreak() {
      const t4 = this.getSelectedRange();
      this.setDocument(this.document.insertBlockBreakAtRange(t4));
      const e2 = t4[0], i3 = e2 + 1;
      return this.setSelection(i3), this.notifyDelegateOfInsertionAtRange([e2, i3]);
    }
    insertLineBreak() {
      const t4 = new Tn(this);
      if (t4.shouldDecreaseListLevel()) return this.decreaseListLevel(), this.setSelection(t4.startPosition);
      if (t4.shouldPrependListItem()) {
        const e2 = new an([t4.block.copyWithoutText()]);
        return this.insertDocument(e2);
      }
      return t4.shouldInsertBlockBreak() ? this.insertBlockBreak() : t4.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : t4.shouldBreakFormattedBlock() ? this.breakFormattedBlock(t4) : this.insertString("\n");
    }
    insertHTML(t4) {
      const e2 = hn.parse(t4, { purifyOptions: { SAFE_FOR_XML: true } }).getDocument(), i3 = this.getSelectedRange();
      this.setDocument(this.document.mergeDocumentAtRange(e2, i3));
      const n3 = i3[0], r3 = n3 + e2.getLength() - 1;
      return this.setSelection(r3), this.notifyDelegateOfInsertionAtRange([n3, r3]);
    }
    replaceHTML(t4) {
      const e2 = hn.parse(t4).getDocument().copyUsingObjectsFromDocument(this.document), i3 = this.getLocationRange({ strict: false }), n3 = this.document.rangeFromLocationRange(i3);
      return this.setDocument(e2), this.setSelection(n3);
    }
    insertFile(t4) {
      return this.insertFiles([t4]);
    }
    insertFiles(t4) {
      const e2 = [];
      return Array.from(t4).forEach((t5) => {
        var i3;
        if (null !== (i3 = this.delegate) && void 0 !== i3 && i3.compositionShouldAcceptFile(t5)) {
          const i4 = Vi.attachmentForFile(t5);
          e2.push(i4);
        }
      }), this.insertAttachments(e2);
    }
    insertAttachment(t4) {
      return this.insertAttachments([t4]);
    }
    insertAttachments(t4) {
      let e2 = new Yi();
      return Array.from(t4).forEach((t5) => {
        var n3;
        const r3 = t5.getType(), o3 = null === (n3 = i2[r3]) || void 0 === n3 ? void 0 : n3.presentation, s4 = this.getCurrentTextAttributes();
        o3 && (s4.presentation = o3);
        const a5 = Yi.textForAttachmentWithAttributes(t5, s4);
        e2 = e2.appendText(a5);
      }), this.insertText(e2);
    }
    shouldManageDeletingInDirection(t4) {
      const e2 = this.getLocationRange();
      if (Lt(e2)) {
        if ("backward" === t4 && 0 === e2[0].offset) return true;
        if (this.shouldManageMovingCursorInDirection(t4)) return true;
      } else if (e2[0].index !== e2[1].index) return true;
      return false;
    }
    deleteInDirection(t4) {
      let e2, i3, n3, { length: r3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const o3 = this.getLocationRange();
      let s4 = this.getSelectedRange();
      const a5 = Lt(s4);
      if (a5 ? i3 = "backward" === t4 && 0 === o3[0].offset : n3 = o3[0].index !== o3[1].index, i3 && this.canDecreaseBlockAttributeLevel()) {
        const t5 = this.getBlock();
        if (t5.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(s4[0]), t5.isEmpty()) return false;
      }
      return a5 && (s4 = this.getExpandedRangeInDirection(t4, { length: r3 }), "backward" === t4 && (e2 = this.getAttachmentAtRange(s4))), e2 ? (this.editAttachment(e2), false) : (this.setDocument(this.document.removeTextAtRange(s4)), this.setSelection(s4[0]), !i3 && !n3 && void 0);
    }
    moveTextFromRange(t4) {
      const [e2] = Array.from(this.getSelectedRange());
      return this.setDocument(this.document.moveTextFromRangeToPosition(t4, e2)), this.setSelection(e2);
    }
    removeAttachment(t4) {
      const e2 = this.document.getRangeOfAttachment(t4);
      if (e2) return this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e2)), this.setSelection(e2[0]);
    }
    removeLastBlockAttribute() {
      const [t4, e2] = Array.from(this.getSelectedRange()), i3 = this.document.getBlockAtPosition(e2);
      return this.removeCurrentAttribute(i3.getLastAttribute()), this.setSelection(t4);
    }
    insertPlaceholder() {
      return this.placeholderPosition = this.getPosition(), this.insertString(" ");
    }
    selectPlaceholder() {
      if (null != this.placeholderPosition) return this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + 1]), this.getSelectedRange();
    }
    forgetPlaceholder() {
      this.placeholderPosition = null;
    }
    hasCurrentAttribute(t4) {
      const e2 = this.currentAttributes[t4];
      return null != e2 && false !== e2;
    }
    toggleCurrentAttribute(t4) {
      const e2 = !this.currentAttributes[t4];
      return e2 ? this.setCurrentAttribute(t4, e2) : this.removeCurrentAttribute(t4);
    }
    canSetCurrentAttribute(t4) {
      return mt(t4) ? this.canSetCurrentBlockAttribute(t4) : this.canSetCurrentTextAttribute(t4);
    }
    canSetCurrentTextAttribute(t4) {
      const e2 = this.getSelectedDocument();
      if (e2) {
        for (const t5 of Array.from(e2.getAttachments())) if (!t5.hasContent()) return false;
        return true;
      }
    }
    canSetCurrentBlockAttribute(t4) {
      const e2 = this.getBlock();
      if (e2) return !e2.isTerminalBlock();
    }
    setCurrentAttribute(t4, e2) {
      return mt(t4) ? this.setBlockAttribute(t4, e2) : (this.setTextAttribute(t4, e2), this.currentAttributes[t4] = e2, this.notifyDelegateOfCurrentAttributesChange());
    }
    setHTMLAtributeAtPosition(t4, e2, i3) {
      var n3;
      const r3 = this.document.getBlockAtPosition(t4), o3 = null === (n3 = mt(r3.getLastAttribute())) || void 0 === n3 ? void 0 : n3.htmlAttributes;
      if (r3 && null != o3 && o3.includes(e2)) {
        const n4 = this.document.setHTMLAttributeAtPosition(t4, e2, i3);
        this.setDocument(n4);
      }
    }
    setTextAttribute(t4, e2) {
      const i3 = this.getSelectedRange();
      if (!i3) return;
      const [n3, r3] = Array.from(i3);
      if (n3 !== r3) return this.setDocument(this.document.addAttributeAtRange(t4, e2, i3));
      if ("href" === t4) {
        const t5 = Yi.textForStringWithAttributes(e2, { href: e2 });
        return this.insertText(t5);
      }
    }
    setBlockAttribute(t4, e2) {
      const i3 = this.getSelectedRange();
      if (this.canSetCurrentAttribute(t4)) return this.setDocument(this.document.applyBlockAttributeAtRange(t4, e2, i3)), this.setSelection(i3);
    }
    removeCurrentAttribute(t4) {
      return mt(t4) ? (this.removeBlockAttribute(t4), this.updateCurrentAttributes()) : (this.removeTextAttribute(t4), delete this.currentAttributes[t4], this.notifyDelegateOfCurrentAttributesChange());
    }
    removeTextAttribute(t4) {
      const e2 = this.getSelectedRange();
      if (e2) return this.setDocument(this.document.removeAttributeAtRange(t4, e2));
    }
    removeBlockAttribute(t4) {
      const e2 = this.getSelectedRange();
      if (e2) return this.setDocument(this.document.removeAttributeAtRange(t4, e2));
    }
    canDecreaseNestingLevel() {
      var t4;
      return (null === (t4 = this.getBlock()) || void 0 === t4 ? void 0 : t4.getNestingLevel()) > 0;
    }
    canIncreaseNestingLevel() {
      var t4;
      const e2 = this.getBlock();
      if (e2) {
        if (null === (t4 = mt(e2.getLastNestableAttribute())) || void 0 === t4 || !t4.listAttribute) return e2.getNestingLevel() > 0;
        {
          const t5 = this.getPreviousBlock();
          if (t5) return function() {
            let t6 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            return ot((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).slice(0, t6.length), t6);
          }(t5.getListItemAttributes(), e2.getListItemAttributes());
        }
      }
    }
    decreaseNestingLevel() {
      const t4 = this.getBlock();
      if (t4) return this.setDocument(this.document.replaceBlock(t4, t4.decreaseNestingLevel()));
    }
    increaseNestingLevel() {
      const t4 = this.getBlock();
      if (t4) return this.setDocument(this.document.replaceBlock(t4, t4.increaseNestingLevel()));
    }
    canDecreaseBlockAttributeLevel() {
      var t4;
      return (null === (t4 = this.getBlock()) || void 0 === t4 ? void 0 : t4.getAttributeLevel()) > 0;
    }
    decreaseBlockAttributeLevel() {
      var t4;
      const e2 = null === (t4 = this.getBlock()) || void 0 === t4 ? void 0 : t4.getLastAttribute();
      if (e2) return this.removeCurrentAttribute(e2);
    }
    decreaseListLevel() {
      let [t4] = Array.from(this.getSelectedRange());
      const { index: e2 } = this.document.locationFromPosition(t4);
      let i3 = e2;
      const n3 = this.getBlock().getAttributeLevel();
      let r3 = this.document.getBlockAtIndex(i3 + 1);
      for (; r3 && r3.isListItem() && !(r3.getAttributeLevel() <= n3); ) i3++, r3 = this.document.getBlockAtIndex(i3 + 1);
      t4 = this.document.positionFromLocation({ index: e2, offset: 0 });
      const o3 = this.document.positionFromLocation({ index: i3, offset: 0 });
      return this.setDocument(this.document.removeLastListAttributeAtRange([t4, o3]));
    }
    updateCurrentAttributes() {
      const t4 = this.getSelectedRange({ ignoreLock: true });
      if (t4) {
        const e2 = this.document.getCommonAttributesAtRange(t4);
        if (Array.from(gt()).forEach((t5) => {
          e2[t5] || this.canSetCurrentAttribute(t5) || (e2[t5] = false);
        }), !Tt(e2, this.currentAttributes)) return this.currentAttributes = e2, this.notifyDelegateOfCurrentAttributesChange();
      }
    }
    getCurrentAttributes() {
      return m2.call({}, this.currentAttributes);
    }
    getCurrentTextAttributes() {
      const t4 = {};
      for (const e2 in this.currentAttributes) {
        const i3 = this.currentAttributes[e2];
        false !== i3 && ft(e2) && (t4[e2] = i3);
      }
      return t4;
    }
    freezeSelection() {
      return this.setCurrentAttribute("frozen", true);
    }
    thawSelection() {
      return this.removeCurrentAttribute("frozen");
    }
    hasFrozenSelection() {
      return this.hasCurrentAttribute("frozen");
    }
    setSelection(t4) {
      var e2;
      const i3 = this.document.locationRangeFromRange(t4);
      return null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.compositionDidRequestChangingSelectionToLocationRange(i3);
    }
    getSelectedRange() {
      const t4 = this.getLocationRange();
      if (t4) return this.document.rangeFromLocationRange(t4);
    }
    setSelectedRange(t4) {
      const e2 = this.document.locationRangeFromRange(t4);
      return this.getSelectionManager().setLocationRange(e2);
    }
    getPosition() {
      const t4 = this.getLocationRange();
      if (t4) return this.document.positionFromLocation(t4[0]);
    }
    getLocationRange(t4) {
      return this.targetLocationRange ? this.targetLocationRange : this.getSelectionManager().getLocationRange(t4) || wt({ index: 0, offset: 0 });
    }
    withTargetLocationRange(t4, e2) {
      let i3;
      this.targetLocationRange = t4;
      try {
        i3 = e2();
      } finally {
        this.targetLocationRange = null;
      }
      return i3;
    }
    withTargetRange(t4, e2) {
      const i3 = this.document.locationRangeFromRange(t4);
      return this.withTargetLocationRange(i3, e2);
    }
    withTargetDOMRange(t4, e2) {
      const i3 = this.createLocationRangeFromDOMRange(t4, { strict: false });
      return this.withTargetLocationRange(i3, e2);
    }
    getExpandedRangeInDirection(t4) {
      let { length: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, [i3, n3] = Array.from(this.getSelectedRange());
      return "backward" === t4 ? e2 ? i3 -= e2 : i3 = this.translateUTF16PositionFromOffset(i3, -1) : e2 ? n3 += e2 : n3 = this.translateUTF16PositionFromOffset(n3, 1), wt([i3, n3]);
    }
    shouldManageMovingCursorInDirection(t4) {
      if (this.editingAttachment) return true;
      const e2 = this.getExpandedRangeInDirection(t4);
      return null != this.getAttachmentAtRange(e2);
    }
    moveCursorInDirection(t4) {
      let e2, i3;
      if (this.editingAttachment) i3 = this.document.getRangeOfAttachment(this.editingAttachment);
      else {
        const n3 = this.getSelectedRange();
        i3 = this.getExpandedRangeInDirection(t4), e2 = !Dt(n3, i3);
      }
      if ("backward" === t4 ? this.setSelectedRange(i3[0]) : this.setSelectedRange(i3[1]), e2) {
        const t5 = this.getAttachmentAtRange(i3);
        if (t5) return this.editAttachment(t5);
      }
    }
    expandSelectionInDirection(t4) {
      let { length: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const i3 = this.getExpandedRangeInDirection(t4, { length: e2 });
      return this.setSelectedRange(i3);
    }
    expandSelectionForEditing() {
      if (this.hasCurrentAttribute("href")) return this.expandSelectionAroundCommonAttribute("href");
    }
    expandSelectionAroundCommonAttribute(t4) {
      const e2 = this.getPosition(), i3 = this.document.getRangeOfCommonAttributeAtPosition(t4, e2);
      return this.setSelectedRange(i3);
    }
    selectionContainsAttachments() {
      var t4;
      return (null === (t4 = this.getSelectedAttachments()) || void 0 === t4 ? void 0 : t4.length) > 0;
    }
    selectionIsInCursorTarget() {
      return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
    }
    positionIsCursorTarget(t4) {
      const e2 = this.document.locationFromPosition(t4);
      if (e2) return this.locationIsCursorTarget(e2);
    }
    positionIsBlockBreak(t4) {
      var e2;
      return null === (e2 = this.document.getPieceAtPosition(t4)) || void 0 === e2 ? void 0 : e2.isBlockBreak();
    }
    getSelectedDocument() {
      const t4 = this.getSelectedRange();
      if (t4) return this.document.getDocumentAtRange(t4);
    }
    getSelectedAttachments() {
      var t4;
      return null === (t4 = this.getSelectedDocument()) || void 0 === t4 ? void 0 : t4.getAttachments();
    }
    getAttachments() {
      return this.attachments.slice(0);
    }
    refreshAttachments() {
      const t4 = this.document.getAttachments(), { added: e2, removed: i3 } = function() {
        let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
        const i4 = [], n3 = [], r3 = /* @__PURE__ */ new Set();
        t5.forEach((t6) => {
          r3.add(t6);
        });
        const o3 = /* @__PURE__ */ new Set();
        return e3.forEach((t6) => {
          o3.add(t6), r3.has(t6) || i4.push(t6);
        }), t5.forEach((t6) => {
          o3.has(t6) || n3.push(t6);
        }), { added: i4, removed: n3 };
      }(this.attachments, t4);
      return this.attachments = t4, Array.from(i3).forEach((t5) => {
        var e3, i4;
        t5.delegate = null, null === (e3 = this.delegate) || void 0 === e3 || null === (i4 = e3.compositionDidRemoveAttachment) || void 0 === i4 || i4.call(e3, t5);
      }), (() => {
        const t5 = [];
        return Array.from(e2).forEach((e3) => {
          var i4, n3;
          e3.delegate = this, t5.push(null === (i4 = this.delegate) || void 0 === i4 || null === (n3 = i4.compositionDidAddAttachment) || void 0 === n3 ? void 0 : n3.call(i4, e3));
        }), t5;
      })();
    }
    attachmentDidChangeAttributes(t4) {
      var e2, i3;
      return this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.compositionDidEditAttachment) || void 0 === i3 ? void 0 : i3.call(e2, t4);
    }
    attachmentDidChangePreviewURL(t4) {
      var e2, i3;
      return this.revision++, null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.compositionDidChangeAttachmentPreviewURL) || void 0 === i3 ? void 0 : i3.call(e2, t4);
    }
    editAttachment(t4, e2) {
      var i3, n3;
      if (t4 !== this.editingAttachment) return this.stopEditingAttachment(), this.editingAttachment = t4, null === (i3 = this.delegate) || void 0 === i3 || null === (n3 = i3.compositionDidStartEditingAttachment) || void 0 === n3 ? void 0 : n3.call(i3, this.editingAttachment, e2);
    }
    stopEditingAttachment() {
      var t4, e2;
      this.editingAttachment && (null === (t4 = this.delegate) || void 0 === t4 || null === (e2 = t4.compositionDidStopEditingAttachment) || void 0 === e2 || e2.call(t4, this.editingAttachment), this.editingAttachment = null);
    }
    updateAttributesForAttachment(t4, e2) {
      return this.setDocument(this.document.updateAttributesForAttachment(t4, e2));
    }
    removeAttributeForAttachment(t4, e2) {
      return this.setDocument(this.document.removeAttributeForAttachment(t4, e2));
    }
    breakFormattedBlock(t4) {
      let { document: e2 } = t4;
      const { block: i3 } = t4;
      let n3 = t4.startPosition, r3 = [n3 - 1, n3];
      i3.getBlockBreakPosition() === t4.startLocation.offset ? (i3.breaksOnReturn() && "\n" === t4.nextCharacter ? n3 += 1 : e2 = e2.removeTextAtRange(r3), r3 = [n3, n3]) : "\n" === t4.nextCharacter ? "\n" === t4.previousCharacter ? r3 = [n3 - 1, n3 + 1] : (r3 = [n3, n3 + 1], n3 += 1) : t4.startLocation.offset - 1 != 0 && (n3 += 1);
      const o3 = new an([i3.removeLastAttribute().copyWithoutText()]);
      return this.setDocument(e2.insertDocumentAtRange(o3, r3)), this.setSelection(n3);
    }
    getPreviousBlock() {
      const t4 = this.getLocationRange();
      if (t4) {
        const { index: e2 } = t4[0];
        if (e2 > 0) return this.document.getBlockAtIndex(e2 - 1);
      }
    }
    getBlock() {
      const t4 = this.getLocationRange();
      if (t4) return this.document.getBlockAtIndex(t4[0].index);
    }
    getAttachmentAtRange(t4) {
      const e2 = this.document.getDocumentAtRange(t4);
      if (e2.toString() === "".concat("\uFFFC", "\n")) return e2.getAttachments()[0];
    }
    notifyDelegateOfCurrentAttributesChange() {
      var t4, e2;
      return null === (t4 = this.delegate) || void 0 === t4 || null === (e2 = t4.compositionDidChangeCurrentAttributes) || void 0 === e2 ? void 0 : e2.call(t4, this.currentAttributes);
    }
    notifyDelegateOfInsertionAtRange(t4) {
      var e2, i3;
      return null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.compositionDidPerformInsertionAtRange) || void 0 === i3 ? void 0 : i3.call(e2, t4);
    }
    translateUTF16PositionFromOffset(t4, e2) {
      const i3 = this.document.toUTF16String(), n3 = i3.offsetFromUCS2Offset(t4);
      return i3.offsetToUCS2Offset(n3 + e2);
    }
  };
  wn.proxyMethod("getSelectionManager().getPointRange"), wn.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), wn.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), wn.proxyMethod("getSelectionManager().locationIsCursorTarget"), wn.proxyMethod("getSelectionManager().selectionIsExpanded"), wn.proxyMethod("delegate?.getSelectionManager");
  var Ln = class extends q {
    constructor(t4) {
      super(...arguments), this.composition = t4, this.undoEntries = [], this.redoEntries = [];
    }
    recordUndoEntry(t4) {
      let { context: e2, consolidatable: i3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const n3 = this.undoEntries.slice(-1)[0];
      if (!i3 || !Dn(n3, t4, e2)) {
        const i4 = this.createEntry({ description: t4, context: e2 });
        this.undoEntries.push(i4), this.redoEntries = [];
      }
    }
    undo() {
      const t4 = this.undoEntries.pop();
      if (t4) {
        const e2 = this.createEntry(t4);
        return this.redoEntries.push(e2), this.composition.loadSnapshot(t4.snapshot);
      }
    }
    redo() {
      const t4 = this.redoEntries.pop();
      if (t4) {
        const e2 = this.createEntry(t4);
        return this.undoEntries.push(e2), this.composition.loadSnapshot(t4.snapshot);
      }
    }
    canUndo() {
      return this.undoEntries.length > 0;
    }
    canRedo() {
      return this.redoEntries.length > 0;
    }
    createEntry() {
      let { description: t4, context: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return { description: null == t4 ? void 0 : t4.toString(), context: JSON.stringify(e2), snapshot: this.composition.getSnapshot() };
    }
  };
  var Dn = (t4, e2, i3) => (null == t4 ? void 0 : t4.description) === (null == e2 ? void 0 : e2.toString()) && (null == t4 ? void 0 : t4.context) === JSON.stringify(i3);
  var Nn = "attachmentGallery";
  var In = class {
    constructor(t4) {
      this.document = t4.document, this.selectedRange = t4.selectedRange;
    }
    perform() {
      return this.removeBlockAttribute(), this.applyBlockAttribute();
    }
    getSnapshot() {
      return { document: this.document, selectedRange: this.selectedRange };
    }
    removeBlockAttribute() {
      return this.findRangesOfBlocks().map((t4) => this.document = this.document.removeAttributeAtRange(Nn, t4));
    }
    applyBlockAttribute() {
      let t4 = 0;
      this.findRangesOfPieces().forEach((e2) => {
        e2[1] - e2[0] > 1 && (e2[0] += t4, e2[1] += t4, "\n" !== this.document.getCharacterAtPosition(e2[1]) && (this.document = this.document.insertBlockBreakAtRange(e2[1]), e2[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), e2[1]++, t4++), 0 !== e2[0] && "\n" !== this.document.getCharacterAtPosition(e2[0] - 1) && (this.document = this.document.insertBlockBreakAtRange(e2[0]), e2[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), e2[0]++, t4++), this.document = this.document.applyBlockAttributeAtRange(Nn, true, e2));
      });
    }
    findRangesOfBlocks() {
      return this.document.findRangesForBlockAttribute(Nn);
    }
    findRangesOfPieces() {
      return this.document.findRangesForTextAttribute("presentation", { withValue: "gallery" });
    }
    moveSelectedRangeForward() {
      this.selectedRange[0] += 1, this.selectedRange[1] += 1;
    }
  };
  var On = function(t4) {
    const e2 = new In(t4);
    return e2.perform(), e2.getSnapshot();
  };
  var Fn = [On];
  var Pn = class {
    constructor(t4, e2, i3) {
      this.insertFiles = this.insertFiles.bind(this), this.composition = t4, this.selectionManager = e2, this.element = i3, this.undoManager = new Ln(this.composition), this.filters = Fn.slice(0);
    }
    loadDocument(t4) {
      return this.loadSnapshot({ document: t4, selectedRange: [0, 0] });
    }
    loadHTML() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
      const e2 = hn.parse(t4, { referenceElement: this.element }).getDocument();
      return this.loadDocument(e2);
    }
    loadJSON(t4) {
      let { document: e2, selectedRange: i3 } = t4;
      return e2 = an.fromJSON(e2), this.loadSnapshot({ document: e2, selectedRange: i3 });
    }
    loadSnapshot(t4) {
      return this.undoManager = new Ln(this.composition), this.composition.loadSnapshot(t4);
    }
    getDocument() {
      return this.composition.document;
    }
    getSelectedDocument() {
      return this.composition.getSelectedDocument();
    }
    getSnapshot() {
      return this.composition.getSnapshot();
    }
    toJSON() {
      return this.getSnapshot();
    }
    deleteInDirection(t4) {
      return this.composition.deleteInDirection(t4);
    }
    insertAttachment(t4) {
      return this.composition.insertAttachment(t4);
    }
    insertAttachments(t4) {
      return this.composition.insertAttachments(t4);
    }
    insertDocument(t4) {
      return this.composition.insertDocument(t4);
    }
    insertFile(t4) {
      return this.composition.insertFile(t4);
    }
    insertFiles(t4) {
      return this.composition.insertFiles(t4);
    }
    insertHTML(t4) {
      return this.composition.insertHTML(t4);
    }
    insertString(t4) {
      return this.composition.insertString(t4);
    }
    insertText(t4) {
      return this.composition.insertText(t4);
    }
    insertLineBreak() {
      return this.composition.insertLineBreak();
    }
    getSelectedRange() {
      return this.composition.getSelectedRange();
    }
    getPosition() {
      return this.composition.getPosition();
    }
    getClientRectAtPosition(t4) {
      const e2 = this.getDocument().locationRangeFromRange([t4, t4 + 1]);
      return this.selectionManager.getClientRectAtLocationRange(e2);
    }
    expandSelectionInDirection(t4) {
      return this.composition.expandSelectionInDirection(t4);
    }
    moveCursorInDirection(t4) {
      return this.composition.moveCursorInDirection(t4);
    }
    setSelectedRange(t4) {
      return this.composition.setSelectedRange(t4);
    }
    activateAttribute(t4) {
      let e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      return this.composition.setCurrentAttribute(t4, e2);
    }
    attributeIsActive(t4) {
      return this.composition.hasCurrentAttribute(t4);
    }
    canActivateAttribute(t4) {
      return this.composition.canSetCurrentAttribute(t4);
    }
    deactivateAttribute(t4) {
      return this.composition.removeCurrentAttribute(t4);
    }
    setHTMLAtributeAtPosition(t4, e2, i3) {
      this.composition.setHTMLAtributeAtPosition(t4, e2, i3);
    }
    canDecreaseNestingLevel() {
      return this.composition.canDecreaseNestingLevel();
    }
    canIncreaseNestingLevel() {
      return this.composition.canIncreaseNestingLevel();
    }
    decreaseNestingLevel() {
      if (this.canDecreaseNestingLevel()) return this.composition.decreaseNestingLevel();
    }
    increaseNestingLevel() {
      if (this.canIncreaseNestingLevel()) return this.composition.increaseNestingLevel();
    }
    canRedo() {
      return this.undoManager.canRedo();
    }
    canUndo() {
      return this.undoManager.canUndo();
    }
    recordUndoEntry(t4) {
      let { context: e2, consolidatable: i3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return this.undoManager.recordUndoEntry(t4, { context: e2, consolidatable: i3 });
    }
    redo() {
      if (this.canRedo()) return this.undoManager.redo();
    }
    undo() {
      if (this.canUndo()) return this.undoManager.undo();
    }
  };
  var Mn = class {
    constructor(t4) {
      this.element = t4;
    }
    findLocationFromContainerAndOffset(t4, e2) {
      let { strict: i3 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { strict: true }, n3 = 0, r3 = false;
      const o3 = { index: 0, offset: 0 }, s4 = this.findAttachmentElementParentForNode(t4);
      s4 && (t4 = s4.parentNode, e2 = E(s4));
      const a5 = R(this.element, { usingFilter: Wn });
      for (; a5.nextNode(); ) {
        const s5 = a5.currentNode;
        if (s5 === t4 && B(t4)) {
          F(s5) || (o3.offset += e2);
          break;
        }
        if (s5.parentNode === t4) {
          if (n3++ === e2) break;
        } else if (!C(t4, s5) && n3 > 0) break;
        N(s5, { strict: i3 }) ? (r3 && o3.index++, o3.offset = 0, r3 = true) : o3.offset += Bn(s5);
      }
      return o3;
    }
    findContainerAndOffsetFromLocation(t4) {
      let e2, i3;
      if (0 === t4.index && 0 === t4.offset) {
        for (e2 = this.element, i3 = 0; e2.firstChild; ) if (e2 = e2.firstChild, D(e2)) {
          i3 = 1;
          break;
        }
        return [e2, i3];
      }
      let [n3, r3] = this.findNodeAndOffsetFromLocation(t4);
      if (n3) {
        if (B(n3)) 0 === Bn(n3) ? (e2 = n3.parentNode.parentNode, i3 = E(n3.parentNode), F(n3, { name: "right" }) && i3++) : (e2 = n3, i3 = t4.offset - r3);
        else {
          if (e2 = n3.parentNode, !N(n3.previousSibling) && !D(e2)) for (; n3 === e2.lastChild && (n3 = e2, e2 = e2.parentNode, !D(e2)); ) ;
          i3 = E(n3), 0 !== t4.offset && i3++;
        }
        return [e2, i3];
      }
    }
    findNodeAndOffsetFromLocation(t4) {
      let e2, i3, n3 = 0;
      for (const r3 of this.getSignificantNodesForIndex(t4.index)) {
        const o3 = Bn(r3);
        if (t4.offset <= n3 + o3) if (B(r3)) {
          if (e2 = r3, i3 = n3, t4.offset === i3 && F(e2)) break;
        } else e2 || (e2 = r3, i3 = n3);
        if (n3 += o3, n3 > t4.offset) break;
      }
      return [e2, i3];
    }
    findAttachmentElementParentForNode(t4) {
      for (; t4 && t4 !== this.element; ) {
        if (P(t4)) return t4;
        t4 = t4.parentNode;
      }
    }
    getSignificantNodesForIndex(t4) {
      const e2 = [], i3 = R(this.element, { usingFilter: _n });
      let n3 = false;
      for (; i3.nextNode(); ) {
        const o3 = i3.currentNode;
        var r3;
        if (I(o3)) {
          if (null != r3 ? r3++ : r3 = 0, r3 === t4) n3 = true;
          else if (n3) break;
        } else n3 && e2.push(o3);
      }
      return e2;
    }
  };
  var Bn = function(t4) {
    if (t4.nodeType === Node.TEXT_NODE) {
      if (F(t4)) return 0;
      return t4.textContent.length;
    }
    return "br" === k(t4) || P(t4) ? 1 : 0;
  };
  var _n = function(t4) {
    return jn(t4) === NodeFilter.FILTER_ACCEPT ? Wn(t4) : NodeFilter.FILTER_REJECT;
  };
  var jn = function(t4) {
    return M(t4) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var Wn = function(t4) {
    return P(t4.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
  };
  var Un = class {
    createDOMRangeFromPoint(t4) {
      let e2, { x: i3, y: n3 } = t4;
      if (document.caretPositionFromPoint) {
        const { offsetNode: t5, offset: r3 } = document.caretPositionFromPoint(i3, n3);
        return e2 = document.createRange(), e2.setStart(t5, r3), e2;
      }
      if (document.caretRangeFromPoint) return document.caretRangeFromPoint(i3, n3);
      if (document.body.createTextRange) {
        const t5 = Mt();
        try {
          const t6 = document.body.createTextRange();
          t6.moveToPoint(i3, n3), t6.select();
        } catch (t6) {
        }
        return e2 = Mt(), Bt(t5), e2;
      }
    }
    getClientRectsForDOMRange(t4) {
      const e2 = Array.from(t4.getClientRects());
      return [e2[0], e2[e2.length - 1]];
    }
  };
  var Vn = class extends q {
    constructor(t4) {
      super(...arguments), this.didMouseDown = this.didMouseDown.bind(this), this.selectionDidChange = this.selectionDidChange.bind(this), this.element = t4, this.locationMapper = new Mn(this.element), this.pointMapper = new Un(), this.lockCount = 0, b2("mousedown", { onElement: this.element, withCallback: this.didMouseDown });
    }
    getLocationRange() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return false === t4.strict ? this.createLocationRangeFromDOMRange(Mt()) : t4.ignoreLock ? this.currentLocationRange : this.lockedLocationRange ? this.lockedLocationRange : this.currentLocationRange;
    }
    setLocationRange(t4) {
      if (this.lockedLocationRange) return;
      t4 = wt(t4);
      const e2 = this.createDOMRangeFromLocationRange(t4);
      e2 && (Bt(e2), this.updateCurrentLocationRange(t4));
    }
    setLocationRangeFromPointRange(t4) {
      t4 = wt(t4);
      const e2 = this.getLocationAtPoint(t4[0]), i3 = this.getLocationAtPoint(t4[1]);
      this.setLocationRange([e2, i3]);
    }
    getClientRectAtLocationRange(t4) {
      const e2 = this.createDOMRangeFromLocationRange(t4);
      if (e2) return this.getClientRectsForDOMRange(e2)[1];
    }
    locationIsCursorTarget(t4) {
      const e2 = Array.from(this.findNodeAndOffsetFromLocation(t4))[0];
      return F(e2);
    }
    lock() {
      0 == this.lockCount++ && (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange());
    }
    unlock() {
      if (0 == --this.lockCount) {
        const { lockedLocationRange: t4 } = this;
        if (this.lockedLocationRange = null, null != t4) return this.setLocationRange(t4);
      }
    }
    clearSelection() {
      var t4;
      return null === (t4 = Pt()) || void 0 === t4 ? void 0 : t4.removeAllRanges();
    }
    selectionIsCollapsed() {
      var t4;
      return true === (null === (t4 = Mt()) || void 0 === t4 ? void 0 : t4.collapsed);
    }
    selectionIsExpanded() {
      return !this.selectionIsCollapsed();
    }
    createLocationRangeFromDOMRange(t4, e2) {
      if (null == t4 || !this.domRangeWithinElement(t4)) return;
      const i3 = this.findLocationFromContainerAndOffset(t4.startContainer, t4.startOffset, e2);
      if (!i3) return;
      const n3 = t4.collapsed ? void 0 : this.findLocationFromContainerAndOffset(t4.endContainer, t4.endOffset, e2);
      return wt([i3, n3]);
    }
    didMouseDown() {
      return this.pauseTemporarily();
    }
    pauseTemporarily() {
      let t4;
      this.paused = true;
      const e2 = () => {
        if (this.paused = false, clearTimeout(i3), Array.from(t4).forEach((t5) => {
          t5.destroy();
        }), C(document, this.element)) return this.selectionDidChange();
      }, i3 = setTimeout(e2, 200);
      t4 = ["mousemove", "keydown"].map((t5) => b2(t5, { onElement: document, withCallback: e2 }));
    }
    selectionDidChange() {
      if (!this.paused && !x(this.element)) return this.updateCurrentLocationRange();
    }
    updateCurrentLocationRange(t4) {
      var e2, i3;
      if ((null != t4 ? t4 : t4 = this.createLocationRangeFromDOMRange(Mt())) && !Dt(t4, this.currentLocationRange)) return this.currentLocationRange = t4, null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.locationRangeDidChange) || void 0 === i3 ? void 0 : i3.call(e2, this.currentLocationRange.slice(0));
    }
    createDOMRangeFromLocationRange(t4) {
      const e2 = this.findContainerAndOffsetFromLocation(t4[0]), i3 = Lt(t4) ? e2 : this.findContainerAndOffsetFromLocation(t4[1]) || e2;
      if (null != e2 && null != i3) {
        const t5 = document.createRange();
        return t5.setStart(...Array.from(e2 || [])), t5.setEnd(...Array.from(i3 || [])), t5;
      }
    }
    getLocationAtPoint(t4) {
      const e2 = this.createDOMRangeFromPoint(t4);
      var i3;
      if (e2) return null === (i3 = this.createLocationRangeFromDOMRange(e2)) || void 0 === i3 ? void 0 : i3[0];
    }
    domRangeWithinElement(t4) {
      return t4.collapsed ? C(this.element, t4.startContainer) : C(this.element, t4.startContainer) && C(this.element, t4.endContainer);
    }
  };
  Vn.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), Vn.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), Vn.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), Vn.proxyMethod("pointMapper.createDOMRangeFromPoint"), Vn.proxyMethod("pointMapper.getClientRectsForDOMRange");
  var zn = Object.freeze({ __proto__: null, Attachment: Vi, AttachmentManager: kn, AttachmentPiece: zi, Block: Xi, Composition: wn, Document: an, Editor: Pn, HTMLParser: hn, HTMLSanitizer: di, LineBreakInsertion: Tn, LocationMapper: Mn, ManagedAttachment: Rn, Piece: Wi, PointMapper: Un, SelectionManager: Vn, SplittableList: Hi, StringPiece: qi, Text: Yi, UndoManager: Ln });
  var qn = Object.freeze({ __proto__: null, ObjectView: ie, AttachmentView: pi, BlockView: Ei, DocumentView: Si, PieceView: Ai, PreviewableAttachmentView: vi, TextView: yi });
  var { lang: Hn, css: Jn, keyNames: Kn } = z;
  var Gn = function(t4) {
    return function() {
      const e2 = t4.apply(this, arguments);
      e2.do(), this.undos || (this.undos = []), this.undos.push(e2.undo);
    };
  };
  var Yn = class extends q {
    constructor(t4, e2, i3) {
      let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
      super(...arguments), Di(this, "makeElementMutable", Gn(() => ({ do: () => {
        this.element.dataset.trixMutable = true;
      }, undo: () => delete this.element.dataset.trixMutable }))), Di(this, "addToolbar", Gn(() => {
        const t5 = T({ tagName: "div", className: Jn.attachmentToolbar, data: { trixMutable: true }, childNodes: T({ tagName: "div", className: "trix-button-row", childNodes: T({ tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: T({ tagName: "button", className: "trix-button trix-button--remove", textContent: Hn.remove, attributes: { title: Hn.remove }, data: { trixAction: "remove" } }) }) }) });
        return this.attachment.isPreviewable() && t5.appendChild(T({ tagName: "div", className: Jn.attachmentMetadataContainer, childNodes: T({ tagName: "span", className: Jn.attachmentMetadata, childNodes: [T({ tagName: "span", className: Jn.attachmentName, textContent: this.attachment.getFilename(), attributes: { title: this.attachment.getFilename() } }), T({ tagName: "span", className: Jn.attachmentSize, textContent: this.attachment.getFormattedFilesize() })] }) })), b2("click", { onElement: t5, withCallback: this.didClickToolbar }), b2("click", { onElement: t5, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton }), v("trix-attachment-before-toolbar", { onElement: this.element, attributes: { toolbar: t5, attachment: this.attachment } }), { do: () => this.element.appendChild(t5), undo: () => S(t5) };
      })), Di(this, "installCaptionEditor", Gn(() => {
        const t5 = T({ tagName: "textarea", className: Jn.attachmentCaptionEditor, attributes: { placeholder: Hn.captionPlaceholder }, data: { trixMutable: true } });
        t5.value = this.attachmentPiece.getCaption();
        const e3 = t5.cloneNode();
        e3.classList.add("trix-autoresize-clone"), e3.tabIndex = -1;
        const i4 = function() {
          e3.value = t5.value, t5.style.height = e3.scrollHeight + "px";
        };
        b2("input", { onElement: t5, withCallback: i4 }), b2("input", { onElement: t5, withCallback: this.didInputCaption }), b2("keydown", { onElement: t5, withCallback: this.didKeyDownCaption }), b2("change", { onElement: t5, withCallback: this.didChangeCaption }), b2("blur", { onElement: t5, withCallback: this.didBlurCaption });
        const n4 = this.element.querySelector("figcaption"), r3 = n4.cloneNode();
        return { do: () => {
          if (n4.style.display = "none", r3.appendChild(t5), r3.appendChild(e3), r3.classList.add("".concat(Jn.attachmentCaption, "--editing")), n4.parentElement.insertBefore(r3, n4), i4(), this.options.editCaption) return Rt(() => t5.focus());
        }, undo() {
          S(r3), n4.style.display = null;
        } };
      })), this.didClickToolbar = this.didClickToolbar.bind(this), this.didClickActionButton = this.didClickActionButton.bind(this), this.didKeyDownCaption = this.didKeyDownCaption.bind(this), this.didInputCaption = this.didInputCaption.bind(this), this.didChangeCaption = this.didChangeCaption.bind(this), this.didBlurCaption = this.didBlurCaption.bind(this), this.attachmentPiece = t4, this.element = e2, this.container = i3, this.options = n3, this.attachment = this.attachmentPiece.attachment, "a" === k(this.element) && (this.element = this.element.firstChild), this.install();
    }
    install() {
      this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() && this.installCaptionEditor();
    }
    uninstall() {
      var t4;
      let e2 = this.undos.pop();
      for (this.savePendingCaption(); e2; ) e2(), e2 = this.undos.pop();
      null === (t4 = this.delegate) || void 0 === t4 || t4.didUninstallAttachmentEditor(this);
    }
    savePendingCaption() {
      if (null != this.pendingCaption) {
        const r3 = this.pendingCaption;
        var t4, e2, i3, n3;
        if (this.pendingCaption = null, r3) null === (t4 = this.delegate) || void 0 === t4 || null === (e2 = t4.attachmentEditorDidRequestUpdatingAttributesForAttachment) || void 0 === e2 || e2.call(t4, { caption: r3 }, this.attachment);
        else null === (i3 = this.delegate) || void 0 === i3 || null === (n3 = i3.attachmentEditorDidRequestRemovingAttributeForAttachment) || void 0 === n3 || n3.call(i3, "caption", this.attachment);
      }
    }
    didClickToolbar(t4) {
      return t4.preventDefault(), t4.stopPropagation();
    }
    didClickActionButton(t4) {
      var e2;
      if ("remove" === t4.target.getAttribute("data-trix-action")) return null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.attachmentEditorDidRequestRemovalOfAttachment(this.attachment);
    }
    didKeyDownCaption(t4) {
      var e2, i3;
      if ("return" === Kn[t4.keyCode]) return t4.preventDefault(), this.savePendingCaption(), null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.attachmentEditorDidRequestDeselectingAttachment) || void 0 === i3 ? void 0 : i3.call(e2, this.attachment);
    }
    didInputCaption(t4) {
      this.pendingCaption = t4.target.value.replace(/\s/g, " ").trim();
    }
    didChangeCaption(t4) {
      return this.savePendingCaption();
    }
    didBlurCaption(t4) {
      return this.savePendingCaption();
    }
  };
  var Xn = class extends q {
    constructor(t4, i3) {
      super(...arguments), this.didFocus = this.didFocus.bind(this), this.didBlur = this.didBlur.bind(this), this.didClickAttachment = this.didClickAttachment.bind(this), this.element = t4, this.composition = i3, this.documentView = new Si(this.composition.document, { element: this.element }), b2("focus", { onElement: this.element, withCallback: this.didFocus }), b2("blur", { onElement: this.element, withCallback: this.didBlur }), b2("click", { onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true }), b2("mousedown", { onElement: this.element, matchingSelector: e, withCallback: this.didClickAttachment }), b2("click", { onElement: this.element, matchingSelector: "a".concat(e), preventDefault: true });
    }
    didFocus(t4) {
      var e2;
      const i3 = () => {
        var t5, e3;
        if (!this.focused) return this.focused = true, null === (t5 = this.delegate) || void 0 === t5 || null === (e3 = t5.compositionControllerDidFocus) || void 0 === e3 ? void 0 : e3.call(t5);
      };
      return (null === (e2 = this.blurPromise) || void 0 === e2 ? void 0 : e2.then(i3)) || i3();
    }
    didBlur(t4) {
      this.blurPromise = new Promise((t5) => Rt(() => {
        var e2, i3;
        x(this.element) || (this.focused = null, null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.compositionControllerDidBlur) || void 0 === i3 || i3.call(e2));
        return this.blurPromise = null, t5();
      }));
    }
    didClickAttachment(t4, e2) {
      var i3, n3;
      const r3 = this.findAttachmentForElement(e2), o3 = !!y(t4.target, { matchingSelector: "figcaption" });
      return null === (i3 = this.delegate) || void 0 === i3 || null === (n3 = i3.compositionControllerDidSelectAttachment) || void 0 === n3 ? void 0 : n3.call(i3, r3, { editCaption: o3 });
    }
    getSerializableElement() {
      return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
    }
    render() {
      var t4, e2, i3, n3, r3, o3;
      (this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced()) && (null === (i3 = this.delegate) || void 0 === i3 || null === (n3 = i3.compositionControllerWillSyncDocumentView) || void 0 === n3 || n3.call(i3), this.documentView.sync(), null === (r3 = this.delegate) || void 0 === r3 || null === (o3 = r3.compositionControllerDidSyncDocumentView) || void 0 === o3 || o3.call(r3));
      return null === (t4 = this.delegate) || void 0 === t4 || null === (e2 = t4.compositionControllerDidRender) || void 0 === e2 ? void 0 : e2.call(t4);
    }
    rerenderViewForObject(t4) {
      return this.invalidateViewForObject(t4), this.render();
    }
    invalidateViewForObject(t4) {
      return this.documentView.invalidateViewForObject(t4);
    }
    isViewCachingEnabled() {
      return this.documentView.isViewCachingEnabled();
    }
    enableViewCaching() {
      return this.documentView.enableViewCaching();
    }
    disableViewCaching() {
      return this.documentView.disableViewCaching();
    }
    refreshViewCache() {
      return this.documentView.garbageCollectCachedViews();
    }
    isEditingAttachment() {
      return !!this.attachmentEditor;
    }
    installAttachmentEditorForAttachment(t4, e2) {
      var i3;
      if ((null === (i3 = this.attachmentEditor) || void 0 === i3 ? void 0 : i3.attachment) === t4) return;
      const n3 = this.documentView.findElementForObject(t4);
      if (!n3) return;
      this.uninstallAttachmentEditor();
      const r3 = this.composition.document.getAttachmentPieceForAttachment(t4);
      this.attachmentEditor = new Yn(r3, n3, this.element, e2), this.attachmentEditor.delegate = this;
    }
    uninstallAttachmentEditor() {
      var t4;
      return null === (t4 = this.attachmentEditor) || void 0 === t4 ? void 0 : t4.uninstall();
    }
    didUninstallAttachmentEditor() {
      return this.attachmentEditor = null, this.render();
    }
    attachmentEditorDidRequestUpdatingAttributesForAttachment(t4, e2) {
      var i3, n3;
      return null === (i3 = this.delegate) || void 0 === i3 || null === (n3 = i3.compositionControllerWillUpdateAttachment) || void 0 === n3 || n3.call(i3, e2), this.composition.updateAttributesForAttachment(t4, e2);
    }
    attachmentEditorDidRequestRemovingAttributeForAttachment(t4, e2) {
      var i3, n3;
      return null === (i3 = this.delegate) || void 0 === i3 || null === (n3 = i3.compositionControllerWillUpdateAttachment) || void 0 === n3 || n3.call(i3, e2), this.composition.removeAttributeForAttachment(t4, e2);
    }
    attachmentEditorDidRequestRemovalOfAttachment(t4) {
      var e2, i3;
      return null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.compositionControllerDidRequestRemovalOfAttachment) || void 0 === i3 ? void 0 : i3.call(e2, t4);
    }
    attachmentEditorDidRequestDeselectingAttachment(t4) {
      var e2, i3;
      return null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.compositionControllerDidRequestDeselectingAttachment) || void 0 === i3 ? void 0 : i3.call(e2, t4);
    }
    canSyncDocumentView() {
      return !this.isEditingAttachment();
    }
    findAttachmentForElement(t4) {
      return this.composition.document.getAttachmentById(parseInt(t4.dataset.trixId, 10));
    }
  };
  var $n = class extends q {
  };
  var Zn = "data-trix-mutable";
  var Qn = "[".concat(Zn, "]");
  var tr = { attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true };
  var er = class extends q {
    constructor(t4) {
      super(t4), this.didMutate = this.didMutate.bind(this), this.element = t4, this.observer = new window.MutationObserver(this.didMutate), this.start();
    }
    start() {
      return this.reset(), this.observer.observe(this.element, tr);
    }
    stop() {
      return this.observer.disconnect();
    }
    didMutate(t4) {
      var e2, i3;
      if (this.mutations.push(...Array.from(this.findSignificantMutations(t4) || [])), this.mutations.length) return null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.elementDidMutate) || void 0 === i3 || i3.call(e2, this.getMutationSummary()), this.reset();
    }
    reset() {
      this.mutations = [];
    }
    findSignificantMutations(t4) {
      return t4.filter((t5) => this.mutationIsSignificant(t5));
    }
    mutationIsSignificant(t4) {
      if (this.nodeIsMutable(t4.target)) return false;
      for (const e2 of Array.from(this.nodesModifiedByMutation(t4))) if (this.nodeIsSignificant(e2)) return true;
      return false;
    }
    nodeIsSignificant(t4) {
      return t4 !== this.element && !this.nodeIsMutable(t4) && !M(t4);
    }
    nodeIsMutable(t4) {
      return y(t4, { matchingSelector: Qn });
    }
    nodesModifiedByMutation(t4) {
      const e2 = [];
      switch (t4.type) {
        case "attributes":
          t4.attributeName !== Zn && e2.push(t4.target);
          break;
        case "characterData":
          e2.push(t4.target.parentNode), e2.push(t4.target);
          break;
        case "childList":
          e2.push(...Array.from(t4.addedNodes || [])), e2.push(...Array.from(t4.removedNodes || []));
      }
      return e2;
    }
    getMutationSummary() {
      return this.getTextMutationSummary();
    }
    getTextMutationSummary() {
      const { additions: t4, deletions: e2 } = this.getTextChangesFromCharacterData(), i3 = this.getTextChangesFromChildList();
      Array.from(i3.additions).forEach((e3) => {
        Array.from(t4).includes(e3) || t4.push(e3);
      }), e2.push(...Array.from(i3.deletions || []));
      const n3 = {}, r3 = t4.join("");
      r3 && (n3.textAdded = r3);
      const o3 = e2.join("");
      return o3 && (n3.textDeleted = o3), n3;
    }
    getMutationsByType(t4) {
      return Array.from(this.mutations).filter((e2) => e2.type === t4);
    }
    getTextChangesFromChildList() {
      let t4, e2;
      const i3 = [], n3 = [];
      Array.from(this.getMutationsByType("childList")).forEach((t5) => {
        i3.push(...Array.from(t5.addedNodes || [])), n3.push(...Array.from(t5.removedNodes || []));
      });
      0 === i3.length && 1 === n3.length && I(n3[0]) ? (t4 = [], e2 = ["\n"]) : (t4 = ir(i3), e2 = ir(n3));
      const r3 = t4.filter((t5, i4) => t5 !== e2[i4]).map(Wt), o3 = e2.filter((e3, i4) => e3 !== t4[i4]).map(Wt);
      return { additions: r3, deletions: o3 };
    }
    getTextChangesFromCharacterData() {
      let t4, e2;
      const i3 = this.getMutationsByType("characterData");
      if (i3.length) {
        const n3 = i3[0], r3 = i3[i3.length - 1], o3 = function(t5, e3) {
          let i4, n4;
          return t5 = $3.box(t5), (e3 = $3.box(e3)).length < t5.length ? [n4, i4] = zt(t5, e3) : [i4, n4] = zt(e3, t5), { added: i4, removed: n4 };
        }(Wt(n3.oldValue), Wt(r3.target.data));
        t4 = o3.added, e2 = o3.removed;
      }
      return { additions: t4 ? [t4] : [], deletions: e2 ? [e2] : [] };
    }
  };
  var ir = function() {
    let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const e2 = [];
    for (const i3 of Array.from(t4)) switch (i3.nodeType) {
      case Node.TEXT_NODE:
        e2.push(i3.data);
        break;
      case Node.ELEMENT_NODE:
        "br" === k(i3) ? e2.push("\n") : e2.push(...Array.from(ir(i3.childNodes) || []));
    }
    return e2;
  };
  var nr = class extends ee {
    constructor(t4) {
      super(...arguments), this.file = t4;
    }
    perform(t4) {
      const e2 = new FileReader();
      return e2.onerror = () => t4(false), e2.onload = () => {
        e2.onerror = null;
        try {
          e2.abort();
        } catch (t5) {
        }
        return t4(true, this.file);
      }, e2.readAsArrayBuffer(this.file);
    }
  };
  var rr = class {
    constructor(t4) {
      this.element = t4;
    }
    shouldIgnore(t4) {
      return !!a2.samsungAndroid && (this.previousEvent = this.event, this.event = t4, this.checkSamsungKeyboardBuggyModeStart(), this.checkSamsungKeyboardBuggyModeEnd(), this.buggyMode);
    }
    checkSamsungKeyboardBuggyModeStart() {
      this.insertingLongTextAfterUnidentifiedChar() && or(this.element.innerText, this.event.data) && (this.buggyMode = true, this.event.preventDefault());
    }
    checkSamsungKeyboardBuggyModeEnd() {
      this.buggyMode && "insertText" !== this.event.inputType && (this.buggyMode = false);
    }
    insertingLongTextAfterUnidentifiedChar() {
      var t4;
      return this.isBeforeInputInsertText() && this.previousEventWasUnidentifiedKeydown() && (null === (t4 = this.event.data) || void 0 === t4 ? void 0 : t4.length) > 50;
    }
    isBeforeInputInsertText() {
      return "beforeinput" === this.event.type && "insertText" === this.event.inputType;
    }
    previousEventWasUnidentifiedKeydown() {
      var t4, e2;
      return "keydown" === (null === (t4 = this.previousEvent) || void 0 === t4 ? void 0 : t4.type) && "Unidentified" === (null === (e2 = this.previousEvent) || void 0 === e2 ? void 0 : e2.key);
    }
  };
  var or = (t4, e2) => ar(t4) === ar(e2);
  var sr = new RegExp("(".concat("\uFFFC", "|").concat(d2, "|").concat(g, "|\\s)+"), "g");
  var ar = (t4) => t4.replace(sr, " ").trim();
  var lr = class extends q {
    constructor(t4) {
      super(...arguments), this.element = t4, this.mutationObserver = new er(this.element), this.mutationObserver.delegate = this, this.flakyKeyboardDetector = new rr(this.element);
      for (const t5 in this.constructor.events) b2(t5, { onElement: this.element, withCallback: this.handlerFor(t5) });
    }
    elementDidMutate(t4) {
    }
    editorWillSyncDocumentView() {
      return this.mutationObserver.stop();
    }
    editorDidSyncDocumentView() {
      return this.mutationObserver.start();
    }
    requestRender() {
      var t4, e2;
      return null === (t4 = this.delegate) || void 0 === t4 || null === (e2 = t4.inputControllerDidRequestRender) || void 0 === e2 ? void 0 : e2.call(t4);
    }
    requestReparse() {
      var t4, e2;
      return null === (t4 = this.delegate) || void 0 === t4 || null === (e2 = t4.inputControllerDidRequestReparse) || void 0 === e2 || e2.call(t4), this.requestRender();
    }
    attachFiles(t4) {
      const e2 = Array.from(t4).map((t5) => new nr(t5));
      return Promise.all(e2).then((t5) => {
        this.handleInput(function() {
          var e3, i3;
          return null === (e3 = this.delegate) || void 0 === e3 || e3.inputControllerWillAttachFiles(), null === (i3 = this.responder) || void 0 === i3 || i3.insertFiles(t5), this.requestRender();
        });
      });
    }
    handlerFor(t4) {
      return (e2) => {
        e2.defaultPrevented || this.handleInput(() => {
          if (!x(this.element)) {
            if (this.flakyKeyboardDetector.shouldIgnore(e2)) return;
            this.eventName = t4, this.constructor.events[t4].call(this, e2);
          }
        });
      };
    }
    handleInput(t4) {
      try {
        var e2;
        null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillHandleInput(), t4.call(this);
      } finally {
        var i3;
        null === (i3 = this.delegate) || void 0 === i3 || i3.inputControllerDidHandleInput();
      }
    }
    createLinkHTML(t4, e2) {
      const i3 = document.createElement("a");
      return i3.href = t4, i3.textContent = e2 || t4, i3.outerHTML;
    }
  };
  var cr;
  Di(lr, "events", {});
  var { browser: ur, keyNames: hr } = z;
  var dr = 0;
  var gr = class extends lr {
    constructor() {
      super(...arguments), this.resetInputSummary();
    }
    setInputSummary() {
      let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.inputSummary.eventName = this.eventName;
      for (const e2 in t4) {
        const i3 = t4[e2];
        this.inputSummary[e2] = i3;
      }
      return this.inputSummary;
    }
    resetInputSummary() {
      this.inputSummary = {};
    }
    reset() {
      return this.resetInputSummary(), Ft.reset();
    }
    elementDidMutate(t4) {
      var e2, i3;
      return this.isComposing() ? null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.inputControllerDidAllowUnhandledInput) || void 0 === i3 ? void 0 : i3.call(e2) : this.handleInput(function() {
        return this.mutationIsSignificant(t4) && (this.mutationIsExpected(t4) ? this.requestRender() : this.requestReparse()), this.reset();
      });
    }
    mutationIsExpected(t4) {
      let { textAdded: e2, textDeleted: i3 } = t4;
      if (this.inputSummary.preferDocument) return true;
      const n3 = null != e2 ? e2 === this.inputSummary.textAdded : !this.inputSummary.textAdded, r3 = null != i3 ? this.inputSummary.didDelete : !this.inputSummary.didDelete, o3 = ["\n", " \n"].includes(e2) && !n3, s4 = "\n" === i3 && !r3;
      if (o3 && !s4 || s4 && !o3) {
        const t5 = this.getSelectedRange();
        if (t5) {
          var a5;
          const i4 = o3 ? e2.replace(/\n$/, "").length || -1 : (null == e2 ? void 0 : e2.length) || 1;
          if (null !== (a5 = this.responder) && void 0 !== a5 && a5.positionIsBlockBreak(t5[1] + i4)) return true;
        }
      }
      return n3 && r3;
    }
    mutationIsSignificant(t4) {
      var e2;
      const i3 = Object.keys(t4).length > 0, n3 = "" === (null === (e2 = this.compositionInput) || void 0 === e2 ? void 0 : e2.getEndData());
      return i3 || !n3;
    }
    getCompositionInput() {
      if (this.isComposing()) return this.compositionInput;
      this.compositionInput = new vr(this);
    }
    isComposing() {
      return this.compositionInput && !this.compositionInput.isEnded();
    }
    deleteInDirection(t4, e2) {
      var i3;
      return false !== (null === (i3 = this.responder) || void 0 === i3 ? void 0 : i3.deleteInDirection(t4)) ? this.setInputSummary({ didDelete: true }) : e2 ? (e2.preventDefault(), this.requestRender()) : void 0;
    }
    serializeSelectionToDataTransfer(t4) {
      var e2;
      if (!function(t5) {
        if (null == t5 || !t5.setData) return false;
        for (const e3 in Ct) {
          const i4 = Ct[e3];
          try {
            if (t5.setData(e3, i4), !t5.getData(e3) === i4) return false;
          } catch (t6) {
            return false;
          }
        }
        return true;
      }(t4)) return;
      const i3 = null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.getSelectedDocument().toSerializableDocument();
      return t4.setData("application/x-trix-document", JSON.stringify(i3)), t4.setData("text/html", Si.render(i3).innerHTML), t4.setData("text/plain", i3.toString().replace(/\n$/, "")), true;
    }
    canAcceptDataTransfer(t4) {
      const e2 = {};
      return Array.from((null == t4 ? void 0 : t4.types) || []).forEach((t5) => {
        e2[t5] = true;
      }), e2.Files || e2["application/x-trix-document"] || e2["text/html"] || e2["text/plain"];
    }
    getPastedHTMLUsingHiddenElement(t4) {
      const e2 = this.getSelectedRange(), i3 = { position: "absolute", left: "".concat(window.pageXOffset, "px"), top: "".concat(window.pageYOffset, "px"), opacity: 0 }, n3 = T({ style: i3, tagName: "div", editable: true });
      return document.body.appendChild(n3), n3.focus(), requestAnimationFrame(() => {
        const i4 = n3.innerHTML;
        return S(n3), this.setSelectedRange(e2), t4(i4);
      });
    }
  };
  Di(gr, "events", { keydown(t4) {
    this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true;
    const e2 = hr[t4.keyCode];
    if (e2) {
      var i3;
      let n4 = this.keys;
      ["ctrl", "alt", "shift", "meta"].forEach((e3) => {
        var i4;
        t4["".concat(e3, "Key")] && ("ctrl" === e3 && (e3 = "control"), n4 = null === (i4 = n4) || void 0 === i4 ? void 0 : i4[e3]);
      }), null != (null === (i3 = n4) || void 0 === i3 ? void 0 : i3[e2]) && (this.setInputSummary({ keyName: e2 }), Ft.reset(), n4[e2].call(this, t4));
    }
    if (St(t4)) {
      const e3 = String.fromCharCode(t4.keyCode).toLowerCase();
      if (e3) {
        var n3;
        const i4 = ["alt", "shift"].map((e4) => {
          if (t4["".concat(e4, "Key")]) return e4;
        }).filter((t5) => t5);
        i4.push(e3), null !== (n3 = this.delegate) && void 0 !== n3 && n3.inputControllerDidReceiveKeyboardCommand(i4) && t4.preventDefault();
      }
    }
  }, keypress(t4) {
    if (null != this.inputSummary.eventName) return;
    if (t4.metaKey) return;
    if (t4.ctrlKey && !t4.altKey) return;
    const e2 = fr(t4);
    var i3, n3;
    return e2 ? (null === (i3 = this.delegate) || void 0 === i3 || i3.inputControllerWillPerformTyping(), null === (n3 = this.responder) || void 0 === n3 || n3.insertString(e2), this.setInputSummary({ textAdded: e2, didDelete: this.selectionIsExpanded() })) : void 0;
  }, textInput(t4) {
    const { data: e2 } = t4, { textAdded: i3 } = this.inputSummary;
    if (i3 && i3 !== e2 && i3.toUpperCase() === e2) {
      var n3;
      const t5 = this.getSelectedRange();
      return this.setSelectedRange([t5[0], t5[1] + i3.length]), null === (n3 = this.responder) || void 0 === n3 || n3.insertString(e2), this.setInputSummary({ textAdded: e2 }), this.setSelectedRange(t5);
    }
  }, dragenter(t4) {
    t4.preventDefault();
  }, dragstart(t4) {
    var e2, i3;
    return this.serializeSelectionToDataTransfer(t4.dataTransfer), this.draggedRange = this.getSelectedRange(), null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.inputControllerDidStartDrag) || void 0 === i3 ? void 0 : i3.call(e2);
  }, dragover(t4) {
    if (this.draggedRange || this.canAcceptDataTransfer(t4.dataTransfer)) {
      t4.preventDefault();
      const n3 = { x: t4.clientX, y: t4.clientY };
      var e2, i3;
      if (!Tt(n3, this.draggingPoint)) return this.draggingPoint = n3, null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.inputControllerDidReceiveDragOverPoint) || void 0 === i3 ? void 0 : i3.call(e2, this.draggingPoint);
    }
  }, dragend(t4) {
    var e2, i3;
    null === (e2 = this.delegate) || void 0 === e2 || null === (i3 = e2.inputControllerDidCancelDrag) || void 0 === i3 || i3.call(e2), this.draggedRange = null, this.draggingPoint = null;
  }, drop(t4) {
    var e2, i3;
    t4.preventDefault();
    const n3 = null === (e2 = t4.dataTransfer) || void 0 === e2 ? void 0 : e2.files, r3 = t4.dataTransfer.getData("application/x-trix-document"), o3 = { x: t4.clientX, y: t4.clientY };
    if (null === (i3 = this.responder) || void 0 === i3 || i3.setLocationRangeFromPointRange(o3), null != n3 && n3.length) this.attachFiles(n3);
    else if (this.draggedRange) {
      var s4, a5;
      null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillMoveText(), null === (a5 = this.responder) || void 0 === a5 || a5.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender();
    } else if (r3) {
      var l5;
      const t5 = an.fromJSONString(r3);
      null === (l5 = this.responder) || void 0 === l5 || l5.insertDocument(t5), this.requestRender();
    }
    this.draggedRange = null, this.draggingPoint = null;
  }, cut(t4) {
    var e2, i3;
    if (null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionIsExpanded() && (this.serializeSelectionToDataTransfer(t4.clipboardData) && t4.preventDefault(), null === (i3 = this.delegate) || void 0 === i3 || i3.inputControllerWillCutText(), this.deleteInDirection("backward"), t4.defaultPrevented)) return this.requestRender();
  }, copy(t4) {
    var e2;
    null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionIsExpanded() && this.serializeSelectionToDataTransfer(t4.clipboardData) && t4.preventDefault();
  }, paste(t4) {
    const e2 = t4.clipboardData || t4.testClipboardData, i3 = { clipboard: e2 };
    if (!e2 || br(t4)) return void this.getPastedHTMLUsingHiddenElement((t5) => {
      var e3, n4, r4;
      return i3.type = "text/html", i3.html = t5, null === (e3 = this.delegate) || void 0 === e3 || e3.inputControllerWillPaste(i3), null === (n4 = this.responder) || void 0 === n4 || n4.insertHTML(i3.html), this.requestRender(), null === (r4 = this.delegate) || void 0 === r4 ? void 0 : r4.inputControllerDidPaste(i3);
    });
    const n3 = e2.getData("URL"), r3 = e2.getData("text/html"), o3 = e2.getData("public.url-name");
    if (n3) {
      var s4, a5, l5;
      let t5;
      i3.type = "text/html", t5 = o3 ? Vt(o3).trim() : n3, i3.html = this.createLinkHTML(n3, t5), null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillPaste(i3), this.setInputSummary({ textAdded: t5, didDelete: this.selectionIsExpanded() }), null === (a5 = this.responder) || void 0 === a5 || a5.insertHTML(i3.html), this.requestRender(), null === (l5 = this.delegate) || void 0 === l5 || l5.inputControllerDidPaste(i3);
    } else if (Et(e2)) {
      var c4, u5, h4;
      i3.type = "text/plain", i3.string = e2.getData("text/plain"), null === (c4 = this.delegate) || void 0 === c4 || c4.inputControllerWillPaste(i3), this.setInputSummary({ textAdded: i3.string, didDelete: this.selectionIsExpanded() }), null === (u5 = this.responder) || void 0 === u5 || u5.insertString(i3.string), this.requestRender(), null === (h4 = this.delegate) || void 0 === h4 || h4.inputControllerDidPaste(i3);
    } else if (r3) {
      var d5, g4, m4;
      i3.type = "text/html", i3.html = r3, null === (d5 = this.delegate) || void 0 === d5 || d5.inputControllerWillPaste(i3), null === (g4 = this.responder) || void 0 === g4 || g4.insertHTML(i3.html), this.requestRender(), null === (m4 = this.delegate) || void 0 === m4 || m4.inputControllerDidPaste(i3);
    } else if (Array.from(e2.types).includes("Files")) {
      var p4, f4;
      const t5 = null === (p4 = e2.items) || void 0 === p4 || null === (p4 = p4[0]) || void 0 === p4 || null === (f4 = p4.getAsFile) || void 0 === f4 ? void 0 : f4.call(p4);
      if (t5) {
        var b5, v4, A4;
        const e3 = mr(t5);
        !t5.name && e3 && (t5.name = "pasted-file-".concat(++dr, ".").concat(e3)), i3.type = "File", i3.file = t5, null === (b5 = this.delegate) || void 0 === b5 || b5.inputControllerWillAttachFiles(), null === (v4 = this.responder) || void 0 === v4 || v4.insertFile(i3.file), this.requestRender(), null === (A4 = this.delegate) || void 0 === A4 || A4.inputControllerDidPaste(i3);
      }
    }
    t4.preventDefault();
  }, compositionstart(t4) {
    return this.getCompositionInput().start(t4.data);
  }, compositionupdate(t4) {
    return this.getCompositionInput().update(t4.data);
  }, compositionend(t4) {
    return this.getCompositionInput().end(t4.data);
  }, beforeinput(t4) {
    this.inputSummary.didInput = true;
  }, input(t4) {
    return this.inputSummary.didInput = true, t4.stopPropagation();
  } }), Di(gr, "keys", { backspace(t4) {
    var e2;
    return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t4);
  }, delete(t4) {
    var e2;
    return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t4);
  }, return(t4) {
    var e2, i3;
    return this.setInputSummary({ preferDocument: true }), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i3 = this.responder) || void 0 === i3 ? void 0 : i3.insertLineBreak();
  }, tab(t4) {
    var e2, i3;
    null !== (e2 = this.responder) && void 0 !== e2 && e2.canIncreaseNestingLevel() && (null === (i3 = this.responder) || void 0 === i3 || i3.increaseNestingLevel(), this.requestRender(), t4.preventDefault());
  }, left(t4) {
    var e2;
    if (this.selectionIsInCursorTarget()) return t4.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("backward");
  }, right(t4) {
    var e2;
    if (this.selectionIsInCursorTarget()) return t4.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("forward");
  }, control: { d(t4) {
    var e2;
    return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t4);
  }, h(t4) {
    var e2;
    return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t4);
  }, o(t4) {
    var e2, i3;
    return t4.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i3 = this.responder) || void 0 === i3 || i3.insertString("\n", { updatePosition: false }), this.requestRender();
  } }, shift: { return(t4) {
    var e2, i3;
    null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i3 = this.responder) || void 0 === i3 || i3.insertString("\n"), this.requestRender(), t4.preventDefault();
  }, tab(t4) {
    var e2, i3;
    null !== (e2 = this.responder) && void 0 !== e2 && e2.canDecreaseNestingLevel() && (null === (i3 = this.responder) || void 0 === i3 || i3.decreaseNestingLevel(), this.requestRender(), t4.preventDefault());
  }, left(t4) {
    if (this.selectionIsInCursorTarget()) return t4.preventDefault(), this.expandSelectionInDirection("backward");
  }, right(t4) {
    if (this.selectionIsInCursorTarget()) return t4.preventDefault(), this.expandSelectionInDirection("forward");
  } }, alt: { backspace(t4) {
    var e2;
    return this.setInputSummary({ preferDocument: false }), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.inputControllerWillPerformTyping();
  } }, meta: { backspace(t4) {
    var e2;
    return this.setInputSummary({ preferDocument: false }), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.inputControllerWillPerformTyping();
  } } }), gr.proxyMethod("responder?.getSelectedRange"), gr.proxyMethod("responder?.setSelectedRange"), gr.proxyMethod("responder?.expandSelectionInDirection"), gr.proxyMethod("responder?.selectionIsInCursorTarget"), gr.proxyMethod("responder?.selectionIsExpanded");
  var mr = (t4) => {
    var e2;
    return null === (e2 = t4.type) || void 0 === e2 || null === (e2 = e2.match(/\/(\w+)$/)) || void 0 === e2 ? void 0 : e2[1];
  };
  var pr = !(null === (cr = " ".codePointAt) || void 0 === cr || !cr.call(" ", 0));
  var fr = function(t4) {
    if (t4.key && pr && t4.key.codePointAt(0) === t4.keyCode) return t4.key;
    {
      let e2;
      if (null === t4.which ? e2 = t4.keyCode : 0 !== t4.which && 0 !== t4.charCode && (e2 = t4.charCode), null != e2 && "escape" !== hr[e2]) return $3.fromCodepoints([e2]).toString();
    }
  };
  var br = function(t4) {
    const e2 = t4.clipboardData;
    if (e2) {
      if (e2.types.includes("text/html")) {
        for (const t5 of e2.types) {
          const i3 = /^CorePasteboardFlavorType/.test(t5), n3 = /^dyn\./.test(t5) && e2.getData(t5);
          if (i3 || n3) return true;
        }
        return false;
      }
      {
        const t5 = e2.types.includes("com.apple.webarchive"), i3 = e2.types.includes("com.apple.flat-rtfd");
        return t5 || i3;
      }
    }
  };
  var vr = class extends q {
    constructor(t4) {
      super(...arguments), this.inputController = t4, this.responder = this.inputController.responder, this.delegate = this.inputController.delegate, this.inputSummary = this.inputController.inputSummary, this.data = {};
    }
    start(t4) {
      if (this.data.start = t4, this.isSignificant()) {
        var e2, i3;
        if ("keypress" === this.inputSummary.eventName && this.inputSummary.textAdded) null === (i3 = this.responder) || void 0 === i3 || i3.deleteInDirection("left");
        this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.getSelectedRange();
      }
    }
    update(t4) {
      if (this.data.update = t4, this.isSignificant()) {
        const t5 = this.selectPlaceholder();
        t5 && (this.forgetPlaceholder(), this.range = t5);
      }
    }
    end(t4) {
      return this.data.end = t4, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({ preferDocument: true, didInput: false }), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i3 = this.responder) || void 0 === i3 || i3.setSelectedRange(this.range), null === (n3 = this.responder) || void 0 === n3 || n3.insertString(this.data.end), null === (r3 = this.responder) || void 0 === r3 ? void 0 : r3.setSelectedRange(this.range[0] + this.data.end.length)) : null != this.data.start || null != this.data.update ? (this.requestReparse(), this.inputController.reset()) : void 0) : this.inputController.reset();
      var e2, i3, n3, r3;
    }
    getEndData() {
      return this.data.end;
    }
    isEnded() {
      return null != this.getEndData();
    }
    isSignificant() {
      return !ur.composesExistingText || this.inputSummary.didInput;
    }
    canApplyToDocument() {
      var t4, e2;
      return 0 === (null === (t4 = this.data.start) || void 0 === t4 ? void 0 : t4.length) && (null === (e2 = this.data.end) || void 0 === e2 ? void 0 : e2.length) > 0 && this.range;
    }
  };
  vr.proxyMethod("inputController.setInputSummary"), vr.proxyMethod("inputController.requestRender"), vr.proxyMethod("inputController.requestReparse"), vr.proxyMethod("responder?.selectionIsExpanded"), vr.proxyMethod("responder?.insertPlaceholder"), vr.proxyMethod("responder?.selectPlaceholder"), vr.proxyMethod("responder?.forgetPlaceholder");
  var Ar = class extends lr {
    constructor() {
      super(...arguments), this.render = this.render.bind(this);
    }
    elementDidMutate() {
      return this.scheduledRender ? this.composing ? null === (t4 = this.delegate) || void 0 === t4 || null === (e2 = t4.inputControllerDidAllowUnhandledInput) || void 0 === e2 ? void 0 : e2.call(t4) : void 0 : this.reparse();
      var t4, e2;
    }
    scheduleRender() {
      return this.scheduledRender ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
    }
    render() {
      var t4, e2;
      (cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing) || (null === (e2 = this.delegate) || void 0 === e2 || e2.render());
      null === (t4 = this.afterRender) || void 0 === t4 || t4.call(this), this.afterRender = null;
    }
    reparse() {
      var t4;
      return null === (t4 = this.delegate) || void 0 === t4 ? void 0 : t4.reparse();
    }
    insertString() {
      var t4;
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", i3 = arguments.length > 1 ? arguments[1] : void 0;
      return null === (t4 = this.delegate) || void 0 === t4 || t4.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
        var t5;
        return null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.insertString(e2, i3);
      });
    }
    toggleAttributeIfSupported(t4) {
      var e2;
      if (gt().includes(t4)) return null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformFormatting(t4), this.withTargetDOMRange(function() {
        var e3;
        return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.toggleCurrentAttribute(t4);
      });
    }
    activateAttributeIfSupported(t4, e2) {
      var i3;
      if (gt().includes(t4)) return null === (i3 = this.delegate) || void 0 === i3 || i3.inputControllerWillPerformFormatting(t4), this.withTargetDOMRange(function() {
        var i4;
        return null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.setCurrentAttribute(t4, e2);
      });
    }
    deleteInDirection(t4) {
      let { recordUndoEntry: e2 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { recordUndoEntry: true };
      var i3;
      e2 && (null === (i3 = this.delegate) || void 0 === i3 || i3.inputControllerWillPerformTyping());
      const n3 = () => {
        var e3;
        return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.deleteInDirection(t4);
      }, r3 = this.getTargetDOMRange({ minLength: this.composing ? 1 : 2 });
      return r3 ? this.withTargetDOMRange(r3, n3) : n3();
    }
    withTargetDOMRange(t4, e2) {
      var i3;
      return "function" == typeof t4 && (e2 = t4, t4 = this.getTargetDOMRange()), t4 ? null === (i3 = this.responder) || void 0 === i3 ? void 0 : i3.withTargetDOMRange(t4, e2.bind(this)) : (Ft.reset(), e2.call(this));
    }
    getTargetDOMRange() {
      var t4, e2;
      let { minLength: i3 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { minLength: 0 };
      const n3 = null === (t4 = (e2 = this.event).getTargetRanges) || void 0 === t4 ? void 0 : t4.call(e2);
      if (n3 && n3.length) {
        const t5 = yr(n3[0]);
        if (0 === i3 || t5.toString().length >= i3) return t5;
      }
    }
    withEvent(t4, e2) {
      let i3;
      this.event = t4;
      try {
        i3 = e2.call(this);
      } finally {
        this.event = null;
      }
      return i3;
    }
  };
  Di(Ar, "events", { keydown(t4) {
    if (St(t4)) {
      var e2;
      const i3 = Rr(t4);
      null !== (e2 = this.delegate) && void 0 !== e2 && e2.inputControllerDidReceiveKeyboardCommand(i3) && t4.preventDefault();
    } else {
      let e3 = t4.key;
      t4.altKey && (e3 += "+Alt"), t4.shiftKey && (e3 += "+Shift");
      const i3 = this.constructor.keys[e3];
      if (i3) return this.withEvent(t4, i3);
    }
  }, paste(t4) {
    var e2;
    let i3;
    const n3 = null === (e2 = t4.clipboardData) || void 0 === e2 ? void 0 : e2.getData("URL");
    return Er(t4) ? (t4.preventDefault(), this.attachFiles(t4.clipboardData.files)) : Sr(t4) ? (t4.preventDefault(), i3 = { type: "text/plain", string: t4.clipboardData.getData("text/plain") }, null === (r3 = this.delegate) || void 0 === r3 || r3.inputControllerWillPaste(i3), null === (o3 = this.responder) || void 0 === o3 || o3.insertString(i3.string), this.render(), null === (s4 = this.delegate) || void 0 === s4 ? void 0 : s4.inputControllerDidPaste(i3)) : n3 ? (t4.preventDefault(), i3 = { type: "text/html", html: this.createLinkHTML(n3) }, null === (a5 = this.delegate) || void 0 === a5 || a5.inputControllerWillPaste(i3), null === (l5 = this.responder) || void 0 === l5 || l5.insertHTML(i3.html), this.render(), null === (c4 = this.delegate) || void 0 === c4 ? void 0 : c4.inputControllerDidPaste(i3)) : void 0;
    var r3, o3, s4, a5, l5, c4;
  }, beforeinput(t4) {
    const e2 = this.constructor.inputTypes[t4.inputType], i3 = (n3 = t4, !(!/iPhone|iPad/.test(navigator.userAgent) || n3.inputType && "insertParagraph" !== n3.inputType));
    var n3;
    e2 && (this.withEvent(t4, e2), i3 || this.scheduleRender()), i3 && this.render();
  }, input(t4) {
    Ft.reset();
  }, dragstart(t4) {
    var e2, i3;
    null !== (e2 = this.responder) && void 0 !== e2 && e2.selectionContainsAttachments() && (t4.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = { range: null === (i3 = this.responder) || void 0 === i3 ? void 0 : i3.getSelectedRange(), point: kr(t4) });
  }, dragenter(t4) {
    xr(t4) && t4.preventDefault();
  }, dragover(t4) {
    if (this.dragging) {
      t4.preventDefault();
      const i3 = kr(t4);
      var e2;
      if (!Tt(i3, this.dragging.point)) return this.dragging.point = i3, null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.setLocationRangeFromPointRange(i3);
    } else xr(t4) && t4.preventDefault();
  }, drop(t4) {
    var e2, i3;
    if (this.dragging) return t4.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillMoveText(), null === (i3 = this.responder) || void 0 === i3 || i3.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender();
    if (xr(t4)) {
      var n3;
      t4.preventDefault();
      const e3 = kr(t4);
      return null === (n3 = this.responder) || void 0 === n3 || n3.setLocationRangeFromPointRange(e3), this.attachFiles(t4.dataTransfer.files);
    }
  }, dragend() {
    var t4;
    this.dragging && (null === (t4 = this.responder) || void 0 === t4 || t4.setSelectedRange(this.dragging.range), this.dragging = null);
  }, compositionend(t4) {
    this.composing && (this.composing = false, a2.recentAndroid || this.scheduleRender());
  } }), Di(Ar, "keys", { ArrowLeft() {
    var t4, e2;
    if (null !== (t4 = this.responder) && void 0 !== t4 && t4.shouldManageMovingCursorInDirection("backward")) return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("backward");
  }, ArrowRight() {
    var t4, e2;
    if (null !== (t4 = this.responder) && void 0 !== t4 && t4.shouldManageMovingCursorInDirection("forward")) return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 ? void 0 : e2.moveCursorInDirection("forward");
  }, Backspace() {
    var t4, e2, i3;
    if (null !== (t4 = this.responder) && void 0 !== t4 && t4.shouldManageDeletingInDirection("backward")) return this.event.preventDefault(), null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillPerformTyping(), null === (i3 = this.responder) || void 0 === i3 || i3.deleteInDirection("backward"), this.render();
  }, Tab() {
    var t4, e2;
    if (null !== (t4 = this.responder) && void 0 !== t4 && t4.canIncreaseNestingLevel()) return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 || e2.increaseNestingLevel(), this.render();
  }, "Tab+Shift"() {
    var t4, e2;
    if (null !== (t4 = this.responder) && void 0 !== t4 && t4.canDecreaseNestingLevel()) return this.event.preventDefault(), null === (e2 = this.responder) || void 0 === e2 || e2.decreaseNestingLevel(), this.render();
  } }), Di(Ar, "inputTypes", { deleteByComposition() {
    return this.deleteInDirection("backward", { recordUndoEntry: false });
  }, deleteByCut() {
    return this.deleteInDirection("backward");
  }, deleteByDrag() {
    return this.event.preventDefault(), this.withTargetDOMRange(function() {
      var t4;
      this.deleteByDragRange = null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.getSelectedRange();
    });
  }, deleteCompositionText() {
    return this.deleteInDirection("backward", { recordUndoEntry: false });
  }, deleteContent() {
    return this.deleteInDirection("backward");
  }, deleteContentBackward() {
    return this.deleteInDirection("backward");
  }, deleteContentForward() {
    return this.deleteInDirection("forward");
  }, deleteEntireSoftLine() {
    return this.deleteInDirection("forward");
  }, deleteHardLineBackward() {
    return this.deleteInDirection("backward");
  }, deleteHardLineForward() {
    return this.deleteInDirection("forward");
  }, deleteSoftLineBackward() {
    return this.deleteInDirection("backward");
  }, deleteSoftLineForward() {
    return this.deleteInDirection("forward");
  }, deleteWordBackward() {
    return this.deleteInDirection("backward");
  }, deleteWordForward() {
    return this.deleteInDirection("forward");
  }, formatBackColor() {
    return this.activateAttributeIfSupported("backgroundColor", this.event.data);
  }, formatBold() {
    return this.toggleAttributeIfSupported("bold");
  }, formatFontColor() {
    return this.activateAttributeIfSupported("color", this.event.data);
  }, formatFontName() {
    return this.activateAttributeIfSupported("font", this.event.data);
  }, formatIndent() {
    var t4;
    if (null !== (t4 = this.responder) && void 0 !== t4 && t4.canIncreaseNestingLevel()) return this.withTargetDOMRange(function() {
      var t5;
      return null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.increaseNestingLevel();
    });
  }, formatItalic() {
    return this.toggleAttributeIfSupported("italic");
  }, formatJustifyCenter() {
    return this.toggleAttributeIfSupported("justifyCenter");
  }, formatJustifyFull() {
    return this.toggleAttributeIfSupported("justifyFull");
  }, formatJustifyLeft() {
    return this.toggleAttributeIfSupported("justifyLeft");
  }, formatJustifyRight() {
    return this.toggleAttributeIfSupported("justifyRight");
  }, formatOutdent() {
    var t4;
    if (null !== (t4 = this.responder) && void 0 !== t4 && t4.canDecreaseNestingLevel()) return this.withTargetDOMRange(function() {
      var t5;
      return null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.decreaseNestingLevel();
    });
  }, formatRemove() {
    this.withTargetDOMRange(function() {
      for (const i3 in null === (t4 = this.responder) || void 0 === t4 ? void 0 : t4.getCurrentAttributes()) {
        var t4, e2;
        null === (e2 = this.responder) || void 0 === e2 || e2.removeCurrentAttribute(i3);
      }
    });
  }, formatSetBlockTextDirection() {
    return this.activateAttributeIfSupported("blockDir", this.event.data);
  }, formatSetInlineTextDirection() {
    return this.activateAttributeIfSupported("textDir", this.event.data);
  }, formatStrikeThrough() {
    return this.toggleAttributeIfSupported("strike");
  }, formatSubscript() {
    return this.toggleAttributeIfSupported("sub");
  }, formatSuperscript() {
    return this.toggleAttributeIfSupported("sup");
  }, formatUnderline() {
    return this.toggleAttributeIfSupported("underline");
  }, historyRedo() {
    var t4;
    return null === (t4 = this.delegate) || void 0 === t4 ? void 0 : t4.inputControllerWillPerformRedo();
  }, historyUndo() {
    var t4;
    return null === (t4 = this.delegate) || void 0 === t4 ? void 0 : t4.inputControllerWillPerformUndo();
  }, insertCompositionText() {
    return this.composing = true, this.insertString(this.event.data);
  }, insertFromComposition() {
    return this.composing = false, this.insertString(this.event.data);
  }, insertFromDrop() {
    const t4 = this.deleteByDragRange;
    var e2;
    if (t4) return this.deleteByDragRange = null, null === (e2 = this.delegate) || void 0 === e2 || e2.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
      var e3;
      return null === (e3 = this.responder) || void 0 === e3 ? void 0 : e3.moveTextFromRange(t4);
    });
  }, insertFromPaste() {
    const { dataTransfer: t4 } = this.event, e2 = { dataTransfer: t4 }, i3 = t4.getData("URL"), n3 = t4.getData("text/html");
    if (i3) {
      var r3;
      let n4;
      this.event.preventDefault(), e2.type = "text/html";
      const o4 = t4.getData("public.url-name");
      n4 = o4 ? Vt(o4).trim() : i3, e2.html = this.createLinkHTML(i3, n4), null === (r3 = this.delegate) || void 0 === r3 || r3.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
        var t5;
        return null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.insertHTML(e2.html);
      }), this.afterRender = () => {
        var t5;
        return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.inputControllerDidPaste(e2);
      };
    } else if (Et(t4)) {
      var o3;
      e2.type = "text/plain", e2.string = t4.getData("text/plain"), null === (o3 = this.delegate) || void 0 === o3 || o3.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
        var t5;
        return null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.insertString(e2.string);
      }), this.afterRender = () => {
        var t5;
        return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.inputControllerDidPaste(e2);
      };
    } else if (Cr(this.event)) {
      var s4;
      e2.type = "File", e2.file = t4.files[0], null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
        var t5;
        return null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.insertFile(e2.file);
      }), this.afterRender = () => {
        var t5;
        return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.inputControllerDidPaste(e2);
      };
    } else if (n3) {
      var a5;
      this.event.preventDefault(), e2.type = "text/html", e2.html = n3, null === (a5 = this.delegate) || void 0 === a5 || a5.inputControllerWillPaste(e2), this.withTargetDOMRange(function() {
        var t5;
        return null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.insertHTML(e2.html);
      }), this.afterRender = () => {
        var t5;
        return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.inputControllerDidPaste(e2);
      };
    }
  }, insertFromYank() {
    return this.insertString(this.event.data);
  }, insertLineBreak() {
    return this.insertString("\n");
  }, insertLink() {
    return this.activateAttributeIfSupported("href", this.event.data);
  }, insertOrderedList() {
    return this.toggleAttributeIfSupported("number");
  }, insertParagraph() {
    var t4;
    return null === (t4 = this.delegate) || void 0 === t4 || t4.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
      var t5;
      return null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.insertLineBreak();
    });
  }, insertReplacementText() {
    const t4 = this.event.dataTransfer.getData("text/plain"), e2 = this.event.getTargetRanges()[0];
    this.withTargetDOMRange(e2, () => {
      this.insertString(t4, { updatePosition: false });
    });
  }, insertText() {
    var t4;
    return this.insertString(this.event.data || (null === (t4 = this.event.dataTransfer) || void 0 === t4 ? void 0 : t4.getData("text/plain")));
  }, insertTranspose() {
    return this.insertString(this.event.data);
  }, insertUnorderedList() {
    return this.toggleAttributeIfSupported("bullet");
  } });
  var yr = function(t4) {
    const e2 = document.createRange();
    return e2.setStart(t4.startContainer, t4.startOffset), e2.setEnd(t4.endContainer, t4.endOffset), e2;
  };
  var xr = (t4) => {
    var e2;
    return Array.from((null === (e2 = t4.dataTransfer) || void 0 === e2 ? void 0 : e2.types) || []).includes("Files");
  };
  var Cr = (t4) => {
    var e2;
    return (null === (e2 = t4.dataTransfer.files) || void 0 === e2 ? void 0 : e2[0]) && !Er(t4) && !((t5) => {
      let { dataTransfer: e3 } = t5;
      return e3.types.includes("Files") && e3.types.includes("text/html") && e3.getData("text/html").includes("urn:schemas-microsoft-com:office:office");
    })(t4);
  };
  var Er = function(t4) {
    const e2 = t4.clipboardData;
    if (e2) {
      return Array.from(e2.types).filter((t5) => t5.match(/file/i)).length === e2.types.length && e2.files.length >= 1;
    }
  };
  var Sr = function(t4) {
    const e2 = t4.clipboardData;
    if (e2) return e2.types.includes("text/plain") && 1 === e2.types.length;
  };
  var Rr = function(t4) {
    const e2 = [];
    return t4.altKey && e2.push("alt"), t4.shiftKey && e2.push("shift"), e2.push(t4.key), e2;
  };
  var kr = (t4) => ({ x: t4.clientX, y: t4.clientY });
  var Tr = "[data-trix-attribute]";
  var wr = "[data-trix-action]";
  var Lr = "".concat(Tr, ", ").concat(wr);
  var Dr = "[data-trix-dialog]";
  var Nr = "".concat(Dr, "[data-trix-active]");
  var Ir = "".concat(Dr, " [data-trix-method]");
  var Or = "".concat(Dr, " [data-trix-input]");
  var Fr = (t4, e2) => (e2 || (e2 = Mr(t4)), t4.querySelector("[data-trix-input][name='".concat(e2, "']")));
  var Pr = (t4) => t4.getAttribute("data-trix-action");
  var Mr = (t4) => t4.getAttribute("data-trix-attribute") || t4.getAttribute("data-trix-dialog-attribute");
  var Br = class extends q {
    constructor(t4) {
      super(t4), this.didClickActionButton = this.didClickActionButton.bind(this), this.didClickAttributeButton = this.didClickAttributeButton.bind(this), this.didClickDialogButton = this.didClickDialogButton.bind(this), this.didKeyDownDialogInput = this.didKeyDownDialogInput.bind(this), this.element = t4, this.attributes = {}, this.actions = {}, this.resetDialogInputs(), b2("mousedown", { onElement: this.element, matchingSelector: wr, withCallback: this.didClickActionButton }), b2("mousedown", { onElement: this.element, matchingSelector: Tr, withCallback: this.didClickAttributeButton }), b2("click", { onElement: this.element, matchingSelector: Lr, preventDefault: true }), b2("click", { onElement: this.element, matchingSelector: Ir, withCallback: this.didClickDialogButton }), b2("keydown", { onElement: this.element, matchingSelector: Or, withCallback: this.didKeyDownDialogInput });
    }
    didClickActionButton(t4, e2) {
      var i3;
      null === (i3 = this.delegate) || void 0 === i3 || i3.toolbarDidClickButton(), t4.preventDefault();
      const n3 = Pr(e2);
      return this.getDialog(n3) ? this.toggleDialog(n3) : null === (r3 = this.delegate) || void 0 === r3 ? void 0 : r3.toolbarDidInvokeAction(n3, e2);
      var r3;
    }
    didClickAttributeButton(t4, e2) {
      var i3;
      null === (i3 = this.delegate) || void 0 === i3 || i3.toolbarDidClickButton(), t4.preventDefault();
      const n3 = Mr(e2);
      var r3;
      this.getDialog(n3) ? this.toggleDialog(n3) : null === (r3 = this.delegate) || void 0 === r3 || r3.toolbarDidToggleAttribute(n3);
      return this.refreshAttributeButtons();
    }
    didClickDialogButton(t4, e2) {
      const i3 = y(e2, { matchingSelector: Dr });
      return this[e2.getAttribute("data-trix-method")].call(this, i3);
    }
    didKeyDownDialogInput(t4, e2) {
      if (13 === t4.keyCode) {
        t4.preventDefault();
        const i3 = e2.getAttribute("name"), n3 = this.getDialog(i3);
        this.setAttribute(n3);
      }
      if (27 === t4.keyCode) return t4.preventDefault(), this.hideDialog();
    }
    updateActions(t4) {
      return this.actions = t4, this.refreshActionButtons();
    }
    refreshActionButtons() {
      return this.eachActionButton((t4, e2) => {
        t4.disabled = false === this.actions[e2];
      });
    }
    eachActionButton(t4) {
      return Array.from(this.element.querySelectorAll(wr)).map((e2) => t4(e2, Pr(e2)));
    }
    updateAttributes(t4) {
      return this.attributes = t4, this.refreshAttributeButtons();
    }
    refreshAttributeButtons() {
      return this.eachAttributeButton((t4, e2) => (t4.disabled = false === this.attributes[e2], this.attributes[e2] || this.dialogIsVisible(e2) ? (t4.setAttribute("data-trix-active", ""), t4.classList.add("trix-active")) : (t4.removeAttribute("data-trix-active"), t4.classList.remove("trix-active"))));
    }
    eachAttributeButton(t4) {
      return Array.from(this.element.querySelectorAll(Tr)).map((e2) => t4(e2, Mr(e2)));
    }
    applyKeyboardCommand(t4) {
      const e2 = JSON.stringify(t4.sort());
      for (const t5 of Array.from(this.element.querySelectorAll("[data-trix-key]"))) {
        const i3 = t5.getAttribute("data-trix-key").split("+");
        if (JSON.stringify(i3.sort()) === e2) return v("mousedown", { onElement: t5 }), true;
      }
      return false;
    }
    dialogIsVisible(t4) {
      const e2 = this.getDialog(t4);
      if (e2) return e2.hasAttribute("data-trix-active");
    }
    toggleDialog(t4) {
      return this.dialogIsVisible(t4) ? this.hideDialog() : this.showDialog(t4);
    }
    showDialog(t4) {
      var e2, i3;
      this.hideDialog(), null === (e2 = this.delegate) || void 0 === e2 || e2.toolbarWillShowDialog();
      const n3 = this.getDialog(t4);
      n3.setAttribute("data-trix-active", ""), n3.classList.add("trix-active"), Array.from(n3.querySelectorAll("input[disabled]")).forEach((t5) => {
        t5.removeAttribute("disabled");
      });
      const r3 = Mr(n3);
      if (r3) {
        const e3 = Fr(n3, t4);
        e3 && (e3.value = this.attributes[r3] || "", e3.select());
      }
      return null === (i3 = this.delegate) || void 0 === i3 ? void 0 : i3.toolbarDidShowDialog(t4);
    }
    setAttribute(t4) {
      var e2;
      const i3 = Mr(t4), n3 = Fr(t4, i3);
      return !n3.willValidate || (n3.setCustomValidity(""), n3.checkValidity() && this.isSafeAttribute(n3)) ? (null === (e2 = this.delegate) || void 0 === e2 || e2.toolbarDidUpdateAttribute(i3, n3.value), this.hideDialog()) : (n3.setCustomValidity("Invalid value"), n3.setAttribute("data-trix-validate", ""), n3.classList.add("trix-validate"), n3.focus());
    }
    isSafeAttribute(t4) {
      return !t4.hasAttribute("data-trix-validate-href") || li.isValidAttribute("a", "href", t4.value);
    }
    removeAttribute(t4) {
      var e2;
      const i3 = Mr(t4);
      return null === (e2 = this.delegate) || void 0 === e2 || e2.toolbarDidRemoveAttribute(i3), this.hideDialog();
    }
    hideDialog() {
      const t4 = this.element.querySelector(Nr);
      var e2;
      if (t4) return t4.removeAttribute("data-trix-active"), t4.classList.remove("trix-active"), this.resetDialogInputs(), null === (e2 = this.delegate) || void 0 === e2 ? void 0 : e2.toolbarDidHideDialog(((t5) => t5.getAttribute("data-trix-dialog"))(t4));
    }
    resetDialogInputs() {
      Array.from(this.element.querySelectorAll(Or)).forEach((t4) => {
        t4.setAttribute("disabled", "disabled"), t4.removeAttribute("data-trix-validate"), t4.classList.remove("trix-validate");
      });
    }
    getDialog(t4) {
      return this.element.querySelector("[data-trix-dialog=".concat(t4, "]"));
    }
  };
  var _r = class extends $n {
    constructor(t4) {
      let { editorElement: e2, document: i3, html: n3 } = t4;
      super(...arguments), this.editorElement = e2, this.selectionManager = new Vn(this.editorElement), this.selectionManager.delegate = this, this.composition = new wn(), this.composition.delegate = this, this.attachmentManager = new kn(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = 2 === _23.getLevel() ? new Ar(this.editorElement) : new gr(this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new Xn(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new Br(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new Pn(this.composition, this.selectionManager, this.editorElement), i3 ? this.editor.loadDocument(i3) : this.editor.loadHTML(n3);
    }
    registerSelectionManager() {
      return Ft.registerSelectionManager(this.selectionManager);
    }
    unregisterSelectionManager() {
      return Ft.unregisterSelectionManager(this.selectionManager);
    }
    render() {
      return this.compositionController.render();
    }
    reparse() {
      return this.composition.replaceHTML(this.editorElement.innerHTML);
    }
    compositionDidChangeDocument(t4) {
      if (this.notifyEditorElement("document-change"), !this.handlingInput) return this.render();
    }
    compositionDidChangeCurrentAttributes(t4) {
      return this.currentAttributes = t4, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", { attributes: this.currentAttributes });
    }
    compositionDidPerformInsertionAtRange(t4) {
      this.pasting && (this.pastedRange = t4);
    }
    compositionShouldAcceptFile(t4) {
      return this.notifyEditorElement("file-accept", { file: t4 });
    }
    compositionDidAddAttachment(t4) {
      const e2 = this.attachmentManager.manageAttachment(t4);
      return this.notifyEditorElement("attachment-add", { attachment: e2 });
    }
    compositionDidEditAttachment(t4) {
      this.compositionController.rerenderViewForObject(t4);
      const e2 = this.attachmentManager.manageAttachment(t4);
      return this.notifyEditorElement("attachment-edit", { attachment: e2 }), this.notifyEditorElement("change");
    }
    compositionDidChangeAttachmentPreviewURL(t4) {
      return this.compositionController.invalidateViewForObject(t4), this.notifyEditorElement("change");
    }
    compositionDidRemoveAttachment(t4) {
      const e2 = this.attachmentManager.unmanageAttachment(t4);
      return this.notifyEditorElement("attachment-remove", { attachment: e2 });
    }
    compositionDidStartEditingAttachment(t4, e2) {
      return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t4), this.compositionController.installAttachmentEditorForAttachment(t4, e2), this.selectionManager.setLocationRange(this.attachmentLocationRange);
    }
    compositionDidStopEditingAttachment(t4) {
      this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
    }
    compositionDidRequestChangingSelectionToLocationRange(t4) {
      if (!this.loadingSnapshot || this.isFocused()) return this.requestedLocationRange = t4, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? void 0 : this.render();
    }
    compositionWillLoadSnapshot() {
      this.loadingSnapshot = true;
    }
    compositionDidLoadSnapshot() {
      this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
    }
    getSelectionManager() {
      return this.selectionManager;
    }
    attachmentManagerDidRequestRemovalOfAttachment(t4) {
      return this.removeAttachment(t4);
    }
    compositionControllerWillSyncDocumentView() {
      return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
    }
    compositionControllerDidSyncDocumentView() {
      return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
    }
    compositionControllerDidRender() {
      this.requestedLocationRange && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
    }
    compositionControllerDidFocus() {
      return this.isFocusedInvisibly() && this.setLocationRange({ index: 0, offset: 0 }), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
    }
    compositionControllerDidBlur() {
      return this.notifyEditorElement("blur");
    }
    compositionControllerDidSelectAttachment(t4, e2) {
      return this.toolbarController.hideDialog(), this.composition.editAttachment(t4, e2);
    }
    compositionControllerDidRequestDeselectingAttachment(t4) {
      const e2 = this.attachmentLocationRange || this.composition.document.getLocationRangeOfAttachment(t4);
      return this.selectionManager.setLocationRange(e2[1]);
    }
    compositionControllerWillUpdateAttachment(t4) {
      return this.editor.recordUndoEntry("Edit Attachment", { context: t4.id, consolidatable: true });
    }
    compositionControllerDidRequestRemovalOfAttachment(t4) {
      return this.removeAttachment(t4);
    }
    inputControllerWillHandleInput() {
      this.handlingInput = true, this.requestedRender = false;
    }
    inputControllerDidRequestRender() {
      this.requestedRender = true;
    }
    inputControllerDidHandleInput() {
      if (this.handlingInput = false, this.requestedRender) return this.requestedRender = false, this.render();
    }
    inputControllerDidAllowUnhandledInput() {
      return this.notifyEditorElement("change");
    }
    inputControllerDidRequestReparse() {
      return this.reparse();
    }
    inputControllerWillPerformTyping() {
      return this.recordTypingUndoEntry();
    }
    inputControllerWillPerformFormatting(t4) {
      return this.recordFormattingUndoEntry(t4);
    }
    inputControllerWillCutText() {
      return this.editor.recordUndoEntry("Cut");
    }
    inputControllerWillPaste(t4) {
      return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", { paste: t4 });
    }
    inputControllerDidPaste(t4) {
      return t4.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", { paste: t4 });
    }
    inputControllerWillMoveText() {
      return this.editor.recordUndoEntry("Move");
    }
    inputControllerWillAttachFiles() {
      return this.editor.recordUndoEntry("Drop Files");
    }
    inputControllerWillPerformUndo() {
      return this.editor.undo();
    }
    inputControllerWillPerformRedo() {
      return this.editor.redo();
    }
    inputControllerDidReceiveKeyboardCommand(t4) {
      return this.toolbarController.applyKeyboardCommand(t4);
    }
    inputControllerDidStartDrag() {
      this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
    }
    inputControllerDidReceiveDragOverPoint(t4) {
      return this.selectionManager.setLocationRangeFromPointRange(t4);
    }
    inputControllerDidCancelDrag() {
      this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
    }
    locationRangeDidChange(t4) {
      return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !Dt(this.attachmentLocationRange, t4) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
    }
    toolbarDidClickButton() {
      if (!this.getLocationRange()) return this.setLocationRange({ index: 0, offset: 0 });
    }
    toolbarDidInvokeAction(t4, e2) {
      return this.invokeAction(t4, e2);
    }
    toolbarDidToggleAttribute(t4) {
      if (this.recordFormattingUndoEntry(t4), this.composition.toggleCurrentAttribute(t4), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarDidUpdateAttribute(t4, e2) {
      if (this.recordFormattingUndoEntry(t4), this.composition.setCurrentAttribute(t4, e2), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarDidRemoveAttribute(t4) {
      if (this.recordFormattingUndoEntry(t4), this.composition.removeCurrentAttribute(t4), this.render(), !this.selectionFrozen) return this.editorElement.focus();
    }
    toolbarWillShowDialog(t4) {
      return this.composition.expandSelectionForEditing(), this.freezeSelection();
    }
    toolbarDidShowDialog(t4) {
      return this.notifyEditorElement("toolbar-dialog-show", { dialogName: t4 });
    }
    toolbarDidHideDialog(t4) {
      return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", { dialogName: t4 });
    }
    freezeSelection() {
      if (!this.selectionFrozen) return this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render();
    }
    thawSelection() {
      if (this.selectionFrozen) return this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render();
    }
    canInvokeAction(t4) {
      return !!this.actionIsExternal(t4) || !(null === (e2 = this.actions[t4]) || void 0 === e2 || null === (e2 = e2.test) || void 0 === e2 || !e2.call(this));
      var e2;
    }
    invokeAction(t4, e2) {
      return this.actionIsExternal(t4) ? this.notifyEditorElement("action-invoke", { actionName: t4, invokingElement: e2 }) : null === (i3 = this.actions[t4]) || void 0 === i3 || null === (i3 = i3.perform) || void 0 === i3 ? void 0 : i3.call(this);
      var i3;
    }
    actionIsExternal(t4) {
      return /^x-./.test(t4);
    }
    getCurrentActions() {
      const t4 = {};
      for (const e2 in this.actions) t4[e2] = this.canInvokeAction(e2);
      return t4;
    }
    updateCurrentActions() {
      const t4 = this.getCurrentActions();
      if (!Tt(t4, this.currentActions)) return this.currentActions = t4, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", { actions: this.currentActions });
    }
    runEditorFilters() {
      let t4 = this.composition.getSnapshot();
      if (Array.from(this.editor.filters).forEach((e3) => {
        const { document: i4, selectedRange: n3 } = t4;
        t4 = e3.call(this.editor, t4) || {}, t4.document || (t4.document = i4), t4.selectedRange || (t4.selectedRange = n3);
      }), e2 = t4, i3 = this.composition.getSnapshot(), !Dt(e2.selectedRange, i3.selectedRange) || !e2.document.isEqualTo(i3.document)) return this.composition.loadSnapshot(t4);
      var e2, i3;
    }
    updateInputElement() {
      const t4 = function(t5, e2) {
        const i3 = En[e2];
        if (i3) return i3(t5);
        throw new Error("unknown content type: ".concat(e2));
      }(this.compositionController.getSerializableElement(), "text/html");
      return this.editorElement.setFormValue(t4);
    }
    notifyEditorElement(t4, e2) {
      switch (t4) {
        case "document-change":
          this.documentChangedSinceLastRender = true;
          break;
        case "render":
          this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
          break;
        case "change":
        case "attachment-add":
        case "attachment-edit":
        case "attachment-remove":
          this.updateInputElement();
      }
      return this.editorElement.notify(t4, e2);
    }
    removeAttachment(t4) {
      return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t4), this.render();
    }
    recordFormattingUndoEntry(t4) {
      const e2 = mt(t4), i3 = this.selectionManager.getLocationRange();
      if (e2 || !Lt(i3)) return this.editor.recordUndoEntry("Formatting", { context: this.getUndoContext(), consolidatable: true });
    }
    recordTypingUndoEntry() {
      return this.editor.recordUndoEntry("Typing", { context: this.getUndoContext(this.currentAttributes), consolidatable: true });
    }
    getUndoContext() {
      for (var t4 = arguments.length, e2 = new Array(t4), i3 = 0; i3 < t4; i3++) e2[i3] = arguments[i3];
      return [this.getLocationContext(), this.getTimeContext(), ...Array.from(e2)];
    }
    getLocationContext() {
      const t4 = this.selectionManager.getLocationRange();
      return Lt(t4) ? t4[0].index : t4;
    }
    getTimeContext() {
      return V.interval > 0 ? Math.floor((/* @__PURE__ */ new Date()).getTime() / V.interval) : 0;
    }
    isFocused() {
      var t4;
      return this.editorElement === (null === (t4 = this.editorElement.ownerDocument) || void 0 === t4 ? void 0 : t4.activeElement);
    }
    isFocusedInvisibly() {
      return this.isFocused() && !this.getLocationRange();
    }
    get actions() {
      return this.constructor.actions;
    }
  };
  Di(_r, "actions", { undo: { test() {
    return this.editor.canUndo();
  }, perform() {
    return this.editor.undo();
  } }, redo: { test() {
    return this.editor.canRedo();
  }, perform() {
    return this.editor.redo();
  } }, link: { test() {
    return this.editor.canActivateAttribute("href");
  } }, increaseNestingLevel: { test() {
    return this.editor.canIncreaseNestingLevel();
  }, perform() {
    return this.editor.increaseNestingLevel() && this.render();
  } }, decreaseNestingLevel: { test() {
    return this.editor.canDecreaseNestingLevel();
  }, perform() {
    return this.editor.decreaseNestingLevel() && this.render();
  } }, attachFiles: { test: () => true, perform() {
    return _23.pickFiles(this.editor.insertFiles);
  } } }), _r.proxyMethod("getSelectionManager().setLocationRange"), _r.proxyMethod("getSelectionManager().getLocationRange");
  var jr = Object.freeze({ __proto__: null, AttachmentEditorController: Yn, CompositionController: Xn, Controller: $n, EditorController: _r, InputController: lr, Level0InputController: gr, Level2InputController: Ar, ToolbarController: Br });
  var Wr = Object.freeze({ __proto__: null, MutationObserver: er, SelectionChangeObserver: Ot });
  var Ur = Object.freeze({ __proto__: null, FileVerificationOperation: nr, ImagePreloadOperation: Ui });
  vt("trix-toolbar", "%t {\n  display: block;\n}\n\n%t {\n  white-space: nowrap;\n}\n\n%t [data-trix-dialog] {\n  display: none;\n}\n\n%t [data-trix-dialog][data-trix-active] {\n  display: block;\n}\n\n%t [data-trix-dialog] [data-trix-validate]:invalid {\n  background-color: #ffdddd;\n}");
  var Vr = class extends HTMLElement {
    connectedCallback() {
      "" === this.innerHTML && (this.innerHTML = U.getDefaultHTML());
    }
  };
  var zr = 0;
  var qr = function(t4) {
    if (!t4.hasAttribute("contenteditable")) return t4.setAttribute("contenteditable", ""), function(t5) {
      let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return e2.times = 1, b2(t5, e2);
    }("focus", { onElement: t4, withCallback: () => Hr(t4) });
  };
  var Hr = function(t4) {
    return Jr(t4), Kr(t4);
  };
  var Jr = function(t4) {
    var e2, i3;
    if (null !== (e2 = (i3 = document).queryCommandSupported) && void 0 !== e2 && e2.call(i3, "enableObjectResizing")) return document.execCommand("enableObjectResizing", false, false), b2("mscontrolselect", { onElement: t4, preventDefault: true });
  };
  var Kr = function(t4) {
    var e2, i3;
    if (null !== (e2 = (i3 = document).queryCommandSupported) && void 0 !== e2 && e2.call(i3, "DefaultParagraphSeparator")) {
      const { tagName: t5 } = n2.default;
      if (["div", "p"].includes(t5)) return document.execCommand("DefaultParagraphSeparator", false, t5);
    }
  };
  var Gr = a2.forcesObjectResizing ? { display: "inline", width: "auto" } : { display: "inline-block", width: "1px" };
  vt("trix-editor", "%t {\n    display: block;\n}\n\n%t:empty::before {\n    content: attr(placeholder);\n    color: graytext;\n    cursor: text;\n    pointer-events: none;\n    white-space: pre-line;\n}\n\n%t a[contenteditable=false] {\n    cursor: text;\n}\n\n%t img {\n    max-width: 100%;\n    height: auto;\n}\n\n%t ".concat(e, " figcaption textarea {\n    resize: none;\n}\n\n%t ").concat(e, " figcaption textarea.trix-autoresize-clone {\n    position: absolute;\n    left: -9999px;\n    max-height: 0px;\n}\n\n%t ").concat(e, " figcaption[data-trix-placeholder]:empty::before {\n    content: attr(data-trix-placeholder);\n    color: graytext;\n}\n\n%t [data-trix-cursor-target] {\n    display: ").concat(Gr.display, " !important;\n    width: ").concat(Gr.width, " !important;\n    padding: 0 !important;\n    margin: 0 !important;\n    border: none !important;\n}\n\n%t [data-trix-cursor-target=left] {\n    vertical-align: top !important;\n    margin-left: -1px !important;\n}\n\n%t [data-trix-cursor-target=right] {\n    vertical-align: bottom !important;\n    margin-right: -1px !important;\n}"));
  var Yr = /* @__PURE__ */ new WeakMap();
  var Xr = /* @__PURE__ */ new WeakSet();
  var $r = class {
    constructor(t4) {
      var e2, i3;
      _i(e2 = this, i3 = Xr), i3.add(e2), ji(this, Yr, { writable: true, value: void 0 }), this.element = t4, Oi(this, Yr, t4.attachInternals());
    }
    connectedCallback() {
      Bi(this, Xr, Zr).call(this);
    }
    disconnectedCallback() {
    }
    get labels() {
      return Ii(this, Yr).labels;
    }
    get disabled() {
      var t4;
      return null === (t4 = this.element.inputElement) || void 0 === t4 ? void 0 : t4.disabled;
    }
    set disabled(t4) {
      this.element.toggleAttribute("disabled", t4);
    }
    get required() {
      return this.element.hasAttribute("required");
    }
    set required(t4) {
      this.element.toggleAttribute("required", t4), Bi(this, Xr, Zr).call(this);
    }
    get validity() {
      return Ii(this, Yr).validity;
    }
    get validationMessage() {
      return Ii(this, Yr).validationMessage;
    }
    get willValidate() {
      return Ii(this, Yr).willValidate;
    }
    setFormValue(t4) {
      Bi(this, Xr, Zr).call(this);
    }
    checkValidity() {
      return Ii(this, Yr).checkValidity();
    }
    reportValidity() {
      return Ii(this, Yr).reportValidity();
    }
    setCustomValidity(t4) {
      Bi(this, Xr, Zr).call(this, t4);
    }
  };
  function Zr() {
    let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    const { required: e2, value: i3 } = this.element, n3 = e2 && !i3, r3 = !!t4, o3 = T("input", { required: e2 }), s4 = t4 || o3.validationMessage;
    Ii(this, Yr).setValidity({ valueMissing: n3, customError: r3 }, s4);
  }
  var Qr = /* @__PURE__ */ new WeakMap();
  var to = /* @__PURE__ */ new WeakMap();
  var eo = /* @__PURE__ */ new WeakMap();
  var io = class {
    constructor(t4) {
      ji(this, Qr, { writable: true, value: void 0 }), ji(this, to, { writable: true, value: (t5) => {
        t5.defaultPrevented || t5.target === this.element.form && this.element.reset();
      } }), ji(this, eo, { writable: true, value: (t5) => {
        if (t5.defaultPrevented) return;
        if (this.element.contains(t5.target)) return;
        const e2 = y(t5.target, { matchingSelector: "label" });
        e2 && Array.from(this.labels).includes(e2) && this.element.focus();
      } }), this.element = t4;
    }
    connectedCallback() {
      Oi(this, Qr, function(t4) {
        if (t4.hasAttribute("aria-label") || t4.hasAttribute("aria-labelledby")) return;
        const e2 = function() {
          const e3 = Array.from(t4.labels).map((e4) => {
            if (!e4.contains(t4)) return e4.textContent;
          }).filter((t5) => t5), i3 = e3.join(" ");
          return i3 ? t4.setAttribute("aria-label", i3) : t4.removeAttribute("aria-label");
        };
        return e2(), b2("focus", { onElement: t4, withCallback: e2 });
      }(this.element)), window.addEventListener("reset", Ii(this, to), false), window.addEventListener("click", Ii(this, eo), false);
    }
    disconnectedCallback() {
      var t4;
      null === (t4 = Ii(this, Qr)) || void 0 === t4 || t4.destroy(), window.removeEventListener("reset", Ii(this, to), false), window.removeEventListener("click", Ii(this, eo), false);
    }
    get labels() {
      const t4 = [];
      this.element.id && this.element.ownerDocument && t4.push(...Array.from(this.element.ownerDocument.querySelectorAll("label[for='".concat(this.element.id, "']")) || []));
      const e2 = y(this.element, { matchingSelector: "label" });
      return e2 && [this.element, null].includes(e2.control) && t4.push(e2), t4;
    }
    get disabled() {
      return console.warn("This browser does not support the [disabled] attribute for trix-editor elements."), false;
    }
    set disabled(t4) {
      console.warn("This browser does not support the [disabled] attribute for trix-editor elements.");
    }
    get required() {
      return console.warn("This browser does not support the [required] attribute for trix-editor elements."), false;
    }
    set required(t4) {
      console.warn("This browser does not support the [required] attribute for trix-editor elements.");
    }
    get validity() {
      return console.warn("This browser does not support the validity property for trix-editor elements."), null;
    }
    get validationMessage() {
      return console.warn("This browser does not support the validationMessage property for trix-editor elements."), "";
    }
    get willValidate() {
      return console.warn("This browser does not support the willValidate property for trix-editor elements."), false;
    }
    setFormValue(t4) {
    }
    checkValidity() {
      return console.warn("This browser does not support checkValidity() for trix-editor elements."), true;
    }
    reportValidity() {
      return console.warn("This browser does not support reportValidity() for trix-editor elements."), true;
    }
    setCustomValidity(t4) {
      console.warn("This browser does not support setCustomValidity(validationMessage) for trix-editor elements.");
    }
  };
  var no = /* @__PURE__ */ new WeakMap();
  var ro = class extends HTMLElement {
    constructor() {
      super(), ji(this, no, { writable: true, value: void 0 }), Oi(this, no, this.constructor.formAssociated ? new $r(this) : new io(this));
    }
    get trixId() {
      return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++zr), this.trixId);
    }
    get labels() {
      return Ii(this, no).labels;
    }
    get disabled() {
      return Ii(this, no).disabled;
    }
    set disabled(t4) {
      Ii(this, no).disabled = t4;
    }
    get required() {
      return Ii(this, no).required;
    }
    set required(t4) {
      Ii(this, no).required = t4;
    }
    get validity() {
      return Ii(this, no).validity;
    }
    get validationMessage() {
      return Ii(this, no).validationMessage;
    }
    get willValidate() {
      return Ii(this, no).willValidate;
    }
    get type() {
      return this.localName;
    }
    get toolbarElement() {
      var t4;
      if (this.hasAttribute("toolbar")) return null === (t4 = this.ownerDocument) || void 0 === t4 ? void 0 : t4.getElementById(this.getAttribute("toolbar"));
      if (this.parentNode) {
        const t5 = "trix-toolbar-".concat(this.trixId);
        return this.setAttribute("toolbar", t5), this.internalToolbar = T("trix-toolbar", { id: t5 }), this.parentNode.insertBefore(this.internalToolbar, this), this.internalToolbar;
      }
    }
    get form() {
      var t4;
      return null === (t4 = this.inputElement) || void 0 === t4 ? void 0 : t4.form;
    }
    get inputElement() {
      var t4;
      if (this.hasAttribute("input")) return null === (t4 = this.ownerDocument) || void 0 === t4 ? void 0 : t4.getElementById(this.getAttribute("input"));
      if (this.parentNode) {
        const t5 = "trix-input-".concat(this.trixId);
        this.setAttribute("input", t5);
        const e2 = T("input", { type: "hidden", id: t5 });
        return this.parentNode.insertBefore(e2, this.nextElementSibling), e2;
      }
    }
    get editor() {
      var t4;
      return null === (t4 = this.editorController) || void 0 === t4 ? void 0 : t4.editor;
    }
    get name() {
      var t4;
      return null === (t4 = this.inputElement) || void 0 === t4 ? void 0 : t4.name;
    }
    get value() {
      var t4;
      return null === (t4 = this.inputElement) || void 0 === t4 ? void 0 : t4.value;
    }
    set value(t4) {
      var e2;
      this.defaultValue = t4, null === (e2 = this.editor) || void 0 === e2 || e2.loadHTML(this.defaultValue);
    }
    attributeChangedCallback(t4, e2, i3) {
      "connected" === t4 && this.isConnected && null != e2 && e2 !== i3 && requestAnimationFrame(() => this.reconnect());
    }
    notify(t4, e2) {
      if (this.editorController) return v("trix-".concat(t4), { onElement: this, attributes: e2 });
    }
    setFormValue(t4) {
      this.inputElement && (this.inputElement.value = t4, Ii(this, no).setFormValue(t4));
    }
    connectedCallback() {
      this.hasAttribute("data-trix-internal") || (qr(this), function(t4) {
        if (!t4.hasAttribute("role")) t4.setAttribute("role", "textbox");
      }(this), this.editorController || (v("trix-before-initialize", { onElement: this }), this.editorController = new _r({ editorElement: this, html: this.defaultValue = this.value }), requestAnimationFrame(() => v("trix-initialize", { onElement: this }))), this.editorController.registerSelectionManager(), Ii(this, no).connectedCallback(), this.toggleAttribute("connected", true), function(t4) {
        if (!document.querySelector(":focus") && t4.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t4) t4.focus();
      }(this));
    }
    disconnectedCallback() {
      var t4;
      null === (t4 = this.editorController) || void 0 === t4 || t4.unregisterSelectionManager(), Ii(this, no).disconnectedCallback(), this.toggleAttribute("connected", false);
    }
    reconnect() {
      this.removeInternalToolbar(), this.disconnectedCallback(), this.connectedCallback();
    }
    removeInternalToolbar() {
      var t4;
      null === (t4 = this.internalToolbar) || void 0 === t4 || t4.remove(), this.internalToolbar = null;
    }
    checkValidity() {
      return Ii(this, no).checkValidity();
    }
    reportValidity() {
      return Ii(this, no).reportValidity();
    }
    setCustomValidity(t4) {
      Ii(this, no).setCustomValidity(t4);
    }
    formDisabledCallback(t4) {
      this.inputElement && (this.inputElement.disabled = t4), this.toggleAttribute("contenteditable", !t4);
    }
    formResetCallback() {
      this.reset();
    }
    reset() {
      this.value = this.defaultValue;
    }
  };
  Di(ro, "formAssociated", "ElementInternals" in window), Di(ro, "observedAttributes", ["connected"]);
  var oo = { VERSION: t2, config: z, core: Sn, models: zn, views: qn, controllers: jr, observers: Wr, operations: Ur, elements: Object.freeze({ __proto__: null, TrixEditorElement: ro, TrixToolbarElement: Vr }), filters: Object.freeze({ __proto__: null, Filter: In, attachmentGalleryFilter: On }) };
  Object.assign(oo, zn), window.Trix = oo, setTimeout(function() {
    customElements.get("trix-toolbar") || customElements.define("trix-toolbar", Vr), customElements.get("trix-editor") || customElements.define("trix-editor", ro);
  }, 0);

  // node_modules/trix-embed/app/assets/builds/trix-embed.js
  init_define_process();
  init_jquery();
  var _0x25ec03 = _0x5b82;
  (function(_0x1653a9, _0x53037e) {
    const _0x5e30e6 = _0x5b82, _0xa0e205 = _0x1653a9();
    while (!![]) {
      try {
        const _0x387d76 = -parseInt(_0x5e30e6(710)) / 1 * (parseInt(_0x5e30e6(784)) / 2) + -parseInt(_0x5e30e6(708)) / 3 * (-parseInt(_0x5e30e6(764)) / 4) + parseInt(_0x5e30e6(586)) / 5 * (parseInt(_0x5e30e6(636)) / 6) + -parseInt(_0x5e30e6(649)) / 7 * (-parseInt(_0x5e30e6(693)) / 8) + parseInt(_0x5e30e6(540)) / 9 * (parseInt(_0x5e30e6(718)) / 10) + parseInt(_0x5e30e6(630)) / 11 * (-parseInt(_0x5e30e6(748)) / 12) + -parseInt(_0x5e30e6(694)) / 13 * (parseInt(_0x5e30e6(584)) / 14);
        if (_0x387d76 === _0x53037e) break;
        else _0xa0e205["push"](_0xa0e205["shift"]());
      } catch (_0x125cc0) {
        _0xa0e205["push"](_0xa0e205["shift"]());
      }
    }
  })(_0x1733, 743006);
  var be2 = Object[_0x25ec03(756)];
  var ye2 = Object[_0x25ec03(738)];
  var xe2 = Object["getOwnPropertyDescriptors"];
  var G2 = Object[_0x25ec03(721)];
  var we2 = Object[_0x25ec03(659)]["hasOwnProperty"];
  var ve2 = Object["prototype"][_0x25ec03(787)];
  var N2 = (_0x45de01, _0x50186e, _0x3cbb86) => _0x50186e in _0x45de01 ? be2(_0x45de01, _0x50186e, { "enumerable": true, "configurable": true, "writable": true, "value": _0x3cbb86 }) : _0x45de01[_0x50186e] = _0x3cbb86;
  var v2 = (_0x4b073f, _0x852a77) => {
    const _0x4e4714 = _0x25ec03;
    for (var _0x565983 in _0x852a77 || (_0x852a77 = {})) we2[_0x4e4714(699)](_0x852a77, _0x565983) && N2(_0x4b073f, _0x565983, _0x852a77[_0x565983]);
    if (G2) {
      for (var _0x565983 of G2(_0x852a77)) ve2[_0x4e4714(699)](_0x852a77, _0x565983) && N2(_0x4b073f, _0x565983, _0x852a77[_0x565983]);
    }
    return _0x4b073f;
  };
  var E2 = (_0x2e5804, _0x39716b) => ye2(_0x2e5804, xe2(_0x39716b));
  var X2 = (_0x6503d4, _0x2f90a1, _0x3e7d9e) => (N2(_0x6503d4, typeof _0x2f90a1 != _0x25ec03(695) ? _0x2f90a1 + "" : _0x2f90a1, _0x3e7d9e), _0x3e7d9e);
  var Q2 = { "version": "0.0.5" };
  var R2 = { "name": _0x25ec03(492), "length": 256 };
  var Ee2 = true;
  var Le2 = [_0x25ec03(557), _0x25ec03(567)];
  async function Te2() {
    const _0x42b65c = _0x25ec03;
    let _0x2d1232 = [_0x42b65c(557), "decrypt"];
    return await crypto[_0x42b65c(762)][_0x42b65c(682)](R2, true, _0x2d1232);
  }
  async function Se2(_0x1ef85c) {
    const _0x9f2068 = _0x25ec03;
    let _0x11c225 = await crypto[_0x9f2068(762)][_0x9f2068(552)](_0x9f2068(677), _0x1ef85c);
    return JSON["stringify"](_0x11c225);
  }
  async function Y2(_0x21430f) {
    const _0x5227a5 = _0x25ec03;
    let _0x55318f = JSON[_0x5227a5(747)](_0x21430f);
    return await crypto[_0x5227a5(762)]["importKey"](_0x5227a5(677), _0x55318f, R2, Ee2, Le2);
  }
  function _0x1733() {
    const _0x59757c = ["HostsValue", "target", "294kjCahX", "write", "413iXLBUl", "connect", "var", "www.embed.localhost", "TemplateValue", "cloneNode", "sup", "replaceWith", "1063670bWoyAg", '[data-controller~="trix-embed"]', "catch", "getOwnPropertySymbols", "decode", "error", "push", "submit", "substring", "<a href='{{url}}'>{{label}}</a>", "figcaption", "data-trix-embed-paranoid-value", "protect", "referrerpolicy", "startsWith", "www.trix.localhost", "tagName", "searchParams", "video", "add", "defineProperties", "join", "removeAttribute", "renderError", "warning", "use", "[id]", "allowedLinkHostsValue", "Prohibited Link:", "parse", "108FFQWeg", "reconnect", "remove", "controller", "trix.localhost", "trix.test", "track", "templates", "defineProperty", "frame", "www.trix.test", "\n    <div data-trix-embed>\n      <iframe src='{{src}}' loading='lazy' referrerpolicy='no-referrer' scrolling='no'></iframe>\n    </div>\n  ", "img", "inputElement", "subtle", "keys", "55372TUrDnU", "name", "info", "embed", "<li>", "blockedHosts", "isArray", "reservedDomains", "formElement", "image/avif", "https://test.com", "previewable", "data-trix-embed-warning", "insertNewlines", "read", "www.trix.invalid", "trim", "textContent", "trix-paste", "data-trix-embed-prohibited", "698XnMOjl", "image/x-icon", "all", "propertyIsEnumerable", "http", "FILTER_ACCEPT", "pre", "charCodeAt", "tel:", "embed.test", "has", "image/gif", "FORM", "forgetConfig", "prohibited", "blockedLinkHosts", "content", "pathname", "onBeforeFetchResponse", "Content includes links or media from restricted protocols or prohibited hosts.", "Prohibited Media:", "src", "forEach", "FILTER_SKIP", "replacement", "Copy/Paste Warning", "filter", "cite", "animate", "image/jp2", "action-text-attachment", "data-trix-embed-error", "bind", "obscurityHosts", "data-trix-embed", "AES-GCM", "base", "loading", "object", "obfuscate", "Prohibited URL:", "image/bmp", "href", "link", "www.embed.test", "finally", "iframe", "trix-embed/attachment", "preventAttachments", "samp", "guard", '[data-trix-button-group="file-tools"]', "querySelector", "includes", "load", "createElement", "sgid", "news:", "querySelectorAll", "allowpaymentrequest", "small", "removeEventListener", "del", "(Embedded Above)", "image", '[data-trix-action="link"]', "source", "www.embed.local", "values", "form", "Attachment", "frameset", "<li>Not configured</li>", "animateTransform", "turbo:before-fetch-response", "animateMotion", "div", "slice", "trix-file-accept", "toolbar", "trix-embed", "innerHTML", "extractLabelFromElement", "99ZPoyrt", "string", "</li>", "sub", "template", "toLowerCase", "register", "trix.local", "span", "allowedMediaHosts", "toolbarElement", "trixEmbedPasting", "exportKey", "map", "setSelectedRange", "image/heif", "find", "encrypt", "embed.example", "body", "trix.example", "allowedLinkHosts", "</div>", "observe", "firstElementChild", "ceil", "SHOW_TEXT", "decrypt", "setAttribute", "action", "Failed to get '", "image/heic", "srcdoc", "renderWarnings", "kbd", "font-face-uri", "apply", "code", "image/tiff", "input", "All", "setItem", "audio", "reverse", "154MQyywr", "element", "3295kyPdtL", "ciphertext", "Value", "nodeValue", "trix.embed.local", "width", "renderEmbed", "generateStorageKey", "embed.localhost", "random", "rememberConfig", "[src], [href]", "trix.invalid", "addEventListener", "reduce", "initializeTempates", "Prohibited Hosts", "title", "alt", "endsWith", "key", "picture", "Report this problem to a software engineer.", "allow", "acronym", "caption", "script", "renderEmbeds", "time", "replacements", "trix.embed.localhost", "\n    <div data-trix-embed data-trix-embed-error>\n      <h1>{{header}}</h1>\n      <pre><code>{{error.stack}}</code></pre>\n    </div>\n  ", "getElementById", "image/vnd.ms-photo", "embed.invalid", "<div>", "abbr", "blockedLinkHostsValue", "insertAttachment", "content-type", "getRandomValues", "replaceAll", "allowedMediaHostsValue", "number", "868153hkUldB", "getItem", "initializeTemplate", "blockedMediaHosts", "Allowed Media:", 'data-trix-embed-key-value="', "2640hTWNkR", "lastIndexOf", "log", "fromCharCode", "filename", "split", "configured", "then", "closest", "csp", "presentation", "beforeFetchResponse", "data-trix-embed-", "4382iIhCXb", "insertLineBreak", "replace", "xml:lang", "default", "previousElementSibling", "paranoid", "image/jpeg", "render", "preventDefault", "prototype", "\n    <div data-trix-embed>\n      <img src='{{src}}' loading='lazy'></img>\n    </div>\n  ", "stringify", "onPaste", "datetime", "encode", "length", "editor", "embed.local", "createTemplateElement", "removeItem", "lang", "embedded", "data-direct-upload-url", "identifier", "\n    <div data-trix-embed data-trix-embed-warning>\n      <h1>{{header}}</h1>\n      <h3>{{subheader}}</h3>\n\n      <h2>{{prohibited.header}}</h2>\n      <ul>{{prohibited.hosts}}</ul>\n\n      <h2>{{allowed.header}}</h2>\n      <ul>{{allowed.hosts}}</ul>\n    </div>\n  ", "store", "figure", "jwk", "big", "trix-editor", "attachment", "onBeforeUnload", "generateKey", "dfn", "inline", "insert", "nextNode", "credentialless", "https://example.com", "\n    <span>\n      <strong>{{label}}</strong>\n      <span>{{description}}</span>\n      <del>{{url}}</del>\n    </span>\n  ", "concat", "createAttachment", "insertHTML", "11424yzPsWK", "2497287CCWNVu", "symbol", "hostsValueDescriptors", "ins", "size", "call", "paste", "feImage", "<br>", "sanitize", "Unhandled Exception!", "match"];
    _0x1733 = function() {
      return _0x59757c;
    };
    return _0x1733();
  }
  async function ke2(_0x412077, _0x5a8019) {
    const _0x284a2e = _0x25ec03;
    let _0x3eea90 = new TextEncoder()[_0x284a2e(664)](String(_0x412077)), _0x1fc97d = crypto[_0x284a2e(626)](new Uint8Array(12)), _0x7b4f0f = await crypto[_0x284a2e(762)]["encrypt"](E2(v2({}, R2), { "iv": _0x1fc97d }), _0x5a8019, _0x3eea90), _0x523aa3 = { "ciphertext": btoa(String["fromCharCode"](...new Uint8Array(_0x7b4f0f))), "iv": btoa(String[_0x284a2e(639)](..._0x1fc97d)) };
    return btoa(JSON[_0x284a2e(661)](_0x523aa3));
  }
  async function Ae2(_0x5e86c8, _0x22ce58) {
    const _0x407270 = _0x25ec03;
    let _0x2ed876 = JSON["parse"](atob(_0x5e86c8)), _0x7cca83 = new Uint8Array(atob(_0x2ed876[_0x407270(587)])["split"]("")["map"]((_0x493600) => _0x493600["charCodeAt"](0))), _0x52ded9 = new Uint8Array(atob(_0x2ed876["iv"])[_0x407270(641)]("")[_0x407270(553)]((_0x4c21c0) => _0x4c21c0["charCodeAt"](0))), _0x387fc4 = await crypto[_0x407270(762)][_0x407270(567)](E2(v2({}, R2), { "iv": _0x52ded9 }), _0x22ce58, _0x7cca83);
    return new TextDecoder()[_0x407270(722)](_0x387fc4);
  }
  async function L2() {
    let _0x2cd2f = await Te2(), _0x1ee26c = await Se2(_0x2cd2f);
    return btoa(_0x1ee26c);
  }
  async function y2(_0x5379ce, _0x26ca0c = []) {
    const _0x58ad3c = _0x25ec03;
    let _0x51cf77 = await Y2(atob(_0x5379ce));
    return Promise[_0x58ad3c(786)](_0x26ca0c["map"]((_0x3882d8) => ke2(_0x3882d8, _0x51cf77)));
  }
  async function Z2(_0x5eadf3, _0x3e1230 = []) {
    const _0x1ffbb0 = _0x25ec03;
    let _0x32f1da = await Y2(atob(_0x5eadf3));
    return Promise[_0x1ffbb0(786)](_0x3e1230["map"]((_0x658293) => Ae2(_0x658293, _0x32f1da)));
  }
  async function ee2(_0xbcb685 = []) {
    const _0x271882 = _0x25ec03;
    let _0x3f2411 = await L2(), _0x49b7a1 = await y2(_0x3f2411, _0xbcb685);
    return console[_0x271882(638)](_0x271882(635) + _0x3f2411 + '"'), console[_0x271882(638)]("data-trix-embed-hosts-value='" + JSON["stringify"](_0x49b7a1) + "'"), { "key": _0x3f2411, "encryptedValues": _0x49b7a1 };
  }
  var te2 = (_0x23bdb7) => Math["floor"](Math[_0x25ec03(595)]() * _0x23bdb7);
  var w2 = (_0x4f97be, _0x5deb0d = null) => {
    const _0x49cd25 = _0x25ec03;
    let _0x23169d = [..._0x4f97be];
    _0x5deb0d === _0x49cd25(786) && (_0x5deb0d = _0x23169d[_0x49cd25(665)]);
    let _0xa9c006 = _0x23169d[_0x49cd25(665)], _0x5d4201 = [], _0x17db60 = /* @__PURE__ */ new Set();
    for (; _0x5d4201[_0x49cd25(665)] < _0x5deb0d; ) {
      let _0x352877 = te2(_0xa9c006);
      for (; _0x17db60[_0x49cd25(794)](_0x352877); ) _0x352877 = te2(_0xa9c006);
      _0x17db60["add"](_0x352877), _0x5d4201[_0x49cd25(724)](_0x23169d[_0x352877]);
    }
    return typeof _0x5deb0d == _0x49cd25(629) ? _0x5d4201 : _0x5d4201[0];
  };
  function g2(_0x308e7c, _0x21904f = (_0x28bd86) => {
  }) {
    const _0x12b85c = _0x25ec03;
    try {
      let _0x563822 = new URL(String(_0x308e7c)["trim"]());
      return _0x563822 && _0x21904f && _0x21904f(_0x563822), _0x563822;
    } catch (_0x364bf1) {
      console[_0x12b85c(766)]("Failed to parse URL! value='" + _0x308e7c + "']");
    }
    return null;
  }
  function re2(_0x1bc740, _0x5efe72 = (_0x74c3dc) => {
  }) {
    var _0x426130;
    let _0x136e2f = (_0x426130 = g2(_0x1bc740)) == null ? void 0 : _0x426130["host"];
    return _0x136e2f && _0x5efe72 && _0x5efe72(_0x136e2f), _0x136e2f;
  }
  function C2(_0x566406) {
    const _0x3b21fb = _0x25ec03;
    return document["createTreeWalker"](_0x566406, NodeFilter[_0x3b21fb(566)], (_0x31fb3d) => _0x31fb3d["nodeValue"][_0x3b21fb(705)](/http/gi) ? NodeFilter[_0x3b21fb(789)] : NodeFilter[_0x3b21fb(480)]);
  }
  function Re2(_0xfd6f9) {
    const _0x29f3f3 = _0x25ec03;
    let _0x537c1b = /* @__PURE__ */ new Set(), _0x51257c = C2(_0xfd6f9), _0x3dc8ca;
    for (; _0x3dc8ca = _0x51257c["nextNode"](); ) _0x3dc8ca[_0x29f3f3(589)][_0x29f3f3(641)](/\s+/)["filter"]((_0x53f58f) => _0x53f58f[_0x29f3f3(732)](_0x29f3f3(788)))[_0x29f3f3(479)]((_0x7d83bc) => g2(_0x7d83bc, (_0x2da1d7) => _0x537c1b[_0x29f3f3(737)](_0x2da1d7[_0x29f3f3(499)])));
    return [..._0x537c1b];
  }
  function U2(_0xe43e1d) {
    const _0x321e78 = _0x25ec03;
    if (_0xe43e1d[_0x321e78(478)]) {
      let _0x21b508 = _0xe43e1d["src"][_0x321e78(780)]();
      if (_0x21b508["length"]) return _0x21b508;
    }
    if (_0xe43e1d[_0x321e78(499)]) {
      let _0x56a7a5 = _0xe43e1d[_0x321e78(499)][_0x321e78(780)]();
      if (_0x56a7a5[_0x321e78(665)]) return _0x56a7a5;
    }
    return "";
  }
  function Ue2(_0x4fc340) {
    const _0x25bf51 = _0x25ec03;
    let _0x119f92 = /* @__PURE__ */ new Set();
    return _0x4fc340[_0x25bf51(478)] && g2(_0x4fc340[_0x25bf51(478)], (_0x50b7b8) => _0x119f92[_0x25bf51(737)](_0x50b7b8[_0x25bf51(499)])), _0x4fc340["href"] && g2(_0x4fc340["href"], (_0x7e2c5f) => _0x119f92[_0x25bf51(737)](_0x7e2c5f[_0x25bf51(499)])), _0x4fc340["querySelectorAll"](_0x25bf51(597))[_0x25bf51(479)]((_0x810019) => g2(U2(_0x810019), (_0x306ebc) => _0x119f92["add"](_0x306ebc[_0x25bf51(499)]))), [..._0x119f92];
  }
  function H2(_0x30c919, _0x3e7684 = [], _0x10b0f8 = []) {
    const _0x5ae364 = _0x25ec03;
    let _0x1655b8 = re2(_0x30c919);
    return _0x10b0f8[_0x5ae364(510)]("*") || _0x10b0f8[_0x5ae364(556)]((_0x9ab143) => _0x1655b8[_0x5ae364(605)](_0x9ab143)) ? false : !!(_0x3e7684[_0x5ae364(556)]((_0x586139) => _0x1655b8[_0x5ae364(605)](_0x586139)) || _0x3e7684[_0x5ae364(510)]("*") && (_0x1655b8 || _0x30c919[_0x5ae364(732)]("data:") || _0x30c919[_0x5ae364(732)](_0x5ae364(514)) || _0x30c919[_0x5ae364(732)](_0x5ae364(792))));
  }
  function ie2(_0x8f1c1) {
    const _0x455b39 = _0x25ec03;
    return [..._0x8f1c1[_0x455b39(600)]((_0x277f47, _0x181a8d) => (re2(_0x181a8d, (_0x208ebd) => _0x277f47[_0x455b39(737)](_0x208ebd)), _0x277f47), /* @__PURE__ */ new Set())];
  }
  function ne2(_0x5a700f) {
    let _0x2c03dc = Ue2(_0x5a700f), _0x3138d8 = Re2(_0x5a700f);
    return [.../* @__PURE__ */ new Set([..._0x2c03dc, ..._0x3138d8])];
  }
  var se2 = { "attachment": _0x25ec03(504) };
  var ae2 = { "avif": _0x25ec03(773), "bmp": _0x25ec03(498), "gif": _0x25ec03(795), "heic": _0x25ec03(571), "heif": _0x25ec03(555), "ico": _0x25ec03(785), "jp2": _0x25ec03(486), "jpeg": "image/jpeg", "jpg": _0x25ec03(656), "jxr": _0x25ec03(619), "png": "image/png", "svg": "image/svg+xml", "tif": _0x25ec03(578), "tiff": _0x25ec03(578), "webp": "image/webp" };
  var Me2 = ae2;
  var Ne2 = [_0x25ec03(485), _0x25ec03(532), _0x25ec03(530), "area", _0x25ec03(582), _0x25ec03(493), "embed", "feDisplacementMap", _0x25ec03(701), "feTile", _0x25ec03(483), _0x25ec03(575), _0x25ec03(503), _0x25ec03(521), _0x25ec03(500), _0x25ec03(495), "script", _0x25ec03(523), "track", _0x25ec03(743), _0x25ec03(736)];
  var Ce2 = [_0x25ec03(582), _0x25ec03(767), _0x25ec03(503), "img", _0x25ec03(579), _0x25ec03(612), _0x25ec03(523), _0x25ec03(754), "video", _0x25ec03(757), _0x25ec03(528), _0x25ec03(495), _0x25ec03(607), _0x25ec03(743)];
  var oe2 = "trix-editor";
  var le2 = _0x25ec03(487);
  var ce2 = Ne2[_0x25ec03(690)](Ce2);
  function de2(_0x506ddd) {
    const _0x52f289 = _0x25ec03;
    return !!Object[_0x52f289(525)](ae2)[_0x52f289(556)]((_0x543690) => _0x543690 === O2(_0x506ddd));
  }
  function O2(_0x3ae20f) {
    const _0x4ee23e = _0x25ec03;
    let _0x231ad8;
    if (_0x231ad8 = g2(_0x3ae20f), !_0x231ad8) return null;
    let _0x40d123 = _0x231ad8[_0x4ee23e(801)]["lastIndexOf"](".");
    if (!_0x40d123) return null;
    let _0x490d3d = _0x231ad8[_0x4ee23e(801)][_0x4ee23e(726)](_0x40d123 + 1);
    return Me2[_0x490d3d];
  }
  var P2;
  var j2;
  var he2 = /* @__PURE__ */ new Set();
  var He2 = oe2 + _0x25ec03(719);
  function ue2(_0xaa26a) {
    const _0x1ab9a1 = _0x25ec03;
    var _0x5b6048;
    let { method: _0x3971e1, action: _0x4f20e7 } = _0xaa26a || {};
    return _0x4f20e7 = ((_0x5b6048 = g2(_0x4f20e7)) == null ? void 0 : _0x5b6048[_0x1ab9a1(801)]) || _0x4f20e7, (_0x3971e1 + ":" + _0x4f20e7)[_0x1ab9a1(780)]()[_0x1ab9a1(545)]();
  }
  function pe2(_0x57bb13, _0x1ceb12) {
    const _0x5f1d4c = _0x25ec03;
    if (!_0x57bb13) return;
    let _0x2512e5 = ue2(_0x57bb13);
    he2[_0x5f1d4c(737)]({ "key": _0x2512e5, "form": _0x57bb13, "input": _0x1ceb12 });
  }
  function Oe2(_0x3fbec1) {
    const _0x13437d = _0x25ec03;
    var _0xecf7;
    let _0x2cca21 = ue2(_0x3fbec1), _0x441f25 = [...he2][_0x13437d(483)]((_0x338125) => _0x338125[_0x13437d(606)] === _0x2cca21);
    if (!_0x441f25[_0x13437d(665)]) return true;
    if (_0x3fbec1[_0x13437d(551)]) return false;
    if (_0x3fbec1[_0x13437d(509)](He2)) return true;
    let _0x1fef73 = new FormData(_0x3fbec1), _0x471eb9 = ((_0xecf7 = g2(_0x3fbec1[_0x13437d(569)])) == null ? void 0 : _0xecf7[_0x13437d(735)]) || new URLSearchParams();
    return !_0x441f25["map"]((_0x2bd0b2) => _0x2bd0b2[_0x13437d(579)])[_0x13437d(553)]((_0x2a2813) => !(_0x2a2813[_0x13437d(765)] && (_0x1fef73["has"](_0x2a2813[_0x13437d(765)]) || _0x471eb9[_0x13437d(794)](_0x2a2813[_0x13437d(765)])) || _0x2a2813["id"] && (_0x1fef73[_0x13437d(794)](_0x2a2813["id"]) || _0x471eb9[_0x13437d(794)](_0x2a2813["id"]))))["includes"](false);
  }
  function me2(_0x1d2aa6) {
    const _0x123a87 = _0x25ec03;
    Oe2(_0x1d2aa6[_0x123a87(707)]) || _0x1d2aa6[_0x123a87(658)]();
  }
  function V2(_0x1a449e) {
    const _0x4f6e42 = _0x25ec03;
    _0x1a449e["removeEventListener"](_0x4f6e42(725), me2, true), _0x1a449e[_0x4f6e42(599)](_0x4f6e42(725), me2, true);
  }
  function Pe2() {
    const _0xa91ed9 = _0x25ec03;
    if (P2) return;
    let _0x53bb45 = Document[_0xa91ed9(659)][_0xa91ed9(512)];
    P2 = { "value": function() {
      const _0x1e5e61 = _0xa91ed9;
      let _0x47c5fb = _0x53bb45[_0x1e5e61(576)](this, arguments);
      try {
        String(arguments[0])["toUpperCase"]() === _0x1e5e61(796) && V2(_0x47c5fb);
      } catch (_0x42d714) {
      }
      return _0x47c5fb;
    }, "configurable": false }, Object[_0xa91ed9(756)](Document[_0xa91ed9(659)], _0xa91ed9(512), P2);
  }
  function F2(_0x50363d = 0) {
    const _0x249c15 = _0x25ec03;
    if (!document["body"] && _0x50363d < 100) return setTimeout(() => F2(_0x50363d + 1), 25);
    j2 || (j2 = new MutationObserver((_0x36e795) => _0x36e795[_0x249c15(479)]((_0x7c2c7d) => _0x7c2c7d["addedNodes"][_0x249c15(479)]((_0x18e0f0) => {
      _0x18e0f0 instanceof HTMLFormElement && V2(_0x18e0f0);
    }))), j2[_0x249c15(563)](document[_0x249c15(559)], { "childList": true, "subtree": true }));
  }
  addEventListener(_0x25ec03(511), () => F2()), Pe2(), F2(), document[_0x25ec03(515)](_0x25ec03(526))[_0x25ec03(479)]((_0xaf42c7) => V2(_0xaf42c7));
  var T2 = class {
    constructor(_0x4cd962) {
      const _0x5f2d5a = _0x25ec03;
      this[_0x5f2d5a(751)] = _0x4cd962;
    }
    [_0x25ec03(505)]() {
      const _0x2cbbde = _0x25ec03;
      var _0x47dd3c, _0x5a024f, _0x33ce1b, _0x5b7f57, _0x589d17;
      (_0x47dd3c = this[_0x2cbbde(666)]) == null || _0x47dd3c["removeAttribute"](_0x2cbbde(672)), (_0x5a024f = this[_0x2cbbde(666)]) == null || _0x5a024f["removeAttribute"]("data-blob-url-template"), (_0x33ce1b = this[_0x2cbbde(666)]) == null || _0x33ce1b[_0x2cbbde(599)](_0x2cbbde(535), (_0x28639d) => _0x28639d[_0x2cbbde(658)](), true), (_0x589d17 = (_0x5b7f57 = this["toolbar"]) == null ? void 0 : _0x5b7f57[_0x2cbbde(509)](_0x2cbbde(508))) == null || _0x589d17[_0x2cbbde(750)]();
    }
    async ["preventLinks"]() {
      const _0x4d0381 = _0x25ec03;
      var _0x3e6780, _0x5f3ffb;
      let _0x467d93 = await this[_0x4d0381(751)][_0x4d0381(561)];
      !(await this[_0x4d0381(751)]["blockedLinkHosts"])["length"] && _0x467d93[_0x4d0381(510)]("*") || (_0x5f3ffb = (_0x3e6780 = this[_0x4d0381(536)]) == null ? void 0 : _0x3e6780[_0x4d0381(509)](_0x4d0381(522))) == null || _0x5f3ffb[_0x4d0381(750)]();
    }
    [_0x25ec03(730)](_0x70543d = 0) {
      const _0x82622f = _0x25ec03;
      if (!this[_0x82622f(536)] && _0x70543d < 100) return setTimeout(() => this[_0x82622f(730)](_0x70543d + 1), 25);
      this[_0x82622f(505)](), this["preventLinks"](), this["form"] && pe2(this[_0x82622f(526)], this[_0x82622f(579)]);
    }
    get [_0x25ec03(666)]() {
      return this["controller"]["element"];
    }
    get [_0x25ec03(536)]() {
      const _0x432955 = _0x25ec03;
      return this[_0x432955(751)]["toolbarElement"];
    }
    get [_0x25ec03(526)]() {
      const _0xb2b5b6 = _0x25ec03;
      return this[_0xb2b5b6(751)][_0xb2b5b6(772)];
    }
    get ["input"]() {
      const _0x1a0ea8 = _0x25ec03;
      return this[_0x1a0ea8(751)][_0x1a0ea8(761)];
    }
  };
  var S2 = class {
    constructor(_0x5356b0) {
      const _0x4b3e49 = _0x25ec03;
      var _0xfe6335, _0x4400cf, _0x55ebde;
      let _0x584ee0 = [location[_0x4b3e49(801)], (_0x4400cf = g2((_0xfe6335 = _0x5356b0[_0x4b3e49(772)]) == null ? void 0 : _0xfe6335[_0x4b3e49(569)])) == null ? void 0 : _0x4400cf["pathname"], (_0x55ebde = _0x5356b0[_0x4b3e49(585)][_0x4b3e49(644)](_0x4b3e49(744))) == null ? void 0 : _0x55ebde["id"]];
      this[_0x4b3e49(751)] = _0x5356b0, this[_0x4b3e49(673)] = _0x584ee0[_0x4b3e49(483)]((_0x5f4fd4) => _0x5f4fd4 && _0x5f4fd4[_0x4b3e49(665)])["join"]("/")[_0x4b3e49(651)](/\/{2,}/g, "/"), this[_0x4b3e49(493)] = this[_0x4b3e49(496)](this["identifier"]);
    }
    [_0x25ec03(641)](_0x48dbb4) {
      const _0xab7f4f = _0x25ec03;
      let _0x248dff = Math[_0xab7f4f(565)](_0x48dbb4[_0xab7f4f(665)] / 2);
      return [_0x48dbb4[_0xab7f4f(534)](0, _0x248dff), _0x48dbb4[_0xab7f4f(534)](_0x248dff)];
    }
    ["obfuscate"](_0x57fa32) {
      const _0x479deb = _0x25ec03;
      var _0x3e58b1;
      let _0x397c7d = [..._0x57fa32]["map"]((_0x217819) => _0x217819[_0x479deb(791)](0));
      return [(_0x3e58b1 = this[_0x479deb(641)](_0x397c7d)[1]) == null ? void 0 : _0x3e58b1[_0x479deb(583)](), _0x397c7d[0]]["flat"]()["join"]("");
    }
    [_0x25ec03(778)](_0x2b1796) {
      const _0x20e54b = _0x25ec03;
      return sessionStorage[_0x20e54b(631)](this[_0x20e54b(593)](_0x2b1796));
    }
    ["write"](_0x15183e, _0x37ea35) {
      const _0x3c37d8 = _0x25ec03;
      return sessionStorage[_0x3c37d8(581)](this[_0x3c37d8(593)](_0x15183e), _0x37ea35);
    }
    [_0x25ec03(750)](_0x485822) {
      const _0x3236df = _0x25ec03;
      return sessionStorage[_0x3236df(669)](this[_0x3236df(593)](_0x485822));
    }
    ["generateStorageKey"](_0x2c7846) {
      const _0x1de9d8 = _0x25ec03;
      let _0x3fe93e = [...this[_0x1de9d8(496)](_0x2c7846)], [_0x27bae8, _0x21a5be] = this[_0x1de9d8(641)](_0x3fe93e);
      return btoa(_0x27bae8 + "/" + this[_0x1de9d8(493)] + "/" + _0x21a5be);
    }
  };
  var D2 = { "link": _0x25ec03(727), "embedded": _0x25ec03(689), "prohibited": _0x25ec03(689), "error": _0x25ec03(617), "iframe": _0x25ec03(759), "image": _0x25ec03(660), "warning": _0x25ec03(674) };
  var je2 = [le2, "a", _0x25ec03(622), _0x25ec03(610), "address", "b", _0x25ec03(678), "blockquote", "br", "cite", _0x25ec03(577), "dd", _0x25ec03(519), _0x25ec03(683), _0x25ec03(533), "dl", "dt", "em", _0x25ec03(728), _0x25ec03(676), "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "iframe", _0x25ec03(760), _0x25ec03(697), _0x25ec03(574), "li", "ol", "p", _0x25ec03(790), _0x25ec03(506), _0x25ec03(517), _0x25ec03(548), "strong", _0x25ec03(543), _0x25ec03(716), _0x25ec03(614), "tt", "ul", _0x25ec03(712)];
  var Ve2 = ["abbr", _0x25ec03(609), "allowfullscreen", _0x25ec03(516), _0x25ec03(604), _0x25ec03(611), _0x25ec03(484), _0x25ec03(625), _0x25ec03(687), _0x25ec03(645), _0x25ec03(491), _0x25ec03(488), _0x25ec03(783), _0x25ec03(776), _0x25ec03(663), _0x25ec03(640), "filesize", "height", _0x25ec03(499), _0x25ec03(670), _0x25ec03(494), _0x25ec03(765), _0x25ec03(646), _0x25ec03(775), _0x25ec03(731), "sandbox", _0x25ec03(513), "src", _0x25ec03(572), _0x25ec03(603), "url", _0x25ec03(591), _0x25ec03(652)];
  var k2 = class {
    constructor(_0x34c807) {
      const _0x57cd80 = _0x25ec03;
      this[_0x57cd80(751)] = _0x34c807, this[_0x57cd80(601)]();
    }
    ["sanitize"](_0xd68ef8) {
      const _0x30d9a7 = _0x25ec03;
      let _0x31130f = document[_0x30d9a7(512)](_0x30d9a7(544));
      _0x31130f[_0x30d9a7(538)] = "<div>" + _0xd68ef8 + "</div>";
      let _0x2eef9c = _0x31130f["content"][_0x30d9a7(564)];
      return [_0x2eef9c]["concat"]([..._0x2eef9c[_0x30d9a7(515)]("*")])[_0x30d9a7(479)]((_0x57fd14) => {
        const _0xe5e65d = _0x30d9a7;
        je2[_0xe5e65d(510)](_0x57fd14["tagName"][_0xe5e65d(545)]()) ? [..._0x57fd14["attributes"]][_0xe5e65d(479)]((_0x5e2b96) => {
          const _0x4b1221 = _0xe5e65d;
          Ve2[_0x4b1221(510)](_0x5e2b96["name"][_0x4b1221(545)]()) || _0x57fd14["removeAttribute"](_0x5e2b96[_0x4b1221(765)]);
        }) : _0x57fd14[_0xe5e65d(750)]();
      }), _0x2eef9c[_0x30d9a7(538)];
    }
    [_0x25ec03(601)]() {
      const _0x2c7d5a = _0x25ec03;
      this[_0x2c7d5a(755)] = D2, Object[_0x2c7d5a(763)](D2)[_0x2c7d5a(479)]((_0x5dd419) => this[_0x2c7d5a(632)](_0x5dd419));
    }
    ["initializeTemplate"](_0xd3e339) {
      const _0x5820c7 = _0x25ec03;
      var _0x25048e, _0x4c5375;
      let _0x1c6d9f = _0xd3e339 + _0x5820c7(714), _0x210670 = this[_0x5820c7(751)][_0x1c6d9f], _0x4fc724 = _0x210670 ? (_0x4c5375 = (_0x25048e = document[_0x5820c7(618)](_0x210670)) == null ? void 0 : _0x25048e[_0x5820c7(538)]) == null ? void 0 : _0x4c5375[_0x5820c7(780)]() : null;
      return this[_0x5820c7(751)][_0x1c6d9f] = null, _0x4fc724 && (this[_0x5820c7(755)][_0xd3e339] = _0x4fc724), this["templates"][_0xd3e339];
    }
    [_0x25ec03(657)](_0x1f5e5b, _0x57fce7 = {}) {
      const _0x32eef6 = _0x25ec03;
      return this["templates"][_0x1f5e5b][_0x32eef6(651)](/{{(.*?)}}/g, (_0x4c2b80, _0x37d89a) => _0x37d89a[_0x32eef6(641)](".")[_0x32eef6(600)]((_0x1f1674, _0x4866e1) => _0x1f1674[_0x4866e1], _0x57fce7));
    }
    [_0x25ec03(592)](_0x4ece3c = "https://example.com") {
      const _0xc7be0 = _0x25ec03;
      let _0x441dfd = de2(_0x4ece3c) ? this["render"](_0xc7be0(521), { "src": _0x4ece3c }) : this["render"](_0xc7be0(503), { "src": _0x4ece3c });
      return this[_0xc7be0(703)](_0x441dfd);
    }
    [_0x25ec03(613)](_0x4bd02d = [_0x25ec03(688), _0x25ec03(774)]) {
      const _0x2eb31e = _0x25ec03;
      if (_0x4bd02d != null && _0x4bd02d[_0x2eb31e(665)]) return _0x4bd02d[_0x2eb31e(553)]((_0x4912d7) => this[_0x2eb31e(592)](_0x4912d7));
    }
    [_0x25ec03(573)](_0x54e66e = [_0x25ec03(688), _0x25ec03(774)], _0x47ae60 = [], _0x354555 = []) {
      const _0x58b06b = _0x25ec03;
      if (_0x54e66e != null && _0x54e66e[_0x58b06b(665)]) return _0x47ae60 = [..._0x47ae60]["sort"](), _0x47ae60[_0x58b06b(510)]("*") && (_0x47ae60 = [_0x58b06b(580)]), _0x354555 = [.../* @__PURE__ */ new Set([..._0x354555, ...ie2(_0x54e66e)])]["sort"](), _0x354555["includes"]("*") && (_0x354555 = ["All"]), this[_0x58b06b(657)](_0x58b06b(742), { "header": _0x58b06b(482), "subheader": _0x58b06b(476), "prohibited": { "header": _0x58b06b(602), "hosts": _0x354555[_0x58b06b(665)] ? _0x354555[_0x58b06b(553)]((_0x21aee0) => _0x58b06b(768) + _0x21aee0 + _0x58b06b(542))["join"]("") : _0x58b06b(529) }, "allowed": { "header": "Allowed Hosts", "hosts": _0x47ae60["length"] ? _0x47ae60[_0x58b06b(553)]((_0x3e3574) => _0x58b06b(768) + _0x3e3574 + _0x58b06b(542))[_0x58b06b(739)]("") : _0x58b06b(529) } });
    }
    [_0x25ec03(741)](_0x1f5f1b) {
      const _0x5229ad = _0x25ec03;
      return this["render"](_0x5229ad(723), { "header": _0x5229ad(704), "subheader": _0x5229ad(608), "error": _0x1f5f1b });
    }
  };
  function fe2(_0x2c0490 = { "Controller": null, "Trix": null }) {
    const _0x3dea0f = _0x25ec03;
    var _0x372023;
    let { Controller: _0x3e44dc, Trix: _0x3bd51a } = _0x2c0490;
    return _0x372023 = class extends _0x3e44dc {
      [_0x3dea0f(711)]() {
        const _0x3c68f2 = _0x3dea0f;
        if (this[_0x3c68f2(662)] = this["paste"]["bind"](this), this[_0x3c68f2(585)]["addEventListener"](_0x3c68f2(782), this[_0x3c68f2(662)], true), this[_0x3c68f2(802)] = this["beforeFetchResponse"][_0x3c68f2(489)](this), addEventListener(_0x3c68f2(531), this[_0x3c68f2(802)], true), this[_0x3c68f2(681)] = this[_0x3c68f2(797)]["bind"](this), addEventListener("beforeunload", this[_0x3c68f2(681)], true), this[_0x3c68f2(675)] = new S2(this), this[_0x3c68f2(507)] = new T2(this), this["configured"]) return this[_0x3c68f2(730)]();
        this[_0x3c68f2(596)]()[_0x3c68f2(643)](() => this[_0x3c68f2(730)](this));
      }
      [_0x3dea0f(749)]() {
        const _0x2e9b3d = _0x3dea0f;
        let _0x4bdbf2 = this[_0x2e9b3d(585)]["getAttribute"]("data-controller") || "", _0x1fc6db = new Set(_0x4bdbf2[_0x2e9b3d(641)](" "));
        _0x1fc6db[_0x2e9b3d(737)](_0x2e9b3d(537)), this["element"][_0x2e9b3d(568)]("data-controller", [..._0x1fc6db][_0x2e9b3d(739)](" ")[_0x2e9b3d(780)]());
      }
      ["disconnect"]() {
        const _0x351110 = _0x3dea0f;
        this[_0x351110(585)][_0x351110(518)](_0x351110(782), this[_0x351110(662)], true), removeEventListener(_0x351110(531), this[_0x351110(802)], true), removeEventListener("beforeunload", this["onBeforeUnload"], true), this[_0x351110(749)]();
      }
      [_0x3dea0f(647)](_0x5afaf7) {
        const _0x23f7e4 = _0x3dea0f;
        try {
          _0x5afaf7[_0x23f7e4(707)]["querySelectorAll"](_0x23f7e4(679))[_0x23f7e4(510)](this[_0x23f7e4(585)]) && this[_0x23f7e4(797)]();
        } catch (_0x374dc7) {
        }
      }
      ["protect"]() {
        const _0x4de490 = _0x3dea0f;
        this["paranoid"] && this["guard"][_0x4de490(730)]();
      }
      async [_0x3dea0f(700)](_0x331459, _0x5c83c6 = 0) {
        const _0xccf447 = _0x3dea0f;
        if (!this["configured"] && _0x5c83c6 < 100) return setTimeout(() => this[_0xccf447(700)](_0x331459, _0x5c83c6 + 1), 25);
        this[_0xccf447(772)] && (this["formElement"][_0xccf447(551)] = true);
        try {
          let { html: _0x333f94, string: _0x30d08e, range: _0x7a61e1 } = _0x331459[_0xccf447(700)], _0x341eb1 = _0x333f94 || _0x30d08e || "", _0xee63a6 = this[_0xccf447(668)](_0x341eb1), _0x33dc74 = ne2(_0xee63a6);
          if (!_0x33dc74["length"]) return;
          _0x331459[_0xccf447(658)](), this[_0xccf447(666)][_0xccf447(554)](_0x7a61e1);
          let _0x42d7e4 = new k2(this);
          try {
            let _0xece02d = await this[_0xccf447(549)] || this[_0xccf447(628)] || [], _0x5c407a = await this[_0xccf447(633)] || this["blockedMediaHostsValue"] || [], _0xfba6 = new Set(_0x33dc74[_0xccf447(483)]((_0x540e39) => O2(_0x540e39)));
            [..._0xee63a6["querySelectorAll"](_0xccf447(503))][_0xccf447(479)]((_0x108af7) => _0xfba6[_0xccf447(737)](_0x108af7["src"])), _0xfba6 = [..._0xfba6];
            let _0x45d0a5 = _0xfba6[_0xccf447(483)]((_0x5f32e0) => H2(_0x5f32e0, _0xece02d, _0x5c407a)), _0xec9502 = _0xfba6[_0xccf447(483)]((_0x361ee5) => !_0x45d0a5["includes"](_0x361ee5)), _0x484c98 = await this[_0xccf447(561)] || this[_0xccf447(745)] || [], _0x16ee64 = await this[_0xccf447(799)] || this[_0xccf447(623)] || [], _0x4214d3 = _0x33dc74[_0xccf447(483)]((_0x233c30) => !_0xfba6[_0xccf447(510)](_0x233c30)), _0x4c8755 = _0x4214d3[_0xccf447(483)]((_0xf510d7) => H2(_0xf510d7, _0x484c98, _0x16ee64)), _0x4a0857 = _0x4214d3[_0xccf447(483)]((_0x5a2eda) => !_0x4c8755["includes"](_0x5a2eda));
            if (_0xec9502[_0xccf447(665)] || _0x4a0857[_0xccf447(665)]) {
              let _0x332460 = [.../* @__PURE__ */ new Set([..._0xec9502, ..._0x4a0857])], _0x20b933 = [.../* @__PURE__ */ new Set([..._0xece02d, ..._0x484c98])]["filter"]((_0x2c7f91) => !this[_0xccf447(771)][_0xccf447(510)](_0x2c7f91)), _0x34bfdd = [.../* @__PURE__ */ new Set([..._0x5c407a, ..._0x16ee64])]["filter"]((_0x3dc144) => !this[_0xccf447(771)]["includes"](_0x3dc144));
              console["log"]("allowedHosts", _0x20b933), console[_0xccf447(638)](_0xccf447(769), _0x34bfdd), await this[_0xccf447(685)](_0x42d7e4["renderWarnings"](_0x332460, _0x20b933, _0x34bfdd));
            }
            if (_0x45d0a5[_0xccf447(665)] && await this[_0xccf447(685)](_0x42d7e4["renderEmbeds"](_0x45d0a5)), _0x33dc74[_0xccf447(665)] === 1 && _0x45d0a5[_0xccf447(665)] === 1) return;
            let _0x1873b8 = this["sanitizePastedElement"](_0xee63a6, { "renderer": _0x42d7e4, "validMediaURLs": _0x45d0a5, "validLinkURLs": _0x4c8755 })[_0xccf447(538)][_0xccf447(780)]();
            _0x1873b8[_0xccf447(665)] && await this[_0xccf447(685)](_0x1873b8, { "disposition": "inline" });
          } catch (_0x420992) {
            this[_0xccf447(685)](_0x42d7e4[_0xccf447(741)](_0x420992));
          }
        } finally {
          this[_0xccf447(772)] && delete this[_0xccf447(772)][_0xccf447(551)];
        }
      }
      [_0x3dea0f(668)](_0x3409fd) {
        const _0xa05143 = _0x3dea0f;
        let _0x9a6a2c = document[_0xa05143(512)](_0xa05143(544));
        return _0x9a6a2c["innerHTML"] = _0xa05143(621) + _0x3409fd["trim"]() + _0xa05143(562), _0x9a6a2c[_0xa05143(800)]["firstElementChild"];
      }
      [_0x3dea0f(539)](_0x302762, _0x5476af = { "default": null }) {
        const _0xf14e4c = _0x3dea0f;
        let _0x2395b0 = _0x302762[_0xf14e4c(603)];
        return _0x2395b0 && _0x2395b0[_0xf14e4c(665)] || (_0x2395b0 = _0x302762[_0xf14e4c(781)][_0xf14e4c(780)](), _0x2395b0 && _0x2395b0[_0xf14e4c(665)]) ? _0x2395b0 : _0x5476af[_0xf14e4c(653)];
      }
      ["sanitizePastedElement"](_0xee0d13, _0x1ed8e5 = { "renderer": null, "validMediaURLs": [], "validLinkURLs": [] }) {
        const _0x39bae0 = _0x3dea0f;
        let { renderer: _0x50a416, validMediaURLs: _0x565a22, validLinkURLs: _0x3ed902 } = _0x1ed8e5;
        _0xee0d13 = _0xee0d13[_0x39bae0(715)](true);
        let _0x14dc0a = C2(_0xee0d13), _0x5ede3c = [], _0x14eb23;
        for (; _0x14eb23 = _0x14dc0a[_0x39bae0(686)](); ) _0x14eb23[_0x39bae0(615)] = _0x14eb23[_0x39bae0(615)] || /* @__PURE__ */ new Set(), _0x5ede3c[_0x39bae0(724)](_0x14eb23), _0x14eb23["nodeValue"][_0x39bae0(641)](/\s+/)[_0x39bae0(483)]((_0x2e9f6d) => _0x2e9f6d[_0x39bae0(732)]("http"))[_0x39bae0(479)]((_0x1db479) => {
          const _0x5cfbc4 = _0x39bae0;
          var _0x4ca75d;
          let _0x4cdf82 = (_0x4ca75d = g2(_0x1db479)) == null ? void 0 : _0x4ca75d[_0x5cfbc4(499)], _0x1fb743 = _0x3ed902[_0x5cfbc4(510)](_0x4cdf82) || _0x3ed902[_0x5cfbc4(510)](_0x4cdf82) ? _0x50a416[_0x5cfbc4(657)](_0x5cfbc4(500), { "url": _0x4cdf82, "label": _0x4cdf82 }) : _0x50a416[_0x5cfbc4(657)](_0x5cfbc4(798), { "url": _0x4cdf82, "label": _0x5cfbc4(497), "description": "" });
          _0x14eb23[_0x5cfbc4(615)][_0x5cfbc4(737)]({ "match": _0x1db479, "replacement": _0x1fb743 });
        });
        return _0x5ede3c[_0x39bae0(479)]((_0x474abf) => {
          const _0x3b8efe = _0x39bae0;
          if (!_0x474abf[_0x3b8efe(615)][_0x3b8efe(698)]) return;
          let _0x5f16ea = _0x474abf[_0x3b8efe(589)];
          [..._0x474abf[_0x3b8efe(615)]]["sort"]((_0x203b5a, _0x2da644) => _0x2da644[_0x3b8efe(705)][_0x3b8efe(665)] - _0x203b5a["match"]["length"])["forEach"]((_0x4cbde8) => _0x5f16ea = _0x5f16ea[_0x3b8efe(627)](_0x4cbde8[_0x3b8efe(705)], _0x4cbde8[_0x3b8efe(481)])), _0x474abf[_0x3b8efe(717)](this[_0x3b8efe(668)](_0x5f16ea));
        }), _0xee0d13[_0x39bae0(515)]("a")[_0x39bae0(479)]((_0x5a6afb) => {
          const _0x310403 = _0x39bae0;
          let _0x470075 = U2(_0x5a6afb), _0x56cb59 = this[_0x310403(539)](_0x5a6afb, { "default": _0x470075 }), _0x43e25b = _0x3ed902[_0x310403(510)](_0x470075) ? _0x50a416[_0x310403(657)](_0x310403(500), { "url": _0x470075, "label": _0x56cb59 }) : _0x50a416[_0x310403(657)]("prohibited", { "url": _0x470075, "label": _0x310403(746), "description": "(" + _0x56cb59 + ")" });
          _0x5a6afb[_0x310403(717)](this[_0x310403(668)](_0x43e25b));
        }), _0xee0d13[_0x39bae0(515)](ce2[_0x39bae0(739)](", "))[_0x39bae0(479)]((_0x3a5984) => {
          const _0x5d40ad = _0x39bae0;
          let _0x508974 = U2(_0x3a5984), _0x18bacc = this[_0x5d40ad(539)](_0x3a5984, { "default": _0x508974 }), _0x89ac13 = _0x565a22[_0x5d40ad(510)](_0x508974) ? _0x50a416[_0x5d40ad(657)](_0x5d40ad(671), { "url": _0x508974, "label": _0x5d40ad(634), "description": _0x5d40ad(520) }) : _0x50a416["render"](_0x5d40ad(798), { "url": _0x508974, "label": _0x5d40ad(477), "description": "" });
          _0x3a5984[_0x5d40ad(717)](this[_0x5d40ad(668)](_0x89ac13));
        }), _0xee0d13[_0x39bae0(538)][_0x39bae0(627)](/(\n|\r|\f|\v)+/g, _0x39bae0(702)), _0xee0d13;
      }
      ["createAttachment"](_0x53df96) {
        const _0x49889f = _0x3dea0f;
        return new _0x3bd51a[_0x49889f(527)]({ "content": _0x53df96, "contentType": se2[_0x49889f(680)] });
      }
      [_0x3dea0f(777)](_0x341aa5 = 1, _0x2a647e = { "delay": 1 }) {
        let { delay: _0x1e28d4 } = _0x2a647e;
        return new Promise((_0x5ebf0d) => {
          setTimeout(() => {
            const _0x3c10ff = _0x5b82;
            for (let _0x540308 = 0; _0x540308 < _0x341aa5; _0x540308++) this[_0x3c10ff(666)][_0x3c10ff(650)]();
            _0x5ebf0d();
          }, _0x1e28d4);
        });
      }
      ["insertAttachment"](_0x133f9e, _0x2fd468 = { "delay": 1 }) {
        let { delay: _0xc14965 } = _0x2fd468;
        return new Promise((_0x2e3903) => {
          setTimeout(() => {
            const _0x3f3672 = _0x5b82;
            this[_0x3f3672(666)][_0x3f3672(624)](this[_0x3f3672(691)](_0x133f9e)), this[_0x3f3672(777)](1, { "delay": _0xc14965 })[_0x3f3672(502)](_0x2e3903);
          }, _0xc14965);
        });
      }
      [_0x3dea0f(692)](_0x8e1a46, _0x428c39 = { "delay": 1 }) {
        let { delay: _0x330dbe } = _0x428c39;
        return new Promise((_0x3e6491) => {
          setTimeout(() => {
            const _0x48845b = _0x5b82;
            this[_0x48845b(666)]["insertHTML"](_0x8e1a46), this[_0x48845b(777)](1, { "delay": _0x330dbe })[_0x48845b(502)](_0x3e6491);
          }, _0x330dbe);
        });
      }
      [_0x3dea0f(685)](_0xc5e31f, _0x50e4fb = { "delay": 1, "disposition": _0x3dea0f(680) }) {
        let { delay: _0x2cb1b6, disposition: _0xbec439 } = _0x50e4fb;
        return _0xc5e31f != null && _0xc5e31f["length"] ? new Promise((_0x3bd69b) => {
          setTimeout(() => {
            const _0x321367 = _0x5b82;
            if (typeof _0xc5e31f == _0x321367(541)) return _0xbec439 === _0x321367(684) ? this[_0x321367(692)](_0xc5e31f, { "delay": _0x2cb1b6 })[_0x321367(720)]((_0x4d66f2) => this[_0x321367(741)](_0x4d66f2))[_0x321367(502)](_0x3bd69b) : this[_0x321367(624)](_0xc5e31f, { "delay": _0x2cb1b6 })["catch"]((_0x174918) => this[_0x321367(741)](_0x174918))["finally"](_0x3bd69b);
            if (Array[_0x321367(770)](_0xc5e31f)) {
              let _0x2b9db1 = _0xbec439 === _0x321367(684) ? _0xc5e31f["map"]((_0x559f4e) => this[_0x321367(692)](_0x559f4e, { "delay": _0x2cb1b6 + 1 })) : _0xc5e31f[_0x321367(553)]((_0x21f9f6) => this[_0x321367(624)](_0x21f9f6, { "delay": _0x2cb1b6 + 1 }));
              return Promise[_0x321367(786)](_0x2b9db1)[_0x321367(720)]((_0x4135a1) => this[_0x321367(741)](_0x4135a1))[_0x321367(502)](_0x3bd69b);
            }
            _0x3bd69b();
          });
        }) : Promise["resolve"]();
      }
      get [_0x3dea0f(666)]() {
        const _0x1a5094 = _0x3dea0f;
        return this[_0x1a5094(585)][_0x1a5094(666)];
      }
      get [_0x3dea0f(550)]() {
        const _0x989688 = _0x3dea0f;
        let _0x891a1e = this[_0x989688(585)]["getAttribute"](_0x989688(536)), _0x59cb0a = _0x891a1e ? document[_0x989688(618)](_0x891a1e) : null;
        if (!_0x59cb0a) {
          let _0xb213b3 = this["element"][_0x989688(654)];
          _0x59cb0a = _0xb213b3 != null && _0xb213b3[_0x989688(734)][_0x989688(705)](/trix-toolbar/i) ? _0xb213b3 : null;
        }
        return _0x59cb0a;
      }
      get ["formElement"]() {
        const _0x1d7362 = _0x3dea0f;
        return this[_0x1d7362(585)][_0x1d7362(644)](_0x1d7362(526));
      }
      get [_0x3dea0f(761)]() {
        const _0x4f2cb8 = _0x3dea0f;
        var _0x11990e;
        let _0x127625 = this[_0x4f2cb8(585)]["getAttribute"](_0x4f2cb8(579));
        return _0x127625 ? (_0x11990e = this[_0x4f2cb8(772)]) == null ? void 0 : _0x11990e[_0x4f2cb8(509)]("#" + _0x127625) : null;
      }
      get [_0x3dea0f(655)]() {
        const _0x30836e = _0x3dea0f;
        return !!this["store"][_0x30836e(778)](_0x30836e(655));
      }
      get [_0x3dea0f(606)]() {
        const _0x5878fb = _0x3dea0f;
        try {
          return JSON[_0x5878fb(747)](this[_0x5878fb(675)][_0x5878fb(778)](_0x5878fb(606)))[2];
        } catch (_0x1a69bd) {
          return null;
        }
      }
      get [_0x3dea0f(642)]() {
        const _0xd91c00 = _0x3dea0f;
        try {
          return this["store"][_0xd91c00(778)]("configured") === "true";
        } catch (_0x115d1b) {
          return false;
        }
      }
      get ["hostsValueDescriptors"]() {
        const _0x2b7917 = _0x3dea0f;
        return Object[_0x2b7917(525)](this["valueDescriptorMap"])[_0x2b7917(483)]((_0x447270) => _0x447270[_0x2b7917(765)][_0x2b7917(605)](_0x2b7917(706)));
      }
      get ["reservedDomains"]() {
        const _0x2dbe87 = _0x3dea0f;
        return [_0x2dbe87(558), _0x2dbe87(620), _0x2dbe87(667), _0x2dbe87(594), _0x2dbe87(793), "trix.embed.example", "trix.embed.invalid", _0x2dbe87(590), _0x2dbe87(616), "trix.embed.test", _0x2dbe87(560), _0x2dbe87(598), _0x2dbe87(547), _0x2dbe87(752), _0x2dbe87(753), "www.embed.example", "www.embed.invalid", _0x2dbe87(524), _0x2dbe87(713), _0x2dbe87(501), "www.trix.example", _0x2dbe87(779), "www.trix.local", _0x2dbe87(733), _0x2dbe87(758)];
      }
      ["rememberConfig"]() {
        return new Promise(async (_0x2ab40b) => {
          const _0x5743c = _0x5b82;
          let _0x251233, _0x5b462a = await L2();
          _0x251233 = await y2(_0x5b462a, w2(this[_0x5743c(771)], 3)), this["store"]["write"](_0x5743c(606), JSON[_0x5743c(661)]([_0x251233[0], _0x251233[1], _0x5b462a, _0x251233[2]])), this["paranoidValue"] !== false && (_0x251233 = await y2(_0x5b462a, w2(this[_0x5743c(771)], 4)), this["store"]["write"](_0x5743c(655), JSON[_0x5743c(661)](_0x251233))), this[_0x5743c(585)][_0x5743c(740)](_0x5743c(729)), this[_0x5743c(696)]["forEach"](async (_0x154325) => {
            const _0x206595 = _0x5743c;
            let { name: _0x26cc38 } = _0x154325, _0x3d0ff1 = _0x26cc38["slice"](0, _0x26cc38["lastIndexOf"](_0x206595(588))), _0x1f22f5 = this[_0x26cc38];
            _0x1f22f5["length"] < 4 && (_0x1f22f5 = _0x1f22f5[_0x206595(690)](w2(this[_0x206595(771)], 4 - _0x1f22f5[_0x206595(665)]))), this[_0x206595(675)][_0x206595(709)](_0x3d0ff1, JSON["stringify"](await y2(_0x5b462a, _0x1f22f5))), this["hasOwnProperty"](_0x3d0ff1) || Object["defineProperty"](this, _0x3d0ff1, { "get": async () => {
              const _0xf8aa5 = _0x206595;
              try {
                return (await Z2(this[_0xf8aa5(606)], JSON["parse"](this[_0xf8aa5(675)][_0xf8aa5(778)](_0x3d0ff1))))[_0xf8aa5(483)]((_0x230251) => !this["reservedDomains"]["includes"](_0x230251));
              } catch (_0xbd12e1) {
                return console[_0xf8aa5(723)](_0xf8aa5(570) + _0x3d0ff1 + "'!", _0xbd12e1), [];
              }
            } }), this["element"][_0x206595(740)](_0x206595(648) + _0x154325[_0x206595(606)]);
          }), _0x251233 = await y2(_0x5b462a, w2(this[_0x5743c(771)], 4)), this[_0x5743c(675)][_0x5743c(709)]("securityHosts", _0x251233), _0x251233 = await y2(_0x5b462a, w2(this[_0x5743c(771)], 4)), this[_0x5743c(675)][_0x5743c(709)](_0x5743c(490), _0x251233), this["store"][_0x5743c(709)]("configured", true), _0x2ab40b();
        });
      }
      ["forgetConfig"]() {
        const _0x960f3b = _0x3dea0f;
        var _0x384b94, _0x5d980e, _0xd10ddc, _0xa87f35, _0x388fd4;
        try {
          (_0x384b94 = this[_0x960f3b(675)]) == null || _0x384b94[_0x960f3b(750)](_0x960f3b(606)), (_0x5d980e = this[_0x960f3b(675)]) == null || _0x5d980e[_0x960f3b(750)](_0x960f3b(655)), this[_0x960f3b(696)]["forEach"](async (_0x1f4b95) => {
            const _0x297e9f = _0x960f3b;
            var _0x4f3e88;
            let { name: _0x3a9970 } = _0x1f4b95, _0x4d46bf = _0x3a9970[_0x297e9f(534)](0, _0x3a9970[_0x297e9f(637)](_0x297e9f(588)));
            (_0x4f3e88 = this["store"]) == null || _0x4f3e88[_0x297e9f(750)](_0x4d46bf);
          }), (_0xd10ddc = this[_0x960f3b(675)]) == null || _0xd10ddc[_0x960f3b(750)]("securityHosts"), (_0xa87f35 = this["store"]) == null || _0xa87f35[_0x960f3b(750)]("obscurityHosts"), (_0x388fd4 = this["store"]) == null || _0x388fd4["remove"](_0x960f3b(642));
        } catch (_0x7f4986) {
        }
      }
    }, X2(_0x372023, _0x3dea0f(525), { "embeddedTemplate": String, "errorTemplate": String, "iframeTemplate": String, "imageTemplate": String, "linkTemplate": String, "prohibitedTemplate": String, "warningTemplate": String, "allowedLinkHosts": Array, "blockedLinkHosts": Array, "allowedMediaHosts": Array, "blockedMediaHosts": Array, "paranoid": { "type": Boolean, "default": true } }), _0x372023;
  }
  var ge2 = false;
  var Fe2 = { "application": null, "Controller": null, "Trix": null };
  function De2(_0x548be0 = Fe2) {
    const _0x23dcf3 = _0x25ec03;
    if (ge2) return;
    let { application: _0xf317bc, Controller: _0x4ef87a, Trix: _0x26f7ab } = _0x548be0;
    _0xf317bc[_0x23dcf3(546)](_0x23dcf3(537), fe2({ "Controller": _0x4ef87a, "Trix": _0x26f7ab })), ge2 = true;
  }
  self["TrixEmbed"] = E2(v2({}, Q2), { "encryptValues": y2, "generateKey": L2, "generateKeyAndEncryptValues": ee2, "initialize": De2 });
  function _0x5b82(_0x30e371, _0x4bfe96) {
    const _0x1733aa = _0x1733();
    return _0x5b82 = function(_0x5b8249, _0xe57db7) {
      _0x5b8249 = _0x5b8249 - 476;
      let _0x29c4d0 = _0x1733aa[_0x5b8249];
      return _0x29c4d0;
    }, _0x5b82(_0x30e371, _0x4bfe96);
  }
  var St2 = self["TrixEmbed"];

  // app/javascript/trix/index.js
  var focusTrixEditor = (morphs, selector, attempts = 1) => {
    if (attempts > 10) return;
    const container = document.getElementById(morphs);
    const editor = container?.querySelector(selector);
    if (container && editor) {
      const clone2 = editor.cloneNode(true);
      editor.replaceWith(clone2);
      clone2.focus();
    } else {
      setTimeout(() => focusTrixEditor(morphs, selector, attempts + 1), 25 * attempts);
    }
  };
  document.addEventListener("turbo-boost:command:finish", (event2) => {
    const { morphs, focusSelector } = event2.detail.elementAttributes || {};
    if (morphs && focusSelector) focusTrixEditor(morphs, focusSelector);
  });

  // app/javascript/controllers/shoelace/alert_controller.js
  init_define_process();
  init_jquery();
  var alert_controller_default2 = class extends application_controller_default {
    connect() {
      if (!this.element.parentElement.classList.contains("sl-toast-stack")) {
        this.element.toast();
      }
    }
  };

  // app/javascript/controllers/shoelace/base_controller.js
  init_define_process();
  init_jquery();
  var base_controller_default = class extends application_controller_default {
    connect() {
      this.setupListeners();
    }
    hasChanges() {
      this.canClose = false;
    }
    noChanges() {
      this.canClose = true;
    }
    handleRequestClose(event2) {
      if (!this.canClose) {
        event2.preventDefault();
        this.confirmChanges(event2);
      }
    }
    preventOutsideClickClose(event2) {
      if (event2.detail.source === "overlay") {
        event2.preventDefault();
      }
    }
    /**
     * Event handler for 'turbo:submit-end' event. Calls this.element.hide() to automatically
     * close a drawer or dialog upon a successful form submission of a form contained
     * within this controller's scope at the time it was connected.
     *
     * Optionally, this behavior can be disabled by setting data-close-on-form-success="false"
     * on the element this controller is bound to.
     * @param {Event[{detail: {formSubmission: {result: {success: boolean}, formElement: HTMLElement}}}]} event
     *
     * @returns {void}
     */
    handleSubmitEnd(event2) {
      const { formSubmission } = event2?.detail;
      const success = formSubmission?.result?.success;
      const formElement = formSubmission?.formElement;
      if (success && this.closeOnFormSuccess) {
        this.canClose = true;
        if (this.originatingFormElementInScope(formElement) || this.canCloseViaTurboConfirm(formElement)) {
          this.element.hide();
        }
      }
    }
    setupListeners() {
      if (this.element.dataset.tracksChanges) {
        this.canClose = true;
        this.element.addEventListener("unsaved-changes:discard", this.hide.bind(this));
        this.element.addEventListener("unsaved-changes:has-changes", this.hasChanges.bind(this));
        this.element.addEventListener("unsaved-changes:no-changes", this.noChanges.bind(this));
        this.element.addEventListener("sl-request-close", this.handleRequestClose.bind(this));
      }
      if (this.element.dataset.denyClose) {
        this.element.addEventListener("sl-request-close", this.preventOutsideClickClose.bind(this));
      }
      document.body.addEventListener("turbo:submit-end", this.handleSubmitEnd.bind(this));
    }
    confirmChanges(event2) {
      if (!this.hasUnsavedChangesOutlet) return;
      let outletsWithChanges = this.unsavedChangesOutlets.filter((outlet) => outlet.isDirty == true);
      if (outletsWithChanges.length) {
        outletsWithChanges.forEach((outlet) => outlet.discard(event2));
      } else {
        this.unsavedChangesOutlets.forEach((outlet) => outlet.discard(event2));
      }
    }
    hide(event2) {
      if (event2) {
        event2.preventDefault();
      }
      this.element.hide();
    }
    remove(event2) {
      event2.stopPropagation();
      this.element.remove();
    }
    disconnect() {
      this.element.removeEventListener("unsaved-changes:discard", this.hide);
      this.element.removeEventListener("unsaved-changes:has-changes", this.hasChanges);
      this.element.removeEventListener("unsaved-changes:no-changes", this.noChanges);
      this.element.removeEventListener("sl-request-close", this.handleRequestClose);
      this.element.removeEventListener("sl-request-close", this.preventOutsideClickClose);
      this.element.removeEventListener("turbo:submit-end", this.handleSubmitEnd);
    }
    /**
     * Whether or not the provided form element is within the scope
     * of this controller at the time it connected, and it is not a
     * turboConfirm form element.
     *
     * @param {formElement: HTMLElement} formElement
     *
     * @returns {boolean}
     */
    originatingFormElementInScope(formElement) {
      return [...this.formElements].includes(formElement);
    }
    /**
     * Whether or not .hide() can be called on the element
     * based on whether the formElement is a TurboConfirm form
     * element and whether the allowCloseViaTurboConfirmValue has
     * been set to true.
     *
     * @param {formElement: HTMLElement} formElement
     *
     * @returns {boolean}
     */
    canCloseViaTurboConfirm(formElement) {
      if (!this.allowCloseViaTurboConfirmValue) {
        return false;
      }
      const { turboConfirm } = formElement.dataset;
      return turboConfirm !== "undefined";
    }
    get closeOnFormSuccess() {
      return this.element.dataset.closeOnFormSuccess === "true";
    }
    get formElements() {
      return this.element.querySelectorAll("form");
    }
    /**
     * Disables focus trapping within the connected element and descendent elements.
     * Re-enables focus trapping by listening for the sl-request-close event on the document.
     *
     * Leverages: https://shoelace.style/components/dialog#properties
     */
    disableFocusTrapping() {
      this.element.modal.activateExternal();
      this.enableFocusTrappingFn = this.enableFocusTrapping.bind(this);
      this.formSubmissionFn = this.formSubmit.bind(this);
      document.addEventListener("sl-request-close", this.enableFocusTrappingFn);
      document.addEventListener("turbo:submit-end", this.formSubmissionFn);
    }
    /**
     * Re-enables focus trapping to underlying element (dialog, drawer, etc.) to prevent
     * tab navigation leaving the drawer or underlying dialog and cleans up event listeners.
     */
    enableFocusTrapping() {
      this.element.modal.deactivateExternal();
      document.removeEventListener("sl-request-close", this.enableFocusTrappingFn);
      document.removeEventListener("turbo:submit-end", this.formSubmissionFn);
    }
    /**
     * Restores the default focus behavior only after the form submission event is successful.
     */
    formSubmit(event2) {
      const { formSubmission } = event2?.detail;
      if (formSubmission?.result?.success) {
        this.enableFocusTrapping();
      }
    }
  };
  __publicField(base_controller_default, "outlets", ["unsaved-changes"]);
  __publicField(base_controller_default, "values", {
    allowCloseViaTurboConfirm: { type: Boolean, default: false }
  });

  // app/javascript/controllers/shoelace/confirm_controller.js
  init_define_process();
  init_jquery();
  var confirm_controller_default = class extends base_controller_default {
    confirm(event2) {
      event2.preventDefault();
      if (!this.validateGuardPhrase()) return;
      this.dispatch("confirm", { detail: { confirm: true, ...this.eventDetailValue } });
      this.element.hide();
    }
    cancel() {
      this.dispatch("confirm", { detail: { confirm: false, ...this.eventDetailValue } });
      if (this.hasInitiatorValue) {
        let confirmAction = document.querySelector(this.initiatorValue);
        confirmAction.classList.remove("disabled");
        confirmAction.disabled = false;
      }
      this.element.hide();
    }
    typeValueChanged() {
      this.updateToType(this.typeValue);
    }
    titleValueChanged() {
      if (this.htmlSafeTitleValue) {
        this.titleTarget.innerHTML = this.titleValue;
      } else {
        this.titleTarget.textContent = this.titleValue;
      }
    }
    descriptionValueChanged() {
      if (this.htmlSafeDescriptionValue) {
        this.descriptionTarget.innerHTML = this.descriptionValue;
      } else {
        this.descriptionTarget.textContent = this.descriptionValue;
      }
    }
    cancelValueChanged() {
      if (this.useIconButtonsValue && this.cancelValue) {
        this.cancelTarget.innerHTML = `<i class="${this.cancelValue}"></i>`;
      } else if (this.cancelValue) {
        this.cancelTarget.textContent = this.cancelValue;
      }
    }
    submitValueChanged() {
      if (this.useIconButtonsValue && this.submitValue) {
        this.submitTarget.innerHTML = `<i class="${this.submitValue}"></i>`;
      } else if (this.submitValue) {
        this.submitTarget.textContent = this.submitValue;
      }
    }
    useIconButtonsValueChanged() {
      if (this.hasSubmitTarget) this.submitValueChanged();
      if (this.hasCancelTarget) this.cancelValueChanged();
    }
    updateToType(type) {
      if (type === "negative") {
        this.iconTarget.replaceChildren(this.negativeIconTemplateTarget.content.cloneNode(true));
        this.submitTarget.classList = "cf-button-danger";
      }
      if (type === "positive") {
        this.iconTarget.replaceChildren(this.positiveIconTemplateTarget.content.cloneNode(true));
        this.submitTarget.classList = "cf-button";
      }
      if (type === "neutral" || !type) {
        this.iconTarget.replaceChildren();
        this.submitTarget.classList = "cf-button";
      }
    }
    // Phrase Guard functionality
    guardPhraseValueChanged() {
      this.hasGuardPhraseValue && this.guardPhraseValue ? this.enableGuardPhrase() : this.disableGuardPhrase();
    }
    enableGuardPhrase() {
      this.disableSubmit();
      this.descriptionWrapperTarget.appendChild(this.guardPhraseTemplateTarget.content.cloneNode(true));
    }
    guardPhraseTargetConnected() {
      this.guardPhraseTarget.textContent = this.guardPhraseValue;
    }
    validateGuardPhrase() {
      if (!this.hasGuardPhraseValue) return true;
      return this.guardPhraseInputTarget.value === this.guardPhraseValue;
    }
    toggleSubmit() {
      this.validateGuardPhrase() ? this.enableSubmit() : this.disableSubmit();
    }
    enableSubmit() {
      this.submitTarget.disabled = false;
    }
    disableSubmit() {
      this.submitTarget.disabled = true;
    }
    disableGuardPhrase() {
      this.enableSubmit();
      if (!this.hasGuardPhraseFieldTarget) return;
      this.guardPhraseFieldTarget.remove();
    }
    reset() {
      this.typeValue = "";
      this.cancelValue = this.defaultCancelValue;
      this.submitValue = this.defaultSubmitValue;
      this.titleValue = this.defaultTitleValue;
      if (this.hasGuardPhraseFieldTarget) {
        this.element.removeAttribute("data-shoelace--confirm-guard-phrase-value");
        this.guardPhraseFieldTarget.remove();
      }
    }
  };
  __publicField(confirm_controller_default, "targets", [
    "icon",
    "negativeIconTemplate",
    "positiveIconTemplate",
    "cancel",
    "submit",
    "title",
    "description",
    "descriptionWrapper",
    "guardPhraseTemplate",
    "guardPhraseField",
    "guardPhrase",
    "guardPhraseInput"
  ]);
  __publicField(confirm_controller_default, "values", {
    type: { type: String, default: "neutral" },
    defaultTitle: String,
    defaultSubmit: String,
    defaultCancel: String,
    title: String,
    submit: String,
    cancel: String,
    description: String,
    eventDetail: Object,
    guardPhrase: String,
    initiator: String,
    htmlSafeDescription: { type: Boolean, default: false },
    htmlSafeTitle: { type: Boolean, default: false },
    useIconButtons: { type: Boolean, default: false }
  });

  // app/javascript/controllers/shoelace/dialog_controller.js
  init_define_process();
  init_jquery();
  var dialog_controller_default = class extends base_controller_default {
    connect() {
      super.connect();
      if (this.element.dataset.autoOpen != "false") {
        this.element.updateComplete.then(() => {
          if (!this.element.open) {
            this.element.show();
            window.dispatchEvent(new Event("turbo:render"));
          }
        });
      }
    }
    // Override the default shoelace dialog controller to prevent closing the dialog
    // when pressing the escape key, as well as when clicking outside the dialog.
    // @see https://shoelace.style/components/dialog?id=customizing-initial-focus
    preventOutsideClickClose(event2) {
      if (["overlay", "keyboard"].includes(event2.detail.source)) this.cancelInitialFocus(event2);
    }
    cancelInitialFocus(event2) {
      event2.preventDefault();
    }
  };

  // app/javascript/controllers/shoelace/drawer_controller.js
  init_define_process();
  init_jquery();
  var drawer_controller_default = class extends base_controller_default {
    connect() {
      super.connect();
      if (this.element.dataset.autoOpen != "false") {
        this.element.updateComplete.then(() => {
          if (!this.element.open) {
            this.element.show();
            window.dispatchEvent(new Event("turbo:render"));
          }
        });
      }
    }
    /**
     * Closes the drawer by hiding the element.
     * @function closeDrawer
     * @returns {void}
     */
    closeDrawer() {
      this.element.hide();
    }
  };

  // app/javascript/controllers/shoelace/dropdown_menu_controller.js
  init_define_process();
  init_jquery();
  var dropdown_menu_controller_default = class extends application_controller_default {
    /**
     * Handler for the `sl-selected` event on the <sl-menu> element
     *
     * @param [CustomEvent] event
     * @param [HTMLElement] event.detail.item - The selected menu item
     * @param [string] event.detail.item.dataset.href - The URL to visit when the user selects the item
     * @param [string] event.detail.item.dataset.turboFrame - The ID of the TurboFrame
     * @param [string] event.detail.item.dataset.turboMethod - The method of the turbo frame visit
     * @return [void]
     */
    menuItemSelected(event2) {
      const { turboFrame, href, turboMethod, target } = event2.detail.item.dataset;
      if (href) {
        if (turboFrame) {
          let frame = document.querySelector(`turbo-frame#${turboFrame}`);
          frame.src = href;
        } else if (turboMethod && turboMethod !== "get") {
          this.performTurboMethodRequest(href, turboMethod);
        } else if (target) {
          window.open(href, target);
        } else {
          Turbo.visit(href);
        }
      } else if (event2.detail.item.querySelector("form")) {
        event2.detail.item.querySelector("form").requestSubmit();
      }
    }
    /**
     * Performs a turbo-stream request to a given href using a given turbo method.
     * This is native Turbo behavior via the data-turbo-method attr that we have to
     * include here in the event a menu item contains a turbo link with
     * a non-GET turbo-method.
     *
     * @param {string} href
     * @param {String} turboMethod (http request method, e.g. `GET` or `DELETE`)
     */
    async performTurboMethodRequest(href, turboMethod) {
      const req = new FetchRequest2(turboMethod, href, { responseKind: "turbo-stream" });
      await req.perform();
    }
    close() {
      this.element.hide();
    }
    handleClick(event2) {
      if (this.menuTarget.contains(event2.target) && this.autoCloseValue == true) {
        this.close();
      }
    }
  };
  __publicField(dropdown_menu_controller_default, "targets", ["menu"]);
  __publicField(dropdown_menu_controller_default, "values", {
    autoClose: { type: Boolean, default: true }
  });

  // app/javascript/controllers/shoelace/switch_controller.js
  init_define_process();
  init_jquery();
  var switch_controller_default = class extends application_controller_default {
    // Submit containing <form> element when a change event is emitted from the <sl-switch> element
    submit() {
      this.formTarget.requestSubmit();
    }
    /**
     * Trigger a request to a remote URL.
     *
     * Depends on the following values:
     * - `remoteUrlValue`: The url to which to perform the request
     * - `remoteUrlMethod`: The HTTP method for the request. Defaut: PATCH
     * - `responseKind`: Specifies which response format will be accepted. Default: `html`.
     * - `remoteUrlPayload`: Any data to send along with the request body. The
     *                     'checked' state of the switch will be merged with this
     *                     data as {checked: <value>}.
     *
     * @param {Event} event - The event object triggered by the data-action attribute.
     * @returns {Promise<void>} A Promise that resolves when the remote submission is completed.
     */
    async remoteSubmit(event2) {
      const checkedIntent = event2.target.checked;
      const request2 = new FetchRequest2(this.remoteUrlMethodValue, this.remoteUrlValue, {
        responseKind: this.responseKindValue,
        body: {
          checked: checkedIntent,
          ...this.remoteUrlPayloadValue
        }
      });
      this.dispatch("remote-submit-start");
      const response2 = await request2.perform();
      if (response2.ok) {
        this.dispatch("remote-submit-success");
        return;
      } else {
        this.element.checked = !checkedIntent;
        console.error(`The response failed with: ${response2.statusCode}`);
        this.dispatch("remote-submit-error");
      }
    }
    /**
     * If the switch wrapps a hidden input field, this method can be
     * used to toggle the value of that field as the switch changes state.
     * @returns {any}
     */
    toggleHiddenField() {
      if (this.hasHiddenFieldTarget) {
        if (this.ifCheckedValue && this.ifUncheckedValue) {
          this.hiddenFieldTarget.value = this.element.checked ? this.ifCheckedValue : this.ifUncheckedValue;
        } else {
          const prevValue = this.hiddenFieldTarget.value === "true";
          this.hiddenFieldTarget.value = !prevValue;
        }
      }
    }
  };
  __publicField(switch_controller_default, "targets", ["form", "hiddenField"]);
  __publicField(switch_controller_default, "values", {
    remoteUrl: { type: String, default: "" },
    remoteUrlMethod: { type: String, default: "PATCH" },
    remoteUrlPayload: Object,
    responseKind: { type: String, default: "html" },
    ifChecked: String,
    ifUnchecked: String
  });

  // app/javascript/controllers/shoelace/tab_group_controller.js
  init_define_process();
  init_jquery();
  var tab_group_controller_default = class extends application_controller_default {
    connect() {
      this.currentScrollYPosition = 0;
      this.navigateToTab = this.navigateToTab.bind(this);
      this.handleTabShow = this.handleTabShow.bind(this);
      this.handlePopState = this.handlePopState.bind(this);
      this.preventVisit = false;
      this.initialHash = window.location.hash;
      this.navigateToTab();
      document.addEventListener("turbo:render", this.navigateToTab);
      this.element.addEventListener("sl-tab-show", this.handleTabShow);
      window.addEventListener("popstate", this.handlePopState);
    }
    disconnect() {
      document.removeEventListener("turbo:render", this.navigateToTab);
      this.element.removeEventListener("sl-tab-show", this.handleTabShow);
      window.removeEventListener("popstate", this.handlePopState);
    }
    handleTabShow(event2) {
      if (!this.handlingPopState && !this.preventVisit && event2.detail.name !== this.initialHash.slice(1)) {
        const newUrl = new URL(window.location);
        newUrl.hash = event2.detail.name;
        Turbo.navigator.history.push(newUrl);
      }
      this.initialHash = "";
      if (this.keepScrollPositionValue) {
        this.handleTabChange();
      }
    }
    handlePopState() {
      const hash3 = window.location.hash.slice(1);
      if (hash3) {
        this.handlingPopState = true;
        this.preventVisit = true;
        this.element.show(hash3);
        this.preventVisit = false;
        this.handlingPopState = false;
      } else {
        const firstTab = this.element.querySelector("sl-tab");
        if (!firstTab) return;
        this.handlingPopState = true;
        this.preventVisit = true;
        this.element.show(firstTab.panel);
        this.preventVisit = false;
        this.handlingPopState = false;
      }
    }
    navigateToTab() {
      let hash3 = window.location.hash.toString();
      if (hash3) {
        setTimeout(() => {
          this.preventVisit = true;
          this.element.show(hash3.slice(1));
          this.preventVisit = false;
        });
      } else {
        const params = new URLSearchParams(window.location.search);
        const redirectedHashParam = params.get("redirect_anchor");
        if (redirectedHashParam) {
          params.delete("redirect_anchor");
          let newParams = params.toString();
          window.history.replaceState(
            null,
            "",
            [window.location.pathname, newParams ? `?${newParams}` : "", "#", redirectedHashParam].join("")
          );
          this.preventVisit = true;
          this.element.show(redirectedHashParam);
          this.preventVisit = false;
        }
      }
    }
    openTab(event2) {
      event2.preventDefault();
      const url = new URL(event2.target.href);
      const newTab = url.hash.slice(1);
      window.history.replaceState(null, "", url.toString());
      this.preventVisit = true;
      this.element.show(newTab);
      this.preventVisit = false;
    }
    handleTabChange() {
      this.currentScrollYPosition = window.scrollY;
    }
    /**
     * Programmatically reveal a sl-tab-panel via action params.
     * @see Shoelace sl-tab-group show() method
     * @see https://shoelace.style/components/tab-group?id=methods
     *
     * @param {Event} event
     * @param {string} event.params.showPanel - the name attribute of the sl-tab-panel to show
     * @example <button type='button' data-action="click->shoelace--tab-group#show"
     *   data-shoelace--tab-group-show-panel-param="mypanelname">
     * @returns {void}
     */
    show(event2) {
      const { showPanel } = event2.params;
      this.element.show(showPanel);
    }
  };
  __publicField(tab_group_controller_default, "values", {
    keepScrollPosition: { type: Boolean, default: false }
  });

  // app/javascript/customer_center/controllers/mobile_nav_controller.js
  init_define_process();
  init_jquery();
  var mobile_nav_controller_default = class extends application_controller_default {
    show() {
      this.drawerTarget.show();
    }
    toggleLessonTree() {
      if (this.lessonTreeTarget.open) {
        this.lessonTreeTarget.hide();
      } else {
        this.lessonTreeTarget.show();
      }
    }
    toggleLanguagePicker() {
      if (this.languagePickerTarget.open) {
        this.languagePickerTarget.hide();
      } else {
        this.languagePickerTarget.show();
      }
    }
  };
  __publicField(mobile_nav_controller_default, "targets", ["drawer", "lessonTree", "languagePicker"]);

  // app/javascript/customer_center/controllers/dark_mode_toggle_controller.js
  init_define_process();
  init_jquery();
  var dark_mode_toggle_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      // intentionally not using classes api
      // this is not publicly configurable
      __publicField(this, "MODES", Object.freeze({
        dark: "dark",
        light: "light",
        system: "system"
      }));
      __publicField(this, "darkModeClasses", [this.MODES.dark, "sl-theme-dark"]);
      __publicField(this, "lightModeClasses", [this.MODES.light, "sl-theme-light"]);
    }
    connect() {
      const theme = localStorage.getItem("customerCenterTheme");
      if (theme) {
        this.radioGroupTarget.value = this.MODES[theme];
      } else {
        this.radioGroupTarget.value = this.MODES.system;
      }
    }
    toggle() {
      const value = this.radioGroupTarget.value;
      if (value == this.MODES.system) {
        document.documentElement.classList.remove(...this.darkModeClasses);
        document.documentElement.classList.remove(...this.lightModeClasses);
        localStorage.removeItem("customerCenterTheme");
        return;
      }
      if (value == this.MODES.light) {
        document.documentElement.classList.remove(...this.darkModeClasses);
        document.documentElement.classList.add(...this.lightModeClasses);
      } else {
        document.documentElement.classList.add(...this.darkModeClasses);
        document.documentElement.classList.remove(...this.lightModeClasses);
      }
      localStorage.customerCenterTheme = value;
    }
  };
  __publicField(dark_mode_toggle_controller_default, "targets", ["radioGroup"]);

  // app/javascript/customer_center/controllers/community_post_controller.js
  init_define_process();
  init_jquery();
  var community_post_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      __publicField(this, "ALLOWED_CLOSERS", ["SL-DIALOG", "SL-DRAWER"]);
    }
    handleHide(event2) {
      if (!this.ALLOWED_CLOSERS.includes(event2.target.tagName)) return;
      this.setPreviousState();
      this.element.remove();
    }
    setPreviousState() {
      if (this.prevUrlValue) {
        window.history.pushState(null, null, this.prevUrlValue);
      }
    }
    scrollToFrame(event2) {
      const scrollToFrame = document.getElementById(event2.detail.frameId);
      scrollToFrame.scrollIntoView({ behavior: "smooth", block: "end" });
    }
  };
  __publicField(community_post_controller_default, "values", { prevUrl: { type: String, default: "" } });

  // app/javascript/customer_center/controllers/community_post_view_controller.js
  init_define_process();
  init_jquery();
  var community_post_view_controller_default = class extends application_controller_default {
    initialize() {
      this.viewedPosts = /* @__PURE__ */ new Set();
      this.observer = null;
      this.debounceTimer = null;
    }
    connect() {
      if (!this.hasPostIdValue || !this.hasUrlValue) return;
      const options = {
        root: null,
        rootMargin: "0px",
        threshold: 0.5
        // Post is considered "viewed" when 50% is visible
      };
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !this.viewedPosts.has(this.postIdValue)) {
            this.markAsViewed();
          }
        });
      }, options);
      this.observer.observe(this.element);
    }
    disconnect() {
      if (this.observer) {
        this.observer.disconnect();
      }
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
      }
    }
    markAsViewed() {
      if (this.viewedPosts.has(this.postIdValue)) return;
      this.viewedPosts.add(this.postIdValue);
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
      }
      this.debounceTimer = setTimeout(async () => {
        try {
          const response2 = await post(this.urlValue, {
            responseKind: "json"
          });
          if (response2.ok) {
            return;
          } else {
            this.viewedPosts.delete(this.postIdValue);
          }
        } catch {
          this.viewedPosts.delete(this.postIdValue);
        }
      }, 1500);
    }
  };
  __publicField(community_post_view_controller_default, "values", {
    postId: String,
    url: String
  });

  // app/javascript/customer_center/controllers/comment_form_controller.js
  init_define_process();
  init_jquery();
  var comment_form_controller_default = class extends application_controller_default {
    submit() {
      this.element.requestSubmit(this.submitButtonTarget);
    }
    enableSubmit() {
      this.submitButtonTarget.classList.remove("text-gray-300", "pointer-events-none");
    }
    disableSubmit() {
      this.submitButtonTarget.classList.add("text-gray-300", "pointer-events-none");
    }
    validateComment(event2) {
      if (!this.validateMaxLength() || !this.validateMinLength()) {
        event2.preventDefault();
      }
    }
    handleTrixChange() {
      if (this.validateMaxLength()) {
        this.charCountTarget.innerHTML = "";
      } else {
        this.charCountTarget.innerHTML = `\u2013${this.contentLength - this.maxLengthValue}`;
      }
      this.detectAndFormatUrls();
    }
    handleTrixPaste() {
      requestAnimationFrame(() => {
        this.detectAndFormatUrls();
      });
    }
    detectAndFormatUrls() {
      const document2 = this.editor.getDocument();
      const text = document2.toString();
      const preBlocks = document2.getBlocks().filter((block) => block.attributes.includes("code"));
      const preBlockRanges = preBlocks.map((block) => {
        const blockIndex = document2.getBlocks().indexOf(block);
        let startPosition = 0;
        for (let i3 = 0; i3 < blockIndex; i3++) {
          const previousBlock = document2.getBlocks()[i3];
          const blockLength2 = previousBlock.toString().length || 0;
          startPosition += blockLength2 + 1;
        }
        const blockLength = block.toString().length || 0;
        return [startPosition - 1, startPosition + blockLength];
      });
      const urlRegex = /\b(https?:\/\/)?[\w-]+(\.[\w-]+)+\.?(:\d+)?(\/\S*)?\b/gi;
      const matches = Array.from(text.matchAll(urlRegex));
      if (!matches.length) return;
      matches.reverse().forEach((match) => {
        const url = match[0];
        const position = match.index;
        const range2 = [position, position + url.length];
        const isInPreBlock = preBlockRanges.some((preRange) => position >= preRange[0] && position < preRange[1]);
        if (isInPreBlock) return;
        const formattedUrl = url.startsWith("http") ? url : `https://${url}`;
        const existingAttachment = document2.getAttachments().find((attachment) => {
          const attributes = attachment.getAttributes?.();
          if (!attributes?.href || attributes?.content || attributes?.sgid || !attachment.getRange) {
            return false;
          }
          const range3 = attachment.getRange();
          return range3[0] === range3[0] && range3[1] === range3[1];
        });
        if (!existingAttachment) {
          const currentSelection = this.editor.getSelectedRange();
          this.editor.recordUndoEntry("Insert Link");
          this.editor.setSelectedRange(range2);
          this.editor.activateAttribute("href", formattedUrl);
          this.editor.setSelectedRange(currentSelection);
        }
      });
    }
    handleTrixInitialize() {
      setTimeout(() => this.insertCursorEnd());
    }
    /* Prevent file attachments to comments directly through Trix */
    handleTrixFileAccept(event2) {
      event2.preventDefault();
    }
    handleTrixAttachmentAdd(event2) {
      const contentType = event2.attachment?.attachment?.attributes?.values?.contentType;
      if (contentType == "image") {
        event2.attachment.remove();
      }
    }
    insertCursorEnd() {
      const length = this.editor.getDocument().getLength();
      this.editor.setSelectedRange(length - 1);
      this.editor.element.focus();
    }
    validateMaxLength() {
      return this.contentLength <= this.maxLengthValue;
    }
    validateMinLength() {
      return this.contentLength > 0 || this.previewImages.length > 0;
    }
    get contentLength() {
      return this.editor.getDocument().toString().length - 1;
    }
    get editor() {
      return this.textAreaTarget.editor;
    }
    get previewImages() {
      return this.imagePreviewTarget.querySelectorAll("img");
    }
  };
  __publicField(comment_form_controller_default, "targets", ["submitButton", "textArea", "charCount", "imagePreview"]);
  __publicField(comment_form_controller_default, "values", {
    maxLength: { type: Number, default: 750 }
  });

  // app/javascript/customer_center/controllers/dropdown_controller.js
  init_define_process();
  init_jquery();
  var dropdown_controller_default = class extends application_controller_default {
    hide(event2) {
      if (["A", "BUTTON"].includes(event2.target.tagName)) {
        this.element.hide();
      }
    }
  };

  // app/javascript/customer_center/controllers/lesson_tree_controller.js
  init_define_process();
  init_jquery();
  var lesson_tree_controller_default = class extends application_controller_default {
    handleDetailsShow(event2) {
      if (event2.target.localName === "sl-details") {
        ;
        [...this.element.querySelectorAll("sl-details")].map((details) => details.open = event2.target === details);
      }
    }
  };

  // app/javascript/customer_center/controllers/post_form_controller.js
  init_define_process();
  init_jquery();
  var _instances3, getFileExtension_fn;
  var post_form_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      __privateAdd(this, _instances3);
    }
    enableSubmit() {
      this.submitBtnTarget.classList.remove("bg-gray-300", "pointer-events-none");
    }
    disableSubmit() {
      this.submitBtnTarget.classList.add("bg-gray-300", "pointer-events-none");
    }
    handleHide() {
      this.element.hide();
      this.dispatch("cancel");
    }
    handleSpaceSelect() {
      this.dispatch("topic-changed", { detail: { spaceId: this.spaceSelectTarget.value } });
    }
    handleSelect() {
      this.showClearImage();
      this.updatePreview();
      this.removeHiddenFieldTarget.value = false;
    }
    handleRemove() {
      this.fileFieldTarget.value = null;
      this.removeHiddenFieldTarget.value = true;
      this.showBrowse();
      this.updatePreview();
    }
    handleImageCrop({ detail: { blob } }) {
      const croppedFile = new File([blob], `cropped_image.${this.originalFileExtensionValue}`, {
        type: this.originalFileType
      });
      const dataTransfer = new DataTransfer();
      dataTransfer.items.add(croppedFile);
      this.fileFieldTarget.files = dataTransfer.files;
      this.updatePreview();
    }
    showBrowse() {
      this.browseTarget.classList.remove(...this.hiddenClasses);
      this.clearImageTarget.classList.add(...this.hiddenClasses);
    }
    showClearImage() {
      this.browseTarget.classList.add(...this.hiddenClasses);
      this.clearImageTarget.classList.remove(...this.hiddenClasses);
    }
    updatePreview() {
      const file = this.fileFieldTarget.files[0];
      if (file) {
        const reader = new FileReader();
        this.originalFileContentTypeValue = file.type;
        this.originalFileExtensionValue = __privateMethod(this, _instances3, getFileExtension_fn).call(this, file);
        reader.onload = (e2) => {
          this.previewWrapperTarget.innerHTML = "";
          let previewContent = this.previewTemplateTarget.content.cloneNode(true);
          previewContent.querySelector("img").src = e2.target.result;
          let wrapper = previewContent.querySelector('[data-controller="image-crop"]');
          wrapper.setAttribute("data-image-crop-content-type-value", this.originalFileContentTypeValue);
          this.previewWrapperTarget.appendChild(previewContent);
        };
        reader.readAsDataURL(file);
      } else {
        this.previewWrapperTarget.innerHTML = "";
      }
    }
    /* Only accept images as inline embeds */
    handleTrixFileAccept(event2) {
      const { type } = event2.file;
      const regex = /^image\/.+/;
      const isMatch = regex.test(type);
      if (!isMatch) {
        event2.preventDefault();
        toast("alert", "Unaccepted file type.", "flash");
      }
    }
    handleTrixAttachmentAdd(event2) {
      const contentType = event2.attachment?.attachment?.attributes?.values?.contentType;
      if (contentType == "image") {
        event2.attachment.remove();
      }
    }
  };
  _instances3 = new WeakSet();
  getFileExtension_fn = function(file) {
    if (!(file instanceof File)) {
      throw new Error("Input must be a File object");
    }
    const fileName = file.name;
    const fileNameParts = fileName.split(".");
    if (fileNameParts.length === 1) {
      return "";
    }
    return fileNameParts[fileNameParts.length - 1].toLowerCase();
  };
  __publicField(post_form_controller_default, "targets", [
    "browse",
    "clearImage",
    "fileField",
    "removeHiddenField",
    "previewWrapper",
    "previewImage",
    "previewTemplate",
    "submitBtn",
    "spaceSelect",
    "bodyEditor"
  ]);
  __publicField(post_form_controller_default, "classes", ["hidden"]);
  __publicField(post_form_controller_default, "values", {
    originalFileExtension: String,
    originalFileContentType: String
  });

  // app/javascript/customer_center/controllers/iframe_resizer_controller.js
  init_define_process();
  init_jquery();
  var iframe_resizer_controller_default = class extends application_controller_default {
    iframeLoaded() {
      this.resize();
      this.element.contentWindow.addEventListener("voomly:video:ready", this.resize.bind(this));
    }
    resize() {
      const height = this.element.contentWindow.document.body.scrollHeight;
      this.element.style.height = height + 50 + "px";
    }
  };

  // app/javascript/customer_center/controllers/trix_mentions_controller.js
  init_define_process();
  init_jquery();
  var import_tributejs = __toESM(require_tribute_min());
  var _instances4, validateMentionedUsers_fn;
  var trix_mentions_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      __privateAdd(this, _instances4);
    }
    connect() {
      this.editor = this.element.editor;
      this.initializeTribute();
    }
    disconnect() {
      this.tribute.detach(this.element);
    }
    initializeTribute() {
      this.tribute = new import_tributejs.default({
        allowSpaces: true,
        lookup: "full_name",
        containerClass: "tribute-container z-[1000]",
        itemClass: "text-color-weak content-md flex items-center",
        values: this.fetchUsers.bind(this),
        menuItemTemplate: function(item) {
          return '<img class="!size-6" src="' + item.original.avatar_url + '">' + item.string;
        }
      });
      this.tribute.attach(this.element);
      this.tribute.range.pasteHtml = this._pasteHtml.bind(this);
      this.element.addEventListener("tribute-replaced", this.replaced);
    }
    async fetchUsers(text, callback2) {
      const response2 = await get2(this.mentionableUsersUrlValue, {
        responseKind: "json",
        query: new URLSearchParams({ q: text })
      });
      if (response2.ok) {
        const body = await response2.json;
        callback2(body);
      } else {
        callback2([]);
      }
    }
    replaced(e2) {
      let mention = e2.detail.item.original;
      let attachment = new oo.Attachment({
        sgid: mention.sgid,
        content: mention.content,
        attachmentType: "mention"
      });
      this.editor.insertAttachment(attachment);
      this.editor.insertString(" ");
    }
    _pasteHtml(html, startPos, endPos) {
      let position = this.editor.getPosition();
      this.editor.setSelectedRange([position - (endPos - startPos), position]);
      this.editor.deleteInDirection("backward");
    }
    handleTopicChanged({ detail: { spaceId } }) {
      if (!this.hasMentionableUsersUrlValue) return;
      const url = new URL(this.mentionableUsersUrlValue, window.location.origin);
      if (!url.searchParams.has("space_id")) return;
      url.searchParams.set("space_id", spaceId);
      this.mentionableUsersUrlValue = url.pathname + url.search;
      __privateMethod(this, _instances4, validateMentionedUsers_fn).call(this, spaceId);
    }
  };
  _instances4 = new WeakSet();
  validateMentionedUsers_fn = async function(spaceId) {
    if (!this.hasValidateMembershipsPathValue) return;
    const mentions = this.editor.getDocument().getAttachments().filter((attachment) => attachment.attributes.values.attachmentType == "mention").map((attachment) => ({
      attachment,
      sgid: attachment.attributes.values.sgid,
      content: attachment.attributes.values.content
    }));
    if (mentions.length === 0) return;
    const response2 = await post(this.validateMembershipsPathValue, {
      body: JSON.stringify({
        space_id: spaceId,
        mentions: mentions.map((mention) => mention.sgid)
      }),
      responseKind: "json"
    });
    const validatedMentions = await response2.json;
    validatedMentions.forEach(({ sgid, valid }) => {
      if (valid) return;
      const mention = mentions.find((mention2) => mention2.sgid === sgid);
      if (!mention) return;
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = mention.content;
      const plainTextContent = (tempDiv.textContent || tempDiv.innerText).trim();
      const pieces = this.editor.getDocument().getPieces();
      const pieceIndex = pieces.findIndex((piece) => piece.attachment == mention.attachment);
      if (pieceIndex === -1) return;
      const position = pieces.slice(0, pieceIndex).reduce((sum, piece) => sum + piece.length, 0);
      this.editor.setSelectedRange([position, position + 1]);
      this.editor.deleteInDirection("forward");
      this.editor.insertString(plainTextContent);
    });
    if (validatedMentions.some(({ valid }) => !valid)) {
      toast("alert", "Some mentioned users were removed; They do not have access to this topic.", "flash", 5e3);
    }
  };
  __publicField(trix_mentions_controller_default, "values", {
    mentionableUsersUrl: String,
    validateMembershipsPath: String
  });

  // app/javascript/customer_center/controllers/activity_chart_controller.js
  init_define_process();
  init_jquery();

  // node_modules/stimulus-chartjs/dist/stimulus-chartjs.es.js
  init_define_process();
  init_jquery();

  // node_modules/stimulus-chartjs/node_modules/chart.js/auto/auto.mjs
  init_define_process();
  init_jquery();

  // node_modules/stimulus-chartjs/node_modules/chart.js/dist/chart.mjs
  init_define_process();
  init_jquery();

  // node_modules/stimulus-chartjs/node_modules/chart.js/dist/chunks/helpers.segment.mjs
  init_define_process();
  init_jquery();
  function noop3() {
  }
  var uid = /* @__PURE__ */ function() {
    let id = 0;
    return function() {
      return id++;
    };
  }();
  function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn3, args, thisArg) {
    if (fn3 && typeof fn3.call === "function") {
      return fn3.apply(thisArg, args);
    }
  }
  function each(loopable, fn3, thisArg, reverse) {
    let i3, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i3 = len - 1; i3 >= 0; i3--) {
          fn3.call(thisArg, loopable[i3], i3);
        }
      } else {
        for (i3 = 0; i3 < len; i3++) {
          fn3.call(thisArg, loopable[i3], i3);
        }
      }
    } else if (isObject(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i3 = 0; i3 < len; i3++) {
        fn3.call(thisArg, loopable[keys[i3]], keys[i3]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i3, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i3 = 0, ilen = a0.length; i3 < ilen; ++i3) {
      v0 = a0[i3];
      v1 = a1[i3];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone$1(source) {
    if (isArray(source)) {
      return source.map(clone$1);
    }
    if (isObject(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k4 = 0;
      for (; k4 < klen; ++k4) {
        target[keys[k4]] = clone$1(source[keys[k4]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone$1(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray(source) ? source : [source];
    const ilen = sources.length;
    if (!isObject(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    for (let i3 = 0; i3 < ilen; ++i3) {
      source = sources[i3];
      if (!isObject(source)) {
        continue;
      }
      const keys = Object.keys(source);
      for (let k4 = 0, klen = keys.length; k4 < klen; ++k4) {
        merger(keys[k4], target, source, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, { merger: _mergerIf });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone$1(sval);
    }
  }
  var keyResolvers = {
    "": (v4) => v4,
    x: (o3) => o3.x,
    y: (o3) => o3.y
  };
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k4 of keys) {
        if (k4 === "") {
          break;
        }
        obj = obj && obj[k4];
      }
      return obj;
    };
  }
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction = (value) => typeof value === "function";
  var setsEqual = (a5, b5) => {
    if (a5.size !== b5.size) {
      return false;
    }
    for (const item of a5) {
      if (!b5.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e2) {
    return e2.type === "mouseup" || e2.type === "click" || e2.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function niceNum(range2) {
    const roundedRange = Math.round(range2);
    range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
    const niceRange = Math.pow(10, Math.floor(log10(range2)));
    const fraction = range2 / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i3;
    for (i3 = 1; i3 < sqrt; i3++) {
      if (value % i3 === 0) {
        result.push(i3);
        result.push(value / i3);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a5, b5) => a5 - b5).pop();
    return result;
  }
  function isNumber(n3) {
    return !isNaN(parseFloat(n3)) && isFinite(n3);
  }
  function almostEquals(x4, y6, epsilon) {
    return Math.abs(x4 - y6) < epsilon;
  }
  function almostWhole(x4, epsilon) {
    const rounded = Math.round(x4);
    return rounded - epsilon <= x4 && rounded + epsilon >= x4;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i3, ilen, value;
    for (i3 = 0, ilen = array.length; i3 < ilen; i3++) {
      value = array[i3][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x4) {
    if (!isNumberFinite(x4)) {
      return;
    }
    let e2 = 1;
    let p4 = 0;
    while (Math.round(x4 * e2) / e2 !== x4) {
      e2 *= 10;
      p4++;
    }
    return p4;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt22) {
    return Math.sqrt(Math.pow(pt22.x - pt1.x, 2) + Math.pow(pt22.y - pt1.y, 2));
  }
  function _angleDiff(a5, b5) {
    return (a5 - b5 + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a5) {
    return (a5 % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start5, end2, sameAngleIsFullCircle) {
    const a5 = _normalizeAngle(angle);
    const s4 = _normalizeAngle(start5);
    const e2 = _normalizeAngle(end2);
    const angleToStart = _normalizeAngle(s4 - a5);
    const angleToEnd = _normalizeAngle(e2 - a5);
    const startToAngle = _normalizeAngle(a5 - s4);
    const endToAngle = _normalizeAngle(a5 - e2);
    return a5 === s4 || a5 === e2 || sameAngleIsFullCircle && s4 === e2 || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min3, max3) {
    return Math.max(min3, Math.min(max3, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start5, end2, epsilon = 1e-6) {
    return value >= Math.min(start5, end2) - epsilon && value <= Math.max(start5, end2) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index2) => table[index2] < value);
    let hi2 = table.length - 1;
    let lo = 0;
    let mid;
    while (hi2 - lo > 1) {
      mid = lo + hi2 >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi2 = mid;
      }
    }
    return { lo, hi: hi2 };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => table[index2][key] <= value : (index2) => table[index2][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
  function _filterBetween(values, min3, max3) {
    let start5 = 0;
    let end2 = values.length;
    while (start5 < end2 && values[start5] < min3) {
      start5++;
    }
    while (end2 > start5 && values[end2 - 1] > max3) {
      end2--;
    }
    return start5 > 0 || end2 < values.length ? values.slice(start5, end2) : values;
  }
  var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [listener]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = /* @__PURE__ */ new Set();
    let i3, ilen;
    for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
      set2.add(items[i3]);
    }
    if (set2.size === ilen) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn3, thisArg, updateFn) {
    const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
    let ticking = false;
    let args = [];
    return function(...rest) {
      args = updateArgs(rest);
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn3.apply(thisArg, args);
        });
      }
    };
  }
  function debounce5(fn3, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn3, delay, args);
      } else {
        fn3.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start5, end2) => align === "start" ? start5 : align === "end" ? end2 : (start5 + end2) / 2;
  var _textX = (align, left2, right2, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right2 : align === "center" ? (left2 + right2) / 2 : left2;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start5 = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, _parsed } = meta;
      const axis = iScale.axis;
      const { min: min3, max: max3, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start5 = _limitValue(
          Math.min(
            _lookupByKey(_parsed, iScale.axis, min3).lo,
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min3)).lo
          ),
          0,
          pointCount - 1
        );
      }
      if (maxDefined) {
        count = _limitValue(
          Math.max(
            _lookupByKey(_parsed, iScale.axis, max3, true).hi + 1,
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max3), true).hi + 1
          ),
          start5,
          pointCount
        ) - start5;
      } else {
        count = pointCount - start5;
      }
    }
    return { start: start5, count };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t4) => t4 === 0 || t4 === 1;
  var elasticIn = (t4, s4, p4) => -(Math.pow(2, 10 * (t4 -= 1)) * Math.sin((t4 - s4) * TAU / p4));
  var elasticOut = (t4, s4, p4) => Math.pow(2, -10 * t4) * Math.sin((t4 - s4) * TAU / p4) + 1;
  var effects = {
    linear: (t4) => t4,
    easeInQuad: (t4) => t4 * t4,
    easeOutQuad: (t4) => -t4 * (t4 - 2),
    easeInOutQuad: (t4) => (t4 /= 0.5) < 1 ? 0.5 * t4 * t4 : -0.5 * (--t4 * (t4 - 2) - 1),
    easeInCubic: (t4) => t4 * t4 * t4,
    easeOutCubic: (t4) => (t4 -= 1) * t4 * t4 + 1,
    easeInOutCubic: (t4) => (t4 /= 0.5) < 1 ? 0.5 * t4 * t4 * t4 : 0.5 * ((t4 -= 2) * t4 * t4 + 2),
    easeInQuart: (t4) => t4 * t4 * t4 * t4,
    easeOutQuart: (t4) => -((t4 -= 1) * t4 * t4 * t4 - 1),
    easeInOutQuart: (t4) => (t4 /= 0.5) < 1 ? 0.5 * t4 * t4 * t4 * t4 : -0.5 * ((t4 -= 2) * t4 * t4 * t4 - 2),
    easeInQuint: (t4) => t4 * t4 * t4 * t4 * t4,
    easeOutQuint: (t4) => (t4 -= 1) * t4 * t4 * t4 * t4 + 1,
    easeInOutQuint: (t4) => (t4 /= 0.5) < 1 ? 0.5 * t4 * t4 * t4 * t4 * t4 : 0.5 * ((t4 -= 2) * t4 * t4 * t4 * t4 + 2),
    easeInSine: (t4) => -Math.cos(t4 * HALF_PI) + 1,
    easeOutSine: (t4) => Math.sin(t4 * HALF_PI),
    easeInOutSine: (t4) => -0.5 * (Math.cos(PI * t4) - 1),
    easeInExpo: (t4) => t4 === 0 ? 0 : Math.pow(2, 10 * (t4 - 1)),
    easeOutExpo: (t4) => t4 === 1 ? 1 : -Math.pow(2, -10 * t4) + 1,
    easeInOutExpo: (t4) => atEdge(t4) ? t4 : t4 < 0.5 ? 0.5 * Math.pow(2, 10 * (t4 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t4 * 2 - 1)) + 2),
    easeInCirc: (t4) => t4 >= 1 ? t4 : -(Math.sqrt(1 - t4 * t4) - 1),
    easeOutCirc: (t4) => Math.sqrt(1 - (t4 -= 1) * t4),
    easeInOutCirc: (t4) => (t4 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t4 * t4) - 1) : 0.5 * (Math.sqrt(1 - (t4 -= 2) * t4) + 1),
    easeInElastic: (t4) => atEdge(t4) ? t4 : elasticIn(t4, 0.075, 0.3),
    easeOutElastic: (t4) => atEdge(t4) ? t4 : elasticOut(t4, 0.075, 0.3),
    easeInOutElastic(t4) {
      const s4 = 0.1125;
      const p4 = 0.45;
      return atEdge(t4) ? t4 : t4 < 0.5 ? 0.5 * elasticIn(t4 * 2, s4, p4) : 0.5 + 0.5 * elasticOut(t4 * 2 - 1, s4, p4);
    },
    easeInBack(t4) {
      const s4 = 1.70158;
      return t4 * t4 * ((s4 + 1) * t4 - s4);
    },
    easeOutBack(t4) {
      const s4 = 1.70158;
      return (t4 -= 1) * t4 * ((s4 + 1) * t4 + s4) + 1;
    },
    easeInOutBack(t4) {
      let s4 = 1.70158;
      if ((t4 /= 0.5) < 1) {
        return 0.5 * (t4 * t4 * (((s4 *= 1.525) + 1) * t4 - s4));
      }
      return 0.5 * ((t4 -= 2) * t4 * (((s4 *= 1.525) + 1) * t4 + s4) + 2);
    },
    easeInBounce: (t4) => 1 - effects.easeOutBounce(1 - t4),
    easeOutBounce(t4) {
      const m4 = 7.5625;
      const d5 = 2.75;
      if (t4 < 1 / d5) {
        return m4 * t4 * t4;
      }
      if (t4 < 2 / d5) {
        return m4 * (t4 -= 1.5 / d5) * t4 + 0.75;
      }
      if (t4 < 2.5 / d5) {
        return m4 * (t4 -= 2.25 / d5) * t4 + 0.9375;
      }
      return m4 * (t4 -= 2.625 / d5) * t4 + 0.984375;
    },
    easeInOutBounce: (t4) => t4 < 0.5 ? effects.easeInBounce(t4 * 2) * 0.5 : effects.easeOutBounce(t4 * 2 - 1) * 0.5 + 0.5
  };
  function round4(v4) {
    return v4 + 0.5 | 0;
  }
  var lim = (v4, l5, h4) => Math.max(Math.min(v4, h4), l5);
  function p2b(v4) {
    return lim(round4(v4 * 2.55), 0, 255);
  }
  function n2b(v4) {
    return lim(round4(v4 * 255), 0, 255);
  }
  function b2n(v4) {
    return lim(round4(v4 / 2.55) / 100, 0, 1);
  }
  function n2p(v4) {
    return lim(round4(v4 * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b5) => hex[b5 & 15];
  var h2 = (b5) => hex[(b5 & 240) >> 4] + hex[b5 & 15];
  var eq = (b5) => (b5 & 240) >> 4 === (b5 & 15);
  var isShort = (v4) => eq(v4.r) && eq(v4.g) && eq(v4.b) && eq(v4.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a5, f4) => a5 < 255 ? f4(a5) : "";
  function hexString(v4) {
    var f4 = isShort(v4) ? h1 : h2;
    return v4 ? "#" + f4(v4.r) + f4(v4.g) + f4(v4.b) + alpha(v4.a, f4) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h4, s4, l5) {
    const a5 = s4 * Math.min(l5, 1 - l5);
    const f4 = (n3, k4 = (n3 + h4 / 30) % 12) => l5 - a5 * Math.max(Math.min(k4 - 3, 9 - k4, 1), -1);
    return [f4(0), f4(8), f4(4)];
  }
  function hsv2rgbn(h4, s4, v4) {
    const f4 = (n3, k4 = (n3 + h4 / 60) % 6) => v4 - v4 * s4 * Math.max(Math.min(k4, 4 - k4, 1), 0);
    return [f4(5), f4(3), f4(1)];
  }
  function hwb2rgbn(h4, w5, b5) {
    const rgb = hsl2rgbn(h4, 1, 0.5);
    let i3;
    if (w5 + b5 > 1) {
      i3 = 1 / (w5 + b5);
      w5 *= i3;
      b5 *= i3;
    }
    for (i3 = 0; i3 < 3; i3++) {
      rgb[i3] *= 1 - w5 - b5;
      rgb[i3] += w5;
    }
    return rgb;
  }
  function hueValue(r3, g4, b5, d5, max3) {
    if (r3 === max3) {
      return (g4 - b5) / d5 + (g4 < b5 ? 6 : 0);
    }
    if (g4 === max3) {
      return (b5 - r3) / d5 + 2;
    }
    return (r3 - g4) / d5 + 4;
  }
  function rgb2hsl(v4) {
    const range2 = 255;
    const r3 = v4.r / range2;
    const g4 = v4.g / range2;
    const b5 = v4.b / range2;
    const max3 = Math.max(r3, g4, b5);
    const min3 = Math.min(r3, g4, b5);
    const l5 = (max3 + min3) / 2;
    let h4, s4, d5;
    if (max3 !== min3) {
      d5 = max3 - min3;
      s4 = l5 > 0.5 ? d5 / (2 - max3 - min3) : d5 / (max3 + min3);
      h4 = hueValue(r3, g4, b5, d5, max3);
      h4 = h4 * 60 + 0.5;
    }
    return [h4 | 0, s4 || 0, l5];
  }
  function calln(f4, a5, b5, c4) {
    return (Array.isArray(a5) ? f4(a5[0], a5[1], a5[2]) : f4(a5, b5, c4)).map(n2b);
  }
  function hsl2rgb(h4, s4, l5) {
    return calln(hsl2rgbn, h4, s4, l5);
  }
  function hwb2rgb(h4, w5, b5) {
    return calln(hwb2rgbn, h4, w5, b5);
  }
  function hsv2rgb(h4, s4, v4) {
    return calln(hsv2rgbn, h4, s4, v4);
  }
  function hue(h4) {
    return (h4 % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m4 = HUE_RE.exec(str);
    let a5 = 255;
    let v4;
    if (!m4) {
      return;
    }
    if (m4[5] !== v4) {
      a5 = m4[6] ? p2b(+m4[5]) : n2b(+m4[5]);
    }
    const h4 = hue(+m4[2]);
    const p1 = +m4[3] / 100;
    const p22 = +m4[4] / 100;
    if (m4[1] === "hwb") {
      v4 = hwb2rgb(h4, p1, p22);
    } else if (m4[1] === "hsv") {
      v4 = hsv2rgb(h4, p1, p22);
    } else {
      v4 = hsl2rgb(h4, p1, p22);
    }
    return {
      r: v4[0],
      g: v4[1],
      b: v4[2],
      a: a5
    };
  }
  function rotate(v4, deg) {
    var h4 = rgb2hsl(v4);
    h4[0] = hue(h4[0] + deg);
    h4 = hsl2rgb(h4);
    v4.r = h4[0];
    v4.g = h4[1];
    v4.b = h4[2];
  }
  function hslString(v4) {
    if (!v4) {
      return;
    }
    const a5 = rgb2hsl(v4);
    const h4 = a5[0];
    const s4 = n2p(a5[1]);
    const l5 = n2p(a5[2]);
    return v4.a < 255 ? `hsla(${h4}, ${s4}%, ${l5}%, ${b2n(v4.a)})` : `hsl(${h4}, ${s4}%, ${l5}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i3, j6, k4, ok, nk;
    for (i3 = 0; i3 < keys.length; i3++) {
      ok = nk = keys[i3];
      for (j6 = 0; j6 < tkeys.length; j6++) {
        k4 = tkeys[j6];
        nk = nk.replace(k4, map[k4]);
      }
      k4 = parseInt(names$1[ok], 16);
      unpacked[nk] = [k4 >> 16 & 255, k4 >> 8 & 255, k4 & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a5 = names[str.toLowerCase()];
    return a5 && {
      r: a5[0],
      g: a5[1],
      b: a5[2],
      a: a5.length === 4 ? a5[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m4 = RGB_RE.exec(str);
    let a5 = 255;
    let r3, g4, b5;
    if (!m4) {
      return;
    }
    if (m4[7] !== r3) {
      const v4 = +m4[7];
      a5 = m4[8] ? p2b(v4) : lim(v4 * 255, 0, 255);
    }
    r3 = +m4[1];
    g4 = +m4[3];
    b5 = +m4[5];
    r3 = 255 & (m4[2] ? p2b(r3) : lim(r3, 0, 255));
    g4 = 255 & (m4[4] ? p2b(g4) : lim(g4, 0, 255));
    b5 = 255 & (m4[6] ? p2b(b5) : lim(b5, 0, 255));
    return {
      r: r3,
      g: g4,
      b: b5,
      a: a5
    };
  }
  function rgbString(v4) {
    return v4 && (v4.a < 255 ? `rgba(${v4.r}, ${v4.g}, ${v4.b}, ${b2n(v4.a)})` : `rgb(${v4.r}, ${v4.g}, ${v4.b})`);
  }
  var to2 = (v4) => v4 <= 31308e-7 ? v4 * 12.92 : Math.pow(v4, 1 / 2.4) * 1.055 - 0.055;
  var from = (v4) => v4 <= 0.04045 ? v4 / 12.92 : Math.pow((v4 + 0.055) / 1.055, 2.4);
  function interpolate2(rgb1, rgb2, t4) {
    const r3 = from(b2n(rgb1.r));
    const g4 = from(b2n(rgb1.g));
    const b5 = from(b2n(rgb1.b));
    return {
      r: n2b(to2(r3 + t4 * (from(b2n(rgb2.r)) - r3))),
      g: n2b(to2(g4 + t4 * (from(b2n(rgb2.g)) - g4))),
      b: n2b(to2(b5 + t4 * (from(b2n(rgb2.b)) - b5))),
      a: rgb1.a + t4 * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v4, i3, ratio) {
    if (v4) {
      let tmp = rgb2hsl(v4);
      tmp[i3] = Math.max(0, Math.min(tmp[i3] + tmp[i3] * ratio, i3 === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v4.r = tmp[0];
      v4.g = tmp[1];
      v4.b = tmp[2];
    }
  }
  function clone(v4, proto) {
    return v4 ? Object.assign(proto || {}, v4) : v4;
  }
  function fromObject(input) {
    var v4 = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v4 = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v4.a = n2b(input[3]);
        }
      }
    } else {
      v4 = clone(input, { r: 0, g: 0, b: 0, a: 1 });
      v4.a = n2b(v4.a);
    }
    return v4;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class _Color {
    constructor(input) {
      if (input instanceof _Color) {
        return input;
      }
      const type = typeof input;
      let v4;
      if (type === "object") {
        v4 = fromObject(input);
      } else if (type === "string") {
        v4 = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v4;
      this._valid = !!v4;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v4 = clone(this._rgb);
      if (v4) {
        v4.a = b2n(v4.a);
      }
      return v4;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c22 = color2.rgb;
        let w22;
        const p4 = weight === w22 ? 0.5 : weight;
        const w5 = 2 * p4 - 1;
        const a5 = c1.a - c22.a;
        const w1 = ((w5 * a5 === -1 ? w5 : (w5 + a5) / (1 + w5 * a5)) + 1) / 2;
        w22 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w22 * c22.r + 0.5;
        c1.g = 255 & w1 * c1.g + w22 * c22.g + 0.5;
        c1.b = 255 & w1 * c1.b + w22 * c22.b + 0.5;
        c1.a = p4 * c1.a + (1 - p4) * c22.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t4) {
      if (color2) {
        this._rgb = interpolate2(this._rgb, color2._rgb, t4);
      }
      return this;
    }
    clone() {
      return new _Color(this.rgb);
    }
    alpha(a5) {
      this._rgb.a = n2b(a5);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round4(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v4 = this._rgb;
      v4.r = 255 - v4.r;
      v4.g = 255 - v4.g;
      v4.b = 255 - v4.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };
  function index_esm(input) {
    return new Color(input);
  }
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : index_esm(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i3 = 0, n3 = keys.length; i3 < n3; ++i3) {
      const k4 = keys[i3];
      node = node[k4] || (node[k4] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context2) => context2.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name2, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name2;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name2],
          writable: true
        },
        [name2]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
  };
  var defaults2 = new Defaults({
    _scriptable: (name2) => !name2.startsWith("on"),
    _indexable: (name2) => name2 !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  });
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache2) {
    cache2 = cache2 || {};
    let data = cache2.data = cache2.data || {};
    let gc = cache2.garbageCollect = cache2.garbageCollect || [];
    if (cache2.font !== font) {
      data = cache2.data = {};
      gc = cache2.garbageCollect = [];
      cache2.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i3, j6, jlen, thing, nestedThing;
    for (i3 = 0; i3 < ilen; i3++) {
      thing = arrayOfThings[i3];
      if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j6 = 0, jlen = thing.length; j6 < jlen; j6++) {
          nestedThing = thing[j6];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i3 = 0; i3 < gcLen; i3++) {
        delete data[gc[i3]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x4, y6) {
    drawPointLegend(ctx, options, x4, y6, null);
  }
  function drawPointLegend(ctx, options, x4, y6, w5) {
    let type, xOffset, yOffset, size3, cornerRadius, width;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x4, y6);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w5) {
          ctx.ellipse(x4, y6, w5 / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x4, y6, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        ctx.moveTo(x4 + Math.sin(rad) * radius, y6 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x4 + Math.sin(rad) * radius, y6 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x4 + Math.sin(rad) * radius, y6 - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size3 = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size3;
        yOffset = Math.sin(rad + QUARTER_PI) * size3;
        ctx.arc(x4 - xOffset, y6 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x4 + yOffset, y6 - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x4 + xOffset, y6 + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x4 - yOffset, y6 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size3 = Math.SQRT1_2 * radius;
          width = w5 ? w5 / 2 : size3;
          ctx.rect(x4 - width, y6 - size3, 2 * width, 2 * size3);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x4 - xOffset, y6 - yOffset);
        ctx.lineTo(x4 + yOffset, y6 - xOffset);
        ctx.lineTo(x4 + xOffset, y6 + yOffset);
        ctx.lineTo(x4 - yOffset, y6 + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x4 - xOffset, y6 - yOffset);
        ctx.lineTo(x4 + xOffset, y6 + yOffset);
        ctx.moveTo(x4 + yOffset, y6 - xOffset);
        ctx.lineTo(x4 - yOffset, y6 + xOffset);
        break;
      case "star":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x4 - xOffset, y6 - yOffset);
        ctx.lineTo(x4 + xOffset, y6 + yOffset);
        ctx.moveTo(x4 + yOffset, y6 - xOffset);
        ctx.lineTo(x4 - yOffset, y6 + xOffset);
        rad += QUARTER_PI;
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x4 - xOffset, y6 - yOffset);
        ctx.lineTo(x4 + xOffset, y6 + yOffset);
        ctx.moveTo(x4 + yOffset, y6 - xOffset);
        ctx.lineTo(x4 - yOffset, y6 + xOffset);
        break;
      case "line":
        xOffset = w5 ? w5 / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x4 - xOffset, y6 - yOffset);
        ctx.lineTo(x4 + xOffset, y6 + yOffset);
        break;
      case "dash":
        ctx.moveTo(x4, y6);
        ctx.lineTo(x4 + Math.cos(rad) * radius, y6 + Math.sin(rad) * radius);
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip4, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip4) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip4) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(
      flip4 ? previous.cp1x : previous.cp2x,
      flip4 ? previous.cp1y : previous.cp2y,
      flip4 ? target.cp2x : target.cp1x,
      flip4 ? target.cp2y : target.cp1y,
      target.x,
      target.y
    );
  }
  function renderText(ctx, text, x4, y6, font, opts = {}) {
    const lines = isArray(text) ? text : [text];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i3, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i3 = 0; i3 < lines.length; ++i3) {
      line = lines[i3];
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x4, y6, opts.maxWidth);
      }
      ctx.fillText(line, x4, y6, opts.maxWidth);
      decorateText(ctx, x4, y6, line, opts);
      y6 += font.lineHeight;
    }
    ctx.restore();
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x4, y6, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left2 = x4 - metrics.actualBoundingBoxLeft;
      const right2 = x4 + metrics.actualBoundingBoxRight;
      const top2 = y6 - metrics.actualBoundingBoxAscent;
      const bottom2 = y6 + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left2, yDecoration);
      ctx.lineTo(right2, yDecoration);
      ctx.stroke();
    }
  }
  function addRoundedRectPath(ctx, rect) {
    const { x: x4, y: y6, w: w5, h: h4, radius } = rect;
    ctx.arc(x4 + radius.topLeft, y6 + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
    ctx.lineTo(x4, y6 + h4 - radius.bottomLeft);
    ctx.arc(x4 + radius.bottomLeft, y6 + h4 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x4 + w5 - radius.bottomRight, y6 + h4);
    ctx.arc(x4 + w5 - radius.bottomRight, y6 + h4 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x4 + w5, y6 + radius.topRight);
    ctx.arc(x4 + w5 - radius.topRight, y6 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x4 + radius.topLeft, y6);
  }
  var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
  var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
  function toLineHeight(value, size3) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size3 * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size3 * value;
  }
  var numberOrZero = (v4) => +v4 || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read2 = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read2(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults2.font;
    let size3 = valueOrDefault(options.size, fallback.size);
    if (typeof size3 === "string") {
      size3 = parseInt(size3, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = "";
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size3),
      size: size3,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context2, index2, info) {
    let cacheable = true;
    let i3, ilen, value;
    for (i3 = 0, ilen = inputs.length; i3 < ilen; ++i3) {
      value = inputs[i3];
      if (value === void 0) {
        continue;
      }
      if (context2 !== void 0 && typeof value === "function") {
        value = value(context2);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray(value)) {
        value = value[index2 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min: min3, max: max3 } = minmax;
    const change = toDimension(grace, (max3 - min3) / 2);
    const keepZero = (value, add3) => beginAtZero && value === 0 ? 0 : value + add3;
    return {
      min: keepZero(min3, -Math.abs(change)),
      max: keepZero(max3, change)
    };
  }
  function createContext(parentContext, context2) {
    return Object.assign(Object.create(parentContext), context2);
  }
  function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
    if (!defined(fallback)) {
      fallback = _resolve("_fallback", scopes);
    }
    const cache2 = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: rootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
    };
    return new Proxy(cache2, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      get(target, prop) {
        return _cached(
          target,
          prop,
          () => _resolveWithPrefixes(prop, prefixes, scopes, target)
        );
      },
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context2, subProxy, descriptorDefaults) {
    const cache2 = {
      _cacheable: false,
      _proxy: proxy,
      _context: context2,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context2, subProxy, descriptorDefaults)
    };
    return new Proxy(cache2, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      get(target, prop, receiver) {
        return _cached(
          target,
          prop,
          () => _resolveWithContext(target, prop, receiver)
        );
      },
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults3 = { scriptable: true, indexable: true }) {
    const { _scriptable = defaults3.scriptable, _indexable = defaults3.indexable, _allKeys = defaults3.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix2, name2) => prefix2 ? prefix2 + _capitalize(name2) : name2;
  var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, value, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    value = value(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (defined(_context.index) && isIndexable(prop)) {
      value = value[_context.index % value.length];
    } else if (isObject(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s4) => s4 !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [...parentScopes, ...rootScopes];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (defined(fallback) && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(
      Array.from(set2),
      [""],
      rootScopes,
      fallback,
      () => subGetTarget(resolver, prop, value)
    );
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value)) {
      return value;
    }
    return target;
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix2 of prefixes) {
      value = _resolve(readKey(prefix2, prop), scopes);
      if (defined(value)) {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (defined(value)) {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k4) => !k4.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start5, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i3, ilen, index2, item;
    for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
      index2 = i3 + start5;
      item = data[index2];
      parsed[i3] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i3) => i3 < points.length && !points[i3].skip && points[i3];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t4) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t4 * s01;
    const fb = t4 * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i3 = 0; i3 < pointsLen - 1; ++i3) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i3 + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i3], 0, EPSILON)) {
        mK[i3] = mK[i3 + 1] = 0;
        continue;
      }
      alphaK = mK[i3] / deltaK[i3];
      betaK = mK[i3 + 1] / deltaK[i3];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i3] = alphaK * tauK * deltaK[i3];
      mK[i3 + 1] = betaK * tauK * deltaK[i3];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i3 = 0; i3 < pointsLen; ++i3) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i3 + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i3];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i3];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i3, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i3 = 0; i3 < pointsLen; ++i3) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i3 + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i3] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i3] = !pointBefore ? deltaK[i3] : !pointAfter ? deltaK[i3 - 1] : sign(deltaK[i3 - 1]) !== sign(deltaK[i3]) ? 0 : (deltaK[i3 - 1] + deltaK[i3]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt3, min3, max3) {
    return Math.max(Math.min(pt3, max3), min3);
  }
  function capBezierPoints(points, area) {
    let i3, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i3 = 0, ilen = points.length; i3 < ilen; ++i3) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i3 < ilen - 1 && _isPointInArea(points[i3 + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i3];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i3, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt3) => !pt3.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i3 = 0, ilen = points.length; i3 < ilen; ++i3) {
        point = points[i3];
        controlPoints = splineCurve(
          prev,
          point,
          points[Math.min(i3 + 1, ilen - (loop ? 0 : 1)) % ilen],
          options.tension
        );
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle4 = (element) => window.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle4(el).getPropertyValue(property);
  }
  var positions = ["top", "right", "bottom", "left"];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i3 = 0; i3 < 4; i3++) {
      const pos = positions[i3];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x4, y6, target) => (x4 > 0 || y6 > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e2, canvas) {
    const touches = e2.touches;
    const source = touches && touches.length ? touches[0] : e2;
    const { offsetX, offsetY } = source;
    let box = false;
    let x4, y6;
    if (useOffsetPos(offsetX, offsetY, e2.target)) {
      x4 = offsetX;
      y6 = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x4 = source.clientX - rect.left;
      y6 = source.clientY - rect.top;
      box = true;
    }
    return { x: x4, y: y6, box };
  }
  function getRelativePosition(evt, chart) {
    if ("native" in evt) {
      return evt;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle4(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x: x4, y: y6, box } = getCanvasPosition(evt, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x4 - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y6 - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle4(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v4) => Math.round(v4 * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle4(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = deviceHeight / pixelRatio;
    chart.width = deviceWidth / pixelRatio;
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    } catch (e2) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p22, t4, mode) {
    return {
      x: p1.x + t4 * (p22.x - p1.x),
      y: p1.y + t4 * (p22.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p22, t4, mode) {
    return {
      x: p1.x + t4 * (p22.x - p1.x),
      y: mode === "middle" ? t4 < 0.5 ? p1.y : p22.y : mode === "after" ? t4 < 1 ? p1.y : p22.y : t4 > 0 ? p22.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p22, t4, mode) {
    const cp1 = { x: p1.cp2x, y: p1.cp2y };
    const cp2 = { x: p22.cp1x, y: p22.cp1y };
    const a5 = _pointInLine(p1, cp1, t4);
    const b5 = _pointInLine(cp1, cp2, t4);
    const c4 = _pointInLine(cp2, p22, t4);
    const d5 = _pointInLine(a5, b5, t4);
    const e2 = _pointInLine(b5, c4, t4);
    return _pointInLine(d5, e2, t4);
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x4) {
        return rectX + rectX + width - x4;
      },
      setWidth(w5) {
        width = w5;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x4, value) {
        return x4 - value;
      },
      leftForLtr(x4, itemWidth) {
        return x4 - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x4) {
        return x4;
      },
      setWidth(w5) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x4, value) {
        return x4 + value;
      },
      leftForLtr(x4, _itemWidth) {
        return x4;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a5, b5) => a5 - b5,
      normalize: (x4) => x4
    };
  }
  function normalizeSegment({ start: start5, end: end2, count, loop, style }) {
    return {
      start: start5 % count,
      end: end2 % count,
      loop: loop && (end2 - start5 + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start: start5, end: end2, loop } = segment;
    let i3, ilen;
    if (loop) {
      start5 += count;
      end2 += count;
      for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
        if (!between(normalize(points[start5 % count][property]), startBound, endBound)) {
          break;
        }
        start5--;
        end2--;
      }
      start5 %= count;
      end2 %= count;
    }
    if (end2 < start5) {
      end2 += count;
    }
    return { start: start5, end: end2, loop, style: segment.style };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [segment];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start: start5, end: end2, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i3 = start5, prev = start5; i3 <= end2; ++i3) {
      point = points[i3 % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i3 : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({ start: subStart, end: i3, loop, count, style }));
        subStart = null;
      }
      prev = i3;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({ start: subStart, end: end2, loop, count, style }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i3 = 0; i3 < segments.length; i3++) {
      const sub = _boundSegment(segments[i3], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start5 = 0;
    let end2 = count - 1;
    if (loop && !spanGaps) {
      while (start5 < count && !points[start5].skip) {
        start5++;
      }
    }
    while (start5 < count && points[start5].skip) {
      start5++;
    }
    start5 %= count;
    if (loop) {
      end2 += start5;
    }
    while (end2 > start5 && points[end2 % count].skip) {
      end2--;
    }
    end2 %= count;
    return { start: start5, end: end2 };
  }
  function solidSegments(points, start5, max3, loop) {
    const count = points.length;
    const result = [];
    let last = start5;
    let prev = points[start5];
    let end2;
    for (end2 = start5 + 1; end2 <= max3; ++end2) {
      const cur = points[end2 % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({ start: start5 % count, end: (end2 - 1) % count, loop });
          start5 = last = cur.stop ? end2 : null;
        }
      } else {
        last = end2;
        if (prev.skip) {
          start5 = end2;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({ start: start5 % count, end: last % count, loop });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start: start5, end: end2 } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [{ start: start5, end: end2, loop }], points, segmentOptions);
    }
    const max3 = end2 < start5 ? end2 + count : end2;
    const completeLoop = !!line._fullLoop && start5 === 0 && end2 === count - 1;
    return splitByStyles(line, solidSegments(points, start5, max3, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start5 = segments[0].start;
    let i3 = start5;
    function addStyle(s4, e2, l5, st3) {
      const dir = spanGaps ? -1 : 1;
      if (s4 === e2) {
        return;
      }
      s4 += count;
      while (points[s4 % count].skip) {
        s4 -= dir;
      }
      while (points[e2 % count].skip) {
        e2 += dir;
      }
      if (s4 % count !== e2 % count) {
        result.push({ start: s4 % count, end: e2 % count, loop: l5, style: st3 });
        prevStyle = st3;
        start5 = e2 % count;
      }
    }
    for (const segment of segments) {
      start5 = spanGaps ? start5 : segment.start;
      let prev = points[start5 % count];
      let style;
      for (i3 = start5 + 1; i3 <= segment.end; i3++) {
        const pt3 = points[i3 % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt3,
          p0DataIndex: (i3 - 1) % count,
          p1DataIndex: i3 % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start5, i3 - 1, segment.loop, prevStyle);
        }
        prev = pt3;
        prevStyle = style;
      }
      if (start5 < i3 - 1) {
        addStyle(start5, i3 - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
  }

  // node_modules/stimulus-chartjs/node_modules/chart.js/dist/chart.mjs
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn3) => fn3({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i3 = items.length - 1;
        let draw2 = false;
        let item;
        for (; i3 >= 0; --i3) {
          item = items[i3];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i3] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event2, cb) {
      this._getAnims(chart).listeners[event2].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i3 = items.length - 1;
      for (; i3 >= 0; --i3) {
        items[i3].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to3, factor) {
      return factor > 0.5 ? to3 : from2;
    },
    color(from2, to3, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to3 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to3;
    },
    number(from2, to3, factor) {
      return from2 + (to3 - from2) * factor;
    }
  };
  var Animation2 = class {
    constructor(cfg, target, prop, to3) {
      const currentValue = target[prop];
      to3 = resolve([cfg.to, to3, currentValue, cfg.from]);
      const from2 = resolve([cfg.from, currentValue, to3]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to3;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to3, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([cfg.to, to3, currentValue, cfg.from]);
        this._from = resolve([cfg.from, currentValue, to3]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop = this._loop;
      const to3 = this._to;
      let factor;
      this._active = from2 !== to3 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to3;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to3, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({ res, rej });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i3 = 0; i3 < promises.length; i3++) {
        promises[i3][method]();
      }
    }
  };
  var numbers = ["x", "y", "borderWidth", "radius", "tension"];
  var colors = ["color", "borderColor", "backgroundColor"];
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  var animationOptions = Object.keys(defaults2.animation);
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v4) => v4 | 0
        }
      }
    }
  });
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject(config)) {
        return;
      }
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i3;
      for (i3 = props.length - 1; i3 >= 0; --i3) {
        const prop = props[i3];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation2(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i3 = 0; i3 < keys.length; i3++) {
      const anim = animations[keys[i3]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min3 = opts.min === void 0 ? allowedOverflow : 0;
    const max3 = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max3 : min3,
      end: reverse ? min3 : max3
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x4 = scaleClip(xScale, allowedOverflow);
    const y6 = scaleClip(yScale, allowedOverflow);
    return {
      top: y6.end,
      right: x4.end,
      bottom: y6.start,
      left: x4.start
    };
  }
  function toClip(value) {
    let t4, r3, b5, l5;
    if (isObject(value)) {
      t4 = value.top;
      r3 = value.right;
      b5 = value.bottom;
      l5 = value.left;
    } else {
      t4 = r3 = b5 = l5 = value;
    }
    return {
      top: t4,
      right: r3,
      bottom: b5,
      left: l5,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i3, ilen;
    for (i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
      keys.push(metasets[i3].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i3, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    for (i3 = 0, ilen = keys.length; i3 < ilen; ++i3) {
      datasetIndex = +keys[i3];
      if (datasetIndex === dsIndex) {
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
        value += otherValue;
      }
    }
    return value;
  }
  function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i3, ilen, key;
    for (i3 = 0, ilen = keys.length; i3 < ilen; ++i3) {
      key = keys[i3];
      adata[i3] = {
        x: key,
        y: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min: min3, max: max3, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min3 : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max3 : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i3 = 0; i3 < ilen; ++i3) {
      const item = parsed[i3];
      const { [iAxis]: index2, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext(
      parent,
      {
        active: false,
        dataset: void 0,
        datasetIndex: index2,
        index: index2,
        mode: "default",
        type: "dataset"
      }
    );
  }
  function createDataContext(parent, index2, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x4, y6, r3) => axis === "x" ? x4 : axis === "r" ? r3 : y6;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject(data)) {
        this._data = convertObjectDataToArray(data);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start5, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start5 === 0 && count === data.length ? true : meta._sorted;
      let prev = start5 > 0 && meta._parsed[start5 - 1];
      let i3, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray(data[start5])) {
          parsed = this.parseArrayData(meta, data, start5, count);
        } else if (isObject(data[start5])) {
          parsed = this.parseObjectData(meta, data, start5, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start5, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i3 = 0; i3 < count; ++i3) {
          meta._parsed[i3 + start5] = cur = parsed[i3];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start5, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i3, ilen, index2;
      for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
        index2 = i3 + start5;
        parsed[i3] = {
          [iAxis]: singleScale || iScale.parse(labels[index2], index2),
          [vAxis]: vScale.parse(data[index2], index2)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start5, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i3, ilen, index2, item;
      for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
        index2 = i3 + start5;
        item = data[index2];
        parsed[i3] = {
          x: xScale.parse(item[0], index2),
          y: yScale.parse(item[1], index2)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start5, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i3, ilen, index2, item;
      for (i3 = 0, ilen = count; i3 < ilen; ++i3) {
        index2 = i3 + start5;
        item = data[index2];
        parsed[i3] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
        };
      }
      return parsed;
    }
    getParsed(index2) {
      return this._cachedMeta._parsed[index2];
    }
    getDataElement(index2) {
      return this._cachedMeta.data[index2];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]
      };
      return applyStack(stack, value, meta.index, { mode });
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range2.min = Math.min(range2.min, value);
      range2.max = Math.max(range2.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i3, parsed;
      function _skip() {
        parsed = _parsed[i3];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i3 = 0; i3 < ilen; ++i3) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i3 = ilen - 1; i3 >= 0; --i3) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range2, scale, parsed, stack);
          break;
        }
      }
      return range2;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i3, ilen, value;
      for (i3 = 0, ilen = parsed.length; i3 < ilen; ++i3) {
        value = parsed[i3][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start5 = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start5;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i3;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start5, count);
      }
      for (i3 = start5; i3 < start5 + count; ++i3) {
        const element = elements2[i3];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i3 = 0; i3 < active.length; ++i3) {
        active[i3].draw(ctx, area);
      }
    }
    getStyle(index2, active) {
      const mode = active ? "active" : "default";
      return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
    }
    getContext(index2, active, mode) {
      const dataset = this.getDataset();
      let context2;
      if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index2];
        context2 = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
        context2.parsed = this.getParsed(index2);
        context2.raw = dataset.data[index2];
        context2.index = context2.dataIndex = index2;
      } else {
        context2 = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context2.dataset = dataset;
        context2.index = context2.datasetIndex = this.index;
      }
      context2.active = !!active;
      context2.mode = mode;
      return context2;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index2, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index2);
    }
    _resolveElementOptions(elementType2, mode = "default", index2) {
      const active = mode === "active";
      const cache2 = this._cachedDataOpts;
      const cacheKey = elementType2 + "-" + mode;
      const cached = cache2[cacheKey];
      const sharing = this.enableOptionSharing && defined(index2);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType2);
      const prefixes = active ? [`${elementType2}Hover`, "hover", elementType2, ""] : [elementType2, ""];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults2.elements[elementType2]);
      const context2 = () => this.getContext(index2, active);
      const values = config.resolveNamedOptions(scopes, names2, context2, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache2[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index2, transition, active) {
      const chart = this.chart;
      const cache2 = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache2[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index2, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache2[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start5, mode) {
      const firstOpts = this.resolveDataElementOptions(start5, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return { sharedOptions, includeOptions };
    }
    updateElement(element, index2, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index2, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index2, mode, active) {
      element.active = active;
      const options = this.getStyle(index2, active);
      this._resolveAnimations(index2, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", false);
    }
    setHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start5, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end2 = start5 + count;
      let i3;
      const move = (arr) => {
        arr.length += count;
        for (i3 = arr.length - 1; i3 >= end2; i3--) {
          arr[i3] = arr[i3 - count];
        }
      };
      move(data);
      for (i3 = start5; i3 < end2; ++i3) {
        data[i3] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start5, count);
      if (resetNewElements) {
        this.updateElements(data, start5, count, "reset");
      }
    }
    updateElements(element, start5, count, mode) {
    }
    _removeElements(start5, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start5, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start5, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([this.index, ...args]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync(["_insertElements", this.getDataset().data.length - count, count]);
    }
    _onDataPop() {
      this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
    }
    _onDataShift() {
      this._sync(["_removeElements", 0, 1]);
    }
    _onDataSplice(start5, count) {
      if (count) {
        this._sync(["_removeElements", start5, count]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync(["_insertElements", start5, newCount]);
      }
    }
    _onDataUnshift() {
      this._sync(["_insertElements", 0, arguments.length]);
    }
  };
  DatasetController.defaults = {};
  DatasetController.prototype.datasetElementType = null;
  DatasetController.prototype.dataElementType = null;
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i3 = 0, ilen = visibleMetas.length; i3 < ilen; i3++) {
        values = values.concat(visibleMetas[i3].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a5, b5) => a5 - b5));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min3 = scale._length;
    let i3, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min3 = Math.min(min3, Math.abs(curr - prev) || min3);
      }
      prev = curr;
    };
    for (i3 = 0, ilen = values.length; i3 < ilen; ++i3) {
      curr = scale.getPixelForValue(values[i3]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i3 = 0, ilen = scale.ticks.length; i3 < ilen; ++i3) {
      curr = scale.getPixelForTick(i3);
      updateMinAndPrev();
    }
    return min3;
  }
  function computeFitCategoryTraits(index2, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size3, ratio;
    if (isNullOrUndef(thickness)) {
      size3 = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size3 = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size3 / stackCount,
      ratio,
      start: ruler.pixels[index2] - size3 / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start5 = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size3 = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size3 / stackCount,
      ratio: options.barPercentage,
      start: start5
    };
  }
  function parseFloatBar(entry, item, vScale, i3) {
    const startValue = vScale.parse(entry[0], i3);
    const endValue = vScale.parse(entry[1], i3);
    const min3 = Math.min(startValue, endValue);
    const max3 = Math.max(startValue, endValue);
    let barStart = min3;
    let barEnd = max3;
    if (Math.abs(min3) > Math.abs(max3)) {
      barStart = max3;
      barEnd = min3;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min: min3,
      max: max3
    };
  }
  function parseValue(entry, item, vScale, i3) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i3);
    } else {
      item[vScale.axis] = vScale.parse(entry, i3);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start5, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i3, ilen, item, entry;
    for (i3 = start5, ilen = start5 + count; i3 < ilen; ++i3) {
      entry = data[i3];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i3], i3);
      parsed.push(parseValue(entry, item, vScale, i3));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size3, vScale, actualBase) {
    if (size3 !== 0) {
      return sign(size3);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start5, end2, top2, bottom2;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start5 = "left";
      end2 = "right";
    } else {
      reverse = properties.base < properties.y;
      start5 = "bottom";
      end2 = "top";
    }
    if (reverse) {
      top2 = "end";
      bottom2 = "start";
    } else {
      top2 = "start";
      bottom2 = "end";
    }
    return { start: start5, end: end2, reverse, top: top2, bottom: bottom2 };
  }
  function setBorderSkipped(properties, options, stack, index2) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
      return;
    }
    const { start: start5, end: end2, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top2;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom2;
      } else {
        res[parseEdge(bottom2, start5, end2, reverse)] = true;
        edge = top2;
      }
    }
    res[parseEdge(edge, start5, end2, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a5, b5, reverse) {
    if (reverse) {
      edge = swap(edge, a5, b5);
      edge = startEnd(edge, b5, a5);
    } else {
      edge = startEnd(edge, a5, b5);
    }
    return edge;
  }
  function swap(orig, v1, v22) {
    return orig === v1 ? v22 : orig === v22 ? v1 : orig;
  }
  function startEnd(v4, start5, end2) {
    return v4 === "start" ? start5 : v4 === "end" ? end2 : v4;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start5, count) {
      return parseArrayOrPrimitive(meta, data, start5, count);
    }
    parseArrayData(meta, data, start5, count) {
      return parseArrayOrPrimitive(meta, data, start5, count);
    }
    parseObjectData(meta, data, start5, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i3, ilen, item, obj;
      for (i3 = start5, ilen = start5 + count; i3 < ilen; ++i3) {
        obj = data[i3];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i3);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i3));
      }
      return parsed;
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      super.updateRangeFromParsed(range2, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range2.min = Math.min(range2.min, custom.min);
        range2.max = Math.max(range2.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start5, count, mode) {
      const reset = mode === "reset";
      const { index: index2, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start5, mode);
      for (let i3 = start5; i3 < start5 + count; i3++) {
        const parsed = this.getParsed(i3);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i3);
        const ipixels = this._calculateBarIndexPixels(i3, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, bars[i3].active ? "active" : mode);
        }
        const options = properties.options || bars[i3].options;
        setBorderSkipped(properties, options, stack, index2);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i3], i3, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const skipNull = (meta) => {
        const parsed = meta.controller.getParsed(dataIndex);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index2) {
      return this._getStacks(void 0, index2).length;
    }
    _getStackIndex(datasetIndex, name2, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index2 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
      return index2 === -1 ? stacks.length - 1 : index2;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i3, ilen;
      for (i3 = 0, ilen = meta.data.length; i3 < ilen; ++i3) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i3)[iScale.axis], i3));
      }
      const barThickness = opts.barThickness;
      const min3 = barThickness || computeMinSampleSize(meta);
      return {
        min: min3,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index2) {
      const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start5 = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size3;
      if (length !== value) {
        start5 = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start5 = 0;
        }
        start5 += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start5;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index2)) {
        head = vScale.getPixelForValue(start5 + length);
      } else {
        head = base;
      }
      size3 = head - base;
      if (Math.abs(size3) < minBarLength) {
        size3 = barSign(size3, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size3 / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min3 = Math.min(startPixel, endPixel);
        const max3 = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max3), min3);
        head = base + size3;
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size3) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size3 -= halfGrid;
      }
      return {
        size: size3,
        base,
        head,
        center: head + size3 / 2
      };
    }
    _calculateBarIndexPixels(index2, ruler) {
      const scale = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size3;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
        const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
        center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
        size3 = Math.min(maxBarThickness, range2.chunk * range2.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
        size3 = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size3 / 2,
        head: center + size3 / 2,
        center,
        size: size3
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i3 = 0;
      for (; i3 < ilen; ++i3) {
        if (this.getParsed(i3)[vScale.axis] !== null) {
          rects[i3].draw(this._ctx);
        }
      }
    }
  };
  BarController.id = "bar";
  BarController.defaults = {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "base", "width", "height"]
      }
    }
  };
  BarController.overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  };
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start5, count) {
      const parsed = super.parsePrimitiveData(meta, data, start5, count);
      for (let i3 = 0; i3 < parsed.length; i3++) {
        parsed[i3]._custom = this.resolveDataElementOptions(i3 + start5).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start5, count) {
      const parsed = super.parseArrayData(meta, data, start5, count);
      for (let i3 = 0; i3 < parsed.length; i3++) {
        const item = data[start5 + i3];
        parsed[i3]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i3 + start5).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start5, count) {
      const parsed = super.parseObjectData(meta, data, start5, count);
      for (let i3 = 0; i3 < parsed.length; i3++) {
        const item = data[start5 + i3];
        parsed[i3]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i3 + start5).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max3 = 0;
      for (let i3 = data.length - 1; i3 >= 0; --i3) {
        max3 = Math.max(max3, data[i3].size(this.resolveDataElementOptions(i3)) / 2);
      }
      return max3 > 0 && max3;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x4 = xScale.getLabelForValue(parsed.x);
      const y6 = yScale.getLabelForValue(parsed.y);
      const r3 = parsed._custom;
      return {
        label: meta.label,
        value: "(" + x4 + ", " + y6 + (r3 ? ", " + r3 : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start5, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start5, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i3 = start5; i3 < start5 + count; i3++) {
        const point = points[i3];
        const parsed = !reset && this.getParsed(i3);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i3, properties, mode);
      }
    }
    resolveDataElementOptions(index2, mode) {
      const parsed = this.getParsed(index2);
      let values = super.resolveDataElementOptions(index2, mode);
      if (values.$shared) {
        values = Object.assign({}, values, { $shared: false });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  BubbleController.id = "bubble";
  BubbleController.defaults = {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "borderWidth", "radius"]
      }
    }
  };
  BubbleController.overrides = {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          title() {
            return "";
          }
        }
      }
    }
  };
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a5, b5) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a5, a5 * cutout, b5, b5 * cutout);
      const calcMin = (angle, a5, b5) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a5, a5 * cutout, b5, b5 * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return { ratioX, ratioY, offsetX, offsetY };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start5, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i4) => +data[i4];
        if (isObject(data[start5])) {
          const { key = "value" } = this._parsing;
          getter = (i4) => +resolveObjectKey(data[i4], key);
        }
        let i3, ilen;
        for (i3 = start5, ilen = start5 + count; i3 < ilen; ++i3) {
          meta._parsed[i3] = getter(i3);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min3 = TAU;
      let max3 = -TAU;
      for (let i3 = 0; i3 < this.chart.data.datasets.length; ++i3) {
        if (this.chart.isDatasetVisible(i3)) {
          const controller = this.chart.getDatasetMeta(i3).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min3 = Math.min(min3, rotation);
          max3 = Math.max(max3, rotation + circumference);
        }
      }
      return {
        rotation: min3,
        circumference: max3 - min3
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i3, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i3) || meta._parsed[i3] === null || meta.data[i3].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i3] * circumference / TAU);
    }
    updateElements(arcs, start5, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start5, mode);
      let startAngle = this._getRotation();
      let i3;
      for (i3 = 0; i3 < start5; ++i3) {
        startAngle += this._circumference(i3, reset);
      }
      for (i3 = start5; i3 < start5 + count; ++i3) {
        const circumference = this._circumference(i3, reset);
        const arc = arcs[i3];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i3, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i3;
      for (i3 = 0; i3 < metaData.length; i3++) {
        const value = meta._parsed[i3];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i3) && !metaData[i3].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2], chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max3 = 0;
      const chart = this.chart;
      let i3, ilen, meta, controller, options;
      if (!arcs) {
        for (i3 = 0, ilen = chart.data.datasets.length; i3 < ilen; ++i3) {
          if (chart.isDatasetVisible(i3)) {
            meta = chart.getDatasetMeta(i3);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i3 = 0, ilen = arcs.length; i3 < ilen; ++i3) {
        options = controller.resolveDataElementOptions(i3);
        if (options.borderAlign !== "inner") {
          max3 = Math.max(max3, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max3;
    }
    getMaxOffset(arcs) {
      let max3 = 0;
      for (let i3 = 0, ilen = arcs.length; i3 < ilen; ++i3) {
        const options = this.resolveDataElementOptions(i3);
        max3 = Math.max(max3, options.offset || 0, options.hoverOffset || 0);
      }
      return max3;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i3 = 0; i3 < datasetIndex; ++i3) {
        if (this.chart.isDatasetVisible(i3)) {
          ringWeightOffset += this._getRingWeight(i3);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  DoughnutController.id = "doughnut";
  DoughnutController.defaults = {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  DoughnutController.descriptors = {
    _scriptable: (name2) => name2 !== "spacing",
    _indexable: (name2) => name2 !== "spacing"
  };
  DoughnutController.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle } } = chart.legend.options;
              return data.labels.map((label, i3) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i3);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i3),
                  index: i3
                };
              });
            }
            return [];
          }
        },
        onClick(e2, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      },
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(tooltipItem) {
            let dataLabel = tooltipItem.label;
            const value = ": " + tooltipItem.formattedValue;
            if (isArray(dataLabel)) {
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }
            return dataLabel;
          }
        }
      }
    }
  };
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start5, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start5;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start5 = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start5, count, mode);
    }
    updateElements(points, start5, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start5, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start5 > 0 && this.getParsed(start5 - 1);
      for (let i3 = start5; i3 < start5 + count; ++i3) {
        const point = points[i3];
        const parsed = this.getParsed(i3);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i3);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i3);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i3 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i3];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i3, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  LineController.id = "line";
  LineController.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  };
  LineController.overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    parseObjectData(meta, data, start5, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start5, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
      meta.data.forEach((element, index2) => {
        const parsed = this.getParsed(index2).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
          if (parsed < range2.min) {
            range2.min = parsed;
          }
          if (parsed > range2.max) {
            range2.max = parsed;
          }
        }
      });
      return range2;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start5, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i3;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i3 = 0; i3 < start5; ++i3) {
        angle += this._computeAngle(i3, mode, defaultAngle);
      }
      for (i3 = start5; i3 < start5 + count; i3++) {
        const arc = arcs[i3];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i3, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i3) ? scale.getDistanceFromCenterForValue(this.getParsed(i3).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i3, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i3, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index2) => {
        if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index2, mode, defaultAngle) {
      return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
    }
  };
  PolarAreaController.id = "polarArea";
  PolarAreaController.defaults = {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
      }
    },
    indexAxis: "r",
    startAngle: 0
  };
  PolarAreaController.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle } } = chart.legend.options;
              return data.labels.map((label, i3) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i3);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i3),
                  index: i3
                };
              });
            }
            return [];
          }
        },
        onClick(e2, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      },
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(context2) {
            return context2.chart.data.labels[context2.dataIndex] + ": " + context2.formattedValue;
          }
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  };
  var PieController = class extends DoughnutController {
  };
  PieController.id = "pie";
  PieController.defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
  var RadarController = class extends DatasetController {
    getLabelAndValue(index2) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: vScale.getLabels()[index2],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start5, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start5, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start5, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i3 = start5; i3 < start5 + count; i3++) {
        const point = points[i3];
        const options = this.resolveDataElementOptions(i3, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i3, this.getParsed(i3).r);
        const x4 = reset ? scale.xCenter : pointPosition.x;
        const y6 = reset ? scale.yCenter : pointPosition.y;
        const properties = {
          x: x4,
          y: y6,
          angle: pointPosition.angle,
          skip: isNaN(x4) || isNaN(y6),
          options
        };
        this.updateElement(point, i3, properties, mode);
      }
    }
  };
  RadarController.id = "radar";
  RadarController.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  };
  RadarController.overrides = {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  };
  var Element2 = class {
    constructor() {
      this.x = void 0;
      this.y = void 0;
      this.active = false;
      this.options = void 0;
      this.$animations = void 0;
    }
    tooltipPosition(useFinalPosition) {
      const { x: x4, y: y6 } = this.getProps(["x", "y"], useFinalPosition);
      return { x: x4, y: y6 };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  Element2.defaults = {};
  Element2.defaultRoutes = void 0;
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if (remain === 1 || remain === 2 || remain === 5) {
        return formatters.numeric.call(this, tickValue, index2, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = { formatters };
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawBorder: true,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false,
      borderDash: [],
      borderDashOffset: 0,
      borderWidth: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.grid", "borderColor", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
    _indexable: (name2) => name2 !== "backdropPadding"
  });
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i3, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i3 = 0, ilen = numMajorIndices - 1; i3 < ilen; i3++) {
        skip(ticks, newTicks, spacing, majorIndices[i3], majorIndices[i3 + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset3 = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset3 ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i3 = 0, ilen = factors.length - 1; i3 < ilen; i3++) {
      const factor = factors[i3];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i3, ilen;
    for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
      if (ticks[i3].major) {
        result.push(i3);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i3;
    spacing = Math.ceil(spacing);
    for (i3 = 0; i3 < ticks.length; i3++) {
      if (i3 === next) {
        newTicks.push(ticks[i3]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start5 = valueOrDefault(majorStart, 0);
    const end2 = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i3, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start5;
    while (next < 0) {
      count++;
      next = Math.round(start5 + count * spacing);
    }
    for (i3 = Math.max(start5, 0); i3 < end2; i3++) {
      if (i3 === next) {
        newTicks.push(ticks[i3]);
        count++;
        next = Math.round(start5 + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i3, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i3 = 1; i3 < len; ++i3) {
      if (arr[i3] - arr[i3 - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset3) => edge === "top" || edge === "left" ? scale[edge] + offset3 : scale[edge] - offset3;
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i3 = 0;
    for (; i3 < len; i3 += increment) {
      result.push(arr[Math.floor(i3)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index2, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index2, length - 1);
    const start5 = scale._startPixel;
    const end2 = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset3;
    if (offsetGridLines) {
      if (length === 1) {
        offset3 = Math.max(lineValue - start5, end2 - lineValue);
      } else if (index2 === 0) {
        offset3 = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset3 = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset3 : -offset3;
      if (lineValue < start5 - epsilon || lineValue > end2 + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache2) => {
      const gc = cache2.gc;
      const gcLen = gc.length / 2;
      let i3;
      if (gcLen > length) {
        for (i3 = 0; i3 < gcLen; ++i3) {
          delete cache2.data[gc[i3]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset3, position, align) {
    const { top: top2, left: left2, bottom: bottom2, right: right2, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom2 - top2;
    const width = right2 - left2;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left2, right2);
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset3;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset3;
      } else {
        titleY = offsetFromEdge(scale, position, offset3);
      }
      maxWidth = right2 - left2;
    } else {
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset3;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset3;
      } else {
        titleX = offsetFromEdge(scale, position, offset3);
      }
      titleY = _alignStartEnd(align, bottom2, top2);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  var Scale = class _Scale extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index2) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min: min3, max: max3, minDefined, maxDefined } = this.getUserBounds();
      let range2;
      if (minDefined && maxDefined) {
        return { min: min3, max: max3 };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
        range2 = metas[i3].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min3 = Math.min(min3, range2.min);
        }
        if (!maxDefined) {
          max3 = Math.max(max3, range2.max);
        }
      }
      min3 = maxDefined && min3 > max3 ? max3 : min3;
      max3 = minDefined && min3 > max3 ? min3 : max3;
      return {
        min: finiteOrDefault(min3, finiteOrDefault(max3, min3)),
        max: finiteOrDefault(max3, finiteOrDefault(min3, max3))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [this]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [this]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [this]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [this]);
    }
    _callHooks(name2) {
      this.chart.notifyPlugins(name2, this.getContext());
      callback(this.options[name2], [this]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [this]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i3, ilen, tick;
      for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
        tick = ticks[i3];
        tick.label = callback(tickOpts.callback, [tick.value, i3, ticks], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [this]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [this]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = this.ticks.length;
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(
          Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
          Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
        ));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [this]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [this]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [this]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i3, ilen;
      for (i3 = 0, ilen = ticks.length; i3 < ilen; i3++) {
        if (isNullOrUndef(ticks[i3].label)) {
          ticks.splice(i3, 1);
          ilen--;
          i3--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i3, j6, jlen, label, tickFont, fontString, cache2, lineHeight, width, height, nestedLabel;
      for (i3 = 0; i3 < length; ++i3) {
        label = ticks[i3].label;
        tickFont = this._resolveTickFontOptions(i3);
        ctx.font = fontString = tickFont.string;
        cache2 = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache2.data, cache2.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j6 = 0, jlen = label.length; j6 < jlen; ++j6) {
            nestedLabel = label[j6];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache2.data, cache2.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index2) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min: min3, max: max3 } = this;
      return min3 < 0 && max3 < 0 ? max3 : min3 > 0 && max3 > 0 ? min3 : 0;
    }
    getContext(index2) {
      const ticks = this.ticks || [];
      if (index2 >= 0 && index2 < ticks.length) {
        const tick = ticks[index2];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w5 = labelSizes ? labelSizes.widest.width + padding : 0;
      const h4 = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h4 * cos > w5 * sin ? w5 / cos : h4 / sin : h4 * sin < w5 * cos ? h4 / cos : w5 / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position } = options;
      const offset3 = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset3 ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = grid.setContext(this.getContext());
      const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i3, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x22, y22;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y22 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y22 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x22 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x22 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y22 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x22 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i3 = 0; i3 < ticksLength; i3 += step) {
        const optsAtIndex = grid.setContext(this.getContext(i3));
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndex.borderDash || [];
        const borderDashOffset = optsAtIndex.borderDashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i3, offset3);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x22 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y22 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2: x22,
          y2: y22,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i3, ilen, tick, label, x4, y6, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y6 = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y6 = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x4 = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x4 = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y6 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y6 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x4 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x4 = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i3 = 0, ilen = ticks.length; i3 < ilen; ++i3) {
        tick = ticks[i3];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i3));
        pixel = this.getPixelForTick(i3) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i3);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x4 = pixel;
          if (textAlign === "inner") {
            if (i3 === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i3 === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
        } else {
          y6 = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i3];
          const width = labelSizes.widths[i3];
          let top2 = y6 + textOffset - labelPadding.top;
          let left2 = x4 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top2 -= height / 2;
              break;
            case "bottom":
              top2 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left2 -= width / 2;
              break;
            case "right":
              left2 -= width;
              break;
          }
          backdrop = {
            left: left2,
            top: top2,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          rotation,
          label,
          font,
          color: color2,
          strokeColor,
          strokeWidth,
          textOffset,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [x4, y6],
          backdrop
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x4;
      if (position === "left") {
        if (mirror) {
          x4 = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x4 += widest / 2;
          } else {
            textAlign = "right";
            x4 += widest;
          }
        } else {
          x4 = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x4 -= widest / 2;
          } else {
            textAlign = "left";
            x4 = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x4 = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x4 -= widest / 2;
          } else {
            textAlign = "left";
            x4 -= widest;
          }
        } else {
          x4 = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x4 += widest / 2;
          } else {
            textAlign = "right";
            x4 = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return { textAlign, x: x4 };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return { top: 0, left: this.left, bottom: chart.height, right: this.right };
      }
      if (position === "top" || position === "bottom") {
        return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left: left2, top: top2, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left2, top2, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index2 = ticks.findIndex((t4) => t4.value === value);
      if (index2 >= 0) {
        const opts = grid.setContext(this.getContext(index2));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i3, ilen;
      const drawLine = (p1, p22, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p22.x, p22.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
          const item = items[i3];
          if (grid.drawOnChartArea) {
            drawLine(
              { x: item.x1, y: item.y1 },
              { x: item.x2, y: item.y2 },
              item
            );
          }
          if (grid.drawTicks) {
            drawLine(
              { x: item.tx1, y: item.ty1 },
              { x: item.tx2, y: item.ty2 },
              {
                color: item.tickColor,
                width: item.tickWidth,
                borderDash: item.tickBorderDash,
                borderDashOffset: item.tickBorderDashOffset
              }
            );
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { grid } } = this;
      const borderOpts = grid.setContext(this.getContext());
      const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x22, y1, y22;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x22 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y22 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y22 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x22 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.borderWidth;
      ctx.strokeStyle = borderOpts.borderColor;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x22, y22);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      let i3, ilen;
      for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
        const item = items[i3];
        const tickFont = item.font;
        const label = item.label;
        if (item.backdrop) {
          ctx.fillStyle = item.backdrop.color;
          ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
        }
        let y6 = item.textOffset;
        renderText(ctx, label, 0, y6, tickFont, item);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset3 = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject(position)) {
        offset3 += padding.bottom;
        if (isArray(title.text)) {
          offset3 += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset3 += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset3, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [titleX, titleY]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
        return [{
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }];
      }
      return [{
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      }, {
        z: gz + 1,
        draw: () => {
          this.drawBorder();
        }
      }, {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i3, ilen;
      for (i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
        const meta = metas[i3];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index2) {
      const opts = this.options.ticks.setContext(this.getContext(index2));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults2.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults2[scope]) {
        delete defaults2[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults2.get(parentScope) : {},
      defaults2.get(scope),
      item.defaults
    ]);
    defaults2.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults2.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [scope].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults2.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [this.controllers, this.scales, this.elements];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [...args].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i3 = 0; i3 < this._typedRegistries.length; i3++) {
        const reg = this._typedRegistries[i3];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = new Registry();
  var ScatterController = class extends DatasetController {
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start5, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start5;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start5 = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      }
      this.updateElements(points, start5, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start5, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start5, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start5 > 0 && this.getParsed(start5 - 1);
      for (let i3 = start5; i3 < start5 + count; ++i3) {
        const point = points[i3];
        const parsed = this.getParsed(i3);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i3);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i3);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i3 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i3];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i3, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i3, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max3 = 0;
        for (let i3 = data.length - 1; i3 >= 0; --i3) {
          max3 = Math.max(max3, data[i3].size(this.resolveDataElementOptions(i3)) / 2);
        }
        return max3 > 0 && max3;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  ScatterController.id = "scatter";
  ScatterController.defaults = {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  };
  ScatterController.overrides = {
    interaction: {
      mode: "point"
    },
    plugins: {
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(item) {
            return "(" + item.label + ", " + item.formattedValue + ")";
          }
        }
      }
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  };
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PolarAreaController,
    PieController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapter = class {
    constructor(options) {
      this.options = options || {};
    }
    init(chartOptions) {
    }
    formats() {
      return abstract();
    }
    parse(value, format2) {
      return abstract();
    }
    format(timestamp, format2) {
      return abstract();
    }
    add(timestamp, amount, unit) {
      return abstract();
    }
    diff(a5, b5, unit) {
      return abstract();
    }
    startOf(timestamp, unit, weekday) {
      return abstract();
    }
    endOf(timestamp, unit) {
      return abstract();
    }
  };
  DateAdapter.override = function(members) {
    Object.assign(DateAdapter.prototype, members);
  };
  var adapters = {
    _date: DateAdapter
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value);
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range2 = typeof el.getRange === "function" && el.getRange(axis);
        if (range2) {
          const start5 = lookupMethod(data, axis, value - range2);
          const end2 = lookupMethod(data, axis, value + range2);
          return { lo: start5.lo, hi: end2.hi };
        }
      }
    }
    return { lo: 0, hi: data.length - 1 };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
      const { index: index2, data } = metasets[i3];
      const { lo, hi: hi2 } = binarySearch(metasets[i3], axis, value, intersect);
      for (let j6 = lo; j6 <= hi2; ++j6) {
        const element = data[j6];
        if (!element.skip) {
          handler(element, index2, j6);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt22) {
      const deltaX = useX ? Math.abs(pt1.x - pt22.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt22.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({ element, datasetIndex, index: index2 });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
      const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({ element, datasetIndex, index: index2 });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [{ element, datasetIndex, index: index2 }];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({ element, datasetIndex, index: index2 });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({ element, datasetIndex, index: index2 });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index2 = items[0].index;
          const element = meta.data[index2];
          if (element && !element.skip) {
            elements2.push({ element, datasetIndex: meta.index, index: index2 });
          }
        });
        return elements2;
      },
      dataset(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i3 = 0; i3 < data.length; ++i3) {
            items.push({ element: data[i3], datasetIndex, index: i3 });
          }
        }
        return items;
      },
      point(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e2, options, useFinalPosition) {
        const position = getRelativePosition(e2, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
  function filterByPosition(array, position) {
    return array.filter((v4) => v4.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v4) => STATIC_POSITIONS.indexOf(v4.pos) === -1 && v4.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a5, b5) => {
      const v0 = reverse ? b5 : a5;
      const v1 = reverse ? a5 : b5;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i3, ilen, box, pos, stack, stackWeight;
    for (i3 = 0, ilen = (boxes || []).length; i3 < ilen; ++i3) {
      box = boxes[i3];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i3,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i3, ilen, layout;
    for (i3 = 0, ilen = layouts2.length; i3 < ilen; ++i3) {
      layout = layouts2[i3];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left2 = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right2 = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left2.concat(top2),
      rightAndBottom: right2.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left2.concat(right2).concat(centerVertical),
      horizontal: top2.concat(bottom2).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a5, b5) {
    return Math.max(maxPadding[a5], chartArea[a5]) + Math.max(maxPadding[b5], chartArea[b5]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || { size: 0, count: 1 };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = { left: 0, top: 0, right: 0, bottom: 0 };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i3, ilen, layout, box, refit, changed;
    for (i3 = 0, ilen = boxes.length, refit = 0; i3 < ilen; ++i3) {
      layout = boxes[i3];
      box = layout.box;
      box.update(
        layout.width || chartArea.w,
        layout.height || chartArea.h,
        getMargins(layout.horizontal, chartArea)
      );
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left2, top2, width, height) {
    box.top = top2;
    box.left = left2;
    box.right = left2 + width;
    box.bottom = top2 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x: x4, y: y6 } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y6 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y6, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y6, width, height);
        }
        stack.start = y6;
        stack.placed += width;
        y6 = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x4 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x4, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x4, chartArea.top + stack.placed, width, height);
        }
        stack.start = x4;
        stack.placed += height;
        x4 = box.right;
      }
    }
    chartArea.x = x4;
    chartArea.y = y6;
  }
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [{
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index2 !== -1) {
        chart.boxes.splice(index2, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context2) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
  function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
  function fromNativeEvent(event2, chart) {
    const type = EVENT_TYPES[event2.type] || event2.type;
    const { x: x4, y: y6 } = getRelativePosition(event2, chart);
    return {
      type,
      chart,
      native: event2,
      x: x4 !== void 0 ? x4 : null,
      y: y6 !== void 0 ? y6 : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w5 = container.clientWidth;
      listener(width, height);
      if (w5 < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event2) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event2, chart));
      }
    }, chart, (args) => {
      const event2 = args[0];
      return [event2, event2.offsetX, event2.offsetY];
    });
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context2 = canvas && canvas.getContext && canvas.getContext("2d");
      if (context2 && context2.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context2;
      }
      return null;
    }
    releaseContext(context2) {
      const canvas = context2.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      ["height", "width"].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [chart, args, descriptor.options];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins2 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a5, b5) => a5.filter((x4) => !b5.some((y6) => x4.plugin.id === y6.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i3 = 0; i3 < keys.length; i3++) {
      plugins2.push(registry.getPlugin(keys[i3]));
    }
    const local = config.plugins || [];
    for (let i3 = 0; i3 < local.length; i3++) {
      const plugin = local[i3];
      if (plugins2.indexOf(plugin) === -1) {
        plugins2.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return { plugins: plugins2, localIds };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
    const result = [];
    const context2 = chart.getContext();
    for (const plugin of plugins2) {
      const id = plugin.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, { plugin, local: localIds[id] }, opts, context2)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context2) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context2, [""], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults2.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, scaleOptions) {
    if (id === "x" || id === "y") {
      return id;
    }
    return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || { scales: {} };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const firstIDs = /* @__PURE__ */ Object.create(null);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      firstIDs[axis] = firstIDs[axis] || id;
      scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
        scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [defaults2.scales[scale.type], defaults2.scale]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(
        datasetType,
        () => [[
          `datasets.${datasetType}`,
          ""
        ]]
      );
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(
        `${datasetType}.transition.${transition}`,
        () => [
          [
            `datasets.${datasetType}.transitions.${transition}`,
            `transitions.${transition}`
          ],
          [
            `datasets.${datasetType}`,
            ""
          ]
        ]
      );
    }
    datasetElementScopeKeys(datasetType, elementType2) {
      return cachedKeys(
        `${datasetType}-${elementType2}`,
        () => [[
          `datasets.${datasetType}.elements.${elementType2}`,
          `datasets.${datasetType}`,
          `elements.${elementType2}`,
          ""
        ]]
      );
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(
        `${type}-plugin-${id}`,
        () => [[
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]]
      );
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache2 = _scopeCache.get(mainScope);
      if (!cache2 || resetCache) {
        cache2 = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache2);
      }
      return cache2;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache2 = this._cachedScopes(mainScope, resetCache);
      const cached = cache2.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults2, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache2.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults2.datasets[type] || {},
        { type },
        defaults2,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context2, prefixes = [""]) {
      const result = { $shared: true };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context2 = isFunction(context2) ? context2() : context2;
        const subResolver = this.createResolver(scopes, context2, subPrefixes);
        options = _attachContext(resolver, context2, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context2, prefixes = [""], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject(context2) ? _attachContext(resolver, context2, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache2 = resolverCache.get(scopes);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache2);
    }
    const cacheKey = prefixes.join();
    let cached = cache2.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p4) => !p4.toLowerCase().includes("hover"))
      };
      cache2.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version2 = "3.9.1";
  var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l22) {
    return function(a5, b5) {
      return a5[l1] === b5[l1] ? a5[l22] - b5[l22] : a5[l1] - b5[l1];
    };
  }
  function onAnimationsComplete(context2) {
    const chart = context2.chart;
    const animationOptions2 = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions2 && animationOptions2.onComplete, [context2], chart);
  }
  function onAnimationProgress(context2) {
    const chart = context2.chart;
    const animationOptions2 = chart.options.animation;
    callback(animationOptions2 && animationOptions2.onProgress, [context2], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c4) => c4.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start5, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start5) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start5) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e2, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e2.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e2;
  }
  var Chart = class {
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error(
          "Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused."
        );
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context2 = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context2 && context2.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context2;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce5((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context2 || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = { width, height };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", { size: newSize });
      callback(options.onResize, [this, newSize], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(
          Object.keys(scaleOpts).map((id) => {
            const scaleOptions = scaleOpts[id];
            const axis = determineAxis(id, scaleOptions);
            const isRadial = axis === "r";
            const isHorizontal = axis === "x";
            return {
              options: scaleOptions,
              dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
              dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
            };
          })
        );
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a5, b5) => a5.index - b5.index);
      if (numMeta > numData) {
        for (let i3 = numData; i3 < numMeta; ++i3) {
          this._destroyDatasetMeta(i3);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index2) => {
        if (datasets.filter((x4) => x4 === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index2);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i3, ilen;
      this._removeUnreferencedMetasets();
      for (i3 = 0, ilen = datasets.length; i3 < ilen; i3++) {
        const dataset = datasets[i3];
        let meta = this.getDatasetMeta(i3);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i3);
          meta = this.getDatasetMeta(i3);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i3;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i3);
        if (meta.controller) {
          meta.controller.updateIndex(i3);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults2.datasets[type];
          Object.assign(ControllerClass.prototype, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i3);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i3 = 0, ilen = this.data.datasets.length; i3 < ilen; i3++) {
        const { controller } = this.getDatasetMeta(i3);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", { mode });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start: start5, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start5, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(
        _dataChanges.filter((c4) => c4[0] === idx).map((c4, i3) => i3 + "," + c4.splice(1).join(","))
      );
      const changeSet = makeSet(0);
      for (let i3 = 1; i3 < datasetCount; i3++) {
        if (!setsEqual(changeSet, makeSet(i3))) {
          return;
        }
      }
      return Array.from(changeSet).map((c4) => c4.split(",")).map((a5) => ({ method: a5[1], start: +a5[2], count: +a5[3] }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index2) => {
        item._idx = index2;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
        return;
      }
      for (let i3 = 0, ilen = this.data.datasets.length; i3 < ilen; ++i3) {
        this.getDatasetMeta(i3).controller.configure();
      }
      for (let i3 = 0, ilen = this.data.datasets.length; i3 < ilen; ++i3) {
        this._updateDataset(i3, isFunction(mode) ? mode({ datasetIndex: i3 }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", { mode });
    }
    _updateDataset(index2, mode) {
      const meta = this.getDatasetMeta(index2);
      const args = { meta, index: index2, mode, cancelable: true };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({ chart: this });
      }
    }
    draw() {
      let i3;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resize(width, height);
        this._resizeBeforeDraw = null;
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
        return;
      }
      const layers = this._layers;
      for (i3 = 0; i3 < layers.length && layers[i3].z <= 0; ++i3) {
        layers[i3].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i3 < layers.length; ++i3) {
        layers[i3].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i3, ilen;
      for (i3 = 0, ilen = metasets.length; i3 < ilen; ++i3) {
        const meta = metasets[i3];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
        this._drawDataset(metasets[i3]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = this.chartArea;
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e2, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e2, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x4) => x4 && x4._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index2) {
      this._hiddenIndices[index2] = !this._hiddenIndices[index2];
    }
    getDataVisibility(index2) {
      return !this._hiddenIndices[index2];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, { visible });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i3, ilen;
      this.stop();
      animator.remove(this);
      for (i3 = 0, ilen = this.data.datasets.length; i3 < ilen; ++i3) {
        this._destroyDatasetMeta(i3);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      this.notifyPlugins("destroy");
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform2 = this.platform;
      const _add = (type, listener2) => {
        platform2.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e2, x4, y6) => {
        e2.offsetX = x4;
        e2.offsetY = y6;
        this._eventHandler(e2);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform2 = this.platform;
      const _add = (type, listener2) => {
        platform2.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform2.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform2.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix2 = enabled ? "set" : "remove";
      let meta, item, i3, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix2 + "DatasetHoverStyle"]();
      }
      for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
        item = items[i3];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix2 + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a5, b5) => a5.filter((x4) => !b5.some((y6) => x4.datasetIndex === y6.datasetIndex && x4.index === y6.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e2, replay) {
      const args = {
        event: e2,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e2)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e2.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e2, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e2, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e2, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e2);
      const lastEvent = determineLastEvent(e2, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [e2, active, this], this);
        if (isClick) {
          callback(options.onClick, [e2, active, this], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e2, lastActive, inChartArea, useFinalPosition) {
      if (e2.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e2, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
  var enumerable = true;
  Object.defineProperties(Chart, {
    defaults: {
      enumerable,
      value: defaults2
    },
    instances: {
      enumerable,
      value: instances
    },
    overrides: {
      enumerable,
      value: overrides
    },
    registry: {
      enumerable,
      value: registry
    },
    version: {
      enumerable,
      value: version2
    },
    getChart: {
      enumerable,
      value: getChart
    },
    register: {
      enumerable,
      value: (...items) => {
        registry.add(...items);
        invalidatePlugins();
      }
    },
    unregister: {
      enumerable,
      value: (...items) => {
        registry.remove(...items);
        invalidatePlugins();
      }
    }
  });
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x: x4, y: y6, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x4, y6, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x4, y6, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x4, y6, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o3 = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o3.outerStart),
      outerEnd: computeOuterLimit(o3.outerEnd),
      innerStart: _limitValue(o3.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o3.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r3, theta, x4, y6) {
    return {
      x: x4 + r3 * Math.cos(theta),
      y: y6 + r3 * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset3, spacing, end2, circular) {
    const { x: x4, y: y6, startAngle: start5, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset3 - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset3 + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end2 - start5;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset3 / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start5 + angleOffset + spacingOffset;
    const endAngle = end2 - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      ctx.arc(x4, y6, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x4, y6);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x4, y6);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x4, y6);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      ctx.arc(x4, y6, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x4, y6);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x4, y6);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x4, y6);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x4, y6);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x4;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y6;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x4;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y6;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset3, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset3, spacing, startAngle + TAU, circular);
      for (let i3 = 0; i3 < fullCircles; ++i3) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + circumference % TAU;
        if (circumference % TAU === 0) {
          endAngle += TAU;
        }
      }
    }
    pathArc(ctx, element, offset3, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawFullCircleBorders(ctx, element, inner) {
    const { x: x4, y: y6, startAngle, pixelMargin, fullCircles } = element;
    const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
    const innerRadius = element.innerRadius + pixelMargin;
    let i3;
    if (inner) {
      clipArc(ctx, element, startAngle + TAU);
    }
    ctx.beginPath();
    ctx.arc(x4, y6, innerRadius, startAngle + TAU, startAngle, true);
    for (i3 = 0; i3 < fullCircles; ++i3) {
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(x4, y6, outerRadius, startAngle, startAngle + TAU);
    for (i3 = 0; i3 < fullCircles; ++i3) {
      ctx.stroke();
    }
  }
  function drawBorder(ctx, element, offset3, spacing, endAngle, circular) {
    const { options } = element;
    const { borderWidth, borderJoinStyle } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    if (element.fullCircles) {
      drawFullCircleBorders(ctx, element, inner);
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    pathArc(ctx, element, offset3, spacing, endAngle, circular);
    ctx.stroke();
  }
  var ArcElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps(["x", "y"], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = this.options.spacing / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x: x4, y: y6, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const { offset: offset3, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset3) / 2;
      return {
        x: x4 + Math.cos(halfAngle) * halfRadius,
        y: y6 + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset3 = (options.offset || 0) / 2;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      let radiusOffset = 0;
      if (offset3) {
        radiusOffset = offset3 / 2;
        const halfAngle = (this.startAngle + this.endAngle) / 2;
        ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
        if (this.circumference >= PI) {
          radiusOffset = offset3;
        }
      }
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
      ctx.restore();
    }
  };
  ArcElement.id = "arc";
  ArcElement.defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  };
  ArcElement.defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start5 = Math.max(paramsStart, segmentStart);
    const end2 = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start: start5,
      loop: segment.loop,
      ilen: end2 < start5 && !outside ? count + end2 - start5 : end2 - start5
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start: start5, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i3, point, prev;
    for (i3 = 0; i3 <= ilen; ++i3) {
      point = points[(start5 + (reverse ? ilen - i3 : i3)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start5 + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start: start5, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i3, point, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start5 + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i3 = 0; i3 <= ilen; ++i3) {
      point = points[pointIndex(i3)];
      if (point.skip) {
        continue;
      }
      const x4 = point.x;
      const y6 = point.y;
      const truncX = x4 | 0;
      if (truncX === prevX) {
        if (y6 < minY) {
          minY = y6;
        } else if (y6 > maxY) {
          maxY = y6;
        }
        avgX = (countX * avgX + x4) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x4, y6);
        prevX = truncX;
        countX = 0;
        minY = maxY = y6;
      }
      lastY = y6;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start5, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start5, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start5, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, { start: start5, end: start5 + count - 1 })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start5, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start5, count);
    } else {
      strokePathDirect(ctx, line, start5, count);
    }
  }
  var LineElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, { property, start: value, end: value });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i3, ilen;
      for (i3 = 0, ilen = segments.length; i3 < ilen; ++i3) {
        const { start: start5, end: end2 } = segments[i3];
        const p1 = points[start5];
        const p22 = points[end2];
        if (p1 === p22) {
          result.push(p1);
          continue;
        }
        const t4 = Math.abs((value - p1[property]) / (p22[property] - p1[property]));
        const interpolated = _interpolate(p1, p22, t4, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start5, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start5 = start5 || 0;
      count = count || this.points.length - start5;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, { start: start5, end: start5 + count - 1 });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start5, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start5, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  LineElement.id = "line";
  LineElement.defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  };
  LineElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  LineElement.descriptors = {
    _scriptable: true,
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
  };
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([axis], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x: x4, y: y6 } = this.getProps(["x", "y"], useFinalPosition);
      return Math.pow(mouseX - x4, 2) + Math.pow(mouseY - y6, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x4, y: y6 } = this.getProps(["x", "y"], useFinalPosition);
      return { x: x4, y: y6 };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  PointElement.id = "point";
  PointElement.defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  PointElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  function getBarBounds(bar, useFinalPosition) {
    const { x: x4, y: y6, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
    let left2, right2, top2, bottom2, half;
    if (bar.horizontal) {
      half = height / 2;
      left2 = Math.min(x4, base);
      right2 = Math.max(x4, base);
      top2 = y6 - half;
      bottom2 = y6 + half;
    } else {
      half = width / 2;
      left2 = x4 - half;
      right2 = x4 + half;
      top2 = Math.min(y6, base);
      bottom2 = Math.max(y6, base);
    }
    return { left: left2, top: top2, right: right2, bottom: bottom2 };
  }
  function skipOrLimit(skip2, value, min3, max3) {
    return skip2 ? 0 : _limitValue(value, min3, max3);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o3 = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o3.top, 0, maxH),
      r: skipOrLimit(skip2.right, o3.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o3.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o3.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
    const value = bar.options.borderRadius;
    const o3 = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o3.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o3.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o3.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o3.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x4, y6, useFinalPosition) {
    const skipX = x4 === null;
    const skipY = y6 === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x4, bounds.left, bounds.right)) && (skipY || _isBetween(y6, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x4 = rect.x !== refRect.x ? -amount : 0;
    const y6 = rect.y !== refRect.y ? -amount : 0;
    const w5 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x4;
    const h4 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y6;
    return {
      x: rect.x + x4,
      y: rect.y + y6,
      w: rect.w + w5,
      h: rect.h + h4,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x4, y: y6, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
      return {
        x: horizontal ? (x4 + base) / 2 : x4,
        y: horizontal ? y6 : (y6 + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  BarElement.id = "bar";
  BarElement.defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  BarElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    LineElement,
    PointElement,
    BarElement
  });
  function lttbDecimation(data, start5, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start5, start5 + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start5 + count - 1;
    let a5 = start5;
    let i3, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a5];
    for (i3 = 0; i3 < samples - 2; i3++) {
      let avgX = 0;
      let avgY = 0;
      let j6;
      const avgRangeStart = Math.floor((i3 + 1) * bucketWidth) + 1 + start5;
      const avgRangeEnd = Math.min(Math.floor((i3 + 2) * bucketWidth) + 1, count) + start5;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j6 = avgRangeStart; j6 < avgRangeEnd; j6++) {
        avgX += data[j6].x;
        avgY += data[j6].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i3 * bucketWidth) + 1 + start5;
      const rangeTo = Math.min(Math.floor((i3 + 1) * bucketWidth) + 1, count) + start5;
      const { x: pointAx, y: pointAy } = data[a5];
      maxArea = area = -1;
      for (j6 = rangeOffs; j6 < rangeTo; j6++) {
        area = 0.5 * Math.abs(
          (pointAx - avgX) * (data[j6].y - pointAy) - (pointAx - data[j6].x) * (avgY - pointAy)
        );
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j6];
          nextA = j6;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a5 = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start5, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i3, point, x4, y6, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start5 + count - 1;
    const xMin = data[start5].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i3 = start5; i3 < start5 + count; ++i3) {
      point = data[i3];
      x4 = (point.x - xMin) / dx * availableWidth;
      y6 = point.y;
      const truncX = x4 | 0;
      if (truncX === prevX) {
        if (y6 < minY) {
          minY = y6;
          minIndex = i3;
        } else if (y6 > maxY) {
          maxY = y6;
          maxIndex = i3;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i3 - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push({
              ...data[intermediateIndex1],
              x: avgX
            });
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push({
              ...data[intermediateIndex2],
              x: avgX
            });
          }
        }
        if (i3 > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y6;
        minIndex = maxIndex = startIndex = i3;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", { value: data });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start5 = 0;
    let count;
    const { iScale } = meta;
    const { min: min3, max: max3, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start5 = _limitValue(_lookupByKey(points, iScale.axis, min3).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max3).hi + 1, start5, pointCount) - start5;
    } else {
      count = pointCount - start5;
    }
    return { start: start5, count };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start: start5, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d5) {
              this._data = d5;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start5, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start5, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start: start5, end: end2 } = segment;
      end2 = _findSegmentEnd(start5, end2, points);
      const bounds = _getBounds(property, points[start5], points[end2], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start5],
          end: points[end2]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last, loop) {
    if (loop) {
      return;
    }
    let start5 = first[property];
    let end2 = last[property];
    if (property === "angle") {
      start5 = _normalizeAngle(start5);
      end2 = _normalizeAngle(end2);
    }
    return { property, start: start5, end: end2 };
  }
  function _pointsFromSegments(boundary, line) {
    const { x: x4 = null, y: y6 = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start: start5, end: end2 }) => {
      end2 = _findSegmentEnd(start5, end2, linePoints);
      const first = linePoints[start5];
      const last = linePoints[end2];
      if (y6 !== null) {
        points.push({ x: first.x, y: y6 });
        points.push({ x: last.x, y: y6 });
      } else if (x4 !== null) {
        points.push({ x: x4, y: first.y });
        points.push({ x: x4, y: last.y });
      }
    });
    return points;
  }
  function _findSegmentEnd(start5, end2, points) {
    for (; end2 > start5; end2--) {
      const point = points[end2];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end2;
  }
  function _getEdge(a5, b5, prop, fn3) {
    if (a5 && b5) {
      return fn3(a5[prop], b5[prop]);
    }
    return a5 ? a5[prop] : b5 ? b5[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: { tension: 0 },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index2, propagate) {
    const source = sources[index2];
    let fill2 = source.fill;
    const visited = [index2];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index2, count) {
    const fill2 = parseFillOption(line);
    if (isObject(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index2, target, count);
    }
    return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index2, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index2 + target;
    }
    if (target === index2 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale, index: index2, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index2);
    linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
    for (let i3 = 0; i3 < segments.length; i3++) {
      const segment = segments[i3];
      for (let j6 = segment.start; j6 <= segment.end; j6++) {
        addPointsBelow(points, sourcePoints[j6], linesBelow);
      }
    }
    return new LineElement({ points, options: {} });
  }
  function getLinesBelow(scale, index2) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i3 = 0; i3 < metas.length; i3++) {
      const meta = metas[i3];
      if (meta.index === index2) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j6 = 0; j6 < linesBelow.length; j6++) {
      const line = linesBelow[j6];
      const { first, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for (let i3 = 0; i3 < segments.length; i3++) {
      const segment = segments[i3];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return { first, last, point };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x: x4, y: y6, radius } = this;
      bounds = bounds || { start: 0, end: TAU };
      ctx.arc(x4, y6, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x: x4, y: y6, radius } = this;
      const angle = point.angle;
      return {
        x: x4 + Math.cos(angle) * radius,
        y: y6 + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index2) {
    const meta = chart.getDatasetMeta(index2);
    const visible = meta && chart.isDatasetVisible(index2);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale, fill: fill2 } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start5 = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start5);
    const target = [];
    if (options.grid.circular) {
      const center = scale.getPointPositionForValue(0, start5);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i3 = 0; i3 < length; ++i3) {
      target.push(scale.getPointPositionForValue(i3, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, { line, target, above, below, area, scale, axis });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, { line, target, color: above, scale, property });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, { line, target, color: below, scale, property });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start: start5, end: end2 } = segment;
      const firstPoint = points[start5];
      const lastPoint = points[_findSegmentEnd(start5, end2, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start: start5, end: end2 } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, notShape && _getBounds(property, start5, end2));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end2, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start5, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, bounds) {
    const { top: top2, bottom: bottom2 } = scale.chart.chartArea;
    const { property, start: start5, end: end2 } = bounds || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start5, top2, end2 - start5, bottom2 - top2);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i3, line, source;
      for (i3 = 0; i3 < count; ++i3) {
        meta = chart.getDatasetMeta(i3);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i3),
            index: i3,
            fill: _decodeFill(line, i3, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i3 = 0; i3 < count; ++i3) {
        source = sources[i3];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i3, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
        const source = metasets[i3].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i3 = metasets.length - 1; i3 >= 0; --i3) {
        const source = metasets[i3].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a5, b5) => a5 !== null && b5 !== null && a5.datasetIndex === b5.datasetIndex && a5.index === b5.index;
  var Legend = class extends Element2 {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a5, b5) => labelOpts.sort(a5, b5, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [0];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top2 = -lineHeight;
      this.legendItems.forEach((legendItem, i3) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i3 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i3 > 0 ? 0 : 1)] = 0;
          top2 += lineHeight;
          row++;
        }
        hitboxes[i3] = { left: 0, top: top2, row, width: itemWidth, height: itemHeight };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left2 = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i3) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i3 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({ width: currentColWidth, height: currentColHeight });
          left2 += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i3] = { left: left2, top: currentColHeight, col, width: itemWidth, height: itemHeight };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({ width: currentColWidth, height: currentColHeight });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left2), hitbox.width);
          left2 += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top2;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top2 += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults2.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { color: fontColor, padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x4, y6, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x4, boxWidth / 2);
          const centerY = y6 + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y6 + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x4, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v4) => v4 !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x4, y6, legendItem) {
        renderText(ctx, legendItem.text, x4, y6 + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i3) => {
        ctx.strokeStyle = legendItem.fontColor || fontColor;
        ctx.fillStyle = legendItem.fontColor || fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x4 = cursor.x;
        let y6 = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i3 > 0 && x4 + width + padding > this.right) {
            y6 = cursor.y += lineHeight;
            cursor.line++;
            x4 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i3 > 0 && y6 + lineHeight > this.bottom) {
          x4 = cursor.x = x4 + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y6 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x4);
        drawLegendBox(realX, y6, legendItem);
        x4 = _textX(textAlign, x4 + boxWidth + halfFontSize, isHorizontal ? x4 + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x4), y6, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y6;
      let left2 = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y6 = this.top + topPaddingPlusHalfFontSize;
        left2 = _alignStartEnd(opts.align, left2, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size3) => Math.max(acc, size3.height), 0);
        y6 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x4 = _alignStartEnd(position, left2, left2 + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x4, y6, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x4, y6) {
      let i3, hitBox, lh;
      if (_isBetween(x4, this.left, this.right) && _isBetween(y6, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i3 = 0; i3 < lh.length; ++i3) {
          hitBox = lh[i3];
          if (_isBetween(x4, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y6, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i3];
          }
        }
      }
      return null;
    }
    handleEvent(e2) {
      const opts = this.options;
      if (!isListened(e2.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e2.x, e2.y);
      if (e2.type === "mousemove" || e2.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [e2, previous, this], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [e2, hoveredItem, this], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [e2, hoveredItem, this], this);
      }
    }
  };
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e2, legendItem, legend) {
        const index2 = legendItem.datasetIndex;
        const ci2 = legend.chart;
        if (ci2.isDatasetVisible(index2)) {
          ci2.hide(index2);
          legendItem.hidden = true;
        } else {
          ci2.show(index2);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: 0,
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name2) => !name2.startsWith("on"),
      labels: {
        _scriptable: (name2) => !["generateLabels", "filter", "sort"].includes(name2)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset3) {
      const { top: top2, left: left2, bottom: bottom2, right: right2, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left2, right2);
        titleY = top2 + offset3;
        maxWidth = right2 - left2;
      } else {
        if (options.position === "left") {
          titleX = left2 + offset3;
          titleY = _alignStartEnd(align, bottom2, top2);
          rotation = PI * -0.5;
        } else {
          titleX = right2 - offset3;
          titleY = _alignStartEnd(align, top2, bottom2);
          rotation = PI * 0.5;
        }
        maxWidth = bottom2 - top2;
      }
      return { titleX, titleY, maxWidth, rotation };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset3 = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset3);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [titleX, titleY]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i3, len;
      let x4 = 0;
      let y6 = 0;
      let count = 0;
      for (i3 = 0, len = items.length; i3 < len; ++i3) {
        const el = items[i3].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          x4 += pos.x;
          y6 += pos.y;
          ++count;
        }
      }
      return {
        x: x4 / count,
        y: y6 / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x4 = eventPosition.x;
      let y6 = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i3, len, nearestElement;
      for (i3 = 0, len = items.length; i3 < len; ++i3) {
        const el = items[i3].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d5 = distanceBetweenPoints(eventPosition, center);
          if (d5 < minDistance) {
            minDistance = d5;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x4 = tp.x;
        y6 = tp.y;
      }
      return {
        x: x4,
        y: y6
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return { width, height };
  }
  function determineYAlign(chart, size3) {
    const { y: y6, height } = size3;
    if (y6 < height / 2) {
      return "top";
    } else if (y6 > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size3) {
    const { x: x4, width } = size3;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x4 + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x4 - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size3, yAlign) {
    const { x: x4, width } = size3;
    const { width: chartWidth, chartArea: { left: left2, right: right2 } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x4 <= (left2 + right2) / 2 ? "left" : "right";
    } else if (x4 <= width / 2) {
      xAlign = "left";
    } else if (x4 >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size3)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size3) {
    const yAlign = size3.yAlign || options.yAlign || determineYAlign(chart, size3);
    return {
      xAlign: size3.xAlign || options.xAlign || determineXAlign(chart, options, size3, yAlign),
      yAlign
    };
  }
  function alignX(size3, xAlign) {
    let { x: x4, width } = size3;
    if (xAlign === "right") {
      x4 -= width;
    } else if (xAlign === "center") {
      x4 -= width / 2;
    }
    return x4;
  }
  function alignY(size3, yAlign, paddingAndSize) {
    let { y: y6, height } = size3;
    if (yAlign === "top") {
      y6 += paddingAndSize;
    } else if (yAlign === "bottom") {
      y6 -= height + paddingAndSize;
    } else {
      y6 -= height / 2;
    }
    return y6;
  }
  function getBackgroundPoint(options, size3, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x4 = alignX(size3, xAlign);
    const y6 = alignY(size3, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x4 += paddingAndSize;
      } else if (xAlign === "right") {
        x4 -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x4 -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x4 += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x4, 0, chart.width - size3.width),
      y: _limitValue(y6, 0, chart.height - size3.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context2) {
    const override = context2 && context2.dataset && context2.dataset.tooltip && context2.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var Tooltip = class extends Element2 {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart || config._chart;
      this._chart = this.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context2, options) {
      const { callbacks } = options;
      const beforeTitle = callbacks.beforeTitle.apply(this, [context2]);
      const title = callbacks.title.apply(this, [context2]);
      const afterTitle = callbacks.afterTitle.apply(this, [context2]);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context2) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context2);
        pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context2)));
        pushOrConcat(bodyItem.lines, scoped.label.call(this, context2));
        pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context2)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
      const footer = callbacks.footer.apply(this, [tooltipItems]);
      const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i3, len;
      for (i3 = 0, len = active.length; i3 < len; ++i3) {
        tooltipItems.push(createTooltipItem(this.chart, active[i3]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a5, b5) => options.itemSort(a5, b5, data));
      }
      each(tooltipItems, (context2) => {
        const scoped = overrideCallbacks(options.callbacks, context2);
        labelColors.push(scoped.labelColor.call(this, context2));
        labelPointStyles.push(scoped.labelPointStyle.call(this, context2));
        labelTextColors.push(scoped.labelTextColor.call(this, context2));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size3 = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size3);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size3.width,
          height: size3.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, { chart: this.chart, tooltip: this, replay });
      }
    }
    drawCaret(tooltipPoint, ctx, size3, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size3, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size3, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size3;
      let x1, x22, x32, y1, y22, y32;
      if (yAlign === "center") {
        y22 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x22 = x1 - caretSize;
          y1 = y22 + caretSize;
          y32 = y22 - caretSize;
        } else {
          x1 = ptX + width;
          x22 = x1 + caretSize;
          y1 = y22 - caretSize;
          y32 = y22 + caretSize;
        }
        x32 = x1;
      } else {
        if (xAlign === "left") {
          x22 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x22 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x22 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y22 = y1 - caretSize;
          x1 = x22 - caretSize;
          x32 = x22 + caretSize;
        } else {
          y1 = ptY + height;
          y22 = y1 + caretSize;
          x1 = x22 + caretSize;
          x32 = x22 - caretSize;
        }
        y32 = y1;
      }
      return { x1, x2: x22, x3: x32, y1, y2: y22, y3: y32 };
    }
    drawTitle(pt3, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i3;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt3.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i3 = 0; i3 < length; ++i3) {
          ctx.fillText(title[i3], rtlHelper.x(pt3.x), pt3.y + titleFont.lineHeight / 2);
          pt3.y += titleFont.lineHeight + titleSpacing;
          if (i3 + 1 === length) {
            pt3.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt3, i3, rtlHelper, options) {
      const labelColors = this.labelColors[i3];
      const labelPointStyle = this.labelPointStyles[i3];
      const { boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt3.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColors.borderColor;
        ctx.fillStyle = labelColors.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
        ctx.strokeStyle = labelColors.borderColor;
        ctx.setLineDash(labelColors.borderDash || []);
        ctx.lineDashOffset = labelColors.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
        const borderRadius = toTRBLCorners(labelColors.borderRadius);
        if (Object.values(borderRadius).some((v4) => v4 !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColors.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColors.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i3];
    }
    drawBody(pt3, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt3.x + xLinePadding), pt3.y + bodyLineHeight / 2);
        pt3.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i3, j6, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt3.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i3 = 0, ilen = body.length; i3 < ilen; ++i3) {
        bodyItem = body[i3];
        textColor = this.labelTextColors[i3];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt3, i3, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j6 = 0, jlen = lines.length; j6 < jlen; ++j6) {
          fillLineOfText(lines[j6]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt3.y -= bodySpacing;
    }
    drawFooter(pt3, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i3;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt3.x = getAlignedX(this, options.footerAlign, options);
        pt3.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i3 = 0; i3 < length; ++i3) {
          ctx.fillText(footer[i3], rtlHelper.x(pt3.x), pt3.y + footerFont.lineHeight / 2);
          pt3.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt3, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x: x4, y: y6 } = pt3;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x4 + topLeft, y6);
      if (yAlign === "top") {
        this.drawCaret(pt3, ctx, tooltipSize, options);
      }
      ctx.lineTo(x4 + width - topRight, y6);
      ctx.quadraticCurveTo(x4 + width, y6, x4 + width, y6 + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt3, ctx, tooltipSize, options);
      }
      ctx.lineTo(x4 + width, y6 + height - bottomRight);
      ctx.quadraticCurveTo(x4 + width, y6 + height, x4 + width - bottomRight, y6 + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt3, ctx, tooltipSize, options);
      }
      ctx.lineTo(x4 + bottomLeft, y6 + height);
      ctx.quadraticCurveTo(x4, y6 + height, x4, y6 + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt3, ctx, tooltipSize, options);
      }
      ctx.lineTo(x4, y6 + topLeft);
      ctx.quadraticCurveTo(x4, y6, x4 + topLeft, y6);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size3 = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size3.width;
          this.height = size3.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt3 = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt3, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt3.y += padding.top;
        this.drawTitle(pt3, ctx, options);
        this.drawBody(pt3, ctx, options);
        this.drawFooter(pt3, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e2, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e2, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e2);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e2.x,
            y: e2.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e2, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e2.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const active = this.chart.getElementsAtEventForMode(e2, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e2) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e2);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  Tooltip.positioners = positioners;
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({ chart, options });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: ["x", "y", "width", "height", "caretX", "caretY"]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: {
        beforeTitle: noop3,
        title(tooltipItems) {
          if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === "dataset") {
              return item.dataset.label || "";
            } else if (item.label) {
              return item.label;
            } else if (labelCount > 0 && item.dataIndex < labelCount) {
              return labels[item.dataIndex];
            }
          }
          return "";
        },
        afterTitle: noop3,
        beforeBody: noop3,
        beforeLabel: noop3,
        label(tooltipItem) {
          if (this && this.options && this.options.mode === "dataset") {
            return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
          }
          let label = tooltipItem.dataset.label || "";
          if (label) {
            label += ": ";
          }
          const value = tooltipItem.formattedValue;
          if (!isNullOrUndef(value)) {
            label += value;
          }
          return label;
        },
        labelColor(tooltipItem) {
          const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta.controller.getStyle(tooltipItem.dataIndex);
          return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
          };
        },
        labelTextColor() {
          return this.options.bodyColor;
        },
        labelPointStyle(tooltipItem) {
          const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta.controller.getStyle(tooltipItem.dataIndex);
          return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
          };
        },
        afterLabel: noop3,
        afterBody: noop3,
        beforeFooter: noop3,
        footer: noop3,
        afterFooter: noop3
      }
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: ["interaction"]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index2, addedLabels) => {
    if (typeof raw === "string") {
      index2 = labels.push(raw) - 1;
      addedLabels.unshift({ index: index2, label: raw });
    } else if (isNaN(raw)) {
      index2 = null;
    }
    return index2;
  };
  function findOrAddLabel(labels, raw, index2, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index2, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index2 : first;
  }
  var validIndex = (index2, max3) => index2 === null ? null : _limitValue(Math.round(index2), 0, max3);
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index2, label } of added) {
          if (labels[index2] === label) {
            labels.splice(index2, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
      return validIndex(index2, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min3, max: max3 } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min3 = 0;
        }
        if (!maxDefined) {
          max3 = this.getLabels().length - 1;
        }
      }
      this.min = min3;
      this.max = max3;
    }
    buildTicks() {
      const min3 = this.min;
      const max3 = this.max;
      const offset3 = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min3 === 0 && max3 === labels.length - 1 ? labels : labels.slice(min3, max3 + 1);
      this._valueRange = Math.max(labels.length - (offset3 ? 0 : 1), 1);
      this._startValue = this.min - (offset3 ? 0.5 : 0);
      for (let value = min3; value <= max3; value++) {
        ticks.push({ value });
      }
      return ticks;
    }
    getLabelForValue(value) {
      const labels = this.getLabels();
      if (value >= 0 && value < labels.length) {
        return labels[value];
      }
      return value;
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  CategoryScale.id = "category";
  CategoryScale.defaults = {
    ticks: {
      callback: CategoryScale.prototype.getLabelForValue
    }
  };
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min: min3, max: max3, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min3);
    const maxDefined = !isNullOrUndef(max3);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [{ value: rmin }, { value: rmax }];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max3 - min3) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max3 - min3) / spacing, maxTicks));
      spacing = (max3 - min3) / numSpaces;
      niceMin = min3;
      niceMax = max3;
    } else if (countDefined) {
      niceMin = minDefined ? min3 : niceMin;
      niceMax = maxDefined ? max3 : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(
      _decimalPlaces(spacing),
      _decimalPlaces(niceMin)
    );
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j6 = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min3) {
        ticks.push({ value: min3 });
        if (niceMin < min3) {
          j6++;
        }
        if (almostEquals(Math.round((niceMin + j6 * spacing) * factor) / factor, min3, relativeLabelSize(min3, minSpacing, generationOptions))) {
          j6++;
        }
      } else if (niceMin < min3) {
        j6++;
      }
    }
    for (; j6 < numSpaces; ++j6) {
      ticks.push({ value: Math.round((niceMin + j6 * spacing) * factor) / factor });
    }
    if (maxDefined && includeBounds && niceMax !== max3) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max3, relativeLabelSize(max3, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max3;
      } else {
        ticks.push({ value: max3 });
      }
    } else if (!maxDefined || niceMax === max3) {
      ticks.push({ value: niceMax });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min3, max: max3 } = this;
      const setMin = (v4) => min3 = minDefined ? min3 : v4;
      const setMax = (v4) => max3 = maxDefined ? max3 : v4;
      if (beginAtZero) {
        const minSign = sign(min3);
        const maxSign = sign(max3);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min3 === max3) {
        let offset3 = 1;
        if (max3 >= Number.MAX_SAFE_INTEGER || min3 <= Number.MIN_SAFE_INTEGER) {
          offset3 = Math.abs(max3 * 0.05);
        }
        setMax(max3 + offset3);
        if (!beginAtZero) {
          setMin(min3 - offset3);
        }
      }
      this.min = min3;
      this.max = max3;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start5 = this.min;
      let end2 = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset3 = (end2 - start5) / Math.max(ticks.length - 1, 1) / 2;
        start5 -= offset3;
        end2 += offset3;
      }
      this._startValue = start5;
      this._endValue = end2;
      this._valueRange = end2 - start5;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min: min3, max: max3 } = this.getMinMax(true);
      this.min = isNumberFinite(min3) ? min3 : 0;
      this.max = isNumberFinite(max3) ? max3 : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  LinearScale.id = "linear";
  LinearScale.defaults = {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  };
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
    return remain === 1;
  }
  function generateTicks(generationOptions, dataRange) {
    const endExp = Math.floor(log10(dataRange.max));
    const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
    const ticks = [];
    let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
    let exp = Math.floor(log10(tickVal));
    let significand = Math.floor(tickVal / Math.pow(10, exp));
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    do {
      ticks.push({ value: tickVal, major: isMajor(tickVal) });
      ++significand;
      if (significand === 10) {
        significand = 1;
        ++exp;
        precision = exp >= 0 ? 1 : precision;
      }
      tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
    } while (exp < endExp || exp === endExp && significand < endSignificand);
    const lastTick = finiteOrDefault(generationOptions.max, tickVal);
    ticks.push({ value: lastTick, major: isMajor(tickVal) });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min: min3, max: max3 } = this.getMinMax(true);
      this.min = isNumberFinite(min3) ? Math.max(0, min3) : null;
      this.max = isNumberFinite(max3) ? Math.max(0, max3) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min3 = this.min;
      let max3 = this.max;
      const setMin = (v4) => min3 = minDefined ? min3 : v4;
      const setMax = (v4) => max3 = maxDefined ? max3 : v4;
      const exp = (v4, m4) => Math.pow(10, Math.floor(log10(v4)) + m4);
      if (min3 === max3) {
        if (min3 <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(exp(min3, -1));
          setMax(exp(max3, 1));
        }
      }
      if (min3 <= 0) {
        setMin(exp(max3, -1));
      }
      if (max3 <= 0) {
        setMax(exp(min3, 1));
      }
      if (this._zero && this.min !== this._suggestedMin && min3 === exp(this.min, 0)) {
        setMin(exp(min3, -1));
      }
      this.min = min3;
      this.max = max3;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start5 = this.min;
      super.configure();
      this._startValue = log10(start5);
      this._valueRange = log10(this.max) - log10(start5);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  LogarithmicScale.id = "logarithmic";
  LogarithmicScale.defaults = {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  };
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults2.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [label];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size3, min3, max3) {
    if (angle === min3 || angle === max3) {
      return {
        start: pos - size3 / 2,
        end: pos + size3 / 2
      };
    } else if (angle < min3 || angle > max3) {
      return {
        start: pos - size3,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size3
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i3 = 0; i3 < valueCount; i3++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i3));
      padding[i3] = opts.padding;
      const pointPosition = scale.getPointPosition(i3, scale.drawingArea + padding[i3], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i3]);
      labelSizes[i3] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i3) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(
      orig.l - limits.l,
      limits.r - orig.r,
      orig.t - limits.t,
      limits.b - orig.b
    );
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x4 = 0;
    let y6 = 0;
    if (hLimits.start < orig.l) {
      x4 = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x4);
    } else if (hLimits.end > orig.r) {
      x4 = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x4);
    }
    if (vLimits.start < orig.t) {
      y6 = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y6);
    } else if (vLimits.end > orig.b) {
      y6 = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y6);
    }
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const extra = getTickBackdropHeight(opts) / 2;
    const outerDistance = scale.drawingArea;
    const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
    for (let i3 = 0; i3 < valueCount; i3++) {
      const pointLabelPosition = scale.getPointPosition(i3, outerDistance + extra + padding[i3], additionalAngle);
      const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
      const size3 = labelSizes[i3];
      const y6 = yForAngle(pointLabelPosition.y, size3.h, angle);
      const textAlign = getTextAlignForAngle(angle);
      const left2 = leftForTextAlign(pointLabelPosition.x, size3.w, textAlign);
      items.push({
        x: pointLabelPosition.x,
        y: y6,
        textAlign,
        left: left2,
        top: y6,
        right: left2 + size3.w,
        bottom: y6 + size3.h
      });
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x4, w5, align) {
    if (align === "right") {
      x4 -= w5;
    } else if (align === "center") {
      x4 -= w5 / 2;
    }
    return x4;
  }
  function yForAngle(y6, h4, angle) {
    if (angle === 90 || angle === 270) {
      y6 -= h4 / 2;
    } else if (angle > 270 || angle < 90) {
      y6 -= h4;
    }
    return y6;
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i3 = labelCount - 1; i3 >= 0; i3--) {
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i3));
      const plFont = toFont(optsAtIndex.font);
      const { x: x4, y: y6, textAlign, left: left2, top: top2, right: right2, bottom: bottom2 } = scale._pointLabelItems[i3];
      const { backdropColor } = optsAtIndex;
      if (!isNullOrUndef(backdropColor)) {
        const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left2 - padding.left;
        const backdropTop = top2 - padding.top;
        const backdropWidth = right2 - left2 + padding.width;
        const backdropHeight = bottom2 - top2 + padding.height;
        if (Object.values(borderRadius).some((v4) => v4 !== 0)) {
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: backdropLeft,
            y: backdropTop,
            w: backdropWidth,
            h: backdropHeight,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
      }
      renderText(
        ctx,
        scale._pointLabels[i3],
        x4,
        y6 + plFont.lineHeight / 2,
        plFont,
        {
          color: optsAtIndex.color,
          textAlign,
          textBaseline: "middle"
        }
      );
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i3 = 1; i3 < labelCount; i3++) {
        pointPosition = scale.getPointPosition(i3, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(gridLineOpts.borderDash);
    ctx.lineDashOffset = gridLineOpts.borderDashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w5 = this.width = this.maxWidth - padding.width;
      const h4 = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w5 / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h4 / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w5, h4) / 2);
    }
    determineDataLimits() {
      const { min: min3, max: max3 } = this.getMinMax(false);
      this.min = isNumberFinite(min3) && !isNaN(min3) ? min3 : 0;
      this.max = isNumberFinite(max3) && !isNaN(max3) ? max3 : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index2) => {
        const label = callback(this.options.pointLabels.callback, [value, index2], this);
        return label || label === 0 ? label : "";
      }).filter((v4, i3) => this.chart.getDataVisibility(i3));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index2) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index2) {
      const pointLabels = this._pointLabels || [];
      if (index2 >= 0 && index2 < pointLabels.length) {
        const pointLabel = pointLabels[index2];
        return createPointLabelContext(this.getContext(), index2, pointLabel);
      }
    }
    getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index2, value) {
      return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index2) {
      return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index2) {
      const { left: left2, top: top2, right: right2, bottom: bottom2 } = this._pointLabelItems[index2];
      return {
        left: left2,
        top: top2,
        right: right2,
        bottom: bottom2
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid } = opts;
      const labelCount = this._pointLabels.length;
      let i3, offset3, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index2) => {
          if (index2 !== 0) {
            offset3 = this.getDistanceFromCenterForValue(tick.value);
            const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
            drawRadiusLine(this, optsAtIndex, offset3, labelCount);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i3 = labelCount - 1; i3 >= 0; i3--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i3));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset3 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
          position = this.getPointPosition(i3, offset3);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset3, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index2) => {
        if (index2 === 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index2));
        const tickFont = toFont(optsAtIndex.font);
        offset3 = this.getDistanceFromCenterForValue(this.ticks[index2].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(
            -width / 2 - padding.left,
            -offset3 - tickFont.size / 2 - padding.top,
            width + padding.width,
            tickFont.size + padding.height
          );
        }
        renderText(ctx, tick.label, 0, -offset3, tickFont, {
          color: optsAtIndex.color
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  RadialLinearScale.id = "radialLinear";
  RadialLinearScale.defaults = {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  };
  RadialLinearScale.defaultRoutes = {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  };
  RadialLinearScale.descriptors = {
    angleLines: {
      _fallback: "grid"
    }
  };
  var INTERVALS = {
    millisecond: { common: true, size: 1, steps: 1e3 },
    second: { common: true, size: 1e3, steps: 60 },
    minute: { common: true, size: 6e4, steps: 60 },
    hour: { common: true, size: 36e5, steps: 24 },
    day: { common: true, size: 864e5, steps: 30 },
    week: { common: false, size: 6048e5, steps: 4 },
    month: { common: true, size: 2628e6, steps: 12 },
    quarter: { common: false, size: 7884e6, steps: 4 },
    year: { common: true, size: 3154e7 }
  };
  var UNITS = Object.keys(INTERVALS);
  function sorter(a5, b5) {
    return a5 - b5;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round5, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round5) {
      value = round5 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round5);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min3, max3, capacity) {
    const ilen = UNITS.length;
    for (let i3 = UNITS.indexOf(minUnit); i3 < ilen - 1; ++i3) {
      const interval = INTERVALS[UNITS[i3]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max3 - min3) / (factor * interval.size)) <= capacity) {
        return UNITS[i3];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min3, max3) {
    for (let i3 = UNITS.length - 1; i3 >= UNITS.indexOf(minUnit); i3--) {
      const unit = UNITS[i3];
      if (INTERVALS[unit].common && scale._adapter.diff(max3, min3, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i3 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i3 < ilen; ++i3) {
      if (INTERVALS[UNITS[i3]].common) {
        return UNITS[i3];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi: hi2 } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi2];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map3[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i3, value;
    for (i3 = 0; i3 < ilen; ++i3) {
      value = values[i3];
      map3[value] = i3;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index2) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min: min3, max: max3, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min3 = Math.min(min3, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max3 = Math.max(max3, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min3 = isNumberFinite(min3) && !isNaN(min3) ? min3 : +adapter.startOf(Date.now(), unit);
      max3 = isNumberFinite(max3) && !isNaN(max3) ? max3 : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min3, max3 - 1);
      this.max = Math.max(min3 + 1, max3);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min3 = Number.POSITIVE_INFINITY;
      let max3 = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min3 = arr[0];
        max3 = arr[arr.length - 1];
      }
      return { min: min3, max: max3 };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min3 = this.min;
      const max3 = this.max;
      const ticks = _filterBetween(timestamps, min3, max3);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min3)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps) {
      let start5 = 0;
      let end2 = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start5 = 1 - first;
        } else {
          start5 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end2 = last;
        } else {
          end2 = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start5 = _limitValue(start5, 0, limit);
      end2 = _limitValue(end2, 0, limit);
      this._offsets = { start: start5, end: end2, factor: 1 / (start5 + 1 + end2) };
    }
    _generate() {
      const adapter = this._adapter;
      const min3 = this.min;
      const max3 = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min3, max3, this._getLabelCapacity(min3));
      const stepSize = valueOrDefault(timeOpts.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first = min3;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max3, min3, minor) > 1e5 * stepSize) {
        throw new Error(min3 + " and " + max3 + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max3; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max3 || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort((a5, b5) => a5 - b5).map((x4) => +x4);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    _tickFormatFunction(time, index2, ticks, format2) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index2];
      const major = majorUnit && majorFormat && tick && tick.major;
      const label = this._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
      const formatter = options.ticks.callback;
      return formatter ? callback(formatter, [label, index2, ticks], this) : label;
    }
    generateTickLabels(ticks) {
      let i3, ilen, tick;
      for (i3 = 0, ilen = ticks.length; i3 < ilen; ++i3) {
        tick = ticks[i3];
        tick.label = this._tickFormatFunction(tick.value, i3, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format2);
      const size3 = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size3.w : this.height / size3.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i3, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i3 = 0, ilen = metas.length; i3 < ilen; ++i3) {
        timestamps = timestamps.concat(metas[i3].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i3, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i3 = 0, ilen = labels.length; i3 < ilen; ++i3) {
        timestamps.push(parse(this, labels[i3]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  TimeScale.id = "time";
  TimeScale.defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      major: {
        enabled: false
      }
    }
  };
  function interpolate3(table, val, reverse) {
    let lo = 0;
    let hi2 = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi2].pos) {
        ({ lo, hi: hi2 } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi2]);
    } else {
      if (val >= table[lo].time && val <= table[hi2].time) {
        ({ lo, hi: hi2 } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi2]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate3(table, this.min);
      this._tableRange = interpolate3(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min: min3, max: max3 } = this;
      const items = [];
      const table = [];
      let i3, ilen, prev, curr, next;
      for (i3 = 0, ilen = timestamps.length; i3 < ilen; ++i3) {
        curr = timestamps[i3];
        if (curr >= min3 && curr <= max3) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          { time: min3, pos: 0 },
          { time: max3, pos: 1 }
        ];
      }
      for (i3 = 0, ilen = items.length; i3 < ilen; ++i3) {
        next = items[i3 + 1];
        prev = items[i3 - 1];
        curr = items[i3];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({ time: curr, pos: i3 / (ilen - 1) });
        }
      }
      return table;
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate3(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate3(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  TimeSeriesScale.id = "timeseries";
  TimeSeriesScale.defaults = TimeScale.defaults;
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/stimulus-chartjs/node_modules/chart.js/auto/auto.mjs
  Chart.register(...registerables);
  var auto_default = Chart;

  // node_modules/stimulus-chartjs/dist/stimulus-chartjs.es.js
  var __defProp2 = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a5, b5) => {
    for (var prop in b5 || (b5 = {}))
      if (__hasOwnProp2.call(b5, prop))
        __defNormalProp2(a5, prop, b5[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b5)) {
        if (__propIsEnum.call(b5, prop))
          __defNormalProp2(a5, prop, b5[prop]);
      }
    return a5;
  };
  var src_default = class extends Controller {
    connect() {
      const element = this.hasCanvasTarget ? this.canvasTarget : this.element;
      this.chart = new auto_default(element.getContext("2d"), {
        type: this.typeValue,
        data: this.chartData,
        options: this.chartOptions
      });
    }
    disconnect() {
      this.chart.destroy();
      this.chart = void 0;
    }
    get chartData() {
      if (!this.hasDataValue) {
        console.warn("[stimulus-chartjs] You need to pass data as JSON to see the chart.");
      }
      return this.dataValue;
    }
    get chartOptions() {
      return __spreadValues(__spreadValues({}, this.defaultOptions), this.optionsValue);
    }
    get defaultOptions() {
      return {};
    }
  };
  src_default.targets = ["canvas"];
  src_default.values = {
    type: {
      type: String,
      default: "line"
    },
    data: Object,
    options: Object
  };

  // app/javascript/customer_center/controllers/activity_chart_controller.js
  var import_lodash = __toESM(require_lodash());
  var activity_chart_controller_default = class extends src_default {
    connect() {
      super.connect();
      this.chart;
      this.options;
      this.defaultOptions;
      this.applyDashedLineToLastSegment();
      this.chart.resize();
    }
    redraw(event2) {
      const index2 = event2.currentTarget.dataset.index;
      this.chart.setDatasetVisibility(index2, !this.chart.isDatasetVisible(index2));
      this.chart.update();
    }
    applyDashedLineToLastSegment() {
      if (this.chart.data.datasets.length > 0) {
        this.chart.data.datasets.forEach((dataset) => {
          if (dataset.data.length >= 2) {
            dataset.segment = {
              borderWidth: (ctx) => ctx.p1DataIndex === dataset.data.length - 1 ? 2 : 3,
              borderDash: (ctx) => ctx.p1DataIndex === dataset.data.length - 1 ? [5, 5] : []
            };
          }
        });
        this.chart.update();
      }
    }
    get chartOptions() {
      const locale = this.localeValue;
      const tooltipCallback = {
        plugins: {
          tooltip: {
            callbacks: {
              label: function(context2) {
                let label = context2.dataset.label || "";
                if (label) {
                  const labelKey = label.toLowerCase().replace(/\s+/g, "_").replace(/[^a-z0-9_]/g, "");
                  label = i18next_default.t(`activity_chart_controller.${labelKey}`, { lng: locale }) + ": ";
                }
                if (context2.parsed.y !== null) {
                  if (context2.dataset.label.toLowerCase() === "commissions") {
                    label += new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(
                      context2.parsed.y
                    );
                  } else {
                    label += context2.parsed.y;
                  }
                }
                return label;
              },
              title: function(context2) {
                if (context2.length > 0) {
                  const chart = context2[0].chart;
                  const index2 = context2[0].dataIndex;
                  let dateValue = null;
                  if (chart.data.labels && chart.data.labels[index2]) {
                    dateValue = chart.data.labels[index2];
                  }
                  if (dateValue) {
                    const date = new Date(dateValue);
                    if (!isNaN(date.getTime())) {
                      return new Intl.DateTimeFormat(locale, {
                        month: "long",
                        day: "numeric"
                      }).format(date);
                    }
                  }
                }
                return "";
              }
            }
          }
        },
        scales: {
          x: {
            ticks: {
              callback: function(value, index2) {
                const chart = this.chart;
                const label = chart.data.labels[index2];
                if (label) {
                  const date = new Date(label);
                  return new Intl.DateTimeFormat(locale, {
                    month: "short",
                    day: "numeric"
                  }).format(date);
                }
                return label;
              }
            }
          }
        }
      };
      return (0, import_lodash.default)(super.chartOptions, tooltipCallback);
    }
  };
  __publicField(activity_chart_controller_default, "values", {
    locale: { type: String, default: "en" }
  });

  // app/javascript/customer_center/controllers/image_crop_controller.js
  init_define_process();
  init_jquery();
  var import_cropperjs = __toESM(require_cropper());
  var image_crop_controller_default = class extends application_controller_default {
    initCropper() {
      if (this.cropper) return;
      this.cropper = new import_cropperjs.default(this.imageTarget, {
        aspectRatio: 16 / 9
      });
      this.editActionsTarget.classList.remove("hidden");
      this.initTarget.classList.add("hidden");
    }
    commit() {
      this.editActionsTarget.classList.add("hidden");
      this.initTarget.classList.remove("hidden");
      this.cropper.getCroppedCanvas().toBlob((blob) => {
        this.dispatch("crop", {
          detail: {
            blob
          },
          bubbles: true
        });
      }, this.contentTypeValue);
    }
    cancel() {
      this.cropper.destroy();
      this.cropper = null;
      this.editActionsTarget.classList.add("hidden");
      this.initTarget.classList.remove("hidden");
    }
    disconnect() {
      if (this.cropper) {
        this.cropper.destroy();
        this.cropper = null;
      }
    }
  };
  __publicField(image_crop_controller_default, "targets", ["init", "image", "editActions"]);
  __publicField(image_crop_controller_default, "values", {
    contentType: String
  });

  // app/javascript/customer_center/controllers/toast_controller.js
  init_define_process();
  init_jquery();
  var toast_controller_default = class extends application_controller_default {
    toast() {
      toast(this.typeValue, this.messageValue, "flash");
    }
  };
  __publicField(toast_controller_default, "values", {
    type: { type: String, default: "notice" },
    message: String
  });

  // app/javascript/customer_center/controllers/direct_image_uploads_controller.js
  init_define_process();
  init_jquery();
  var import_activestorage2 = __toESM(require_activestorage());
  var direct_image_uploads_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      __publicField(this, "maxFileSize", 1024 * 1024 * 10);
    }
    connect() {
      this.uploadQueueAbortController = new AbortController();
      this.uploadQueue = /* @__PURE__ */ new Map();
      this.uploadInProgress = false;
    }
    disconnect() {
      this.cancelUploadQueue();
    }
    previewItemTargetConnected() {
      if (!this.hasFileLimitValue) return;
      if (this.previewItemTargets.length >= this.fileLimitValue) {
        this.disableUploadInput();
      }
    }
    previewItemTargetDisconnected() {
      if (!this.hasFileLimitValue) return;
      if (this.previewItemTargets.length < this.fileLimitValue) {
        this.enableUploadInput();
      }
    }
    disableUploadInput() {
      this.inputTarget.disabled = true;
      if (this.hasFileSelectButtonTarget) {
        this.fileSelectButtonTarget.classList.add(...this.fileSelectButtonDisabledClasses);
      }
      if (this.hasFileSelectButtonTooltipTarget && this.fileSelectButtonTooltipTarget.dataset.disabledText) {
        this.fileSelectButtonTooltipTarget.setAttribute(
          "content",
          this.fileSelectButtonTooltipTarget.dataset.disabledText
        );
      }
    }
    enableUploadInput() {
      this.inputTarget.disabled = false;
      if (this.hasFileSelectButtonTarget) {
        this.fileSelectButtonTarget.classList.remove(...this.fileSelectButtonDisabledClasses);
      }
      if (this.hasFileSelectButtonTooltipTarget && this.fileSelectButtonTooltipTarget.dataset.enabledText) {
        this.fileSelectButtonTooltipTarget.setAttribute("content", this.fileSelectButtonTooltipTarget.dataset.enabledText);
      }
    }
    cancelUploadQueue() {
      this.uploadQueueAbortController.abort();
      this.uploadQueue.clear();
      this.uploadInProgress = false;
    }
    async handleFileSelect(event2) {
      let files2 = Array.from(event2.target.files);
      const existingAttachments = this.previewItemTargets.length;
      const totalImages = existingAttachments + files2.length;
      if (this.hasFileLimitValue && totalImages > this.fileLimitValue) {
        toast("alert", i18next_default.t("direct_image_uploads_controller.limit_exceeded", { lng: this.localeValue, limit: this.fileLimitValue }), "flash");
        files2 = files2.slice(0, this.fileLimitValue - existingAttachments);
      }
      files2.forEach((file) => {
        if (!this.fileIsValid(file)) return;
        const attachment = { file, abortController: new AbortController() };
        this.uploadQueue.set(this.generateHash(file.name), attachment);
        this.createPreviewElement(file);
      });
      this.dispatch("process-queue-start");
      try {
        await this.processUploadQueue();
      } finally {
        this.uploadQueue.clear();
        this.dispatch("process-queue-end");
      }
    }
    fileIsValid(file) {
      if (file.size > this.maxFileSize) {
        toast("alert", i18next_default.t("direct_image_uploads_controller.too_large", { lng: this.localeValue }), "flash");
        return false;
      }
      return true;
    }
    /* eslint-disable max-len */
    createPreviewElement(file) {
      const reader = new FileReader();
      reader.onload = (e2) => {
        const previewId = this.generateHash(file.name);
        const previewHtml = `
        <div data-preview-item-id="${previewId}" class="image-preview-item relative group/item flex-shrink-0" data-testid="image-preview" data-direct-image-uploads-target="previewItem">
          <img src="${e2.target.result}" class="rounded-sm size-24 object-cover">
          <div data-upload-overlay class="absolute top-0 right-0 left-0 bottom-0 bg-black bg-opacity-50 flex items-center justify-center rounded-sm">
            <sl-spinner style="--indicator-color: var(--cfcc-color-brand-500); --track-color: var(--cfcc-color-brand-300); font-size: 2rem;"></sl-spinner> 
          </div>
          <button
            type="button"
            class="text-white flex items-center justify-center absolute top-0 right-0 lg:opacity-0 lg:group-hover/item:opacity-100"
            data-action="click->direct-image-uploads#removeImage"
            data-testid="remove-image-button"
            data-preview-id="${previewId}">
              <i class="fa-duotone fa-solid fa-circle-xmark rounded-full border-black border" style="--fa-primary-color: #000; --fa-secondary-color: #FFF; --fa-secondary-opacity: 1;"></i>
          </button>
        </div>
      `;
        this.previewTarget.insertAdjacentHTML("beforeend", previewHtml);
      };
      reader.readAsDataURL(file);
    }
    /* eslint-enable max-len */
    async processUploadQueue() {
      if (this.uploadQueue.size <= 0 || this.uploadQueueAbortController.signal.aborted) {
        return Promise.resolve();
      }
      const uploadPromises = [];
      for (const [key, attachment] of this.uploadQueue) {
        const { file, abortController } = attachment;
        if (abortController.signal.aborted || this.uploadQueueAbortController.signal.aborted) {
          this.uploadQueue.delete(key);
          continue;
        }
        uploadPromises.push(
          (async () => {
            try {
              this.uploadInProgress = true;
              const signedId = await this.uploadFile(file);
              this.addSignedIdToForm(file, signedId);
              this.updatePreviewStatus(file);
            } catch (error3) {
              if (error3.message === "Upload aborted") {
                console.warn("Upload aborted:", error3);
              } else {
                console.error("Upload failed:", error3);
              }
              this.updatePreviewStatus(file);
            } finally {
              this.uploadQueue.delete(key);
              this.uploadInProgress = false;
            }
          })()
        );
      }
      await Promise.all(uploadPromises);
    }
    uploadFile(file) {
      return new Promise((resolve2, reject) => {
        const upload = new import_activestorage2.DirectUpload(file, this.urlValue, {
          directUploadWillStoreFileWithXHR: (xhr) => {
            const key = this.generateHash(file.name);
            const attachment = this.uploadQueue.get(key);
            if (!attachment) return;
            if (attachment.abortController.signal.aborted || this.uploadQueueAbortController.signal.aborted) {
              xhr.abort();
              reject(new Error("Upload aborted"));
            } else {
              attachment.xhr = xhr;
              attachment.reject = reject;
              this.uploadQueue.set(key, attachment);
            }
          }
        });
        upload.create((error3, blob) => {
          if (error3) {
            reject(error3);
          } else {
            resolve2(blob.signed_id);
          }
        });
      });
    }
    addSignedIdToForm(file, signedId) {
      const previewId = this.generateHash(file.name);
      const input = document.createElement("input");
      input.type = "hidden";
      input.name = this.signedIdFieldNameValue;
      input.value = signedId;
      this.previewTarget.querySelector(`[data-preview-item-id="${previewId}"]`)?.appendChild(input);
    }
    updatePreviewStatus(file) {
      const fileHash = this.generateHash(file.name);
      const previewElement = this.previewTarget.querySelector(`[data-preview-item-id="${fileHash}"]`);
      if (previewElement) {
        previewElement.querySelector("[data-upload-overlay]").remove();
      }
    }
    removeImage(event2) {
      const previewId = event2.currentTarget.dataset.previewId;
      const previewElement = this.previewItemTargets.find((target) => target.dataset.previewItemId === previewId);
      if (previewElement) previewElement.remove();
      this.cancelUploadForImage(previewId);
    }
    cancelUploadForImage(key) {
      const { abortController, xhr, reject } = this.uploadQueue.get(key) || {};
      if (!abortController) return;
      if (xhr && reject) {
        xhr.abort();
        reject(new Error("Upload aborted"));
      }
      abortController.abort();
    }
    generateHash(filename) {
      let hash3 = 0;
      for (let i3 = 0; i3 < filename.length; i3++) {
        const char = filename.charCodeAt(i3);
        hash3 = (hash3 << 5) - hash3 + char;
        hash3 = hash3 & hash3;
      }
      return `preview-${Math.abs(hash3).toString(16)}`;
    }
  };
  __publicField(direct_image_uploads_controller_default, "targets", ["input", "preview", "previewItem", "fileSelectButton", "fileSelectButtonTooltip"]);
  __publicField(direct_image_uploads_controller_default, "values", {
    url: String,
    signedIdFieldName: { type: String, default: "image_ids[]" },
    fileLimit: Number,
    locale: { type: String, default: "en" }
  });
  __publicField(direct_image_uploads_controller_default, "classes", ["fileSelectButtonDisabled"]);

  // app/javascript/customer_center/controllers/lightbox_controller.js
  init_define_process();
  init_jquery();

  // node_modules/lightgallery/lightgallery.es5.js
  init_define_process();
  init_jquery();
  var __assign = function() {
    __assign = Object.assign || function __assign4(t4) {
      for (var s4, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
        s4 = arguments[i3];
        for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4)) t4[p4] = s4[p4];
      }
      return t4;
    };
    return __assign.apply(this, arguments);
  };
  function __spreadArrays() {
    for (var s4 = 0, i3 = 0, il = arguments.length; i3 < il; i3++) s4 += arguments[i3].length;
    for (var r3 = Array(s4), k4 = 0, i3 = 0; i3 < il; i3++)
      for (var a5 = arguments[i3], j6 = 0, jl = a5.length; j6 < jl; j6++, k4++)
        r3[k4] = a5[j6];
    return r3;
  }
  var lGEvents = {
    afterAppendSlide: "lgAfterAppendSlide",
    init: "lgInit",
    hasVideo: "lgHasVideo",
    containerResize: "lgContainerResize",
    updateSlides: "lgUpdateSlides",
    afterAppendSubHtml: "lgAfterAppendSubHtml",
    beforeOpen: "lgBeforeOpen",
    afterOpen: "lgAfterOpen",
    slideItemLoad: "lgSlideItemLoad",
    beforeSlide: "lgBeforeSlide",
    afterSlide: "lgAfterSlide",
    posterClick: "lgPosterClick",
    dragStart: "lgDragStart",
    dragMove: "lgDragMove",
    dragEnd: "lgDragEnd",
    beforeNextSlide: "lgBeforeNextSlide",
    beforePrevSlide: "lgBeforePrevSlide",
    beforeClose: "lgBeforeClose",
    afterClose: "lgAfterClose",
    rotateLeft: "lgRotateLeft",
    rotateRight: "lgRotateRight",
    flipHorizontal: "lgFlipHorizontal",
    flipVertical: "lgFlipVertical",
    autoplay: "lgAutoplay",
    autoplayStart: "lgAutoplayStart",
    autoplayStop: "lgAutoplayStop"
  };
  var lightGalleryCoreSettings = {
    mode: "lg-slide",
    easing: "ease",
    speed: 400,
    licenseKey: "0000-0000-000-0000",
    height: "100%",
    width: "100%",
    addClass: "",
    startClass: "lg-start-zoom",
    backdropDuration: 300,
    container: "",
    startAnimationDuration: 400,
    zoomFromOrigin: true,
    hideBarsDelay: 0,
    showBarsAfter: 1e4,
    slideDelay: 0,
    supportLegacyBrowser: true,
    allowMediaOverlap: false,
    videoMaxSize: "1280-720",
    loadYouTubePoster: true,
    defaultCaptionHeight: 0,
    ariaLabelledby: "",
    ariaDescribedby: "",
    resetScrollPosition: true,
    hideScrollbar: false,
    closable: true,
    swipeToClose: true,
    closeOnTap: true,
    showCloseIcon: true,
    showMaximizeIcon: false,
    loop: true,
    escKey: true,
    keyPress: true,
    trapFocus: true,
    controls: true,
    slideEndAnimation: true,
    hideControlOnEnd: false,
    mousewheel: false,
    getCaptionFromTitleOrAlt: true,
    appendSubHtmlTo: ".lg-sub-html",
    subHtmlSelectorRelative: false,
    preload: 2,
    numberOfSlideItemsInDom: 10,
    selector: "",
    selectWithin: "",
    nextHtml: "",
    prevHtml: "",
    index: 0,
    iframeWidth: "100%",
    iframeHeight: "100%",
    iframeMaxWidth: "100%",
    iframeMaxHeight: "100%",
    download: true,
    counter: true,
    appendCounterTo: ".lg-toolbar",
    swipeThreshold: 50,
    enableSwipe: true,
    enableDrag: true,
    dynamic: false,
    dynamicEl: [],
    extraProps: [],
    exThumbImage: "",
    isMobile: void 0,
    mobileSettings: {
      controls: false,
      showCloseIcon: false,
      download: false
    },
    plugins: [],
    strings: {
      closeGallery: "Close gallery",
      toggleMaximize: "Toggle maximize",
      previousSlide: "Previous slide",
      nextSlide: "Next slide",
      download: "Download",
      playVideo: "Play video",
      mediaLoadingFailed: "Oops... Failed to load content..."
    }
  };
  function initLgPolyfills() {
    (function() {
      if (typeof window.CustomEvent === "function")
        return false;
      function CustomEvent2(event2, params) {
        params = params || {
          bubbles: false,
          cancelable: false,
          detail: null
        };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event2, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      window.CustomEvent = CustomEvent2;
    })();
    (function() {
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
    })();
  }
  var lgQuery = (
    /** @class */
    function() {
      function lgQuery2(selector) {
        this.cssVenderPrefixes = [
          "TransitionDuration",
          "TransitionTimingFunction",
          "Transform",
          "Transition"
        ];
        this.selector = this._getSelector(selector);
        this.firstElement = this._getFirstEl();
        return this;
      }
      lgQuery2.generateUUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c4) {
          var r3 = Math.random() * 16 | 0, v4 = c4 == "x" ? r3 : r3 & 3 | 8;
          return v4.toString(16);
        });
      };
      lgQuery2.prototype._getSelector = function(selector, context2) {
        if (context2 === void 0) {
          context2 = document;
        }
        if (typeof selector !== "string") {
          return selector;
        }
        context2 = context2 || document;
        var fl = selector.substring(0, 1);
        if (fl === "#") {
          return context2.querySelector(selector);
        } else {
          return context2.querySelectorAll(selector);
        }
      };
      lgQuery2.prototype._each = function(func) {
        if (!this.selector) {
          return this;
        }
        if (this.selector.length !== void 0) {
          [].forEach.call(this.selector, func);
        } else {
          func(this.selector, 0);
        }
        return this;
      };
      lgQuery2.prototype._setCssVendorPrefix = function(el, cssProperty, value) {
        var property = cssProperty.replace(/-([a-z])/gi, function(s4, group1) {
          return group1.toUpperCase();
        });
        if (this.cssVenderPrefixes.indexOf(property) !== -1) {
          el.style[property.charAt(0).toLowerCase() + property.slice(1)] = value;
          el.style["webkit" + property] = value;
          el.style["moz" + property] = value;
          el.style["ms" + property] = value;
          el.style["o" + property] = value;
        } else {
          el.style[property] = value;
        }
      };
      lgQuery2.prototype._getFirstEl = function() {
        if (this.selector && this.selector.length !== void 0) {
          return this.selector[0];
        } else {
          return this.selector;
        }
      };
      lgQuery2.prototype.isEventMatched = function(event2, eventName) {
        var eventNamespace2 = eventName.split(".");
        return event2.split(".").filter(function(e2) {
          return e2;
        }).every(function(e2) {
          return eventNamespace2.indexOf(e2) !== -1;
        });
      };
      lgQuery2.prototype.attr = function(attr, value) {
        if (value === void 0) {
          if (!this.firstElement) {
            return "";
          }
          return this.firstElement.getAttribute(attr);
        }
        this._each(function(el) {
          el.setAttribute(attr, value);
        });
        return this;
      };
      lgQuery2.prototype.find = function(selector) {
        return $LG(this._getSelector(selector, this.selector));
      };
      lgQuery2.prototype.first = function() {
        if (this.selector && this.selector.length !== void 0) {
          return $LG(this.selector[0]);
        } else {
          return $LG(this.selector);
        }
      };
      lgQuery2.prototype.eq = function(index2) {
        return $LG(this.selector[index2]);
      };
      lgQuery2.prototype.parent = function() {
        return $LG(this.selector.parentElement);
      };
      lgQuery2.prototype.get = function() {
        return this._getFirstEl();
      };
      lgQuery2.prototype.removeAttr = function(attributes) {
        var attrs = attributes.split(" ");
        this._each(function(el) {
          attrs.forEach(function(attr) {
            return el.removeAttribute(attr);
          });
        });
        return this;
      };
      lgQuery2.prototype.wrap = function(className) {
        if (!this.firstElement) {
          return this;
        }
        var wrapper = document.createElement("div");
        wrapper.className = className;
        this.firstElement.parentNode.insertBefore(wrapper, this.firstElement);
        this.firstElement.parentNode.removeChild(this.firstElement);
        wrapper.appendChild(this.firstElement);
        return this;
      };
      lgQuery2.prototype.addClass = function(classNames) {
        if (classNames === void 0) {
          classNames = "";
        }
        this._each(function(el) {
          classNames.split(" ").forEach(function(className) {
            if (className) {
              el.classList.add(className);
            }
          });
        });
        return this;
      };
      lgQuery2.prototype.removeClass = function(classNames) {
        this._each(function(el) {
          classNames.split(" ").forEach(function(className) {
            if (className) {
              el.classList.remove(className);
            }
          });
        });
        return this;
      };
      lgQuery2.prototype.hasClass = function(className) {
        if (!this.firstElement) {
          return false;
        }
        return this.firstElement.classList.contains(className);
      };
      lgQuery2.prototype.hasAttribute = function(attribute) {
        if (!this.firstElement) {
          return false;
        }
        return this.firstElement.hasAttribute(attribute);
      };
      lgQuery2.prototype.toggleClass = function(className) {
        if (!this.firstElement) {
          return this;
        }
        if (this.hasClass(className)) {
          this.removeClass(className);
        } else {
          this.addClass(className);
        }
        return this;
      };
      lgQuery2.prototype.css = function(property, value) {
        var _this = this;
        this._each(function(el) {
          _this._setCssVendorPrefix(el, property, value);
        });
        return this;
      };
      lgQuery2.prototype.on = function(events, listener) {
        var _this = this;
        if (!this.selector) {
          return this;
        }
        events.split(" ").forEach(function(event2) {
          if (!Array.isArray(lgQuery2.eventListeners[event2])) {
            lgQuery2.eventListeners[event2] = [];
          }
          lgQuery2.eventListeners[event2].push(listener);
          _this.selector.addEventListener(event2.split(".")[0], listener);
        });
        return this;
      };
      lgQuery2.prototype.once = function(event2, listener) {
        var _this = this;
        this.on(event2, function() {
          _this.off(event2);
          listener(event2);
        });
        return this;
      };
      lgQuery2.prototype.off = function(event2) {
        var _this = this;
        if (!this.selector) {
          return this;
        }
        Object.keys(lgQuery2.eventListeners).forEach(function(eventName) {
          if (_this.isEventMatched(event2, eventName)) {
            lgQuery2.eventListeners[eventName].forEach(function(listener) {
              _this.selector.removeEventListener(eventName.split(".")[0], listener);
            });
            lgQuery2.eventListeners[eventName] = [];
          }
        });
        return this;
      };
      lgQuery2.prototype.trigger = function(event2, detail) {
        if (!this.firstElement) {
          return this;
        }
        var customEvent = new CustomEvent(event2.split(".")[0], {
          detail: detail || null
        });
        this.firstElement.dispatchEvent(customEvent);
        return this;
      };
      lgQuery2.prototype.load = function(url) {
        var _this = this;
        fetch(url).then(function(res) {
          return res.text();
        }).then(function(html) {
          _this.selector.innerHTML = html;
        });
        return this;
      };
      lgQuery2.prototype.html = function(html) {
        if (html === void 0) {
          if (!this.firstElement) {
            return "";
          }
          return this.firstElement.innerHTML;
        }
        this._each(function(el) {
          el.innerHTML = html;
        });
        return this;
      };
      lgQuery2.prototype.append = function(html) {
        this._each(function(el) {
          if (typeof html === "string") {
            el.insertAdjacentHTML("beforeend", html);
          } else {
            el.appendChild(html);
          }
        });
        return this;
      };
      lgQuery2.prototype.prepend = function(html) {
        this._each(function(el) {
          el.insertAdjacentHTML("afterbegin", html);
        });
        return this;
      };
      lgQuery2.prototype.remove = function() {
        this._each(function(el) {
          el.parentNode.removeChild(el);
        });
        return this;
      };
      lgQuery2.prototype.empty = function() {
        this._each(function(el) {
          el.innerHTML = "";
        });
        return this;
      };
      lgQuery2.prototype.scrollTop = function(scrollTop) {
        if (scrollTop !== void 0) {
          document.body.scrollTop = scrollTop;
          document.documentElement.scrollTop = scrollTop;
          return this;
        } else {
          return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        }
      };
      lgQuery2.prototype.scrollLeft = function(scrollLeft) {
        if (scrollLeft !== void 0) {
          document.body.scrollLeft = scrollLeft;
          document.documentElement.scrollLeft = scrollLeft;
          return this;
        } else {
          return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
        }
      };
      lgQuery2.prototype.offset = function() {
        if (!this.firstElement) {
          return {
            left: 0,
            top: 0
          };
        }
        var rect = this.firstElement.getBoundingClientRect();
        var bodyMarginLeft = $LG("body").style().marginLeft;
        return {
          left: rect.left - parseFloat(bodyMarginLeft) + this.scrollLeft(),
          top: rect.top + this.scrollTop()
        };
      };
      lgQuery2.prototype.style = function() {
        if (!this.firstElement) {
          return {};
        }
        return this.firstElement.currentStyle || window.getComputedStyle(this.firstElement);
      };
      lgQuery2.prototype.width = function() {
        var style = this.style();
        return this.firstElement.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
      };
      lgQuery2.prototype.height = function() {
        var style = this.style();
        return this.firstElement.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
      };
      lgQuery2.eventListeners = {};
      return lgQuery2;
    }()
  );
  function $LG(selector) {
    initLgPolyfills();
    return new lgQuery(selector);
  }
  var defaultDynamicOptions = [
    "src",
    "sources",
    "subHtml",
    "subHtmlUrl",
    "html",
    "video",
    "poster",
    "slideName",
    "responsive",
    "srcset",
    "sizes",
    "iframe",
    "downloadUrl",
    "download",
    "width",
    "facebookShareUrl",
    "tweetText",
    "iframeTitle",
    "twitterShareUrl",
    "pinterestShareUrl",
    "pinterestText",
    "fbHtml",
    "disqusIdentifier",
    "disqusUrl"
  ];
  function convertToData(attr) {
    if (attr === "href") {
      return "src";
    }
    attr = attr.replace("data-", "");
    attr = attr.charAt(0).toLowerCase() + attr.slice(1);
    attr = attr.replace(/-([a-z])/g, function(g4) {
      return g4[1].toUpperCase();
    });
    return attr;
  }
  var utils2 = {
    /**
     * get possible width and height from the lgSize attribute. Used for ZoomFromOrigin option
     */
    getSize: function(el, container, spacing, defaultLgSize) {
      if (spacing === void 0) {
        spacing = 0;
      }
      var LGel = $LG(el);
      var lgSize = LGel.attr("data-lg-size") || defaultLgSize;
      if (!lgSize) {
        return;
      }
      var isResponsiveSizes = lgSize.split(",");
      if (isResponsiveSizes[1]) {
        var wWidth = window.innerWidth;
        for (var i3 = 0; i3 < isResponsiveSizes.length; i3++) {
          var size_1 = isResponsiveSizes[i3];
          var responsiveWidth = parseInt(size_1.split("-")[2], 10);
          if (responsiveWidth > wWidth) {
            lgSize = size_1;
            break;
          }
          if (i3 === isResponsiveSizes.length - 1) {
            lgSize = size_1;
          }
        }
      }
      var size3 = lgSize.split("-");
      var width = parseInt(size3[0], 10);
      var height = parseInt(size3[1], 10);
      var cWidth = container.width();
      var cHeight = container.height() - spacing;
      var maxWidth = Math.min(cWidth, width);
      var maxHeight = Math.min(cHeight, height);
      var ratio = Math.min(maxWidth / width, maxHeight / height);
      return { width: width * ratio, height: height * ratio };
    },
    /**
     * @desc Get transform value based on the imageSize. Used for ZoomFromOrigin option
     * @param {jQuery Element}
     * @returns {String} Transform CSS string
     */
    getTransform: function(el, container, top2, bottom2, imageSize) {
      if (!imageSize) {
        return;
      }
      var LGel = $LG(el).find("img").first();
      if (!LGel.get()) {
        return;
      }
      var containerRect = container.get().getBoundingClientRect();
      var wWidth = containerRect.width;
      var wHeight = container.height() - (top2 + bottom2);
      var elWidth = LGel.width();
      var elHeight = LGel.height();
      var elStyle = LGel.style();
      var x4 = (wWidth - elWidth) / 2 - LGel.offset().left + (parseFloat(elStyle.paddingLeft) || 0) + (parseFloat(elStyle.borderLeft) || 0) + $LG(window).scrollLeft() + containerRect.left;
      var y6 = (wHeight - elHeight) / 2 - LGel.offset().top + (parseFloat(elStyle.paddingTop) || 0) + (parseFloat(elStyle.borderTop) || 0) + $LG(window).scrollTop() + top2;
      var scX = elWidth / imageSize.width;
      var scY = elHeight / imageSize.height;
      var transform = "translate3d(" + (x4 *= -1) + "px, " + (y6 *= -1) + "px, 0) scale3d(" + scX + ", " + scY + ", 1)";
      return transform;
    },
    getIframeMarkup: function(iframeWidth, iframeHeight, iframeMaxWidth, iframeMaxHeight, src, iframeTitle) {
      var title = iframeTitle ? 'title="' + iframeTitle + '"' : "";
      return '<div class="lg-video-cont lg-has-iframe" style="width:' + iframeWidth + "; max-width:" + iframeMaxWidth + "; height: " + iframeHeight + "; max-height:" + iframeMaxHeight + '">\n                    <iframe class="lg-object" frameborder="0" ' + title + ' src="' + src + '"  allowfullscreen="true"></iframe>\n                </div>';
    },
    getImgMarkup: function(index2, src, altAttr, srcset, sizes, sources) {
      var srcsetAttr = srcset ? 'srcset="' + srcset + '"' : "";
      var sizesAttr = sizes ? 'sizes="' + sizes + '"' : "";
      var imgMarkup = "<img " + altAttr + " " + srcsetAttr + "  " + sizesAttr + ' class="lg-object lg-image" data-index="' + index2 + '" src="' + src + '" />';
      var sourceTag = "";
      if (sources) {
        var sourceObj = typeof sources === "string" ? JSON.parse(sources) : sources;
        sourceTag = sourceObj.map(function(source) {
          var attrs = "";
          Object.keys(source).forEach(function(key) {
            attrs += " " + key + '="' + source[key] + '"';
          });
          return "<source " + attrs + "></source>";
        });
      }
      return "" + sourceTag + imgMarkup;
    },
    // Get src from responsive src
    getResponsiveSrc: function(srcItms) {
      var rsWidth = [];
      var rsSrc = [];
      var src = "";
      for (var i3 = 0; i3 < srcItms.length; i3++) {
        var _src = srcItms[i3].split(" ");
        if (_src[0] === "") {
          _src.splice(0, 1);
        }
        rsSrc.push(_src[0]);
        rsWidth.push(_src[1]);
      }
      var wWidth = window.innerWidth;
      for (var j6 = 0; j6 < rsWidth.length; j6++) {
        if (parseInt(rsWidth[j6], 10) > wWidth) {
          src = rsSrc[j6];
          break;
        }
      }
      return src;
    },
    isImageLoaded: function(img) {
      if (!img)
        return false;
      if (!img.complete) {
        return false;
      }
      if (img.naturalWidth === 0) {
        return false;
      }
      return true;
    },
    getVideoPosterMarkup: function(_poster, dummyImg, videoContStyle, playVideoString, _isVideo) {
      var videoClass = "";
      if (_isVideo && _isVideo.youtube) {
        videoClass = "lg-has-youtube";
      } else if (_isVideo && _isVideo.vimeo) {
        videoClass = "lg-has-vimeo";
      } else {
        videoClass = "lg-has-html5";
      }
      return '<div class="lg-video-cont ' + videoClass + '" style="' + videoContStyle + '">\n                <div class="lg-video-play-button">\n                <svg\n                    viewBox="0 0 20 20"\n                    preserveAspectRatio="xMidYMid"\n                    focusable="false"\n                    aria-labelledby="' + playVideoString + '"\n                    role="img"\n                    class="lg-video-play-icon"\n                >\n                    <title>' + playVideoString + '</title>\n                    <polygon class="lg-video-play-icon-inner" points="1,0 20,10 1,20"></polygon>\n                </svg>\n                <svg class="lg-video-play-icon-bg" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle></svg>\n                <svg class="lg-video-play-icon-circle" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle>\n                </svg>\n            </div>\n            ' + (dummyImg || "") + '\n            <img class="lg-object lg-video-poster" src="' + _poster + '" />\n        </div>';
    },
    getFocusableElements: function(container) {
      var elements2 = container.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input[type="text"]:not([disabled]), input[type="radio"]:not([disabled]), input[type="checkbox"]:not([disabled]), select:not([disabled])');
      var visibleElements = [].filter.call(elements2, function(element) {
        var style = window.getComputedStyle(element);
        return style.display !== "none" && style.visibility !== "hidden";
      });
      return visibleElements;
    },
    /**
     * @desc Create dynamic elements array from gallery items when dynamic option is false
     * It helps to avoid frequent DOM interaction
     * and avoid multiple checks for dynamic elments
     *
     * @returns {Array} dynamicEl
     */
    getDynamicOptions: function(items, extraProps, getCaptionFromTitleOrAlt, exThumbImage) {
      var dynamicElements = [];
      var availableDynamicOptions = __spreadArrays(defaultDynamicOptions, extraProps);
      [].forEach.call(items, function(item) {
        var dynamicEl = {};
        for (var i3 = 0; i3 < item.attributes.length; i3++) {
          var attr = item.attributes[i3];
          if (attr.specified) {
            var dynamicAttr = convertToData(attr.name);
            var label = "";
            if (availableDynamicOptions.indexOf(dynamicAttr) > -1) {
              label = dynamicAttr;
            }
            if (label) {
              dynamicEl[label] = attr.value;
            }
          }
        }
        var currentItem = $LG(item);
        var alt = currentItem.find("img").first().attr("alt");
        var title = currentItem.attr("title");
        var thumb = exThumbImage ? currentItem.attr(exThumbImage) : currentItem.find("img").first().attr("src");
        dynamicEl.thumb = thumb;
        if (getCaptionFromTitleOrAlt && !dynamicEl.subHtml) {
          dynamicEl.subHtml = title || alt || "";
        }
        dynamicEl.alt = alt || title || "";
        dynamicElements.push(dynamicEl);
      });
      return dynamicElements;
    },
    isMobile: function() {
      return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    },
    /**
     * @desc Check the given src is video
     * @param {String} src
     * @return {Object} video type
     * Ex:{ youtube  :  ["//www.youtube.com/watch?v=c0asJgSyxcY", "c0asJgSyxcY"] }
     *
     * @todo - this information can be moved to dynamicEl to avoid frequent calls
     */
    isVideo: function(src, isHTML5VIdeo, index2) {
      if (!src) {
        if (isHTML5VIdeo) {
          return {
            html5: true
          };
        } else {
          console.error("lightGallery :- data-src is not provided on slide item " + (index2 + 1) + ". Please make sure the selector property is properly configured. More info - https://www.lightgalleryjs.com/demos/html-markup/");
          return;
        }
      }
      var youtube = src.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)([\&|?][\S]*)*/i);
      var vimeo = src.match(/\/\/(?:www\.)?(?:player\.)?vimeo.com\/(?:video\/)?([0-9a-z\-_]+)(.*)?/i);
      var wistia = src.match(/https?:\/\/(.+)?(wistia\.com|wi\.st)\/(medias|embed)\/([0-9a-z\-_]+)(.*)/);
      if (youtube) {
        return {
          youtube
        };
      } else if (vimeo) {
        return {
          vimeo
        };
      } else if (wistia) {
        return {
          wistia
        };
      }
    }
  };
  var lgId = 0;
  var LightGallery = (
    /** @class */
    function() {
      function LightGallery2(element, options) {
        this.lgOpened = false;
        this.index = 0;
        this.plugins = [];
        this.lGalleryOn = false;
        this.lgBusy = false;
        this.currentItemsInDom = [];
        this.prevScrollTop = 0;
        this.bodyPaddingRight = 0;
        this.isDummyImageRemoved = false;
        this.dragOrSwipeEnabled = false;
        this.mediaContainerPosition = {
          top: 0,
          bottom: 0
        };
        if (!element) {
          return this;
        }
        lgId++;
        this.lgId = lgId;
        this.el = element;
        this.LGel = $LG(element);
        this.generateSettings(options);
        this.buildModules();
        if (this.settings.dynamic && this.settings.dynamicEl !== void 0 && !Array.isArray(this.settings.dynamicEl)) {
          throw "When using dynamic mode, you must also define dynamicEl as an Array.";
        }
        this.galleryItems = this.getItems();
        this.normalizeSettings();
        this.init();
        this.validateLicense();
        return this;
      }
      LightGallery2.prototype.generateSettings = function(options) {
        this.settings = __assign(__assign({}, lightGalleryCoreSettings), options);
        if (this.settings.isMobile && typeof this.settings.isMobile === "function" ? this.settings.isMobile() : utils2.isMobile()) {
          var mobileSettings = __assign(__assign({}, this.settings.mobileSettings), this.settings.mobileSettings);
          this.settings = __assign(__assign({}, this.settings), mobileSettings);
        }
      };
      LightGallery2.prototype.normalizeSettings = function() {
        if (this.settings.slideEndAnimation) {
          this.settings.hideControlOnEnd = false;
        }
        if (!this.settings.closable) {
          this.settings.swipeToClose = false;
        }
        this.zoomFromOrigin = this.settings.zoomFromOrigin;
        if (this.settings.dynamic) {
          this.zoomFromOrigin = false;
        }
        if (!this.settings.container) {
          this.settings.container = document.body;
        }
        this.settings.preload = Math.min(this.settings.preload, this.galleryItems.length);
      };
      LightGallery2.prototype.init = function() {
        var _this = this;
        this.addSlideVideoInfo(this.galleryItems);
        this.buildStructure();
        this.LGel.trigger(lGEvents.init, {
          instance: this
        });
        if (this.settings.keyPress) {
          this.keyPress();
        }
        setTimeout(function() {
          _this.enableDrag();
          _this.enableSwipe();
          _this.triggerPosterClick();
        }, 50);
        this.arrow();
        if (this.settings.mousewheel) {
          this.mousewheel();
        }
        if (!this.settings.dynamic) {
          this.openGalleryOnItemClick();
        }
      };
      LightGallery2.prototype.openGalleryOnItemClick = function() {
        var _this = this;
        var _loop_1 = function(index3) {
          var element = this_1.items[index3];
          var $element = $LG(element);
          var uuid2 = lgQuery.generateUUID();
          $element.attr("data-lg-id", uuid2).on("click.lgcustom-item-" + uuid2, function(e2) {
            e2.preventDefault();
            var currentItemIndex = _this.settings.index || index3;
            _this.openGallery(currentItemIndex, element);
          });
        };
        var this_1 = this;
        for (var index2 = 0; index2 < this.items.length; index2++) {
          _loop_1(index2);
        }
      };
      LightGallery2.prototype.buildModules = function() {
        var _this = this;
        this.settings.plugins.forEach(function(plugin) {
          _this.plugins.push(new plugin(_this, $LG));
        });
      };
      LightGallery2.prototype.validateLicense = function() {
        if (!this.settings.licenseKey) {
          console.error("Please provide a valid license key");
        } else if (this.settings.licenseKey === "0000-0000-000-0000") {
          console.warn("lightGallery: " + this.settings.licenseKey + " license key is not valid for production use");
        }
      };
      LightGallery2.prototype.getSlideItem = function(index2) {
        return $LG(this.getSlideItemId(index2));
      };
      LightGallery2.prototype.getSlideItemId = function(index2) {
        return "#lg-item-" + this.lgId + "-" + index2;
      };
      LightGallery2.prototype.getIdName = function(id) {
        return id + "-" + this.lgId;
      };
      LightGallery2.prototype.getElementById = function(id) {
        return $LG("#" + this.getIdName(id));
      };
      LightGallery2.prototype.manageSingleSlideClassName = function() {
        if (this.galleryItems.length < 2) {
          this.outer.addClass("lg-single-item");
        } else {
          this.outer.removeClass("lg-single-item");
        }
      };
      LightGallery2.prototype.buildStructure = function() {
        var _this = this;
        var container = this.$container && this.$container.get();
        if (container) {
          return;
        }
        var controls = "";
        var subHtmlCont = "";
        if (this.settings.controls) {
          controls = '<button type="button" id="' + this.getIdName("lg-prev") + '" aria-label="' + this.settings.strings["previousSlide"] + '" class="lg-prev lg-icon"> ' + this.settings.prevHtml + ' </button>\n                <button type="button" id="' + this.getIdName("lg-next") + '" aria-label="' + this.settings.strings["nextSlide"] + '" class="lg-next lg-icon"> ' + this.settings.nextHtml + " </button>";
        }
        if (this.settings.appendSubHtmlTo !== ".lg-item") {
          subHtmlCont = '<div class="lg-sub-html" role="status" aria-live="polite"></div>';
        }
        var addClasses = "";
        if (this.settings.allowMediaOverlap) {
          addClasses += "lg-media-overlap ";
        }
        var ariaLabelledby = this.settings.ariaLabelledby ? 'aria-labelledby="' + this.settings.ariaLabelledby + '"' : "";
        var ariaDescribedby = this.settings.ariaDescribedby ? 'aria-describedby="' + this.settings.ariaDescribedby + '"' : "";
        var containerClassName = "lg-container " + this.settings.addClass + " " + (document.body !== this.settings.container ? "lg-inline" : "");
        var closeIcon = this.settings.closable && this.settings.showCloseIcon ? '<button type="button" aria-label="' + this.settings.strings["closeGallery"] + '" id="' + this.getIdName("lg-close") + '" class="lg-close lg-icon"></button>' : "";
        var maximizeIcon = this.settings.showMaximizeIcon ? '<button type="button" aria-label="' + this.settings.strings["toggleMaximize"] + '" id="' + this.getIdName("lg-maximize") + '" class="lg-maximize lg-icon"></button>' : "";
        var template2 = '\n        <div class="' + containerClassName + '" id="' + this.getIdName("lg-container") + '" tabindex="-1" aria-modal="true" ' + ariaLabelledby + " " + ariaDescribedby + ' role="dialog"\n        >\n            <div id="' + this.getIdName("lg-backdrop") + '" class="lg-backdrop"></div>\n\n            <div id="' + this.getIdName("lg-outer") + '" class="lg-outer lg-use-css3 lg-css3 lg-hide-items ' + addClasses + ' ">\n\n              <div id="' + this.getIdName("lg-content") + '" class="lg-content">\n                <div id="' + this.getIdName("lg-inner") + '" class="lg-inner">\n                </div>\n                ' + controls + '\n              </div>\n                <div id="' + this.getIdName("lg-toolbar") + '" class="lg-toolbar lg-group">\n                    ' + maximizeIcon + "\n                    " + closeIcon + "\n                    </div>\n                    " + (this.settings.appendSubHtmlTo === ".lg-outer" ? subHtmlCont : "") + '\n                <div id="' + this.getIdName("lg-components") + '" class="lg-components">\n                    ' + (this.settings.appendSubHtmlTo === ".lg-sub-html" ? subHtmlCont : "") + "\n                </div>\n            </div>\n        </div>\n        ";
        $LG(this.settings.container).append(template2);
        if (document.body !== this.settings.container) {
          $LG(this.settings.container).css("position", "relative");
        }
        this.outer = this.getElementById("lg-outer");
        this.$lgComponents = this.getElementById("lg-components");
        this.$backdrop = this.getElementById("lg-backdrop");
        this.$container = this.getElementById("lg-container");
        this.$inner = this.getElementById("lg-inner");
        this.$content = this.getElementById("lg-content");
        this.$toolbar = this.getElementById("lg-toolbar");
        this.$backdrop.css("transition-duration", this.settings.backdropDuration + "ms");
        var outerClassNames = this.settings.mode + " ";
        this.manageSingleSlideClassName();
        if (this.settings.enableDrag) {
          outerClassNames += "lg-grab ";
        }
        this.outer.addClass(outerClassNames);
        this.$inner.css("transition-timing-function", this.settings.easing);
        this.$inner.css("transition-duration", this.settings.speed + "ms");
        if (this.settings.download) {
          this.$toolbar.append('<a id="' + this.getIdName("lg-download") + '" target="_blank" rel="noopener" aria-label="' + this.settings.strings["download"] + '" download class="lg-download lg-icon"></a>');
        }
        this.counter();
        $LG(window).on("resize.lg.global" + this.lgId + " orientationchange.lg.global" + this.lgId, function() {
          _this.refreshOnResize();
        });
        this.hideBars();
        this.manageCloseGallery();
        this.toggleMaximize();
        this.initModules();
      };
      LightGallery2.prototype.refreshOnResize = function() {
        if (this.lgOpened) {
          var currentGalleryItem = this.galleryItems[this.index];
          var __slideVideoInfo = currentGalleryItem.__slideVideoInfo;
          this.mediaContainerPosition = this.getMediaContainerPosition();
          var _a = this.mediaContainerPosition, top_1 = _a.top, bottom2 = _a.bottom;
          this.currentImageSize = utils2.getSize(this.items[this.index], this.outer, top_1 + bottom2, __slideVideoInfo && this.settings.videoMaxSize);
          if (__slideVideoInfo) {
            this.resizeVideoSlide(this.index, this.currentImageSize);
          }
          if (this.zoomFromOrigin && !this.isDummyImageRemoved) {
            var imgStyle = this.getDummyImgStyles(this.currentImageSize);
            this.outer.find(".lg-current .lg-dummy-img").first().attr("style", imgStyle);
          }
          this.LGel.trigger(lGEvents.containerResize);
        }
      };
      LightGallery2.prototype.resizeVideoSlide = function(index2, imageSize) {
        var lgVideoStyle = this.getVideoContStyle(imageSize);
        var currentSlide = this.getSlideItem(index2);
        currentSlide.find(".lg-video-cont").attr("style", lgVideoStyle);
      };
      LightGallery2.prototype.updateSlides = function(items, index2) {
        if (this.index > items.length - 1) {
          this.index = items.length - 1;
        }
        if (items.length === 1) {
          this.index = 0;
        }
        if (!items.length) {
          this.closeGallery();
          return;
        }
        var currentSrc = this.galleryItems[index2].src;
        this.galleryItems = items;
        this.updateControls();
        this.$inner.empty();
        this.currentItemsInDom = [];
        var _index = 0;
        this.galleryItems.some(function(galleryItem, itemIndex) {
          if (galleryItem.src === currentSrc) {
            _index = itemIndex;
            return true;
          }
          return false;
        });
        this.currentItemsInDom = this.organizeSlideItems(_index, -1);
        this.loadContent(_index, true);
        this.getSlideItem(_index).addClass("lg-current");
        this.index = _index;
        this.updateCurrentCounter(_index);
        this.LGel.trigger(lGEvents.updateSlides);
      };
      LightGallery2.prototype.getItems = function() {
        this.items = [];
        if (!this.settings.dynamic) {
          if (this.settings.selector === "this") {
            this.items.push(this.el);
          } else if (this.settings.selector) {
            if (typeof this.settings.selector === "string") {
              if (this.settings.selectWithin) {
                var selectWithin = $LG(this.settings.selectWithin);
                this.items = selectWithin.find(this.settings.selector).get();
              } else {
                this.items = this.el.querySelectorAll(this.settings.selector);
              }
            } else {
              this.items = this.settings.selector;
            }
          } else {
            this.items = this.el.children;
          }
          return utils2.getDynamicOptions(this.items, this.settings.extraProps, this.settings.getCaptionFromTitleOrAlt, this.settings.exThumbImage);
        } else {
          return this.settings.dynamicEl || [];
        }
      };
      LightGallery2.prototype.shouldHideScrollbar = function() {
        return this.settings.hideScrollbar && document.body === this.settings.container;
      };
      LightGallery2.prototype.hideScrollbar = function() {
        if (!this.shouldHideScrollbar()) {
          return;
        }
        this.bodyPaddingRight = parseFloat($LG("body").style().paddingRight);
        var bodyRect = document.documentElement.getBoundingClientRect();
        var scrollbarWidth = window.innerWidth - bodyRect.width;
        $LG(document.body).css("padding-right", scrollbarWidth + this.bodyPaddingRight + "px");
        $LG(document.body).addClass("lg-overlay-open");
      };
      LightGallery2.prototype.resetScrollBar = function() {
        if (!this.shouldHideScrollbar()) {
          return;
        }
        $LG(document.body).css("padding-right", this.bodyPaddingRight + "px");
        $LG(document.body).removeClass("lg-overlay-open");
      };
      LightGallery2.prototype.openGallery = function(index2, element) {
        var _this = this;
        if (index2 === void 0) {
          index2 = this.settings.index;
        }
        if (this.lgOpened)
          return;
        this.lgOpened = true;
        this.outer.removeClass("lg-hide-items");
        this.hideScrollbar();
        this.$container.addClass("lg-show");
        var itemsToBeInsertedToDom = this.getItemsToBeInsertedToDom(index2, index2);
        this.currentItemsInDom = itemsToBeInsertedToDom;
        var items = "";
        itemsToBeInsertedToDom.forEach(function(item) {
          items = items + ('<div id="' + item + '" class="lg-item"></div>');
        });
        this.$inner.append(items);
        this.addHtml(index2);
        var transform = "";
        this.mediaContainerPosition = this.getMediaContainerPosition();
        var _a = this.mediaContainerPosition, top2 = _a.top, bottom2 = _a.bottom;
        if (!this.settings.allowMediaOverlap) {
          this.setMediaContainerPosition(top2, bottom2);
        }
        var __slideVideoInfo = this.galleryItems[index2].__slideVideoInfo;
        if (this.zoomFromOrigin && element) {
          this.currentImageSize = utils2.getSize(element, this.outer, top2 + bottom2, __slideVideoInfo && this.settings.videoMaxSize);
          transform = utils2.getTransform(element, this.outer, top2, bottom2, this.currentImageSize);
        }
        if (!this.zoomFromOrigin || !transform) {
          this.outer.addClass(this.settings.startClass);
          this.getSlideItem(index2).removeClass("lg-complete");
        }
        var timeout = this.settings.zoomFromOrigin ? 100 : this.settings.backdropDuration;
        setTimeout(function() {
          _this.outer.addClass("lg-components-open");
        }, timeout);
        this.index = index2;
        this.LGel.trigger(lGEvents.beforeOpen);
        this.getSlideItem(index2).addClass("lg-current");
        this.lGalleryOn = false;
        this.prevScrollTop = $LG(window).scrollTop();
        setTimeout(function() {
          if (_this.zoomFromOrigin && transform) {
            var currentSlide_1 = _this.getSlideItem(index2);
            currentSlide_1.css("transform", transform);
            setTimeout(function() {
              currentSlide_1.addClass("lg-start-progress lg-start-end-progress").css("transition-duration", _this.settings.startAnimationDuration + "ms");
              _this.outer.addClass("lg-zoom-from-image");
            });
            setTimeout(function() {
              currentSlide_1.css("transform", "translate3d(0, 0, 0)");
            }, 100);
          }
          setTimeout(function() {
            _this.$backdrop.addClass("in");
            _this.$container.addClass("lg-show-in");
          }, 10);
          setTimeout(function() {
            if (_this.settings.trapFocus && document.body === _this.settings.container) {
              _this.trapFocus();
            }
          }, _this.settings.backdropDuration + 50);
          if (!_this.zoomFromOrigin || !transform) {
            setTimeout(function() {
              _this.outer.addClass("lg-visible");
            }, _this.settings.backdropDuration);
          }
          _this.slide(index2, false, false, false);
          _this.LGel.trigger(lGEvents.afterOpen);
        });
        if (document.body === this.settings.container) {
          $LG("html").addClass("lg-on");
        }
      };
      LightGallery2.prototype.getMediaContainerPosition = function() {
        if (this.settings.allowMediaOverlap) {
          return {
            top: 0,
            bottom: 0
          };
        }
        var top2 = this.$toolbar.get().clientHeight || 0;
        var subHtml = this.outer.find(".lg-components .lg-sub-html").get();
        var captionHeight = this.settings.defaultCaptionHeight || subHtml && subHtml.clientHeight || 0;
        var thumbContainer = this.outer.find(".lg-thumb-outer").get();
        var thumbHeight = thumbContainer ? thumbContainer.clientHeight : 0;
        var bottom2 = thumbHeight + captionHeight;
        return {
          top: top2,
          bottom: bottom2
        };
      };
      LightGallery2.prototype.setMediaContainerPosition = function(top2, bottom2) {
        if (top2 === void 0) {
          top2 = 0;
        }
        if (bottom2 === void 0) {
          bottom2 = 0;
        }
        this.$content.css("top", top2 + "px").css("bottom", bottom2 + "px");
      };
      LightGallery2.prototype.hideBars = function() {
        var _this = this;
        setTimeout(function() {
          _this.outer.removeClass("lg-hide-items");
          if (_this.settings.hideBarsDelay > 0) {
            _this.outer.on("mousemove.lg click.lg touchstart.lg", function() {
              _this.outer.removeClass("lg-hide-items");
              clearTimeout(_this.hideBarTimeout);
              _this.hideBarTimeout = setTimeout(function() {
                _this.outer.addClass("lg-hide-items");
              }, _this.settings.hideBarsDelay);
            });
            _this.outer.trigger("mousemove.lg");
          }
        }, this.settings.showBarsAfter);
      };
      LightGallery2.prototype.initPictureFill = function($img) {
        if (this.settings.supportLegacyBrowser) {
          try {
            picturefill({
              elements: [$img.get()]
            });
          } catch (e2) {
            console.warn("lightGallery :- If you want srcset or picture tag to be supported for older browser please include picturefil javascript library in your document.");
          }
        }
      };
      LightGallery2.prototype.counter = function() {
        if (this.settings.counter) {
          var counterHtml = '<div class="lg-counter" role="status" aria-live="polite">\n                <span id="' + this.getIdName("lg-counter-current") + '" class="lg-counter-current">' + (this.index + 1) + ' </span> /\n                <span id="' + this.getIdName("lg-counter-all") + '" class="lg-counter-all">' + this.galleryItems.length + " </span></div>";
          this.outer.find(this.settings.appendCounterTo).append(counterHtml);
        }
      };
      LightGallery2.prototype.addHtml = function(index2) {
        var subHtml;
        var subHtmlUrl;
        if (this.galleryItems[index2].subHtmlUrl) {
          subHtmlUrl = this.galleryItems[index2].subHtmlUrl;
        } else {
          subHtml = this.galleryItems[index2].subHtml;
        }
        if (!subHtmlUrl) {
          if (subHtml) {
            var fL = subHtml.substring(0, 1);
            if (fL === "." || fL === "#") {
              if (this.settings.subHtmlSelectorRelative && !this.settings.dynamic) {
                subHtml = $LG(this.items).eq(index2).find(subHtml).first().html();
              } else {
                subHtml = $LG(subHtml).first().html();
              }
            }
          } else {
            subHtml = "";
          }
        }
        if (this.settings.appendSubHtmlTo !== ".lg-item") {
          if (subHtmlUrl) {
            this.outer.find(".lg-sub-html").load(subHtmlUrl);
          } else {
            this.outer.find(".lg-sub-html").html(subHtml);
          }
        } else {
          var currentSlide = $LG(this.getSlideItemId(index2));
          if (subHtmlUrl) {
            currentSlide.load(subHtmlUrl);
          } else {
            currentSlide.append('<div class="lg-sub-html">' + subHtml + "</div>");
          }
        }
        if (typeof subHtml !== "undefined" && subHtml !== null) {
          if (subHtml === "") {
            this.outer.find(this.settings.appendSubHtmlTo).addClass("lg-empty-html");
          } else {
            this.outer.find(this.settings.appendSubHtmlTo).removeClass("lg-empty-html");
          }
        }
        this.LGel.trigger(lGEvents.afterAppendSubHtml, {
          index: index2
        });
      };
      LightGallery2.prototype.preload = function(index2) {
        for (var i3 = 1; i3 <= this.settings.preload; i3++) {
          if (i3 >= this.galleryItems.length - index2) {
            break;
          }
          this.loadContent(index2 + i3, false);
        }
        for (var j6 = 1; j6 <= this.settings.preload; j6++) {
          if (index2 - j6 < 0) {
            break;
          }
          this.loadContent(index2 - j6, false);
        }
      };
      LightGallery2.prototype.getDummyImgStyles = function(imageSize) {
        if (!imageSize)
          return "";
        return "width:" + imageSize.width + "px;\n                margin-left: -" + imageSize.width / 2 + "px;\n                margin-top: -" + imageSize.height / 2 + "px;\n                height:" + imageSize.height + "px";
      };
      LightGallery2.prototype.getVideoContStyle = function(imageSize) {
        if (!imageSize)
          return "";
        return "width:" + imageSize.width + "px;\n                height:" + imageSize.height + "px";
      };
      LightGallery2.prototype.getDummyImageContent = function($currentSlide, index2, alt) {
        var $currentItem;
        if (!this.settings.dynamic) {
          $currentItem = $LG(this.items).eq(index2);
        }
        if ($currentItem) {
          var _dummyImgSrc = void 0;
          if (!this.settings.exThumbImage) {
            _dummyImgSrc = $currentItem.find("img").first().attr("src");
          } else {
            _dummyImgSrc = $currentItem.attr(this.settings.exThumbImage);
          }
          if (!_dummyImgSrc)
            return "";
          var imgStyle = this.getDummyImgStyles(this.currentImageSize);
          var dummyImgContent = "<img " + alt + ' style="' + imgStyle + '" class="lg-dummy-img" src="' + _dummyImgSrc + '" />';
          $currentSlide.addClass("lg-first-slide");
          this.outer.addClass("lg-first-slide-loading");
          return dummyImgContent;
        }
        return "";
      };
      LightGallery2.prototype.setImgMarkup = function(src, $currentSlide, index2) {
        var currentGalleryItem = this.galleryItems[index2];
        var alt = currentGalleryItem.alt, srcset = currentGalleryItem.srcset, sizes = currentGalleryItem.sizes, sources = currentGalleryItem.sources;
        var imgContent = "";
        var altAttr = alt ? 'alt="' + alt + '"' : "";
        if (this.isFirstSlideWithZoomAnimation()) {
          imgContent = this.getDummyImageContent($currentSlide, index2, altAttr);
        } else {
          imgContent = utils2.getImgMarkup(index2, src, altAttr, srcset, sizes, sources);
        }
        var imgMarkup = '<picture class="lg-img-wrap"> ' + imgContent + "</picture>";
        $currentSlide.prepend(imgMarkup);
      };
      LightGallery2.prototype.onSlideObjectLoad = function($slide, isHTML5VideoWithoutPoster, onLoad, onError) {
        var mediaObject = $slide.find(".lg-object").first();
        if (utils2.isImageLoaded(mediaObject.get()) || isHTML5VideoWithoutPoster) {
          onLoad();
        } else {
          mediaObject.on("load.lg error.lg", function() {
            onLoad && onLoad();
          });
          mediaObject.on("error.lg", function() {
            onError && onError();
          });
        }
      };
      LightGallery2.prototype.onLgObjectLoad = function(currentSlide, index2, delay, speed, isFirstSlide, isHTML5VideoWithoutPoster) {
        var _this = this;
        this.onSlideObjectLoad(currentSlide, isHTML5VideoWithoutPoster, function() {
          _this.triggerSlideItemLoad(currentSlide, index2, delay, speed, isFirstSlide);
        }, function() {
          currentSlide.addClass("lg-complete lg-complete_");
          currentSlide.html('<span class="lg-error-msg">' + _this.settings.strings["mediaLoadingFailed"] + "</span>");
        });
      };
      LightGallery2.prototype.triggerSlideItemLoad = function($currentSlide, index2, delay, speed, isFirstSlide) {
        var _this = this;
        var currentGalleryItem = this.galleryItems[index2];
        var _speed = isFirstSlide && this.getSlideType(currentGalleryItem) === "video" && !currentGalleryItem.poster ? speed : 0;
        setTimeout(function() {
          $currentSlide.addClass("lg-complete lg-complete_");
          _this.LGel.trigger(lGEvents.slideItemLoad, {
            index: index2,
            delay: delay || 0,
            isFirstSlide
          });
        }, _speed);
      };
      LightGallery2.prototype.isFirstSlideWithZoomAnimation = function() {
        return !!(!this.lGalleryOn && this.zoomFromOrigin && this.currentImageSize);
      };
      LightGallery2.prototype.addSlideVideoInfo = function(items) {
        var _this = this;
        items.forEach(function(element, index2) {
          element.__slideVideoInfo = utils2.isVideo(element.src, !!element.video, index2);
          if (element.__slideVideoInfo && _this.settings.loadYouTubePoster && !element.poster && element.__slideVideoInfo.youtube) {
            element.poster = "//img.youtube.com/vi/" + element.__slideVideoInfo.youtube[1] + "/maxresdefault.jpg";
          }
        });
      };
      LightGallery2.prototype.loadContent = function(index2, rec) {
        var _this = this;
        var currentGalleryItem = this.galleryItems[index2];
        var $currentSlide = $LG(this.getSlideItemId(index2));
        var poster = currentGalleryItem.poster, srcset = currentGalleryItem.srcset, sizes = currentGalleryItem.sizes, sources = currentGalleryItem.sources;
        var src = currentGalleryItem.src;
        var video = currentGalleryItem.video;
        var _html5Video = video && typeof video === "string" ? JSON.parse(video) : video;
        if (currentGalleryItem.responsive) {
          var srcDyItms = currentGalleryItem.responsive.split(",");
          src = utils2.getResponsiveSrc(srcDyItms) || src;
        }
        var videoInfo = currentGalleryItem.__slideVideoInfo;
        var lgVideoStyle = "";
        var iframe = !!currentGalleryItem.iframe;
        var isFirstSlide = !this.lGalleryOn;
        var delay = 0;
        if (isFirstSlide) {
          if (this.zoomFromOrigin && this.currentImageSize) {
            delay = this.settings.startAnimationDuration + 10;
          } else {
            delay = this.settings.backdropDuration + 10;
          }
        }
        if (!$currentSlide.hasClass("lg-loaded")) {
          if (videoInfo) {
            var _a = this.mediaContainerPosition, top_2 = _a.top, bottom2 = _a.bottom;
            var videoSize = utils2.getSize(this.items[index2], this.outer, top_2 + bottom2, videoInfo && this.settings.videoMaxSize);
            lgVideoStyle = this.getVideoContStyle(videoSize);
          }
          if (iframe) {
            var markup = utils2.getIframeMarkup(this.settings.iframeWidth, this.settings.iframeHeight, this.settings.iframeMaxWidth, this.settings.iframeMaxHeight, src, currentGalleryItem.iframeTitle);
            $currentSlide.prepend(markup);
          } else if (poster) {
            var dummyImg = "";
            var hasStartAnimation = isFirstSlide && this.zoomFromOrigin && this.currentImageSize;
            if (hasStartAnimation) {
              dummyImg = this.getDummyImageContent($currentSlide, index2, "");
            }
            var markup = utils2.getVideoPosterMarkup(poster, dummyImg || "", lgVideoStyle, this.settings.strings["playVideo"], videoInfo);
            $currentSlide.prepend(markup);
          } else if (videoInfo) {
            var markup = '<div class="lg-video-cont " style="' + lgVideoStyle + '"></div>';
            $currentSlide.prepend(markup);
          } else {
            this.setImgMarkup(src, $currentSlide, index2);
            if (srcset || sources) {
              var $img = $currentSlide.find(".lg-object");
              this.initPictureFill($img);
            }
          }
          if (poster || videoInfo) {
            this.LGel.trigger(lGEvents.hasVideo, {
              index: index2,
              src,
              html5Video: _html5Video,
              hasPoster: !!poster
            });
          }
          this.LGel.trigger(lGEvents.afterAppendSlide, { index: index2 });
          if (this.lGalleryOn && this.settings.appendSubHtmlTo === ".lg-item") {
            this.addHtml(index2);
          }
        }
        var _speed = 0;
        if (delay && !$LG(document.body).hasClass("lg-from-hash")) {
          _speed = delay;
        }
        if (this.isFirstSlideWithZoomAnimation()) {
          setTimeout(function() {
            $currentSlide.removeClass("lg-start-end-progress lg-start-progress").removeAttr("style");
          }, this.settings.startAnimationDuration + 100);
          if (!$currentSlide.hasClass("lg-loaded")) {
            setTimeout(function() {
              if (_this.getSlideType(currentGalleryItem) === "image") {
                var alt = currentGalleryItem.alt;
                var altAttr = alt ? 'alt="' + alt + '"' : "";
                $currentSlide.find(".lg-img-wrap").append(utils2.getImgMarkup(index2, src, altAttr, srcset, sizes, currentGalleryItem.sources));
                if (srcset || sources) {
                  var $img2 = $currentSlide.find(".lg-object");
                  _this.initPictureFill($img2);
                }
              }
              if (_this.getSlideType(currentGalleryItem) === "image" || _this.getSlideType(currentGalleryItem) === "video" && poster) {
                _this.onLgObjectLoad($currentSlide, index2, delay, _speed, true, false);
                _this.onSlideObjectLoad($currentSlide, !!(videoInfo && videoInfo.html5 && !poster), function() {
                  _this.loadContentOnFirstSlideLoad(index2, $currentSlide, _speed);
                }, function() {
                  _this.loadContentOnFirstSlideLoad(index2, $currentSlide, _speed);
                });
              }
            }, this.settings.startAnimationDuration + 100);
          }
        }
        $currentSlide.addClass("lg-loaded");
        if (!this.isFirstSlideWithZoomAnimation() || this.getSlideType(currentGalleryItem) === "video" && !poster) {
          this.onLgObjectLoad($currentSlide, index2, delay, _speed, isFirstSlide, !!(videoInfo && videoInfo.html5 && !poster));
        }
        if ((!this.zoomFromOrigin || !this.currentImageSize) && $currentSlide.hasClass("lg-complete_") && !this.lGalleryOn) {
          setTimeout(function() {
            $currentSlide.addClass("lg-complete");
          }, this.settings.backdropDuration);
        }
        this.lGalleryOn = true;
        if (rec === true) {
          if (!$currentSlide.hasClass("lg-complete_")) {
            $currentSlide.find(".lg-object").first().on("load.lg error.lg", function() {
              _this.preload(index2);
            });
          } else {
            this.preload(index2);
          }
        }
      };
      LightGallery2.prototype.loadContentOnFirstSlideLoad = function(index2, $currentSlide, speed) {
        var _this = this;
        setTimeout(function() {
          $currentSlide.find(".lg-dummy-img").remove();
          $currentSlide.removeClass("lg-first-slide");
          _this.outer.removeClass("lg-first-slide-loading");
          _this.isDummyImageRemoved = true;
          _this.preload(index2);
        }, speed + 300);
      };
      LightGallery2.prototype.getItemsToBeInsertedToDom = function(index2, prevIndex, numberOfItems) {
        var _this = this;
        if (numberOfItems === void 0) {
          numberOfItems = 0;
        }
        var itemsToBeInsertedToDom = [];
        var possibleNumberOfItems = Math.max(numberOfItems, 3);
        possibleNumberOfItems = Math.min(possibleNumberOfItems, this.galleryItems.length);
        var prevIndexItem = "lg-item-" + this.lgId + "-" + prevIndex;
        if (this.galleryItems.length <= 3) {
          this.galleryItems.forEach(function(_element, index3) {
            itemsToBeInsertedToDom.push("lg-item-" + _this.lgId + "-" + index3);
          });
          return itemsToBeInsertedToDom;
        }
        if (index2 < (this.galleryItems.length - 1) / 2) {
          for (var idx = index2; idx > index2 - possibleNumberOfItems / 2 && idx >= 0; idx--) {
            itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + idx);
          }
          var numberOfExistingItems = itemsToBeInsertedToDom.length;
          for (var idx = 0; idx < possibleNumberOfItems - numberOfExistingItems; idx++) {
            itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (index2 + idx + 1));
          }
        } else {
          for (var idx = index2; idx <= this.galleryItems.length - 1 && idx < index2 + possibleNumberOfItems / 2; idx++) {
            itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + idx);
          }
          var numberOfExistingItems = itemsToBeInsertedToDom.length;
          for (var idx = 0; idx < possibleNumberOfItems - numberOfExistingItems; idx++) {
            itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (index2 - idx - 1));
          }
        }
        if (this.settings.loop) {
          if (index2 === this.galleryItems.length - 1) {
            itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-0");
          } else if (index2 === 0) {
            itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (this.galleryItems.length - 1));
          }
        }
        if (itemsToBeInsertedToDom.indexOf(prevIndexItem) === -1) {
          itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + prevIndex);
        }
        return itemsToBeInsertedToDom;
      };
      LightGallery2.prototype.organizeSlideItems = function(index2, prevIndex) {
        var _this = this;
        var itemsToBeInsertedToDom = this.getItemsToBeInsertedToDom(index2, prevIndex, this.settings.numberOfSlideItemsInDom);
        itemsToBeInsertedToDom.forEach(function(item) {
          if (_this.currentItemsInDom.indexOf(item) === -1) {
            _this.$inner.append('<div id="' + item + '" class="lg-item"></div>');
          }
        });
        this.currentItemsInDom.forEach(function(item) {
          if (itemsToBeInsertedToDom.indexOf(item) === -1) {
            $LG("#" + item).remove();
          }
        });
        return itemsToBeInsertedToDom;
      };
      LightGallery2.prototype.getPreviousSlideIndex = function() {
        var prevIndex = 0;
        try {
          var currentItemId = this.outer.find(".lg-current").first().attr("id");
          prevIndex = parseInt(currentItemId.split("-")[3]) || 0;
        } catch (error3) {
          prevIndex = 0;
        }
        return prevIndex;
      };
      LightGallery2.prototype.setDownloadValue = function(index2) {
        if (this.settings.download) {
          var currentGalleryItem = this.galleryItems[index2];
          var hideDownloadBtn = currentGalleryItem.downloadUrl === false || currentGalleryItem.downloadUrl === "false";
          if (hideDownloadBtn) {
            this.outer.addClass("lg-hide-download");
          } else {
            var $download = this.getElementById("lg-download");
            this.outer.removeClass("lg-hide-download");
            $download.attr("href", currentGalleryItem.downloadUrl || currentGalleryItem.src);
            if (currentGalleryItem.download) {
              $download.attr("download", currentGalleryItem.download);
            }
          }
        }
      };
      LightGallery2.prototype.makeSlideAnimation = function(direction, currentSlideItem, previousSlideItem) {
        var _this = this;
        if (this.lGalleryOn) {
          previousSlideItem.addClass("lg-slide-progress");
        }
        setTimeout(function() {
          _this.outer.addClass("lg-no-trans");
          _this.outer.find(".lg-item").removeClass("lg-prev-slide lg-next-slide");
          if (direction === "prev") {
            currentSlideItem.addClass("lg-prev-slide");
            previousSlideItem.addClass("lg-next-slide");
          } else {
            currentSlideItem.addClass("lg-next-slide");
            previousSlideItem.addClass("lg-prev-slide");
          }
          setTimeout(function() {
            _this.outer.find(".lg-item").removeClass("lg-current");
            currentSlideItem.addClass("lg-current");
            _this.outer.removeClass("lg-no-trans");
          }, 50);
        }, this.lGalleryOn ? this.settings.slideDelay : 0);
      };
      LightGallery2.prototype.slide = function(index2, fromTouch, fromThumb, direction) {
        var _this = this;
        var prevIndex = this.getPreviousSlideIndex();
        this.currentItemsInDom = this.organizeSlideItems(index2, prevIndex);
        if (this.lGalleryOn && prevIndex === index2) {
          return;
        }
        var numberOfGalleryItems = this.galleryItems.length;
        if (!this.lgBusy) {
          if (this.settings.counter) {
            this.updateCurrentCounter(index2);
          }
          var currentSlideItem = this.getSlideItem(index2);
          var previousSlideItem_1 = this.getSlideItem(prevIndex);
          var currentGalleryItem = this.galleryItems[index2];
          var videoInfo = currentGalleryItem.__slideVideoInfo;
          this.outer.attr("data-lg-slide-type", this.getSlideType(currentGalleryItem));
          this.setDownloadValue(index2);
          if (videoInfo) {
            var _a = this.mediaContainerPosition, top_3 = _a.top, bottom2 = _a.bottom;
            var videoSize = utils2.getSize(this.items[index2], this.outer, top_3 + bottom2, videoInfo && this.settings.videoMaxSize);
            this.resizeVideoSlide(index2, videoSize);
          }
          this.LGel.trigger(lGEvents.beforeSlide, {
            prevIndex,
            index: index2,
            fromTouch: !!fromTouch,
            fromThumb: !!fromThumb
          });
          this.lgBusy = true;
          clearTimeout(this.hideBarTimeout);
          this.arrowDisable(index2);
          if (!direction) {
            if (index2 < prevIndex) {
              direction = "prev";
            } else if (index2 > prevIndex) {
              direction = "next";
            }
          }
          if (!fromTouch) {
            this.makeSlideAnimation(direction, currentSlideItem, previousSlideItem_1);
          } else {
            this.outer.find(".lg-item").removeClass("lg-prev-slide lg-current lg-next-slide");
            var touchPrev = void 0;
            var touchNext = void 0;
            if (numberOfGalleryItems > 2) {
              touchPrev = index2 - 1;
              touchNext = index2 + 1;
              if (index2 === 0 && prevIndex === numberOfGalleryItems - 1) {
                touchNext = 0;
                touchPrev = numberOfGalleryItems - 1;
              } else if (index2 === numberOfGalleryItems - 1 && prevIndex === 0) {
                touchNext = 0;
                touchPrev = numberOfGalleryItems - 1;
              }
            } else {
              touchPrev = 0;
              touchNext = 1;
            }
            if (direction === "prev") {
              this.getSlideItem(touchNext).addClass("lg-next-slide");
            } else {
              this.getSlideItem(touchPrev).addClass("lg-prev-slide");
            }
            currentSlideItem.addClass("lg-current");
          }
          if (!this.lGalleryOn) {
            this.loadContent(index2, true);
          } else {
            setTimeout(function() {
              _this.loadContent(index2, true);
              if (_this.settings.appendSubHtmlTo !== ".lg-item") {
                _this.addHtml(index2);
              }
            }, this.settings.speed + 50 + (fromTouch ? 0 : this.settings.slideDelay));
          }
          setTimeout(function() {
            _this.lgBusy = false;
            previousSlideItem_1.removeClass("lg-slide-progress");
            _this.LGel.trigger(lGEvents.afterSlide, {
              prevIndex,
              index: index2,
              fromTouch,
              fromThumb
            });
          }, (this.lGalleryOn ? this.settings.speed + 100 : 100) + (fromTouch ? 0 : this.settings.slideDelay));
        }
        this.index = index2;
      };
      LightGallery2.prototype.updateCurrentCounter = function(index2) {
        this.getElementById("lg-counter-current").html(index2 + 1 + "");
      };
      LightGallery2.prototype.updateCounterTotal = function() {
        this.getElementById("lg-counter-all").html(this.galleryItems.length + "");
      };
      LightGallery2.prototype.getSlideType = function(item) {
        if (item.__slideVideoInfo) {
          return "video";
        } else if (item.iframe) {
          return "iframe";
        } else {
          return "image";
        }
      };
      LightGallery2.prototype.touchMove = function(startCoords, endCoords, e2) {
        var distanceX = endCoords.pageX - startCoords.pageX;
        var distanceY = endCoords.pageY - startCoords.pageY;
        var allowSwipe = false;
        if (this.swipeDirection) {
          allowSwipe = true;
        } else {
          if (Math.abs(distanceX) > 15) {
            this.swipeDirection = "horizontal";
            allowSwipe = true;
          } else if (Math.abs(distanceY) > 15) {
            this.swipeDirection = "vertical";
            allowSwipe = true;
          }
        }
        if (!allowSwipe) {
          return;
        }
        var $currentSlide = this.getSlideItem(this.index);
        if (this.swipeDirection === "horizontal") {
          e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
          this.outer.addClass("lg-dragging");
          this.setTranslate($currentSlide, distanceX, 0);
          var width = $currentSlide.get().offsetWidth;
          var slideWidthAmount = width * 15 / 100;
          var gutter = slideWidthAmount - Math.abs(distanceX * 10 / 100);
          this.setTranslate(this.outer.find(".lg-prev-slide").first(), -width + distanceX - gutter, 0);
          this.setTranslate(this.outer.find(".lg-next-slide").first(), width + distanceX + gutter, 0);
        } else if (this.swipeDirection === "vertical") {
          if (this.settings.swipeToClose) {
            e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
            this.$container.addClass("lg-dragging-vertical");
            var opacity = 1 - Math.abs(distanceY) / window.innerHeight;
            this.$backdrop.css("opacity", opacity);
            var scale = 1 - Math.abs(distanceY) / (window.innerWidth * 2);
            this.setTranslate($currentSlide, 0, distanceY, scale, scale);
            if (Math.abs(distanceY) > 100) {
              this.outer.addClass("lg-hide-items").removeClass("lg-components-open");
            }
          }
        }
      };
      LightGallery2.prototype.touchEnd = function(endCoords, startCoords, event2) {
        var _this = this;
        var distance;
        if (this.settings.mode !== "lg-slide") {
          this.outer.addClass("lg-slide");
        }
        setTimeout(function() {
          _this.$container.removeClass("lg-dragging-vertical");
          _this.outer.removeClass("lg-dragging lg-hide-items").addClass("lg-components-open");
          var triggerClick = true;
          if (_this.swipeDirection === "horizontal") {
            distance = endCoords.pageX - startCoords.pageX;
            var distanceAbs = Math.abs(endCoords.pageX - startCoords.pageX);
            if (distance < 0 && distanceAbs > _this.settings.swipeThreshold) {
              _this.goToNextSlide(true);
              triggerClick = false;
            } else if (distance > 0 && distanceAbs > _this.settings.swipeThreshold) {
              _this.goToPrevSlide(true);
              triggerClick = false;
            }
          } else if (_this.swipeDirection === "vertical") {
            distance = Math.abs(endCoords.pageY - startCoords.pageY);
            if (_this.settings.closable && _this.settings.swipeToClose && distance > 100) {
              _this.closeGallery();
              return;
            } else {
              _this.$backdrop.css("opacity", 1);
            }
          }
          _this.outer.find(".lg-item").removeAttr("style");
          if (triggerClick && Math.abs(endCoords.pageX - startCoords.pageX) < 5) {
            var target = $LG(event2.target);
            if (_this.isPosterElement(target)) {
              _this.LGel.trigger(lGEvents.posterClick);
            }
          }
          _this.swipeDirection = void 0;
        });
        setTimeout(function() {
          if (!_this.outer.hasClass("lg-dragging") && _this.settings.mode !== "lg-slide") {
            _this.outer.removeClass("lg-slide");
          }
        }, this.settings.speed + 100);
      };
      LightGallery2.prototype.enableSwipe = function() {
        var _this = this;
        var startCoords = {};
        var endCoords = {};
        var isMoved = false;
        var isSwiping = false;
        if (this.settings.enableSwipe) {
          this.$inner.on("touchstart.lg", function(e2) {
            _this.dragOrSwipeEnabled = true;
            var $item = _this.getSlideItem(_this.index);
            if (($LG(e2.target).hasClass("lg-item") || $item.get().contains(e2.target)) && !_this.outer.hasClass("lg-zoomed") && !_this.lgBusy && e2.touches.length === 1) {
              isSwiping = true;
              _this.touchAction = "swipe";
              _this.manageSwipeClass();
              startCoords = {
                pageX: e2.touches[0].pageX,
                pageY: e2.touches[0].pageY
              };
            }
          });
          this.$inner.on("touchmove.lg", function(e2) {
            if (isSwiping && _this.touchAction === "swipe" && e2.touches.length === 1) {
              endCoords = {
                pageX: e2.touches[0].pageX,
                pageY: e2.touches[0].pageY
              };
              _this.touchMove(startCoords, endCoords, e2);
              isMoved = true;
            }
          });
          this.$inner.on("touchend.lg", function(event2) {
            if (_this.touchAction === "swipe") {
              if (isMoved) {
                isMoved = false;
                _this.touchEnd(endCoords, startCoords, event2);
              } else if (isSwiping) {
                var target = $LG(event2.target);
                if (_this.isPosterElement(target)) {
                  _this.LGel.trigger(lGEvents.posterClick);
                }
              }
              _this.touchAction = void 0;
              isSwiping = false;
            }
          });
        }
      };
      LightGallery2.prototype.enableDrag = function() {
        var _this = this;
        var startCoords = {};
        var endCoords = {};
        var isDraging = false;
        var isMoved = false;
        if (this.settings.enableDrag) {
          this.outer.on("mousedown.lg", function(e2) {
            _this.dragOrSwipeEnabled = true;
            var $item = _this.getSlideItem(_this.index);
            if ($LG(e2.target).hasClass("lg-item") || $item.get().contains(e2.target)) {
              if (!_this.outer.hasClass("lg-zoomed") && !_this.lgBusy) {
                e2.preventDefault();
                if (!_this.lgBusy) {
                  _this.manageSwipeClass();
                  startCoords = {
                    pageX: e2.pageX,
                    pageY: e2.pageY
                  };
                  isDraging = true;
                  _this.outer.get().scrollLeft += 1;
                  _this.outer.get().scrollLeft -= 1;
                  _this.outer.removeClass("lg-grab").addClass("lg-grabbing");
                  _this.LGel.trigger(lGEvents.dragStart);
                }
              }
            }
          });
          $LG(window).on("mousemove.lg.global" + this.lgId, function(e2) {
            if (isDraging && _this.lgOpened) {
              isMoved = true;
              endCoords = {
                pageX: e2.pageX,
                pageY: e2.pageY
              };
              _this.touchMove(startCoords, endCoords);
              _this.LGel.trigger(lGEvents.dragMove);
            }
          });
          $LG(window).on("mouseup.lg.global" + this.lgId, function(event2) {
            if (!_this.lgOpened) {
              return;
            }
            var target = $LG(event2.target);
            if (isMoved) {
              isMoved = false;
              _this.touchEnd(endCoords, startCoords, event2);
              _this.LGel.trigger(lGEvents.dragEnd);
            } else if (_this.isPosterElement(target)) {
              _this.LGel.trigger(lGEvents.posterClick);
            }
            if (isDraging) {
              isDraging = false;
              _this.outer.removeClass("lg-grabbing").addClass("lg-grab");
            }
          });
        }
      };
      LightGallery2.prototype.triggerPosterClick = function() {
        var _this = this;
        this.$inner.on("click.lg", function(event2) {
          if (!_this.dragOrSwipeEnabled && _this.isPosterElement($LG(event2.target))) {
            _this.LGel.trigger(lGEvents.posterClick);
          }
        });
      };
      LightGallery2.prototype.manageSwipeClass = function() {
        var _touchNext = this.index + 1;
        var _touchPrev = this.index - 1;
        if (this.settings.loop && this.galleryItems.length > 2) {
          if (this.index === 0) {
            _touchPrev = this.galleryItems.length - 1;
          } else if (this.index === this.galleryItems.length - 1) {
            _touchNext = 0;
          }
        }
        this.outer.find(".lg-item").removeClass("lg-next-slide lg-prev-slide");
        if (_touchPrev > -1) {
          this.getSlideItem(_touchPrev).addClass("lg-prev-slide");
        }
        this.getSlideItem(_touchNext).addClass("lg-next-slide");
      };
      LightGallery2.prototype.goToNextSlide = function(fromTouch) {
        var _this = this;
        var _loop = this.settings.loop;
        if (fromTouch && this.galleryItems.length < 3) {
          _loop = false;
        }
        if (!this.lgBusy) {
          if (this.index + 1 < this.galleryItems.length) {
            this.index++;
            this.LGel.trigger(lGEvents.beforeNextSlide, {
              index: this.index
            });
            this.slide(this.index, !!fromTouch, false, "next");
          } else {
            if (_loop) {
              this.index = 0;
              this.LGel.trigger(lGEvents.beforeNextSlide, {
                index: this.index
              });
              this.slide(this.index, !!fromTouch, false, "next");
            } else if (this.settings.slideEndAnimation && !fromTouch) {
              this.outer.addClass("lg-right-end");
              setTimeout(function() {
                _this.outer.removeClass("lg-right-end");
              }, 400);
            }
          }
        }
      };
      LightGallery2.prototype.goToPrevSlide = function(fromTouch) {
        var _this = this;
        var _loop = this.settings.loop;
        if (fromTouch && this.galleryItems.length < 3) {
          _loop = false;
        }
        if (!this.lgBusy) {
          if (this.index > 0) {
            this.index--;
            this.LGel.trigger(lGEvents.beforePrevSlide, {
              index: this.index,
              fromTouch
            });
            this.slide(this.index, !!fromTouch, false, "prev");
          } else {
            if (_loop) {
              this.index = this.galleryItems.length - 1;
              this.LGel.trigger(lGEvents.beforePrevSlide, {
                index: this.index,
                fromTouch
              });
              this.slide(this.index, !!fromTouch, false, "prev");
            } else if (this.settings.slideEndAnimation && !fromTouch) {
              this.outer.addClass("lg-left-end");
              setTimeout(function() {
                _this.outer.removeClass("lg-left-end");
              }, 400);
            }
          }
        }
      };
      LightGallery2.prototype.keyPress = function() {
        var _this = this;
        $LG(window).on("keydown.lg.global" + this.lgId, function(e2) {
          if (_this.lgOpened && _this.settings.escKey === true && e2.keyCode === 27) {
            e2.preventDefault();
            if (_this.settings.allowMediaOverlap && _this.outer.hasClass("lg-can-toggle") && _this.outer.hasClass("lg-components-open")) {
              _this.outer.removeClass("lg-components-open");
            } else {
              _this.closeGallery();
            }
          }
          if (_this.lgOpened && _this.galleryItems.length > 1) {
            if (e2.keyCode === 37) {
              e2.preventDefault();
              _this.goToPrevSlide();
            }
            if (e2.keyCode === 39) {
              e2.preventDefault();
              _this.goToNextSlide();
            }
          }
        });
      };
      LightGallery2.prototype.arrow = function() {
        var _this = this;
        this.getElementById("lg-prev").on("click.lg", function() {
          _this.goToPrevSlide();
        });
        this.getElementById("lg-next").on("click.lg", function() {
          _this.goToNextSlide();
        });
      };
      LightGallery2.prototype.arrowDisable = function(index2) {
        if (!this.settings.loop && this.settings.hideControlOnEnd) {
          var $prev = this.getElementById("lg-prev");
          var $next = this.getElementById("lg-next");
          if (index2 + 1 === this.galleryItems.length) {
            $next.attr("disabled", "disabled").addClass("disabled");
          } else {
            $next.removeAttr("disabled").removeClass("disabled");
          }
          if (index2 === 0) {
            $prev.attr("disabled", "disabled").addClass("disabled");
          } else {
            $prev.removeAttr("disabled").removeClass("disabled");
          }
        }
      };
      LightGallery2.prototype.setTranslate = function($el, xValue, yValue, scaleX, scaleY) {
        if (scaleX === void 0) {
          scaleX = 1;
        }
        if (scaleY === void 0) {
          scaleY = 1;
        }
        $el.css("transform", "translate3d(" + xValue + "px, " + yValue + "px, 0px) scale3d(" + scaleX + ", " + scaleY + ", 1)");
      };
      LightGallery2.prototype.mousewheel = function() {
        var _this = this;
        var lastCall = 0;
        this.outer.on("wheel.lg", function(e2) {
          if (!e2.deltaY || _this.galleryItems.length < 2) {
            return;
          }
          e2.preventDefault();
          var now3 = (/* @__PURE__ */ new Date()).getTime();
          if (now3 - lastCall < 1e3) {
            return;
          }
          lastCall = now3;
          if (e2.deltaY > 0) {
            _this.goToNextSlide();
          } else if (e2.deltaY < 0) {
            _this.goToPrevSlide();
          }
        });
      };
      LightGallery2.prototype.isSlideElement = function(target) {
        return target.hasClass("lg-outer") || target.hasClass("lg-item") || target.hasClass("lg-img-wrap");
      };
      LightGallery2.prototype.isPosterElement = function(target) {
        var playButton = this.getSlideItem(this.index).find(".lg-video-play-button").get();
        return target.hasClass("lg-video-poster") || target.hasClass("lg-video-play-button") || playButton && playButton.contains(target.get());
      };
      LightGallery2.prototype.toggleMaximize = function() {
        var _this = this;
        this.getElementById("lg-maximize").on("click.lg", function() {
          _this.$container.toggleClass("lg-inline");
          _this.refreshOnResize();
        });
      };
      LightGallery2.prototype.invalidateItems = function() {
        for (var index2 = 0; index2 < this.items.length; index2++) {
          var element = this.items[index2];
          var $element = $LG(element);
          $element.off("click.lgcustom-item-" + $element.attr("data-lg-id"));
        }
      };
      LightGallery2.prototype.trapFocus = function() {
        var _this = this;
        this.$container.get().focus({
          preventScroll: true
        });
        $LG(window).on("keydown.lg.global" + this.lgId, function(e2) {
          if (!_this.lgOpened) {
            return;
          }
          var isTabPressed = e2.key === "Tab" || e2.keyCode === 9;
          if (!isTabPressed) {
            return;
          }
          var focusableEls = utils2.getFocusableElements(_this.$container.get());
          var firstFocusableEl = focusableEls[0];
          var lastFocusableEl = focusableEls[focusableEls.length - 1];
          if (e2.shiftKey) {
            if (document.activeElement === firstFocusableEl) {
              lastFocusableEl.focus();
              e2.preventDefault();
            }
          } else {
            if (document.activeElement === lastFocusableEl) {
              firstFocusableEl.focus();
              e2.preventDefault();
            }
          }
        });
      };
      LightGallery2.prototype.manageCloseGallery = function() {
        var _this = this;
        if (!this.settings.closable)
          return;
        var mousedown = false;
        this.getElementById("lg-close").on("click.lg", function() {
          _this.closeGallery();
        });
        if (this.settings.closeOnTap) {
          this.outer.on("mousedown.lg", function(e2) {
            var target = $LG(e2.target);
            if (_this.isSlideElement(target)) {
              mousedown = true;
            } else {
              mousedown = false;
            }
          });
          this.outer.on("mousemove.lg", function() {
            mousedown = false;
          });
          this.outer.on("mouseup.lg", function(e2) {
            var target = $LG(e2.target);
            if (_this.isSlideElement(target) && mousedown) {
              if (!_this.outer.hasClass("lg-dragging")) {
                _this.closeGallery();
              }
            }
          });
        }
      };
      LightGallery2.prototype.closeGallery = function(force) {
        var _this = this;
        if (!this.lgOpened || !this.settings.closable && !force) {
          return 0;
        }
        this.LGel.trigger(lGEvents.beforeClose);
        if (this.settings.resetScrollPosition && !this.settings.hideScrollbar) {
          $LG(window).scrollTop(this.prevScrollTop);
        }
        var currentItem = this.items[this.index];
        var transform;
        if (this.zoomFromOrigin && currentItem) {
          var _a = this.mediaContainerPosition, top_4 = _a.top, bottom2 = _a.bottom;
          var _b = this.galleryItems[this.index], __slideVideoInfo = _b.__slideVideoInfo, poster = _b.poster;
          var imageSize = utils2.getSize(currentItem, this.outer, top_4 + bottom2, __slideVideoInfo && poster && this.settings.videoMaxSize);
          transform = utils2.getTransform(currentItem, this.outer, top_4, bottom2, imageSize);
        }
        if (this.zoomFromOrigin && transform) {
          this.outer.addClass("lg-closing lg-zoom-from-image");
          this.getSlideItem(this.index).addClass("lg-start-end-progress").css("transition-duration", this.settings.startAnimationDuration + "ms").css("transform", transform);
        } else {
          this.outer.addClass("lg-hide-items");
          this.outer.removeClass("lg-zoom-from-image");
        }
        this.destroyModules();
        this.lGalleryOn = false;
        this.isDummyImageRemoved = false;
        this.zoomFromOrigin = this.settings.zoomFromOrigin;
        clearTimeout(this.hideBarTimeout);
        this.hideBarTimeout = false;
        $LG("html").removeClass("lg-on");
        this.outer.removeClass("lg-visible lg-components-open");
        this.$backdrop.removeClass("in").css("opacity", 0);
        var removeTimeout = this.zoomFromOrigin && transform ? Math.max(this.settings.startAnimationDuration, this.settings.backdropDuration) : this.settings.backdropDuration;
        this.$container.removeClass("lg-show-in");
        setTimeout(function() {
          if (_this.zoomFromOrigin && transform) {
            _this.outer.removeClass("lg-zoom-from-image");
          }
          _this.$container.removeClass("lg-show");
          _this.resetScrollBar();
          _this.$backdrop.removeAttr("style").css("transition-duration", _this.settings.backdropDuration + "ms");
          _this.outer.removeClass("lg-closing " + _this.settings.startClass);
          _this.getSlideItem(_this.index).removeClass("lg-start-end-progress");
          _this.$inner.empty();
          if (_this.lgOpened) {
            _this.LGel.trigger(lGEvents.afterClose, {
              instance: _this
            });
          }
          if (_this.$container.get()) {
            _this.$container.get().blur();
          }
          _this.lgOpened = false;
        }, removeTimeout + 100);
        return removeTimeout + 100;
      };
      LightGallery2.prototype.initModules = function() {
        this.plugins.forEach(function(module2) {
          try {
            module2.init();
          } catch (err) {
            console.warn("lightGallery:- make sure lightGallery module is properly initiated");
          }
        });
      };
      LightGallery2.prototype.destroyModules = function(destroy2) {
        this.plugins.forEach(function(module2) {
          try {
            if (destroy2) {
              module2.destroy();
            } else {
              module2.closeGallery && module2.closeGallery();
            }
          } catch (err) {
            console.warn("lightGallery:- make sure lightGallery module is properly destroyed");
          }
        });
      };
      LightGallery2.prototype.refresh = function(galleryItems) {
        if (!this.settings.dynamic) {
          this.invalidateItems();
        }
        if (galleryItems) {
          this.galleryItems = galleryItems;
        } else {
          this.galleryItems = this.getItems();
        }
        this.updateControls();
        this.openGalleryOnItemClick();
        this.LGel.trigger(lGEvents.updateSlides);
      };
      LightGallery2.prototype.updateControls = function() {
        this.addSlideVideoInfo(this.galleryItems);
        this.updateCounterTotal();
        this.manageSingleSlideClassName();
      };
      LightGallery2.prototype.destroyGallery = function() {
        this.destroyModules(true);
        if (!this.settings.dynamic) {
          this.invalidateItems();
        }
        $LG(window).off(".lg.global" + this.lgId);
        this.LGel.off(".lg");
        this.$container.remove();
      };
      LightGallery2.prototype.destroy = function() {
        var closeTimeout = this.closeGallery(true);
        if (closeTimeout) {
          setTimeout(this.destroyGallery.bind(this), closeTimeout);
        } else {
          this.destroyGallery();
        }
        return closeTimeout;
      };
      return LightGallery2;
    }()
  );
  function lightGallery(el, options) {
    return new LightGallery(el, options);
  }
  var lightgallery_es5_default = lightGallery;

  // node_modules/lightgallery/plugins/zoom/lg-zoom.es5.js
  init_define_process();
  init_jquery();
  var __assign2 = function() {
    __assign2 = Object.assign || function __assign4(t4) {
      for (var s4, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
        s4 = arguments[i3];
        for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4)) t4[p4] = s4[p4];
      }
      return t4;
    };
    return __assign2.apply(this, arguments);
  };
  var zoomSettings = {
    scale: 1,
    zoom: true,
    infiniteZoom: true,
    actualSize: true,
    showZoomInOutIcons: false,
    actualSizeIcons: {
      zoomIn: "lg-zoom-in",
      zoomOut: "lg-zoom-out"
    },
    enableZoomAfter: 300,
    zoomPluginStrings: {
      zoomIn: "Zoom in",
      zoomOut: "Zoom out",
      viewActualSize: "View actual size"
    }
  };
  var lGEvents2 = {
    afterAppendSlide: "lgAfterAppendSlide",
    init: "lgInit",
    hasVideo: "lgHasVideo",
    containerResize: "lgContainerResize",
    updateSlides: "lgUpdateSlides",
    afterAppendSubHtml: "lgAfterAppendSubHtml",
    beforeOpen: "lgBeforeOpen",
    afterOpen: "lgAfterOpen",
    slideItemLoad: "lgSlideItemLoad",
    beforeSlide: "lgBeforeSlide",
    afterSlide: "lgAfterSlide",
    posterClick: "lgPosterClick",
    dragStart: "lgDragStart",
    dragMove: "lgDragMove",
    dragEnd: "lgDragEnd",
    beforeNextSlide: "lgBeforeNextSlide",
    beforePrevSlide: "lgBeforePrevSlide",
    beforeClose: "lgBeforeClose",
    afterClose: "lgAfterClose",
    rotateLeft: "lgRotateLeft",
    rotateRight: "lgRotateRight",
    flipHorizontal: "lgFlipHorizontal",
    flipVertical: "lgFlipVertical",
    autoplay: "lgAutoplay",
    autoplayStart: "lgAutoplayStart",
    autoplayStop: "lgAutoplayStop"
  };
  var ZOOM_TRANSITION_DURATION = 500;
  var Zoom = (
    /** @class */
    function() {
      function Zoom2(instance, $LG2) {
        this.core = instance;
        this.$LG = $LG2;
        this.settings = __assign2(__assign2({}, zoomSettings), this.core.settings);
        return this;
      }
      Zoom2.prototype.buildTemplates = function() {
        var zoomIcons = this.settings.showZoomInOutIcons ? '<button id="' + this.core.getIdName("lg-zoom-in") + '" type="button" aria-label="' + this.settings.zoomPluginStrings["zoomIn"] + '" class="lg-zoom-in lg-icon"></button><button id="' + this.core.getIdName("lg-zoom-out") + '" type="button" aria-label="' + this.settings.zoomPluginStrings["zoomIn"] + '" class="lg-zoom-out lg-icon"></button>' : "";
        if (this.settings.actualSize) {
          zoomIcons += '<button id="' + this.core.getIdName("lg-actual-size") + '" type="button" aria-label="' + this.settings.zoomPluginStrings["viewActualSize"] + '" class="' + this.settings.actualSizeIcons.zoomIn + ' lg-icon"></button>';
        }
        this.core.outer.addClass("lg-use-transition-for-zoom");
        this.core.$toolbar.first().append(zoomIcons);
      };
      Zoom2.prototype.enableZoom = function(event2) {
        var _this = this;
        var _speed = this.settings.enableZoomAfter + event2.detail.delay;
        if (this.$LG("body").first().hasClass("lg-from-hash") && event2.detail.delay) {
          _speed = 0;
        } else {
          this.$LG("body").first().removeClass("lg-from-hash");
        }
        this.zoomableTimeout = setTimeout(function() {
          if (!_this.isImageSlide(_this.core.index)) {
            return;
          }
          _this.core.getSlideItem(event2.detail.index).addClass("lg-zoomable");
          if (event2.detail.index === _this.core.index) {
            _this.setZoomEssentials();
          }
        }, _speed + 30);
      };
      Zoom2.prototype.enableZoomOnSlideItemLoad = function() {
        this.core.LGel.on(lGEvents2.slideItemLoad + ".zoom", this.enableZoom.bind(this));
      };
      Zoom2.prototype.getDragCords = function(e2) {
        return {
          x: e2.pageX,
          y: e2.pageY
        };
      };
      Zoom2.prototype.getSwipeCords = function(e2) {
        var x4 = e2.touches[0].pageX;
        var y6 = e2.touches[0].pageY;
        return {
          x: x4,
          y: y6
        };
      };
      Zoom2.prototype.getDragAllowedAxises = function(scale, scaleDiff) {
        var $image = this.core.getSlideItem(this.core.index).find(".lg-image").first().get();
        var height = 0;
        var width = 0;
        var rect = $image.getBoundingClientRect();
        if (scale) {
          height = $image.offsetHeight * scale;
          width = $image.offsetWidth * scale;
        } else if (scaleDiff) {
          height = rect.height + scaleDiff * rect.height;
          width = rect.width + scaleDiff * rect.width;
        } else {
          height = rect.height;
          width = rect.width;
        }
        var allowY = height > this.containerRect.height;
        var allowX = width > this.containerRect.width;
        return {
          allowX,
          allowY
        };
      };
      Zoom2.prototype.setZoomEssentials = function() {
        this.containerRect = this.core.$content.get().getBoundingClientRect();
      };
      Zoom2.prototype.zoomImage = function(scale, scaleDiff, reposition, resetToMax) {
        if (Math.abs(scaleDiff) <= 0)
          return;
        var offsetX = this.containerRect.width / 2 + this.containerRect.left;
        var offsetY = this.containerRect.height / 2 + this.containerRect.top + this.scrollTop;
        var originalX;
        var originalY;
        if (scale === 1) {
          this.positionChanged = false;
        }
        var dragAllowedAxises = this.getDragAllowedAxises(0, scaleDiff);
        var allowY = dragAllowedAxises.allowY, allowX = dragAllowedAxises.allowX;
        if (this.positionChanged) {
          originalX = this.left / (this.scale - scaleDiff);
          originalY = this.top / (this.scale - scaleDiff);
          this.pageX = offsetX - originalX;
          this.pageY = offsetY - originalY;
          this.positionChanged = false;
        }
        var possibleSwipeCords = this.getPossibleSwipeDragCords(scaleDiff);
        var x4;
        var y6;
        var _x = offsetX - this.pageX;
        var _y = offsetY - this.pageY;
        if (scale - scaleDiff > 1) {
          var scaleVal = (scale - scaleDiff) / Math.abs(scaleDiff);
          _x = (scaleDiff < 0 ? -_x : _x) + this.left * (scaleVal + (scaleDiff < 0 ? -1 : 1));
          _y = (scaleDiff < 0 ? -_y : _y) + this.top * (scaleVal + (scaleDiff < 0 ? -1 : 1));
          x4 = _x / scaleVal;
          y6 = _y / scaleVal;
        } else {
          var scaleVal = (scale - scaleDiff) * scaleDiff;
          x4 = _x * scaleVal;
          y6 = _y * scaleVal;
        }
        if (reposition) {
          if (allowX) {
            if (this.isBeyondPossibleLeft(x4, possibleSwipeCords.minX)) {
              x4 = possibleSwipeCords.minX;
            } else if (this.isBeyondPossibleRight(x4, possibleSwipeCords.maxX)) {
              x4 = possibleSwipeCords.maxX;
            }
          } else {
            if (scale > 1) {
              if (x4 < possibleSwipeCords.minX) {
                x4 = possibleSwipeCords.minX;
              } else if (x4 > possibleSwipeCords.maxX) {
                x4 = possibleSwipeCords.maxX;
              }
            }
          }
          if (allowY) {
            if (this.isBeyondPossibleTop(y6, possibleSwipeCords.minY)) {
              y6 = possibleSwipeCords.minY;
            } else if (this.isBeyondPossibleBottom(y6, possibleSwipeCords.maxY)) {
              y6 = possibleSwipeCords.maxY;
            }
          } else {
            if (scale > 1) {
              if (y6 < possibleSwipeCords.minY) {
                y6 = possibleSwipeCords.minY;
              } else if (y6 > possibleSwipeCords.maxY) {
                y6 = possibleSwipeCords.maxY;
              }
            }
          }
        }
        this.setZoomStyles({
          x: x4,
          y: y6,
          scale
        });
        this.left = x4;
        this.top = y6;
        if (resetToMax) {
          this.setZoomImageSize();
        }
      };
      Zoom2.prototype.resetImageTranslate = function(index2) {
        if (!this.isImageSlide(index2)) {
          return;
        }
        var $image = this.core.getSlideItem(index2).find(".lg-image").first();
        this.imageReset = false;
        $image.removeClass("reset-transition reset-transition-y reset-transition-x");
        this.core.outer.removeClass("lg-actual-size");
        $image.css("width", "auto").css("height", "auto");
        setTimeout(function() {
          $image.removeClass("no-transition");
        }, 10);
      };
      Zoom2.prototype.setZoomImageSize = function() {
        var _this = this;
        var $image = this.core.getSlideItem(this.core.index).find(".lg-image").first();
        setTimeout(function() {
          var actualSizeScale = _this.getCurrentImageActualSizeScale();
          if (_this.scale >= actualSizeScale) {
            $image.addClass("no-transition");
            _this.imageReset = true;
          }
        }, ZOOM_TRANSITION_DURATION);
        setTimeout(function() {
          var actualSizeScale = _this.getCurrentImageActualSizeScale();
          if (_this.scale >= actualSizeScale) {
            var dragAllowedAxises = _this.getDragAllowedAxises(_this.scale);
            $image.css("width", $image.get().naturalWidth + "px").css("height", $image.get().naturalHeight + "px");
            _this.core.outer.addClass("lg-actual-size");
            if (dragAllowedAxises.allowX && dragAllowedAxises.allowY) {
              $image.addClass("reset-transition");
            } else if (dragAllowedAxises.allowX && !dragAllowedAxises.allowY) {
              $image.addClass("reset-transition-x");
            } else if (!dragAllowedAxises.allowX && dragAllowedAxises.allowY) {
              $image.addClass("reset-transition-y");
            }
          }
        }, ZOOM_TRANSITION_DURATION + 50);
      };
      Zoom2.prototype.setZoomStyles = function(style) {
        var $imageWrap = this.core.getSlideItem(this.core.index).find(".lg-img-wrap").first();
        var $image = this.core.getSlideItem(this.core.index).find(".lg-image").first();
        var $dummyImage = this.core.outer.find(".lg-current .lg-dummy-img").first();
        this.scale = style.scale;
        $image.css("transform", "scale3d(" + style.scale + ", " + style.scale + ", 1)");
        $dummyImage.css("transform", "scale3d(" + style.scale + ", " + style.scale + ", 1)");
        var transform = "translate3d(" + style.x + "px, " + style.y + "px, 0)";
        $imageWrap.css("transform", transform);
      };
      Zoom2.prototype.setActualSize = function(index2, event2) {
        var _this = this;
        if (this.zoomInProgress) {
          return;
        }
        this.zoomInProgress = true;
        var currentItem = this.core.galleryItems[this.core.index];
        this.resetImageTranslate(index2);
        setTimeout(function() {
          if (!currentItem.src || _this.core.outer.hasClass("lg-first-slide-loading")) {
            return;
          }
          var scale = _this.getCurrentImageActualSizeScale();
          var prevScale = _this.scale;
          if (_this.core.outer.hasClass("lg-zoomed")) {
            _this.scale = 1;
          } else {
            _this.scale = _this.getScale(scale);
          }
          _this.setPageCords(event2);
          _this.beginZoom(_this.scale);
          _this.zoomImage(_this.scale, _this.scale - prevScale, true, true);
        }, 50);
        setTimeout(function() {
          _this.core.outer.removeClass("lg-grabbing").addClass("lg-grab");
        }, 60);
        setTimeout(function() {
          _this.zoomInProgress = false;
        }, ZOOM_TRANSITION_DURATION + 110);
      };
      Zoom2.prototype.getNaturalWidth = function(index2) {
        var $image = this.core.getSlideItem(index2).find(".lg-image").first();
        var naturalWidth = this.core.galleryItems[index2].width;
        return naturalWidth ? parseFloat(naturalWidth) : $image.get().naturalWidth;
      };
      Zoom2.prototype.getActualSizeScale = function(naturalWidth, width) {
        var _scale;
        var scale;
        if (naturalWidth >= width) {
          _scale = naturalWidth / width;
          scale = _scale || 2;
        } else {
          scale = 1;
        }
        return scale;
      };
      Zoom2.prototype.getCurrentImageActualSizeScale = function() {
        var $image = this.core.getSlideItem(this.core.index).find(".lg-image").first();
        var width = $image.get().offsetWidth;
        var naturalWidth = this.getNaturalWidth(this.core.index) || width;
        return this.getActualSizeScale(naturalWidth, width);
      };
      Zoom2.prototype.getPageCords = function(event2) {
        var cords = {};
        if (event2) {
          cords.x = event2.pageX || event2.touches[0].pageX;
          cords.y = event2.pageY || event2.touches[0].pageY;
        } else {
          var containerRect = this.core.$content.get().getBoundingClientRect();
          cords.x = containerRect.width / 2 + containerRect.left;
          cords.y = containerRect.height / 2 + this.scrollTop + containerRect.top;
        }
        return cords;
      };
      Zoom2.prototype.setPageCords = function(event2) {
        var pageCords = this.getPageCords(event2);
        this.pageX = pageCords.x;
        this.pageY = pageCords.y;
      };
      Zoom2.prototype.manageActualPixelClassNames = function() {
        var $actualSize = this.core.getElementById("lg-actual-size");
        $actualSize.removeClass(this.settings.actualSizeIcons.zoomIn).addClass(this.settings.actualSizeIcons.zoomOut);
      };
      Zoom2.prototype.beginZoom = function(scale) {
        this.core.outer.removeClass("lg-zoom-drag-transition lg-zoom-dragging");
        if (scale > 1) {
          this.core.outer.addClass("lg-zoomed");
          this.manageActualPixelClassNames();
        } else {
          this.resetZoom();
        }
        return scale > 1;
      };
      Zoom2.prototype.getScale = function(scale) {
        var actualSizeScale = this.getCurrentImageActualSizeScale();
        if (scale < 1) {
          scale = 1;
        } else if (scale > actualSizeScale) {
          scale = actualSizeScale;
        }
        return scale;
      };
      Zoom2.prototype.init = function() {
        var _this = this;
        if (!this.settings.zoom) {
          return;
        }
        this.buildTemplates();
        this.enableZoomOnSlideItemLoad();
        var tapped = null;
        this.core.outer.on("dblclick.lg", function(event2) {
          if (!_this.$LG(event2.target).hasClass("lg-image")) {
            return;
          }
          _this.setActualSize(_this.core.index, event2);
        });
        this.core.outer.on("touchstart.lg", function(event2) {
          var $target = _this.$LG(event2.target);
          if (event2.touches.length === 1 && $target.hasClass("lg-image")) {
            if (!tapped) {
              tapped = setTimeout(function() {
                tapped = null;
              }, 300);
            } else {
              clearTimeout(tapped);
              tapped = null;
              event2.preventDefault();
              _this.setActualSize(_this.core.index, event2);
            }
          }
        });
        this.core.LGel.on(lGEvents2.containerResize + ".zoom " + lGEvents2.rotateRight + ".zoom " + lGEvents2.rotateLeft + ".zoom " + lGEvents2.flipHorizontal + ".zoom " + lGEvents2.flipVertical + ".zoom", function() {
          if (!_this.core.lgOpened || !_this.isImageSlide(_this.core.index) || _this.core.touchAction) {
            return;
          }
          var _LGel = _this.core.getSlideItem(_this.core.index).find(".lg-img-wrap").first();
          _this.top = 0;
          _this.left = 0;
          _this.setZoomEssentials();
          _this.setZoomSwipeStyles(_LGel, { x: 0, y: 0 });
          _this.positionChanged = true;
        });
        this.$LG(window).on("scroll.lg.zoom.global" + this.core.lgId, function() {
          if (!_this.core.lgOpened)
            return;
          _this.scrollTop = _this.$LG(window).scrollTop();
        });
        this.core.getElementById("lg-zoom-out").on("click.lg", function() {
          if (!_this.isImageSlide(_this.core.index)) {
            return;
          }
          var timeout = 0;
          if (_this.imageReset) {
            _this.resetImageTranslate(_this.core.index);
            timeout = 50;
          }
          setTimeout(function() {
            var scale = _this.scale - _this.settings.scale;
            if (scale < 1) {
              scale = 1;
            }
            _this.beginZoom(scale);
            _this.zoomImage(scale, -_this.settings.scale, true, !_this.settings.infiniteZoom);
          }, timeout);
        });
        this.core.getElementById("lg-zoom-in").on("click.lg", function() {
          _this.zoomIn();
        });
        this.core.getElementById("lg-actual-size").on("click.lg", function() {
          _this.setActualSize(_this.core.index);
        });
        this.core.LGel.on(lGEvents2.beforeOpen + ".zoom", function() {
          _this.core.outer.find(".lg-item").removeClass("lg-zoomable");
        });
        this.core.LGel.on(lGEvents2.afterOpen + ".zoom", function() {
          _this.scrollTop = _this.$LG(window).scrollTop();
          _this.pageX = _this.core.outer.width() / 2;
          _this.pageY = _this.core.outer.height() / 2 + _this.scrollTop;
          _this.scale = 1;
        });
        this.core.LGel.on(lGEvents2.afterSlide + ".zoom", function(event2) {
          var prevIndex = event2.detail.prevIndex;
          _this.scale = 1;
          _this.positionChanged = false;
          _this.zoomInProgress = false;
          _this.resetZoom(prevIndex);
          _this.resetImageTranslate(prevIndex);
          if (_this.isImageSlide(_this.core.index)) {
            _this.setZoomEssentials();
          }
        });
        this.zoomDrag();
        this.pinchZoom();
        this.zoomSwipe();
        this.zoomableTimeout = false;
        this.positionChanged = false;
        this.zoomInProgress = false;
      };
      Zoom2.prototype.zoomIn = function() {
        if (!this.isImageSlide(this.core.index)) {
          return;
        }
        var scale = this.scale + this.settings.scale;
        if (!this.settings.infiniteZoom) {
          scale = this.getScale(scale);
        }
        this.beginZoom(scale);
        this.zoomImage(scale, Math.min(this.settings.scale, scale - this.scale), true, !this.settings.infiniteZoom);
      };
      Zoom2.prototype.resetZoom = function(index2) {
        this.core.outer.removeClass("lg-zoomed lg-zoom-drag-transition");
        var $actualSize = this.core.getElementById("lg-actual-size");
        var $item = this.core.getSlideItem(index2 !== void 0 ? index2 : this.core.index);
        $actualSize.removeClass(this.settings.actualSizeIcons.zoomOut).addClass(this.settings.actualSizeIcons.zoomIn);
        $item.find(".lg-img-wrap").first().removeAttr("style");
        $item.find(".lg-image").first().removeAttr("style");
        this.scale = 1;
        this.left = 0;
        this.top = 0;
        this.setPageCords();
      };
      Zoom2.prototype.getTouchDistance = function(e2) {
        return Math.sqrt((e2.touches[0].pageX - e2.touches[1].pageX) * (e2.touches[0].pageX - e2.touches[1].pageX) + (e2.touches[0].pageY - e2.touches[1].pageY) * (e2.touches[0].pageY - e2.touches[1].pageY));
      };
      Zoom2.prototype.pinchZoom = function() {
        var _this = this;
        var startDist = 0;
        var pinchStarted = false;
        var initScale = 1;
        var prevScale = 0;
        var $item = this.core.getSlideItem(this.core.index);
        this.core.outer.on("touchstart.lg", function(e2) {
          $item = _this.core.getSlideItem(_this.core.index);
          if (!_this.isImageSlide(_this.core.index)) {
            return;
          }
          if (e2.touches.length === 2) {
            e2.preventDefault();
            if (_this.core.outer.hasClass("lg-first-slide-loading")) {
              return;
            }
            initScale = _this.scale || 1;
            _this.core.outer.removeClass("lg-zoom-drag-transition lg-zoom-dragging");
            _this.setPageCords(e2);
            _this.resetImageTranslate(_this.core.index);
            _this.core.touchAction = "pinch";
            startDist = _this.getTouchDistance(e2);
          }
        });
        this.core.$inner.on("touchmove.lg", function(e2) {
          if (e2.touches.length === 2 && _this.core.touchAction === "pinch" && (_this.$LG(e2.target).hasClass("lg-item") || $item.get().contains(e2.target))) {
            e2.preventDefault();
            var endDist = _this.getTouchDistance(e2);
            var distance = startDist - endDist;
            if (!pinchStarted && Math.abs(distance) > 5) {
              pinchStarted = true;
            }
            if (pinchStarted) {
              prevScale = _this.scale;
              var _scale = Math.max(1, initScale + -distance * 0.02);
              _this.scale = Math.round((_scale + Number.EPSILON) * 100) / 100;
              var diff = _this.scale - prevScale;
              _this.zoomImage(_this.scale, Math.round((diff + Number.EPSILON) * 100) / 100, false, false);
            }
          }
        });
        this.core.$inner.on("touchend.lg", function(e2) {
          if (_this.core.touchAction === "pinch" && (_this.$LG(e2.target).hasClass("lg-item") || $item.get().contains(e2.target))) {
            pinchStarted = false;
            startDist = 0;
            if (_this.scale <= 1) {
              _this.resetZoom();
            } else {
              var actualSizeScale = _this.getCurrentImageActualSizeScale();
              if (_this.scale >= actualSizeScale) {
                var scaleDiff = actualSizeScale - _this.scale;
                if (scaleDiff === 0) {
                  scaleDiff = 0.01;
                }
                _this.zoomImage(actualSizeScale, scaleDiff, false, true);
              }
              _this.manageActualPixelClassNames();
              _this.core.outer.addClass("lg-zoomed");
            }
            _this.core.touchAction = void 0;
          }
        });
      };
      Zoom2.prototype.touchendZoom = function(startCoords, endCoords, allowX, allowY, touchDuration) {
        var distanceXnew = endCoords.x - startCoords.x;
        var distanceYnew = endCoords.y - startCoords.y;
        var speedX = Math.abs(distanceXnew) / touchDuration + 1;
        var speedY = Math.abs(distanceYnew) / touchDuration + 1;
        if (speedX > 2) {
          speedX += 1;
        }
        if (speedY > 2) {
          speedY += 1;
        }
        distanceXnew = distanceXnew * speedX;
        distanceYnew = distanceYnew * speedY;
        var _LGel = this.core.getSlideItem(this.core.index).find(".lg-img-wrap").first();
        var distance = {};
        distance.x = this.left + distanceXnew;
        distance.y = this.top + distanceYnew;
        var possibleSwipeCords = this.getPossibleSwipeDragCords();
        if (Math.abs(distanceXnew) > 15 || Math.abs(distanceYnew) > 15) {
          if (allowY) {
            if (this.isBeyondPossibleTop(distance.y, possibleSwipeCords.minY)) {
              distance.y = possibleSwipeCords.minY;
            } else if (this.isBeyondPossibleBottom(distance.y, possibleSwipeCords.maxY)) {
              distance.y = possibleSwipeCords.maxY;
            }
          }
          if (allowX) {
            if (this.isBeyondPossibleLeft(distance.x, possibleSwipeCords.minX)) {
              distance.x = possibleSwipeCords.minX;
            } else if (this.isBeyondPossibleRight(distance.x, possibleSwipeCords.maxX)) {
              distance.x = possibleSwipeCords.maxX;
            }
          }
          if (allowY) {
            this.top = distance.y;
          } else {
            distance.y = this.top;
          }
          if (allowX) {
            this.left = distance.x;
          } else {
            distance.x = this.left;
          }
          this.setZoomSwipeStyles(_LGel, distance);
          this.positionChanged = true;
        }
      };
      Zoom2.prototype.getZoomSwipeCords = function(startCoords, endCoords, allowX, allowY, possibleSwipeCords) {
        var distance = {};
        if (allowY) {
          distance.y = this.top + (endCoords.y - startCoords.y);
          if (this.isBeyondPossibleTop(distance.y, possibleSwipeCords.minY)) {
            var diffMinY = possibleSwipeCords.minY - distance.y;
            distance.y = possibleSwipeCords.minY - diffMinY / 6;
          } else if (this.isBeyondPossibleBottom(distance.y, possibleSwipeCords.maxY)) {
            var diffMaxY = distance.y - possibleSwipeCords.maxY;
            distance.y = possibleSwipeCords.maxY + diffMaxY / 6;
          }
        } else {
          distance.y = this.top;
        }
        if (allowX) {
          distance.x = this.left + (endCoords.x - startCoords.x);
          if (this.isBeyondPossibleLeft(distance.x, possibleSwipeCords.minX)) {
            var diffMinX = possibleSwipeCords.minX - distance.x;
            distance.x = possibleSwipeCords.minX - diffMinX / 6;
          } else if (this.isBeyondPossibleRight(distance.x, possibleSwipeCords.maxX)) {
            var difMaxX = distance.x - possibleSwipeCords.maxX;
            distance.x = possibleSwipeCords.maxX + difMaxX / 6;
          }
        } else {
          distance.x = this.left;
        }
        return distance;
      };
      Zoom2.prototype.isBeyondPossibleLeft = function(x4, minX) {
        return x4 >= minX;
      };
      Zoom2.prototype.isBeyondPossibleRight = function(x4, maxX) {
        return x4 <= maxX;
      };
      Zoom2.prototype.isBeyondPossibleTop = function(y6, minY) {
        return y6 >= minY;
      };
      Zoom2.prototype.isBeyondPossibleBottom = function(y6, maxY) {
        return y6 <= maxY;
      };
      Zoom2.prototype.isImageSlide = function(index2) {
        var currentItem = this.core.galleryItems[index2];
        return this.core.getSlideType(currentItem) === "image";
      };
      Zoom2.prototype.getPossibleSwipeDragCords = function(scale) {
        var $image = this.core.getSlideItem(this.core.index).find(".lg-image").first();
        var bottom2 = this.core.mediaContainerPosition.bottom;
        var imgRect = $image.get().getBoundingClientRect();
        var imageHeight = imgRect.height;
        var imageWidth = imgRect.width;
        if (scale) {
          imageHeight = imageHeight + scale * imageHeight;
          imageWidth = imageWidth + scale * imageWidth;
        }
        var minY = (imageHeight - this.containerRect.height) / 2;
        var maxY = (this.containerRect.height - imageHeight) / 2 + bottom2;
        var minX = (imageWidth - this.containerRect.width) / 2;
        var maxX = (this.containerRect.width - imageWidth) / 2;
        var possibleSwipeCords = {
          minY,
          maxY,
          minX,
          maxX
        };
        return possibleSwipeCords;
      };
      Zoom2.prototype.setZoomSwipeStyles = function(LGel, distance) {
        LGel.css("transform", "translate3d(" + distance.x + "px, " + distance.y + "px, 0)");
      };
      Zoom2.prototype.zoomSwipe = function() {
        var _this = this;
        var startCoords = {};
        var endCoords = {};
        var isMoved = false;
        var allowX = false;
        var allowY = false;
        var startTime = /* @__PURE__ */ new Date();
        var endTime = /* @__PURE__ */ new Date();
        var possibleSwipeCords;
        var _LGel;
        var $item = this.core.getSlideItem(this.core.index);
        this.core.$inner.on("touchstart.lg", function(e2) {
          if (!_this.isImageSlide(_this.core.index)) {
            return;
          }
          $item = _this.core.getSlideItem(_this.core.index);
          if ((_this.$LG(e2.target).hasClass("lg-item") || $item.get().contains(e2.target)) && e2.touches.length === 1 && _this.core.outer.hasClass("lg-zoomed")) {
            e2.preventDefault();
            startTime = /* @__PURE__ */ new Date();
            _this.core.touchAction = "zoomSwipe";
            _LGel = _this.core.getSlideItem(_this.core.index).find(".lg-img-wrap").first();
            var dragAllowedAxises = _this.getDragAllowedAxises(0);
            allowY = dragAllowedAxises.allowY;
            allowX = dragAllowedAxises.allowX;
            if (allowX || allowY) {
              startCoords = _this.getSwipeCords(e2);
            }
            possibleSwipeCords = _this.getPossibleSwipeDragCords();
            _this.core.outer.addClass("lg-zoom-dragging lg-zoom-drag-transition");
          }
        });
        this.core.$inner.on("touchmove.lg", function(e2) {
          if (e2.touches.length === 1 && _this.core.touchAction === "zoomSwipe" && (_this.$LG(e2.target).hasClass("lg-item") || $item.get().contains(e2.target))) {
            e2.preventDefault();
            _this.core.touchAction = "zoomSwipe";
            endCoords = _this.getSwipeCords(e2);
            var distance = _this.getZoomSwipeCords(startCoords, endCoords, allowX, allowY, possibleSwipeCords);
            if (Math.abs(endCoords.x - startCoords.x) > 15 || Math.abs(endCoords.y - startCoords.y) > 15) {
              isMoved = true;
              _this.setZoomSwipeStyles(_LGel, distance);
            }
          }
        });
        this.core.$inner.on("touchend.lg", function(e2) {
          if (_this.core.touchAction === "zoomSwipe" && (_this.$LG(e2.target).hasClass("lg-item") || $item.get().contains(e2.target))) {
            e2.preventDefault();
            _this.core.touchAction = void 0;
            _this.core.outer.removeClass("lg-zoom-dragging");
            if (!isMoved) {
              return;
            }
            isMoved = false;
            endTime = /* @__PURE__ */ new Date();
            var touchDuration = endTime.valueOf() - startTime.valueOf();
            _this.touchendZoom(startCoords, endCoords, allowX, allowY, touchDuration);
          }
        });
      };
      Zoom2.prototype.zoomDrag = function() {
        var _this = this;
        var startCoords = {};
        var endCoords = {};
        var isDragging = false;
        var isMoved = false;
        var allowX = false;
        var allowY = false;
        var startTime;
        var endTime;
        var possibleSwipeCords;
        var _LGel;
        this.core.outer.on("mousedown.lg.zoom", function(e2) {
          if (!_this.isImageSlide(_this.core.index)) {
            return;
          }
          var $item = _this.core.getSlideItem(_this.core.index);
          if (_this.$LG(e2.target).hasClass("lg-item") || $item.get().contains(e2.target)) {
            startTime = /* @__PURE__ */ new Date();
            _LGel = _this.core.getSlideItem(_this.core.index).find(".lg-img-wrap").first();
            var dragAllowedAxises = _this.getDragAllowedAxises(0);
            allowY = dragAllowedAxises.allowY;
            allowX = dragAllowedAxises.allowX;
            if (_this.core.outer.hasClass("lg-zoomed")) {
              if (_this.$LG(e2.target).hasClass("lg-object") && (allowX || allowY)) {
                e2.preventDefault();
                startCoords = _this.getDragCords(e2);
                possibleSwipeCords = _this.getPossibleSwipeDragCords();
                isDragging = true;
                _this.core.outer.removeClass("lg-grab").addClass("lg-grabbing lg-zoom-drag-transition lg-zoom-dragging");
              }
            }
          }
        });
        this.$LG(window).on("mousemove.lg.zoom.global" + this.core.lgId, function(e2) {
          if (isDragging) {
            isMoved = true;
            endCoords = _this.getDragCords(e2);
            var distance = _this.getZoomSwipeCords(startCoords, endCoords, allowX, allowY, possibleSwipeCords);
            _this.setZoomSwipeStyles(_LGel, distance);
          }
        });
        this.$LG(window).on("mouseup.lg.zoom.global" + this.core.lgId, function(e2) {
          if (isDragging) {
            endTime = /* @__PURE__ */ new Date();
            isDragging = false;
            _this.core.outer.removeClass("lg-zoom-dragging");
            if (isMoved && (startCoords.x !== endCoords.x || startCoords.y !== endCoords.y)) {
              endCoords = _this.getDragCords(e2);
              var touchDuration = endTime.valueOf() - startTime.valueOf();
              _this.touchendZoom(startCoords, endCoords, allowX, allowY, touchDuration);
            }
            isMoved = false;
          }
          _this.core.outer.removeClass("lg-grabbing").addClass("lg-grab");
        });
      };
      Zoom2.prototype.closeGallery = function() {
        this.resetZoom();
        this.zoomInProgress = false;
      };
      Zoom2.prototype.destroy = function() {
        this.$LG(window).off(".lg.zoom.global" + this.core.lgId);
        this.core.LGel.off(".lg.zoom");
        this.core.LGel.off(".zoom");
        clearTimeout(this.zoomableTimeout);
        this.zoomableTimeout = false;
      };
      return Zoom2;
    }()
  );
  var lg_zoom_es5_default = Zoom;

  // node_modules/lightgallery/plugins/video/lg-video.es5.js
  init_define_process();
  init_jquery();
  var __assign3 = function() {
    __assign3 = Object.assign || function __assign4(t4) {
      for (var s4, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
        s4 = arguments[i3];
        for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4)) t4[p4] = s4[p4];
      }
      return t4;
    };
    return __assign3.apply(this, arguments);
  };
  var videoSettings = {
    autoplayFirstVideo: true,
    youTubePlayerParams: false,
    vimeoPlayerParams: false,
    wistiaPlayerParams: false,
    gotoNextSlideOnVideoEnd: true,
    autoplayVideoOnSlide: false,
    videojs: false,
    videojsTheme: "",
    videojsOptions: {}
  };
  var lGEvents3 = {
    afterAppendSlide: "lgAfterAppendSlide",
    init: "lgInit",
    hasVideo: "lgHasVideo",
    containerResize: "lgContainerResize",
    updateSlides: "lgUpdateSlides",
    afterAppendSubHtml: "lgAfterAppendSubHtml",
    beforeOpen: "lgBeforeOpen",
    afterOpen: "lgAfterOpen",
    slideItemLoad: "lgSlideItemLoad",
    beforeSlide: "lgBeforeSlide",
    afterSlide: "lgAfterSlide",
    posterClick: "lgPosterClick",
    dragStart: "lgDragStart",
    dragMove: "lgDragMove",
    dragEnd: "lgDragEnd",
    beforeNextSlide: "lgBeforeNextSlide",
    beforePrevSlide: "lgBeforePrevSlide",
    beforeClose: "lgBeforeClose",
    afterClose: "lgAfterClose",
    rotateLeft: "lgRotateLeft",
    rotateRight: "lgRotateRight",
    flipHorizontal: "lgFlipHorizontal",
    flipVertical: "lgFlipVertical",
    autoplay: "lgAutoplay",
    autoplayStart: "lgAutoplayStart",
    autoplayStop: "lgAutoplayStop"
  };
  var param = function(obj) {
    return Object.keys(obj).map(function(k4) {
      return encodeURIComponent(k4) + "=" + encodeURIComponent(obj[k4]);
    }).join("&");
  };
  var paramsToObject = function(url) {
    var paramas = url.slice(1).split("&").map(function(p4) {
      return p4.split("=");
    }).reduce(function(obj, pair) {
      var _a = pair.map(decodeURIComponent), key = _a[0], value = _a[1];
      obj[key] = value;
      return obj;
    }, {});
    return paramas;
  };
  var getYouTubeParams = function(videoInfo, youTubePlayerParamsSettings) {
    if (!videoInfo.youtube)
      return "";
    var slideUrlParams = videoInfo.youtube[2] ? paramsToObject(videoInfo.youtube[2]) : "";
    var defaultYouTubePlayerParams = {
      wmode: "opaque",
      autoplay: 0,
      mute: 1,
      enablejsapi: 1
    };
    var playerParamsSettings = youTubePlayerParamsSettings || {};
    var youTubePlayerParams = __assign3(__assign3(__assign3({}, defaultYouTubePlayerParams), playerParamsSettings), slideUrlParams);
    var youTubeParams = "?" + param(youTubePlayerParams);
    return youTubeParams;
  };
  var isYouTubeNoCookie = function(url) {
    return url.includes("youtube-nocookie.com");
  };
  var getVimeoURLParams = function(defaultParams, videoInfo) {
    if (!videoInfo || !videoInfo.vimeo)
      return "";
    var urlParams = videoInfo.vimeo[2] || "";
    var defaultPlayerParams = defaultParams && Object.keys(defaultParams).length !== 0 ? "&" + param(defaultParams) : "";
    var urlWithHash = videoInfo.vimeo[0].split("/").pop() || "";
    var urlWithHashWithParams = urlWithHash.split("?")[0] || "";
    var hash3 = urlWithHashWithParams.split("#")[0];
    var isPrivate = videoInfo.vimeo[1] !== hash3;
    if (isPrivate) {
      urlParams = urlParams.replace("/" + hash3, "");
    }
    urlParams = urlParams[0] == "?" ? "&" + urlParams.slice(1) : urlParams || "";
    var vimeoPlayerParams = "?autoplay=0&muted=1" + (isPrivate ? "&h=" + hash3 : "") + defaultPlayerParams + urlParams;
    return vimeoPlayerParams;
  };
  var Video = (
    /** @class */
    function() {
      function Video2(instance) {
        this.core = instance;
        this.settings = __assign3(__assign3({}, videoSettings), this.core.settings);
        return this;
      }
      Video2.prototype.init = function() {
        var _this = this;
        this.core.LGel.on(lGEvents3.hasVideo + ".video", this.onHasVideo.bind(this));
        this.core.LGel.on(lGEvents3.posterClick + ".video", function() {
          var $el = _this.core.getSlideItem(_this.core.index);
          _this.loadVideoOnPosterClick($el);
        });
        this.core.LGel.on(lGEvents3.slideItemLoad + ".video", this.onSlideItemLoad.bind(this));
        this.core.LGel.on(lGEvents3.beforeSlide + ".video", this.onBeforeSlide.bind(this));
        this.core.LGel.on(lGEvents3.afterSlide + ".video", this.onAfterSlide.bind(this));
      };
      Video2.prototype.onSlideItemLoad = function(event2) {
        var _this = this;
        var _a = event2.detail, isFirstSlide = _a.isFirstSlide, index2 = _a.index;
        if (this.settings.autoplayFirstVideo && isFirstSlide && index2 === this.core.index) {
          setTimeout(function() {
            _this.loadAndPlayVideo(index2);
          }, 200);
        }
        if (!isFirstSlide && this.settings.autoplayVideoOnSlide && index2 === this.core.index) {
          this.loadAndPlayVideo(index2);
        }
      };
      Video2.prototype.onHasVideo = function(event2) {
        var _a = event2.detail, index2 = _a.index, src = _a.src, html5Video = _a.html5Video, hasPoster = _a.hasPoster;
        if (!hasPoster) {
          this.appendVideos(this.core.getSlideItem(index2), {
            src,
            addClass: "lg-object",
            index: index2,
            html5Video
          });
          this.gotoNextSlideOnVideoEnd(src, index2);
        }
      };
      Video2.prototype.onBeforeSlide = function(event2) {
        if (this.core.lGalleryOn) {
          var prevIndex = event2.detail.prevIndex;
          this.pauseVideo(prevIndex);
        }
      };
      Video2.prototype.onAfterSlide = function(event2) {
        var _this = this;
        var _a = event2.detail, index2 = _a.index, prevIndex = _a.prevIndex;
        var $slide = this.core.getSlideItem(index2);
        if (this.settings.autoplayVideoOnSlide && index2 !== prevIndex) {
          if ($slide.hasClass("lg-complete")) {
            setTimeout(function() {
              _this.loadAndPlayVideo(index2);
            }, 100);
          }
        }
      };
      Video2.prototype.loadAndPlayVideo = function(index2) {
        var $slide = this.core.getSlideItem(index2);
        var currentGalleryItem = this.core.galleryItems[index2];
        if (currentGalleryItem.poster) {
          this.loadVideoOnPosterClick($slide, true);
        } else {
          this.playVideo(index2);
        }
      };
      Video2.prototype.playVideo = function(index2) {
        this.controlVideo(index2, "play");
      };
      Video2.prototype.pauseVideo = function(index2) {
        this.controlVideo(index2, "pause");
      };
      Video2.prototype.getVideoHtml = function(src, addClass, index2, html5Video) {
        var video = "";
        var videoInfo = this.core.galleryItems[index2].__slideVideoInfo || {};
        var currentGalleryItem = this.core.galleryItems[index2];
        var videoTitle = currentGalleryItem.title || currentGalleryItem.alt;
        videoTitle = videoTitle ? 'title="' + videoTitle + '"' : "";
        var commonIframeProps = 'allowtransparency="true"\n            frameborder="0"\n            scrolling="no"\n            allowfullscreen\n            mozallowfullscreen\n            webkitallowfullscreen\n            oallowfullscreen\n            msallowfullscreen';
        if (videoInfo.youtube) {
          var videoId = "lg-youtube" + index2;
          var youTubeParams = getYouTubeParams(videoInfo, this.settings.youTubePlayerParams);
          var isYouTubeNoCookieURL = isYouTubeNoCookie(src);
          var youtubeURL = isYouTubeNoCookieURL ? "//www.youtube-nocookie.com/" : "//www.youtube.com/";
          video = '<iframe allow="autoplay" id=' + videoId + ' class="lg-video-object lg-youtube ' + addClass + '" ' + videoTitle + ' src="' + youtubeURL + "embed/" + (videoInfo.youtube[1] + youTubeParams) + '" ' + commonIframeProps + "></iframe>";
        } else if (videoInfo.vimeo) {
          var videoId = "lg-vimeo" + index2;
          var playerParams = getVimeoURLParams(this.settings.vimeoPlayerParams, videoInfo);
          video = '<iframe allow="autoplay" id=' + videoId + ' class="lg-video-object lg-vimeo ' + addClass + '" ' + videoTitle + ' src="//player.vimeo.com/video/' + (videoInfo.vimeo[1] + playerParams) + '" ' + commonIframeProps + "></iframe>";
        } else if (videoInfo.wistia) {
          var wistiaId = "lg-wistia" + index2;
          var playerParams = param(this.settings.wistiaPlayerParams);
          playerParams = playerParams ? "?" + playerParams : "";
          video = '<iframe allow="autoplay" id="' + wistiaId + '" src="//fast.wistia.net/embed/iframe/' + (videoInfo.wistia[4] + playerParams) + '" ' + videoTitle + ' class="wistia_embed lg-video-object lg-wistia ' + addClass + '" name="wistia_embed" ' + commonIframeProps + "></iframe>";
        } else if (videoInfo.html5) {
          var html5VideoMarkup = "";
          for (var i3 = 0; i3 < html5Video.source.length; i3++) {
            html5VideoMarkup += '<source src="' + html5Video.source[i3].src + '" type="' + html5Video.source[i3].type + '">';
          }
          if (html5Video.tracks) {
            var _loop_1 = function(i4) {
              var trackAttributes = "";
              var track = html5Video.tracks[i4];
              Object.keys(track || {}).forEach(function(key) {
                trackAttributes += key + '="' + track[key] + '" ';
              });
              html5VideoMarkup += "<track " + trackAttributes + ">";
            };
            for (var i3 = 0; i3 < html5Video.tracks.length; i3++) {
              _loop_1(i3);
            }
          }
          var html5VideoAttrs_1 = "";
          var videoAttributes_1 = html5Video.attributes || {};
          Object.keys(videoAttributes_1 || {}).forEach(function(key) {
            html5VideoAttrs_1 += key + '="' + videoAttributes_1[key] + '" ';
          });
          video = '<video class="lg-video-object lg-html5 ' + (this.settings.videojs && this.settings.videojsTheme ? this.settings.videojsTheme + " " : "") + " " + (this.settings.videojs ? " video-js" : "") + '" ' + html5VideoAttrs_1 + ">\n                " + html5VideoMarkup + "\n                Your browser does not support HTML5 video.\n            </video>";
        }
        return video;
      };
      Video2.prototype.appendVideos = function(el, videoParams) {
        var _a;
        var videoHtml = this.getVideoHtml(videoParams.src, videoParams.addClass, videoParams.index, videoParams.html5Video);
        el.find(".lg-video-cont").append(videoHtml);
        var $videoElement = el.find(".lg-video-object").first();
        if (videoParams.html5Video) {
          $videoElement.on("mousedown.lg.video", function(e2) {
            e2.stopPropagation();
          });
        }
        if (this.settings.videojs && ((_a = this.core.galleryItems[videoParams.index].__slideVideoInfo) === null || _a === void 0 ? void 0 : _a.html5)) {
          try {
            return videojs($videoElement.get(), this.settings.videojsOptions);
          } catch (e2) {
            console.error("lightGallery:- Make sure you have included videojs");
          }
        }
      };
      Video2.prototype.gotoNextSlideOnVideoEnd = function(src, index2) {
        var _this = this;
        var $videoElement = this.core.getSlideItem(index2).find(".lg-video-object").first();
        var videoInfo = this.core.galleryItems[index2].__slideVideoInfo || {};
        if (this.settings.gotoNextSlideOnVideoEnd) {
          if (videoInfo.html5) {
            $videoElement.on("ended", function() {
              _this.core.goToNextSlide();
            });
          } else if (videoInfo.vimeo) {
            try {
              new Vimeo.Player($videoElement.get()).on("ended", function() {
                _this.core.goToNextSlide();
              });
            } catch (e2) {
              console.error("lightGallery:- Make sure you have included //github.com/vimeo/player.js");
            }
          } else if (videoInfo.wistia) {
            try {
              window._wq = window._wq || [];
              window._wq.push({
                id: $videoElement.attr("id"),
                onReady: function(video) {
                  video.bind("end", function() {
                    _this.core.goToNextSlide();
                  });
                }
              });
            } catch (e2) {
              console.error("lightGallery:- Make sure you have included //fast.wistia.com/assets/external/E-v1.js");
            }
          }
        }
      };
      Video2.prototype.controlVideo = function(index2, action) {
        var $videoElement = this.core.getSlideItem(index2).find(".lg-video-object").first();
        var videoInfo = this.core.galleryItems[index2].__slideVideoInfo || {};
        if (!$videoElement.get())
          return;
        if (videoInfo.youtube) {
          try {
            $videoElement.get().contentWindow.postMessage('{"event":"command","func":"' + action + 'Video","args":""}', "*");
          } catch (e2) {
            console.error("lightGallery:- " + e2);
          }
        } else if (videoInfo.vimeo) {
          try {
            new Vimeo.Player($videoElement.get())[action]();
          } catch (e2) {
            console.error("lightGallery:- Make sure you have included //github.com/vimeo/player.js");
          }
        } else if (videoInfo.html5) {
          if (this.settings.videojs) {
            try {
              videojs($videoElement.get())[action]();
            } catch (e2) {
              console.error("lightGallery:- Make sure you have included videojs");
            }
          } else {
            $videoElement.get()[action]();
          }
        } else if (videoInfo.wistia) {
          try {
            window._wq = window._wq || [];
            window._wq.push({
              id: $videoElement.attr("id"),
              onReady: function(video) {
                video[action]();
              }
            });
          } catch (e2) {
            console.error("lightGallery:- Make sure you have included //fast.wistia.com/assets/external/E-v1.js");
          }
        }
      };
      Video2.prototype.loadVideoOnPosterClick = function($el, forcePlay) {
        var _this = this;
        if (!$el.hasClass("lg-video-loaded")) {
          if (!$el.hasClass("lg-has-video")) {
            $el.addClass("lg-has-video");
            var _html = void 0;
            var _src = this.core.galleryItems[this.core.index].src;
            var video = this.core.galleryItems[this.core.index].video;
            if (video) {
              _html = typeof video === "string" ? JSON.parse(video) : video;
            }
            var videoJsPlayer_1 = this.appendVideos($el, {
              src: _src,
              addClass: "",
              index: this.core.index,
              html5Video: _html
            });
            this.gotoNextSlideOnVideoEnd(_src, this.core.index);
            var $tempImg = $el.find(".lg-object").first().get();
            $el.find(".lg-video-cont").first().append($tempImg);
            $el.addClass("lg-video-loading");
            videoJsPlayer_1 && videoJsPlayer_1.ready(function() {
              videoJsPlayer_1.on("loadedmetadata", function() {
                _this.onVideoLoadAfterPosterClick($el, _this.core.index);
              });
            });
            $el.find(".lg-video-object").first().on("load.lg error.lg loadedmetadata.lg", function() {
              setTimeout(function() {
                _this.onVideoLoadAfterPosterClick($el, _this.core.index);
              }, 50);
            });
          } else {
            this.playVideo(this.core.index);
          }
        } else if (forcePlay) {
          this.playVideo(this.core.index);
        }
      };
      Video2.prototype.onVideoLoadAfterPosterClick = function($el, index2) {
        $el.addClass("lg-video-loaded");
        this.playVideo(index2);
      };
      Video2.prototype.destroy = function() {
        this.core.LGel.off(".lg.video");
        this.core.LGel.off(".video");
      };
      return Video2;
    }()
  );
  var lg_video_es5_default = Video;

  // app/javascript/customer_center/controllers/lightbox_controller.js
  var lightbox_controller_default = class extends application_controller_default {
    constructor() {
      super(...arguments);
      __publicField(this, "licenseKey", "481CF2E8-EBC6-4E56-A0E3-57D880CC8865");
    }
    connect() {
      this.lightGallery = lightgallery_es5_default(this.element, {
        ...this.defaultOptions,
        ...this.optionsValue
      });
    }
    disconnect() {
      this.lightGallery.destroy();
    }
    get defaultOptions() {
      return {
        selector: "a",
        plugins: [lg_zoom_es5_default, lg_video_es5_default],
        videojs: true,
        gotoNextSlideOnVideoEnd: false,
        licenseKey: this.licenseKey,
        download: false,
        mobileSettings: {
          controls: false,
          showCloseIcon: true
        }
      };
    }
  };
  __publicField(lightbox_controller_default, "values", {
    options: Object
  });

  // app/javascript/customer_center/controllers/video_embeds_controller.js
  init_define_process();
  init_jquery();
  var video_embeds_controller_default = class extends application_controller_default {
    openDialog() {
      this.dialogTarget.show();
    }
    hideDialog() {
      this.dialogTarget.hide();
    }
    resetForm() {
      this.formTarget.reset();
      this.formTarget.querySelector('input[type="submit"]').disabled = false;
    }
    async handleSubmit(e2) {
      e2.preventDefault();
      const formData = new FormData(e2.target);
      const videoUrl = formData.get("video_url");
      const data = await this.fetchVideoData(videoUrl);
      this.insertVideoPreview(videoUrl, data.thumbnail_url, data);
      this.dialogTarget.hide();
      this.resetForm();
    }
    /* eslint-disable max-len */
    insertVideoPreview(videoUrl, thumbnailUrl, data) {
      const timestamp = Date.now();
      const previewHtml = `
      <div class="relative group/item flex-shrink-0" data-video-embed-preview>
        <input type="hidden" name="${this.fieldNameValue}[${timestamp}][url]" value="${videoUrl}">
        <input type="hidden" name="${this.fieldNameValue}[${timestamp}][data]" value='${this.safeJsonForHtml(data)}'> 
        <img src="${thumbnailUrl}" class="rounded-sm aspect-video h-24 object-cover" />
        <div class="absolute flex items-center justify-center top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 size-6">
          <i class="fa-duotone fa-solid fa-circle-play text-2xl" style="--fa-primary-color: #ffffff; --fa-secondary-color: #000000; --fa-secondary-opacity: 1;"></i>
        </div>
        <button
          type="button"
          class="text-white flex items-center justify-center absolute top-0 right-0 lg:opacity-0 lg:group-hover/item:opacity-100 size-8"
          data-action="click->video-embeds#removeVideo"
        >
            <i class="fa-duotone fa-solid fa-circle-xmark rounded-full border-black border" style="--fa-primary-color: #000; --fa-secondary-color: #FFF; --fa-secondary-opacity: 1;"></i>
        </button>
      </div>
    `;
      this.previewTarget.insertAdjacentHTML("beforeend", previewHtml);
    }
    /* eslint-enable max-len */
    removeVideo(event2) {
      event2.target.closest("[data-video-embed-preview]").remove();
    }
    async fetchVideoData(url) {
      const videoType = this.getVideoType(url);
      if (!videoType) {
        throw new Error("Unsupported video URL");
      }
      if (videoType === "voomly") {
        let data = await this.fetchVoomlyData(url);
        return this.camelToSnakeCase(data);
      } else {
        const oembedUrl = this.getOembedUrl(url, videoType);
        try {
          const response2 = await fetch(oembedUrl);
          if (!response2.ok) {
            toast("alert", "Unsupported video url. Please try again.", "flash");
            throw new Error("Failed to fetch oEmbed data");
          }
          const data = await response2.json();
          return data;
        } catch (error3) {
          console.error("Error fetching video data:", error3);
          throw error3;
        } finally {
          this.resetForm();
        }
      }
    }
    getVideoType(url) {
      if (url.includes("youtube.com") || url.includes("youtu.be")) {
        return "youtube";
      } else if (url.includes("vimeo.com")) {
        return "vimeo";
      } else if (url.includes("loom.com")) {
        return "loom";
      } else if (url.includes("voomly.com")) {
        return "voomly";
      }
      return null;
    }
    getOembedUrl(url, videoType) {
      switch (videoType) {
        case "youtube":
          return `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
        case "vimeo":
          return `https://vimeo.com/api/oembed.json?url=${encodeURIComponent(url)}`;
        case "loom":
          return `https://www.loom.com/v1/oembed?url=${encodeURIComponent(url)}`;
        default:
          throw new Error("Unsupported video type");
      }
    }
    async fetchVoomlyData(url) {
      const videoId = this.extractVoomlyId(url);
      const voomlyEmbedUrl = `https://api.voomly.com/embed-videos/${videoId}`;
      try {
        const response2 = await fetch(voomlyEmbedUrl);
        if (!response2.ok) {
          toast("alert", "Unsupported Voomly url. Please try again.", "flash");
          throw new Error("Failed to fetch Voomly data");
        }
        const data = await response2.json();
        return data;
      } catch (error3) {
        console.error("Error fetching video data:", error3);
        throw error3;
      } finally {
        this.resetForm();
      }
    }
    extractVoomlyId(url) {
      const match = url.match(/\/v\/([^/]+)/);
      return match ? match[1] : null;
    }
    camelToSnakeCase(data) {
      if (Array.isArray(data)) {
        return data.map((item) => this.camelToSnakeCase(item));
      } else if (data !== null && typeof data === "object") {
        return Object.fromEntries(
          Object.entries(data).map(([key, value]) => [
            key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`),
            this.camelToSnakeCase(value)
          ])
        );
      }
      return data;
    }
    escapeHtml(str) {
      const htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      return str.replace(/[&<>"']/g, (match) => htmlEscapes[match]);
    }
    safeJsonForHtml(obj) {
      return this.escapeHtml(JSON.stringify(obj));
    }
  };
  __publicField(video_embeds_controller_default, "targets", ["dialog", "url", "preview", "form"]);
  __publicField(video_embeds_controller_default, "values", {
    urlRegex: String,
    fieldName: { type: String, default: "communities_spaces_post[video_embeds_attributes]" }
  });

  // app/javascript/customer_center/controllers/emoji_dropdown_controller.js
  init_define_process();
  init_jquery();

  // node_modules/emoji-mart/dist/module.js
  init_define_process();
  init_jquery();
  function $parcel$interopDefault(a5) {
    return a5 && a5.__esModule ? a5.default : a5;
  }
  function $d74df3b4624fbf50$export$2e2bcd8739ae039(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    else obj[key] = value;
    return obj;
  }
  var $fb96b826c0c5f37a$var$n;
  var $fb96b826c0c5f37a$export$41c562ebe57d11e2;
  var $fb96b826c0c5f37a$var$u;
  var $fb96b826c0c5f37a$export$a8257692ac88316c;
  var $fb96b826c0c5f37a$var$t;
  var $fb96b826c0c5f37a$var$r;
  var $fb96b826c0c5f37a$var$o;
  var $fb96b826c0c5f37a$var$f;
  var $fb96b826c0c5f37a$var$e = {};
  var $fb96b826c0c5f37a$var$c = [];
  var $fb96b826c0c5f37a$var$s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function $fb96b826c0c5f37a$var$a(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
    for (var u5 in $fb96b826c0c5f37a$export$41c562ebe57d11e22) n3[u5] = $fb96b826c0c5f37a$export$41c562ebe57d11e22[u5];
    return n3;
  }
  function $fb96b826c0c5f37a$var$h(n3) {
    var $fb96b826c0c5f37a$export$41c562ebe57d11e22 = n3.parentNode;
    $fb96b826c0c5f37a$export$41c562ebe57d11e22 && $fb96b826c0c5f37a$export$41c562ebe57d11e22.removeChild(n3);
  }
  function $fb96b826c0c5f37a$export$c8a8987d4410bf2d($fb96b826c0c5f37a$export$41c562ebe57d11e22, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2) {
    var t4, r3, o3, f4 = {};
    for (o3 in u5) "key" == o3 ? t4 = u5[o3] : "ref" == o3 ? r3 = u5[o3] : f4[o3] = u5[o3];
    if (arguments.length > 2 && (f4.children = arguments.length > 3 ? $fb96b826c0c5f37a$var$n.call(arguments, 2) : $fb96b826c0c5f37a$export$a8257692ac88316c2), "function" == typeof $fb96b826c0c5f37a$export$41c562ebe57d11e22 && null != $fb96b826c0c5f37a$export$41c562ebe57d11e22.defaultProps) for (o3 in $fb96b826c0c5f37a$export$41c562ebe57d11e22.defaultProps) void 0 === f4[o3] && (f4[o3] = $fb96b826c0c5f37a$export$41c562ebe57d11e22.defaultProps[o3]);
    return $fb96b826c0c5f37a$var$y($fb96b826c0c5f37a$export$41c562ebe57d11e22, f4, t4, r3, null);
  }
  function $fb96b826c0c5f37a$var$y(n3, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3, o3) {
    var f4 = {
      type: n3,
      props: $fb96b826c0c5f37a$export$a8257692ac88316c2,
      key: t4,
      ref: r3,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o3 ? ++$fb96b826c0c5f37a$var$u : o3
    };
    return null == o3 && null != $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode && $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode(f4), f4;
  }
  function $fb96b826c0c5f37a$export$7d1e3a5e95ceca43() {
    return {
      current: null
    };
  }
  function $fb96b826c0c5f37a$export$ffb0004e005737fa(n3) {
    return n3.children;
  }
  function $fb96b826c0c5f37a$export$16fa2f45be04daa8(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
    this.props = n3, this.context = $fb96b826c0c5f37a$export$41c562ebe57d11e22;
  }
  function $fb96b826c0c5f37a$var$k(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
    if (null == $fb96b826c0c5f37a$export$41c562ebe57d11e22) return n3.__ ? $fb96b826c0c5f37a$var$k(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
    for (var u5; $fb96b826c0c5f37a$export$41c562ebe57d11e22 < n3.__k.length; $fb96b826c0c5f37a$export$41c562ebe57d11e22++) if (null != (u5 = n3.__k[$fb96b826c0c5f37a$export$41c562ebe57d11e22]) && null != u5.__e) return u5.__e;
    return "function" == typeof n3.type ? $fb96b826c0c5f37a$var$k(n3) : null;
  }
  function $fb96b826c0c5f37a$var$b(n3) {
    var $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5;
    if (null != (n3 = n3.__) && null != n3.__c) {
      for (n3.__e = n3.__c.base = null, $fb96b826c0c5f37a$export$41c562ebe57d11e22 = 0; $fb96b826c0c5f37a$export$41c562ebe57d11e22 < n3.__k.length; $fb96b826c0c5f37a$export$41c562ebe57d11e22++) if (null != (u5 = n3.__k[$fb96b826c0c5f37a$export$41c562ebe57d11e22]) && null != u5.__e) {
        n3.__e = n3.__c.base = u5.__e;
        break;
      }
      return $fb96b826c0c5f37a$var$b(n3);
    }
  }
  function $fb96b826c0c5f37a$var$m(n3) {
    (!n3.__d && (n3.__d = true) && $fb96b826c0c5f37a$var$t.push(n3) && !$fb96b826c0c5f37a$var$g.__r++ || $fb96b826c0c5f37a$var$o !== $fb96b826c0c5f37a$export$41c562ebe57d11e2.debounceRendering) && (($fb96b826c0c5f37a$var$o = $fb96b826c0c5f37a$export$41c562ebe57d11e2.debounceRendering) || $fb96b826c0c5f37a$var$r)($fb96b826c0c5f37a$var$g);
  }
  function $fb96b826c0c5f37a$var$g() {
    for (var n1; $fb96b826c0c5f37a$var$g.__r = $fb96b826c0c5f37a$var$t.length; ) n1 = $fb96b826c0c5f37a$var$t.sort(function(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
      return n3.__v.__b - $fb96b826c0c5f37a$export$41c562ebe57d11e22.__v.__b;
    }), $fb96b826c0c5f37a$var$t = [], n1.some(function(n3) {
      var $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3, o3;
      n3.__d && (r3 = (t4 = ($fb96b826c0c5f37a$export$41c562ebe57d11e22 = n3).__v).__e, (o3 = $fb96b826c0c5f37a$export$41c562ebe57d11e22.__P) && (u5 = [], ($fb96b826c0c5f37a$export$a8257692ac88316c2 = $fb96b826c0c5f37a$var$a({}, t4)).__v = t4.__v + 1, $fb96b826c0c5f37a$var$j(o3, t4, $fb96b826c0c5f37a$export$a8257692ac88316c2, $fb96b826c0c5f37a$export$41c562ebe57d11e22.__n, void 0 !== o3.ownerSVGElement, null != t4.__h ? [
        r3
      ] : null, u5, null == r3 ? $fb96b826c0c5f37a$var$k(t4) : r3, t4.__h), $fb96b826c0c5f37a$var$z(u5, t4), t4.__e != r3 && $fb96b826c0c5f37a$var$b(t4)));
    });
  }
  function $fb96b826c0c5f37a$var$w(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3, o3, f4, s4, a5) {
    var h4, $fb96b826c0c5f37a$export$c8a8987d4410bf2d2, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432, $fb96b826c0c5f37a$export$16fa2f45be04daa82, b5, m4, g4, w5 = $fb96b826c0c5f37a$export$a8257692ac88316c2 && $fb96b826c0c5f37a$export$a8257692ac88316c2.__k || $fb96b826c0c5f37a$var$c, $fb96b826c0c5f37a$export$47e4c5b3006812772 = w5.length;
    for (u5.__k = [], h4 = 0; h4 < $fb96b826c0c5f37a$export$41c562ebe57d11e22.length; h4++) if (null != ($fb96b826c0c5f37a$export$16fa2f45be04daa82 = u5.__k[h4] = null == ($fb96b826c0c5f37a$export$16fa2f45be04daa82 = $fb96b826c0c5f37a$export$41c562ebe57d11e22[h4]) || "boolean" == typeof $fb96b826c0c5f37a$export$16fa2f45be04daa82 ? null : "string" == typeof $fb96b826c0c5f37a$export$16fa2f45be04daa82 || "number" == typeof $fb96b826c0c5f37a$export$16fa2f45be04daa82 || "bigint" == typeof $fb96b826c0c5f37a$export$16fa2f45be04daa82 ? $fb96b826c0c5f37a$var$y(null, $fb96b826c0c5f37a$export$16fa2f45be04daa82, null, null, $fb96b826c0c5f37a$export$16fa2f45be04daa82) : Array.isArray($fb96b826c0c5f37a$export$16fa2f45be04daa82) ? $fb96b826c0c5f37a$var$y($fb96b826c0c5f37a$export$ffb0004e005737fa, {
      children: $fb96b826c0c5f37a$export$16fa2f45be04daa82
    }, null, null, null) : $fb96b826c0c5f37a$export$16fa2f45be04daa82.__b > 0 ? $fb96b826c0c5f37a$var$y($fb96b826c0c5f37a$export$16fa2f45be04daa82.type, $fb96b826c0c5f37a$export$16fa2f45be04daa82.props, $fb96b826c0c5f37a$export$16fa2f45be04daa82.key, null, $fb96b826c0c5f37a$export$16fa2f45be04daa82.__v) : $fb96b826c0c5f37a$export$16fa2f45be04daa82)) {
      if ($fb96b826c0c5f37a$export$16fa2f45be04daa82.__ = u5, $fb96b826c0c5f37a$export$16fa2f45be04daa82.__b = u5.__b + 1, null === ($fb96b826c0c5f37a$export$7d1e3a5e95ceca432 = w5[h4]) || $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 && $fb96b826c0c5f37a$export$16fa2f45be04daa82.key == $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.key && $fb96b826c0c5f37a$export$16fa2f45be04daa82.type === $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.type) w5[h4] = void 0;
      else for ($fb96b826c0c5f37a$export$c8a8987d4410bf2d2 = 0; $fb96b826c0c5f37a$export$c8a8987d4410bf2d2 < $fb96b826c0c5f37a$export$47e4c5b3006812772; $fb96b826c0c5f37a$export$c8a8987d4410bf2d2++) {
        if (($fb96b826c0c5f37a$export$7d1e3a5e95ceca432 = w5[$fb96b826c0c5f37a$export$c8a8987d4410bf2d2]) && $fb96b826c0c5f37a$export$16fa2f45be04daa82.key == $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.key && $fb96b826c0c5f37a$export$16fa2f45be04daa82.type === $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.type) {
          w5[$fb96b826c0c5f37a$export$c8a8987d4410bf2d2] = void 0;
          break;
        }
        $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 = null;
      }
      $fb96b826c0c5f37a$var$j(n3, $fb96b826c0c5f37a$export$16fa2f45be04daa82, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 = $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 || $fb96b826c0c5f37a$var$e, t4, r3, o3, f4, s4, a5), b5 = $fb96b826c0c5f37a$export$16fa2f45be04daa82.__e, ($fb96b826c0c5f37a$export$c8a8987d4410bf2d2 = $fb96b826c0c5f37a$export$16fa2f45be04daa82.ref) && $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.ref != $fb96b826c0c5f37a$export$c8a8987d4410bf2d2 && (g4 || (g4 = []), $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.ref && g4.push($fb96b826c0c5f37a$export$7d1e3a5e95ceca432.ref, null, $fb96b826c0c5f37a$export$16fa2f45be04daa82), g4.push($fb96b826c0c5f37a$export$c8a8987d4410bf2d2, $fb96b826c0c5f37a$export$16fa2f45be04daa82.__c || b5, $fb96b826c0c5f37a$export$16fa2f45be04daa82)), null != b5 ? (null == m4 && (m4 = b5), "function" == typeof $fb96b826c0c5f37a$export$16fa2f45be04daa82.type && $fb96b826c0c5f37a$export$16fa2f45be04daa82.__k === $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.__k ? $fb96b826c0c5f37a$export$16fa2f45be04daa82.__d = s4 = $fb96b826c0c5f37a$var$x($fb96b826c0c5f37a$export$16fa2f45be04daa82, s4, n3) : s4 = $fb96b826c0c5f37a$var$P(n3, $fb96b826c0c5f37a$export$16fa2f45be04daa82, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432, w5, b5, s4), "function" == typeof u5.type && (u5.__d = s4)) : s4 && $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.__e == s4 && s4.parentNode != n3 && (s4 = $fb96b826c0c5f37a$var$k($fb96b826c0c5f37a$export$7d1e3a5e95ceca432));
    }
    for (u5.__e = m4, h4 = $fb96b826c0c5f37a$export$47e4c5b3006812772; h4--; ) null != w5[h4] && ("function" == typeof u5.type && null != w5[h4].__e && w5[h4].__e == u5.__d && (u5.__d = $fb96b826c0c5f37a$var$k($fb96b826c0c5f37a$export$a8257692ac88316c2, h4 + 1)), $fb96b826c0c5f37a$var$N(w5[h4], w5[h4]));
    if (g4) for (h4 = 0; h4 < g4.length; h4++) $fb96b826c0c5f37a$var$M(g4[h4], g4[++h4], g4[++h4]);
  }
  function $fb96b826c0c5f37a$var$x(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5) {
    for (var $fb96b826c0c5f37a$export$a8257692ac88316c2, t4 = n3.__k, r3 = 0; t4 && r3 < t4.length; r3++) ($fb96b826c0c5f37a$export$a8257692ac88316c2 = t4[r3]) && ($fb96b826c0c5f37a$export$a8257692ac88316c2.__ = n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22 = "function" == typeof $fb96b826c0c5f37a$export$a8257692ac88316c2.type ? $fb96b826c0c5f37a$var$x($fb96b826c0c5f37a$export$a8257692ac88316c2, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5) : $fb96b826c0c5f37a$var$P(u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, $fb96b826c0c5f37a$export$a8257692ac88316c2.__e, $fb96b826c0c5f37a$export$41c562ebe57d11e22));
    return $fb96b826c0c5f37a$export$41c562ebe57d11e22;
  }
  function $fb96b826c0c5f37a$export$47e4c5b300681277(n22, $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
    return $fb96b826c0c5f37a$export$41c562ebe57d11e22 = $fb96b826c0c5f37a$export$41c562ebe57d11e22 || [], null == n22 || "boolean" == typeof n22 || (Array.isArray(n22) ? n22.some(function(n3) {
      $fb96b826c0c5f37a$export$47e4c5b300681277(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22);
    }) : $fb96b826c0c5f37a$export$41c562ebe57d11e22.push(n22)), $fb96b826c0c5f37a$export$41c562ebe57d11e22;
  }
  function $fb96b826c0c5f37a$var$P(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3) {
    var o3, f4, e2;
    if (void 0 !== $fb96b826c0c5f37a$export$41c562ebe57d11e22.__d) o3 = $fb96b826c0c5f37a$export$41c562ebe57d11e22.__d, $fb96b826c0c5f37a$export$41c562ebe57d11e22.__d = void 0;
    else if (null == u5 || t4 != r3 || null == t4.parentNode) n: if (null == r3 || r3.parentNode !== n3) n3.appendChild(t4), o3 = null;
    else {
      for (f4 = r3, e2 = 0; (f4 = f4.nextSibling) && e2 < $fb96b826c0c5f37a$export$a8257692ac88316c2.length; e2 += 2) if (f4 == t4) break n;
      n3.insertBefore(t4, r3), o3 = r3;
    }
    return void 0 !== o3 ? o3 : t4.nextSibling;
  }
  function $fb96b826c0c5f37a$var$C(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4) {
    var r3;
    for (r3 in u5) "children" === r3 || "key" === r3 || r3 in $fb96b826c0c5f37a$export$41c562ebe57d11e22 || $fb96b826c0c5f37a$var$H(n3, r3, null, u5[r3], $fb96b826c0c5f37a$export$a8257692ac88316c2);
    for (r3 in $fb96b826c0c5f37a$export$41c562ebe57d11e22) t4 && "function" != typeof $fb96b826c0c5f37a$export$41c562ebe57d11e22[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u5[r3] === $fb96b826c0c5f37a$export$41c562ebe57d11e22[r3] || $fb96b826c0c5f37a$var$H(n3, r3, $fb96b826c0c5f37a$export$41c562ebe57d11e22[r3], u5[r3], $fb96b826c0c5f37a$export$a8257692ac88316c2);
  }
  function $fb96b826c0c5f37a$var$$(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5) {
    "-" === $fb96b826c0c5f37a$export$41c562ebe57d11e22[0] ? n3.setProperty($fb96b826c0c5f37a$export$41c562ebe57d11e22, u5) : n3[$fb96b826c0c5f37a$export$41c562ebe57d11e22] = null == u5 ? "" : "number" != typeof u5 || $fb96b826c0c5f37a$var$s.test($fb96b826c0c5f37a$export$41c562ebe57d11e22) ? u5 : u5 + "px";
  }
  function $fb96b826c0c5f37a$var$H(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4) {
    var r3;
    n: if ("style" === $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
      if ("string" == typeof u5) n3.style.cssText = u5;
      else {
        if ("string" == typeof $fb96b826c0c5f37a$export$a8257692ac88316c2 && (n3.style.cssText = $fb96b826c0c5f37a$export$a8257692ac88316c2 = ""), $fb96b826c0c5f37a$export$a8257692ac88316c2) for ($fb96b826c0c5f37a$export$41c562ebe57d11e22 in $fb96b826c0c5f37a$export$a8257692ac88316c2) u5 && $fb96b826c0c5f37a$export$41c562ebe57d11e22 in u5 || $fb96b826c0c5f37a$var$$(n3.style, $fb96b826c0c5f37a$export$41c562ebe57d11e22, "");
        if (u5) for ($fb96b826c0c5f37a$export$41c562ebe57d11e22 in u5) $fb96b826c0c5f37a$export$a8257692ac88316c2 && u5[$fb96b826c0c5f37a$export$41c562ebe57d11e22] === $fb96b826c0c5f37a$export$a8257692ac88316c2[$fb96b826c0c5f37a$export$41c562ebe57d11e22] || $fb96b826c0c5f37a$var$$(n3.style, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5[$fb96b826c0c5f37a$export$41c562ebe57d11e22]);
      }
    } else if ("o" === $fb96b826c0c5f37a$export$41c562ebe57d11e22[0] && "n" === $fb96b826c0c5f37a$export$41c562ebe57d11e22[1]) r3 = $fb96b826c0c5f37a$export$41c562ebe57d11e22 !== ($fb96b826c0c5f37a$export$41c562ebe57d11e22 = $fb96b826c0c5f37a$export$41c562ebe57d11e22.replace(/Capture$/, "")), $fb96b826c0c5f37a$export$41c562ebe57d11e22 = $fb96b826c0c5f37a$export$41c562ebe57d11e22.toLowerCase() in n3 ? $fb96b826c0c5f37a$export$41c562ebe57d11e22.toLowerCase().slice(2) : $fb96b826c0c5f37a$export$41c562ebe57d11e22.slice(2), n3.l || (n3.l = {}), n3.l[$fb96b826c0c5f37a$export$41c562ebe57d11e22 + r3] = u5, u5 ? $fb96b826c0c5f37a$export$a8257692ac88316c2 || n3.addEventListener($fb96b826c0c5f37a$export$41c562ebe57d11e22, r3 ? $fb96b826c0c5f37a$var$T : $fb96b826c0c5f37a$var$I, r3) : n3.removeEventListener($fb96b826c0c5f37a$export$41c562ebe57d11e22, r3 ? $fb96b826c0c5f37a$var$T : $fb96b826c0c5f37a$var$I, r3);
    else if ("dangerouslySetInnerHTML" !== $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
      if (t4) $fb96b826c0c5f37a$export$41c562ebe57d11e22 = $fb96b826c0c5f37a$export$41c562ebe57d11e22.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if ("href" !== $fb96b826c0c5f37a$export$41c562ebe57d11e22 && "list" !== $fb96b826c0c5f37a$export$41c562ebe57d11e22 && "form" !== $fb96b826c0c5f37a$export$41c562ebe57d11e22 && "tabIndex" !== $fb96b826c0c5f37a$export$41c562ebe57d11e22 && "download" !== $fb96b826c0c5f37a$export$41c562ebe57d11e22 && $fb96b826c0c5f37a$export$41c562ebe57d11e22 in n3) try {
        n3[$fb96b826c0c5f37a$export$41c562ebe57d11e22] = null == u5 ? "" : u5;
        break n;
      } catch (n32) {
      }
      "function" == typeof u5 || (null != u5 && (false !== u5 || "a" === $fb96b826c0c5f37a$export$41c562ebe57d11e22[0] && "r" === $fb96b826c0c5f37a$export$41c562ebe57d11e22[1]) ? n3.setAttribute($fb96b826c0c5f37a$export$41c562ebe57d11e22, u5) : n3.removeAttribute($fb96b826c0c5f37a$export$41c562ebe57d11e22));
    }
  }
  function $fb96b826c0c5f37a$var$I(n3) {
    this.l[n3.type + false]($fb96b826c0c5f37a$export$41c562ebe57d11e2.event ? $fb96b826c0c5f37a$export$41c562ebe57d11e2.event(n3) : n3);
  }
  function $fb96b826c0c5f37a$var$T(n3) {
    this.l[n3.type + true]($fb96b826c0c5f37a$export$41c562ebe57d11e2.event ? $fb96b826c0c5f37a$export$41c562ebe57d11e2.event(n3) : n3);
  }
  function $fb96b826c0c5f37a$var$j(n4, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3, o3, f4, e2, c4) {
    var s4, h4, $fb96b826c0c5f37a$export$c8a8987d4410bf2d2, y6, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432, k4, b5, m4, g4, x4, $fb96b826c0c5f37a$export$47e4c5b3006812772, P6 = u5.type;
    if (void 0 !== u5.constructor) return null;
    null != $fb96b826c0c5f37a$export$a8257692ac88316c2.__h && (c4 = $fb96b826c0c5f37a$export$a8257692ac88316c2.__h, e2 = u5.__e = $fb96b826c0c5f37a$export$a8257692ac88316c2.__e, u5.__h = null, o3 = [
      e2
    ]), (s4 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b) && s4(u5);
    try {
      n: if ("function" == typeof P6) {
        if (m4 = u5.props, g4 = (s4 = P6.contextType) && t4[s4.__c], x4 = s4 ? g4 ? g4.props.value : s4.__ : t4, $fb96b826c0c5f37a$export$a8257692ac88316c2.__c ? b5 = (h4 = u5.__c = $fb96b826c0c5f37a$export$a8257692ac88316c2.__c).__ = h4.__E : ("prototype" in P6 && P6.prototype.render ? u5.__c = h4 = new P6(m4, x4) : (u5.__c = h4 = new $fb96b826c0c5f37a$export$16fa2f45be04daa8(m4, x4), h4.constructor = P6, h4.render = $fb96b826c0c5f37a$var$O), g4 && g4.sub(h4), h4.props = m4, h4.state || (h4.state = {}), h4.context = x4, h4.__n = t4, $fb96b826c0c5f37a$export$c8a8987d4410bf2d2 = h4.__d = true, h4.__h = []), null == h4.__s && (h4.__s = h4.state), null != P6.getDerivedStateFromProps && (h4.__s == h4.state && (h4.__s = $fb96b826c0c5f37a$var$a({}, h4.__s)), $fb96b826c0c5f37a$var$a(h4.__s, P6.getDerivedStateFromProps(m4, h4.__s))), y6 = h4.props, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 = h4.state, $fb96b826c0c5f37a$export$c8a8987d4410bf2d2) null == P6.getDerivedStateFromProps && null != h4.componentWillMount && h4.componentWillMount(), null != h4.componentDidMount && h4.__h.push(h4.componentDidMount);
        else {
          if (null == P6.getDerivedStateFromProps && m4 !== y6 && null != h4.componentWillReceiveProps && h4.componentWillReceiveProps(m4, x4), !h4.__e && null != h4.shouldComponentUpdate && false === h4.shouldComponentUpdate(m4, h4.__s, x4) || u5.__v === $fb96b826c0c5f37a$export$a8257692ac88316c2.__v) {
            h4.props = m4, h4.state = h4.__s, u5.__v !== $fb96b826c0c5f37a$export$a8257692ac88316c2.__v && (h4.__d = false), h4.__v = u5, u5.__e = $fb96b826c0c5f37a$export$a8257692ac88316c2.__e, u5.__k = $fb96b826c0c5f37a$export$a8257692ac88316c2.__k, u5.__k.forEach(function(n3) {
              n3 && (n3.__ = u5);
            }), h4.__h.length && f4.push(h4);
            break n;
          }
          null != h4.componentWillUpdate && h4.componentWillUpdate(m4, h4.__s, x4), null != h4.componentDidUpdate && h4.__h.push(function() {
            h4.componentDidUpdate(y6, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432, k4);
          });
        }
        h4.context = x4, h4.props = m4, h4.state = h4.__s, (s4 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r) && s4(u5), h4.__d = false, h4.__v = u5, h4.__P = n4, s4 = h4.render(h4.props, h4.state, h4.context), h4.state = h4.__s, null != h4.getChildContext && (t4 = $fb96b826c0c5f37a$var$a($fb96b826c0c5f37a$var$a({}, t4), h4.getChildContext())), $fb96b826c0c5f37a$export$c8a8987d4410bf2d2 || null == h4.getSnapshotBeforeUpdate || (k4 = h4.getSnapshotBeforeUpdate(y6, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432)), $fb96b826c0c5f37a$export$47e4c5b3006812772 = null != s4 && s4.type === $fb96b826c0c5f37a$export$ffb0004e005737fa && null == s4.key ? s4.props.children : s4, $fb96b826c0c5f37a$var$w(n4, Array.isArray($fb96b826c0c5f37a$export$47e4c5b3006812772) ? $fb96b826c0c5f37a$export$47e4c5b3006812772 : [
          $fb96b826c0c5f37a$export$47e4c5b3006812772
        ], u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3, o3, f4, e2, c4), h4.base = u5.__e, u5.__h = null, h4.__h.length && f4.push(h4), b5 && (h4.__E = h4.__ = null), h4.__e = false;
      } else null == o3 && u5.__v === $fb96b826c0c5f37a$export$a8257692ac88316c2.__v ? (u5.__k = $fb96b826c0c5f37a$export$a8257692ac88316c2.__k, u5.__e = $fb96b826c0c5f37a$export$a8257692ac88316c2.__e) : u5.__e = $fb96b826c0c5f37a$var$L($fb96b826c0c5f37a$export$a8257692ac88316c2.__e, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3, o3, f4, c4);
      (s4 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.diffed) && s4(u5);
    } catch (n3) {
      u5.__v = null, (c4 || null != o3) && (u5.__e = e2, u5.__h = !!c4, o3[o3.indexOf(e2)] = null), $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n3, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2);
    }
  }
  function $fb96b826c0c5f37a$var$z(n5, u1) {
    $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c && $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c(u1, n5), n5.some(function(u5) {
      try {
        n5 = u5.__h, u5.__h = [], n5.some(function(n3) {
          n3.call(u5);
        });
      } catch (n3) {
        $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n3, u5.__v);
      }
    });
  }
  function $fb96b826c0c5f37a$var$L($fb96b826c0c5f37a$export$41c562ebe57d11e22, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3, o3, f4, c4) {
    var s4, a5, $fb96b826c0c5f37a$export$c8a8987d4410bf2d2, y6 = $fb96b826c0c5f37a$export$a8257692ac88316c2.props, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 = u5.props, $fb96b826c0c5f37a$export$ffb0004e005737fa2 = u5.type, $fb96b826c0c5f37a$export$16fa2f45be04daa82 = 0;
    if ("svg" === $fb96b826c0c5f37a$export$ffb0004e005737fa2 && (r3 = true), null != o3) {
      for (; $fb96b826c0c5f37a$export$16fa2f45be04daa82 < o3.length; $fb96b826c0c5f37a$export$16fa2f45be04daa82++) if ((s4 = o3[$fb96b826c0c5f37a$export$16fa2f45be04daa82]) && "setAttribute" in s4 == !!$fb96b826c0c5f37a$export$ffb0004e005737fa2 && ($fb96b826c0c5f37a$export$ffb0004e005737fa2 ? s4.localName === $fb96b826c0c5f37a$export$ffb0004e005737fa2 : 3 === s4.nodeType)) {
        $fb96b826c0c5f37a$export$41c562ebe57d11e22 = s4, o3[$fb96b826c0c5f37a$export$16fa2f45be04daa82] = null;
        break;
      }
    }
    if (null == $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
      if (null === $fb96b826c0c5f37a$export$ffb0004e005737fa2) return document.createTextNode($fb96b826c0c5f37a$export$7d1e3a5e95ceca432);
      $fb96b826c0c5f37a$export$41c562ebe57d11e22 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", $fb96b826c0c5f37a$export$ffb0004e005737fa2) : document.createElement($fb96b826c0c5f37a$export$ffb0004e005737fa2, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.is && $fb96b826c0c5f37a$export$7d1e3a5e95ceca432), o3 = null, c4 = false;
    }
    if (null === $fb96b826c0c5f37a$export$ffb0004e005737fa2) y6 === $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 || c4 && $fb96b826c0c5f37a$export$41c562ebe57d11e22.data === $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 || ($fb96b826c0c5f37a$export$41c562ebe57d11e22.data = $fb96b826c0c5f37a$export$7d1e3a5e95ceca432);
    else {
      if (o3 = o3 && $fb96b826c0c5f37a$var$n.call($fb96b826c0c5f37a$export$41c562ebe57d11e22.childNodes), a5 = (y6 = $fb96b826c0c5f37a$export$a8257692ac88316c2.props || $fb96b826c0c5f37a$var$e).dangerouslySetInnerHTML, $fb96b826c0c5f37a$export$c8a8987d4410bf2d2 = $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.dangerouslySetInnerHTML, !c4) {
        if (null != o3) for (y6 = {}, $fb96b826c0c5f37a$export$16fa2f45be04daa82 = 0; $fb96b826c0c5f37a$export$16fa2f45be04daa82 < $fb96b826c0c5f37a$export$41c562ebe57d11e22.attributes.length; $fb96b826c0c5f37a$export$16fa2f45be04daa82++) y6[$fb96b826c0c5f37a$export$41c562ebe57d11e22.attributes[$fb96b826c0c5f37a$export$16fa2f45be04daa82].name] = $fb96b826c0c5f37a$export$41c562ebe57d11e22.attributes[$fb96b826c0c5f37a$export$16fa2f45be04daa82].value;
        ($fb96b826c0c5f37a$export$c8a8987d4410bf2d2 || a5) && ($fb96b826c0c5f37a$export$c8a8987d4410bf2d2 && (a5 && $fb96b826c0c5f37a$export$c8a8987d4410bf2d2.__html == a5.__html || $fb96b826c0c5f37a$export$c8a8987d4410bf2d2.__html === $fb96b826c0c5f37a$export$41c562ebe57d11e22.innerHTML) || ($fb96b826c0c5f37a$export$41c562ebe57d11e22.innerHTML = $fb96b826c0c5f37a$export$c8a8987d4410bf2d2 && $fb96b826c0c5f37a$export$c8a8987d4410bf2d2.__html || ""));
      }
      if ($fb96b826c0c5f37a$var$C($fb96b826c0c5f37a$export$41c562ebe57d11e22, $fb96b826c0c5f37a$export$7d1e3a5e95ceca432, y6, r3, c4), $fb96b826c0c5f37a$export$c8a8987d4410bf2d2) u5.__k = [];
      else if ($fb96b826c0c5f37a$export$16fa2f45be04daa82 = u5.props.children, $fb96b826c0c5f37a$var$w($fb96b826c0c5f37a$export$41c562ebe57d11e22, Array.isArray($fb96b826c0c5f37a$export$16fa2f45be04daa82) ? $fb96b826c0c5f37a$export$16fa2f45be04daa82 : [
        $fb96b826c0c5f37a$export$16fa2f45be04daa82
      ], u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4, r3 && "foreignObject" !== $fb96b826c0c5f37a$export$ffb0004e005737fa2, o3, f4, o3 ? o3[0] : $fb96b826c0c5f37a$export$a8257692ac88316c2.__k && $fb96b826c0c5f37a$var$k($fb96b826c0c5f37a$export$a8257692ac88316c2, 0), c4), null != o3) for ($fb96b826c0c5f37a$export$16fa2f45be04daa82 = o3.length; $fb96b826c0c5f37a$export$16fa2f45be04daa82--; ) null != o3[$fb96b826c0c5f37a$export$16fa2f45be04daa82] && $fb96b826c0c5f37a$var$h(o3[$fb96b826c0c5f37a$export$16fa2f45be04daa82]);
      c4 || ("value" in $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 && void 0 !== ($fb96b826c0c5f37a$export$16fa2f45be04daa82 = $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.value) && ($fb96b826c0c5f37a$export$16fa2f45be04daa82 !== y6.value || $fb96b826c0c5f37a$export$16fa2f45be04daa82 !== $fb96b826c0c5f37a$export$41c562ebe57d11e22.value || "progress" === $fb96b826c0c5f37a$export$ffb0004e005737fa2 && !$fb96b826c0c5f37a$export$16fa2f45be04daa82) && $fb96b826c0c5f37a$var$H($fb96b826c0c5f37a$export$41c562ebe57d11e22, "value", $fb96b826c0c5f37a$export$16fa2f45be04daa82, y6.value, false), "checked" in $fb96b826c0c5f37a$export$7d1e3a5e95ceca432 && void 0 !== ($fb96b826c0c5f37a$export$16fa2f45be04daa82 = $fb96b826c0c5f37a$export$7d1e3a5e95ceca432.checked) && $fb96b826c0c5f37a$export$16fa2f45be04daa82 !== $fb96b826c0c5f37a$export$41c562ebe57d11e22.checked && $fb96b826c0c5f37a$var$H($fb96b826c0c5f37a$export$41c562ebe57d11e22, "checked", $fb96b826c0c5f37a$export$16fa2f45be04daa82, y6.checked, false));
    }
    return $fb96b826c0c5f37a$export$41c562ebe57d11e22;
  }
  function $fb96b826c0c5f37a$var$M(n3, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2) {
    try {
      "function" == typeof n3 ? n3(u5) : n3.current = u5;
    } catch (n6) {
      $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n6, $fb96b826c0c5f37a$export$a8257692ac88316c2);
    }
  }
  function $fb96b826c0c5f37a$var$N(n3, u5, $fb96b826c0c5f37a$export$a8257692ac88316c2) {
    var t4, r3;
    if ($fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount && $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount(n3), (t4 = n3.ref) && (t4.current && t4.current !== n3.__e || $fb96b826c0c5f37a$var$M(t4, null, u5)), null != (t4 = n3.__c)) {
      if (t4.componentWillUnmount) try {
        t4.componentWillUnmount();
      } catch (n4) {
        $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n4, u5);
      }
      t4.base = t4.__P = null;
    }
    if (t4 = n3.__k) for (r3 = 0; r3 < t4.length; r3++) t4[r3] && $fb96b826c0c5f37a$var$N(t4[r3], u5, "function" != typeof n3.type);
    $fb96b826c0c5f37a$export$a8257692ac88316c2 || null == n3.__e || $fb96b826c0c5f37a$var$h(n3.__e), n3.__e = n3.__d = void 0;
  }
  function $fb96b826c0c5f37a$var$O(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22, u5) {
    return this.constructor(n3, u5);
  }
  function $fb96b826c0c5f37a$export$b3890eb0ae9dca99(u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4) {
    var r3, o3, f4;
    $fb96b826c0c5f37a$export$41c562ebe57d11e2.__ && $fb96b826c0c5f37a$export$41c562ebe57d11e2.__(u5, $fb96b826c0c5f37a$export$a8257692ac88316c2), o3 = (r3 = "function" == typeof t4) ? null : t4 && t4.__k || $fb96b826c0c5f37a$export$a8257692ac88316c2.__k, f4 = [], $fb96b826c0c5f37a$var$j($fb96b826c0c5f37a$export$a8257692ac88316c2, u5 = (!r3 && t4 || $fb96b826c0c5f37a$export$a8257692ac88316c2).__k = $fb96b826c0c5f37a$export$c8a8987d4410bf2d($fb96b826c0c5f37a$export$ffb0004e005737fa, null, [
      u5
    ]), o3 || $fb96b826c0c5f37a$var$e, $fb96b826c0c5f37a$var$e, void 0 !== $fb96b826c0c5f37a$export$a8257692ac88316c2.ownerSVGElement, !r3 && t4 ? [
      t4
    ] : o3 ? null : $fb96b826c0c5f37a$export$a8257692ac88316c2.firstChild ? $fb96b826c0c5f37a$var$n.call($fb96b826c0c5f37a$export$a8257692ac88316c2.childNodes) : null, f4, !r3 && t4 ? t4 : o3 ? o3.__e : $fb96b826c0c5f37a$export$a8257692ac88316c2.firstChild, r3), $fb96b826c0c5f37a$var$z(f4, u5);
  }
  $fb96b826c0c5f37a$var$n = $fb96b826c0c5f37a$var$c.slice, $fb96b826c0c5f37a$export$41c562ebe57d11e2 = {
    __e: function(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
      for (var u5, $fb96b826c0c5f37a$export$a8257692ac88316c2, t4; $fb96b826c0c5f37a$export$41c562ebe57d11e22 = $fb96b826c0c5f37a$export$41c562ebe57d11e22.__; ) if ((u5 = $fb96b826c0c5f37a$export$41c562ebe57d11e22.__c) && !u5.__) try {
        if (($fb96b826c0c5f37a$export$a8257692ac88316c2 = u5.constructor) && null != $fb96b826c0c5f37a$export$a8257692ac88316c2.getDerivedStateFromError && (u5.setState($fb96b826c0c5f37a$export$a8257692ac88316c2.getDerivedStateFromError(n3)), t4 = u5.__d), null != u5.componentDidCatch && (u5.componentDidCatch(n3), t4 = u5.__d), t4) return u5.__E = u5;
      } catch ($fb96b826c0c5f37a$export$41c562ebe57d11e23) {
        n3 = $fb96b826c0c5f37a$export$41c562ebe57d11e23;
      }
      throw n3;
    }
  }, $fb96b826c0c5f37a$var$u = 0, $fb96b826c0c5f37a$export$a8257692ac88316c = function(n3) {
    return null != n3 && void 0 === n3.constructor;
  }, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.setState = function(n3, $fb96b826c0c5f37a$export$41c562ebe57d11e22) {
    var u5;
    u5 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = $fb96b826c0c5f37a$var$a({}, this.state), "function" == typeof n3 && (n3 = n3($fb96b826c0c5f37a$var$a({}, u5), this.props)), n3 && $fb96b826c0c5f37a$var$a(u5, n3), null != n3 && this.__v && ($fb96b826c0c5f37a$export$41c562ebe57d11e22 && this.__h.push($fb96b826c0c5f37a$export$41c562ebe57d11e22), $fb96b826c0c5f37a$var$m(this));
  }, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.forceUpdate = function(n3) {
    this.__v && (this.__e = true, n3 && this.__h.push(n3), $fb96b826c0c5f37a$var$m(this));
  }, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.render = $fb96b826c0c5f37a$export$ffb0004e005737fa, $fb96b826c0c5f37a$var$t = [], $fb96b826c0c5f37a$var$r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $fb96b826c0c5f37a$var$g.__r = 0, $fb96b826c0c5f37a$var$f = 0;
  var $bd9dd35321b03dd4$var$o = 0;
  function $bd9dd35321b03dd4$export$34b9dba7ce09269b(_26, $bd9dd35321b03dd4$export$34b9dba7ce09269b2, n3, t4, f4) {
    var l5, s4, u5 = {};
    for (s4 in $bd9dd35321b03dd4$export$34b9dba7ce09269b2) "ref" == s4 ? l5 = $bd9dd35321b03dd4$export$34b9dba7ce09269b2[s4] : u5[s4] = $bd9dd35321b03dd4$export$34b9dba7ce09269b2[s4];
    var a5 = {
      type: _26,
      props: u5,
      key: n3,
      ref: l5,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --$bd9dd35321b03dd4$var$o,
      __source: t4,
      __self: f4
    };
    if ("function" == typeof _26 && (l5 = _26.defaultProps)) for (s4 in l5) void 0 === u5[s4] && (u5[s4] = l5[s4]);
    return $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode && $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode(a5), a5;
  }
  function $f7419c5d8054163a$var$set(key, value) {
    try {
      window.localStorage[`emoji-mart.${key}`] = JSON.stringify(value);
    } catch (error3) {
    }
  }
  function $f7419c5d8054163a$var$get(key) {
    try {
      const value = window.localStorage[`emoji-mart.${key}`];
      if (value) return JSON.parse(value);
    } catch (error3) {
    }
  }
  var $f7419c5d8054163a$export$2e2bcd8739ae039 = {
    set: $f7419c5d8054163a$var$set,
    get: $f7419c5d8054163a$var$get
  };
  var $4b9b19f4b8cc4918$var$CACHE = /* @__PURE__ */ new Map();
  var $4b9b19f4b8cc4918$var$VERSIONS = [
    {
      v: 14,
      emoji: "\u{1FAE0}"
    },
    {
      v: 13.1,
      emoji: "\u{1F636}\u200D\u{1F32B}\uFE0F"
    },
    {
      v: 13,
      emoji: "\u{1F978}"
    },
    {
      v: 12.1,
      emoji: "\u{1F9D1}\u200D\u{1F9B0}"
    },
    {
      v: 12,
      emoji: "\u{1F971}"
    },
    {
      v: 11,
      emoji: "\u{1F970}"
    },
    {
      v: 5,
      emoji: "\u{1F929}"
    },
    {
      v: 4,
      emoji: "\u{1F471}\u200D\u2640\uFE0F"
    },
    {
      v: 3,
      emoji: "\u{1F923}"
    },
    {
      v: 2,
      emoji: "\u{1F44B}\u{1F3FB}"
    },
    {
      v: 1,
      emoji: "\u{1F643}"
    }
  ];
  function $4b9b19f4b8cc4918$var$latestVersion() {
    for (const { v: v4, emoji } of $4b9b19f4b8cc4918$var$VERSIONS) {
      if ($4b9b19f4b8cc4918$var$isSupported(emoji)) return v4;
    }
  }
  function $4b9b19f4b8cc4918$var$noCountryFlags() {
    if ($4b9b19f4b8cc4918$var$isSupported("\u{1F1E8}\u{1F1E6}")) return false;
    return true;
  }
  function $4b9b19f4b8cc4918$var$isSupported(emoji) {
    if ($4b9b19f4b8cc4918$var$CACHE.has(emoji)) return $4b9b19f4b8cc4918$var$CACHE.get(emoji);
    const supported = $4b9b19f4b8cc4918$var$isEmojiSupported(emoji);
    $4b9b19f4b8cc4918$var$CACHE.set(emoji, supported);
    return supported;
  }
  var $4b9b19f4b8cc4918$var$isEmojiSupported = (() => {
    let ctx = null;
    try {
      if (!navigator.userAgent.includes("jsdom")) ctx = document.createElement("canvas").getContext("2d");
    } catch {
    }
    if (!ctx) return () => false;
    const CANVAS_HEIGHT = 25;
    const CANVAS_WIDTH = 20;
    const textSize = Math.floor(CANVAS_HEIGHT / 2);
    ctx.font = textSize + "px Arial, Sans-Serif";
    ctx.textBaseline = "top";
    ctx.canvas.width = CANVAS_WIDTH * 2;
    ctx.canvas.height = CANVAS_HEIGHT;
    return (unicode) => {
      ctx.clearRect(0, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT);
      ctx.fillStyle = "#FF0000";
      ctx.fillText(unicode, 0, 22);
      ctx.fillStyle = "#0000FF";
      ctx.fillText(unicode, CANVAS_WIDTH, 22);
      const a5 = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT).data;
      const count = a5.length;
      let i3 = 0;
      for (; i3 < count && !a5[i3 + 3]; i3 += 4) ;
      if (i3 >= count) return false;
      const x4 = CANVAS_WIDTH + i3 / 4 % CANVAS_WIDTH;
      const y6 = Math.floor(i3 / 4 / CANVAS_WIDTH);
      const b5 = ctx.getImageData(x4, y6, 1, 1).data;
      if (a5[i3] !== b5[0] || a5[i3 + 2] !== b5[2]) return false;
      if (ctx.measureText(unicode).width >= CANVAS_WIDTH) return false;
      return true;
    };
  })();
  var $4b9b19f4b8cc4918$export$2e2bcd8739ae039 = {
    latestVersion: $4b9b19f4b8cc4918$var$latestVersion,
    noCountryFlags: $4b9b19f4b8cc4918$var$noCountryFlags
  };
  var $de71c25967c746d9$var$DEFAULTS = [
    "+1",
    "grinning",
    "kissing_heart",
    "heart_eyes",
    "laughing",
    "stuck_out_tongue_winking_eye",
    "sweat_smile",
    "joy",
    "scream",
    "disappointed",
    "unamused",
    "weary",
    "sob",
    "sunglasses",
    "heart"
  ];
  var $de71c25967c746d9$var$Index = null;
  function $de71c25967c746d9$var$add(emoji) {
    $de71c25967c746d9$var$Index || ($de71c25967c746d9$var$Index = $f7419c5d8054163a$export$2e2bcd8739ae039.get("frequently") || {});
    const emojiId = emoji.id || emoji;
    if (!emojiId) return;
    $de71c25967c746d9$var$Index[emojiId] || ($de71c25967c746d9$var$Index[emojiId] = 0);
    $de71c25967c746d9$var$Index[emojiId] += 1;
    $f7419c5d8054163a$export$2e2bcd8739ae039.set("last", emojiId);
    $f7419c5d8054163a$export$2e2bcd8739ae039.set("frequently", $de71c25967c746d9$var$Index);
  }
  function $de71c25967c746d9$var$get({ maxFrequentRows, perLine }) {
    if (!maxFrequentRows) return [];
    $de71c25967c746d9$var$Index || ($de71c25967c746d9$var$Index = $f7419c5d8054163a$export$2e2bcd8739ae039.get("frequently"));
    let emojiIds = [];
    if (!$de71c25967c746d9$var$Index) {
      $de71c25967c746d9$var$Index = {};
      for (let i3 in $de71c25967c746d9$var$DEFAULTS.slice(0, perLine)) {
        const emojiId = $de71c25967c746d9$var$DEFAULTS[i3];
        $de71c25967c746d9$var$Index[emojiId] = perLine - i3;
        emojiIds.push(emojiId);
      }
      return emojiIds;
    }
    const max3 = maxFrequentRows * perLine;
    const last = $f7419c5d8054163a$export$2e2bcd8739ae039.get("last");
    for (let emojiId in $de71c25967c746d9$var$Index) emojiIds.push(emojiId);
    emojiIds.sort((a5, b5) => {
      const aScore = $de71c25967c746d9$var$Index[b5];
      const bScore = $de71c25967c746d9$var$Index[a5];
      if (aScore == bScore) return a5.localeCompare(b5);
      return aScore - bScore;
    });
    if (emojiIds.length > max3) {
      const removedIds = emojiIds.slice(max3);
      emojiIds = emojiIds.slice(0, max3);
      for (let removedId of removedIds) {
        if (removedId == last) continue;
        delete $de71c25967c746d9$var$Index[removedId];
      }
      if (last && emojiIds.indexOf(last) == -1) {
        delete $de71c25967c746d9$var$Index[emojiIds[emojiIds.length - 1]];
        emojiIds.splice(-1, 1, last);
      }
      $f7419c5d8054163a$export$2e2bcd8739ae039.set("frequently", $de71c25967c746d9$var$Index);
    }
    return emojiIds;
  }
  var $de71c25967c746d9$export$2e2bcd8739ae039 = {
    add: $de71c25967c746d9$var$add,
    get: $de71c25967c746d9$var$get
  };
  var $8d50d93417ef682a$exports = {};
  $8d50d93417ef682a$exports = JSON.parse('{"search":"Search","search_no_results_1":"Oh no!","search_no_results_2":"That emoji couldn\u2019t be found","pick":"Pick an emoji\u2026","add_custom":"Add custom emoji","categories":{"activity":"Activity","custom":"Custom","flags":"Flags","foods":"Food & Drink","frequent":"Frequently used","nature":"Animals & Nature","objects":"Objects","people":"Smileys & People","places":"Travel & Places","search":"Search Results","symbols":"Symbols"},"skins":{"1":"Default","2":"Light","3":"Medium-Light","4":"Medium","5":"Medium-Dark","6":"Dark","choose":"Choose default skin tone"}}');
  var $8984b9eb096f95f2$export$2e2bcd8739ae039 = {
    autoFocus: {
      value: false
    },
    emojiButtonColors: {
      value: null
    },
    emojiButtonRadius: {
      value: "100%"
    },
    emojiButtonSize: {
      value: 36
    },
    emojiSize: {
      value: 24
    },
    emojiVersion: {
      value: 14,
      choices: [
        1,
        2,
        3,
        4,
        5,
        11,
        12,
        12.1,
        13,
        13.1,
        14
      ]
    },
    icons: {
      value: "auto",
      choices: [
        "auto",
        "outline",
        "solid"
      ]
    },
    locale: {
      value: "en",
      choices: [
        "en",
        "ar",
        "cs",
        "de",
        "es",
        "fa",
        "fi",
        "fr",
        "it",
        "ja",
        "nl",
        "pl",
        "pt",
        "ru",
        "uk",
        "zh"
      ]
    },
    maxFrequentRows: {
      value: 4
    },
    navPosition: {
      value: "top",
      choices: [
        "top",
        "bottom",
        "none"
      ]
    },
    noCountryFlags: {
      value: false
    },
    noResultsEmoji: {
      value: null
    },
    perLine: {
      value: 9
    },
    previewEmoji: {
      value: null
    },
    previewPosition: {
      value: "bottom",
      choices: [
        "top",
        "bottom",
        "none"
      ]
    },
    searchPosition: {
      value: "sticky",
      choices: [
        "sticky",
        "static",
        "none"
      ]
    },
    set: {
      value: "native",
      choices: [
        "native",
        "apple",
        "facebook",
        "google",
        "twitter"
      ]
    },
    skin: {
      value: 1,
      choices: [
        1,
        2,
        3,
        4,
        5,
        6
      ]
    },
    skinTonePosition: {
      value: "preview",
      choices: [
        "preview",
        "search",
        "none"
      ]
    },
    theme: {
      value: "auto",
      choices: [
        "auto",
        "light",
        "dark"
      ]
    },
    // Data
    categories: null,
    categoryIcons: null,
    custom: null,
    data: null,
    i18n: null,
    // Callbacks
    getImageURL: null,
    getSpritesheetURL: null,
    onAddCustomEmoji: null,
    onClickOutside: null,
    onEmojiSelect: null,
    // Deprecated
    stickySearch: {
      deprecated: true,
      value: true
    }
  };
  var $94a402d4fc0f5991$export$dbe3113d60765c1a = null;
  var $94a402d4fc0f5991$export$2d0294657ab35f1b = null;
  var $94a402d4fc0f5991$var$fetchCache = {};
  async function $94a402d4fc0f5991$var$fetchJSON(src) {
    if ($94a402d4fc0f5991$var$fetchCache[src]) return $94a402d4fc0f5991$var$fetchCache[src];
    const response2 = await fetch(src);
    const json = await response2.json();
    $94a402d4fc0f5991$var$fetchCache[src] = json;
    return json;
  }
  var $94a402d4fc0f5991$var$promise = null;
  var $94a402d4fc0f5991$var$initCallback = null;
  var $94a402d4fc0f5991$var$initialized = false;
  function $94a402d4fc0f5991$export$2cd8252107eb640b(options, { caller } = {}) {
    $94a402d4fc0f5991$var$promise || ($94a402d4fc0f5991$var$promise = new Promise((resolve2) => {
      $94a402d4fc0f5991$var$initCallback = resolve2;
    }));
    if (options) $94a402d4fc0f5991$var$_init(options);
    else if (caller && !$94a402d4fc0f5991$var$initialized) console.warn(`\`${caller}\` requires data to be initialized first. Promise will be pending until \`init\` is called.`);
    return $94a402d4fc0f5991$var$promise;
  }
  async function $94a402d4fc0f5991$var$_init(props) {
    $94a402d4fc0f5991$var$initialized = true;
    let { emojiVersion, set: set2, locale } = props;
    emojiVersion || (emojiVersion = $8984b9eb096f95f2$export$2e2bcd8739ae039.emojiVersion.value);
    set2 || (set2 = $8984b9eb096f95f2$export$2e2bcd8739ae039.set.value);
    locale || (locale = $8984b9eb096f95f2$export$2e2bcd8739ae039.locale.value);
    if (!$94a402d4fc0f5991$export$2d0294657ab35f1b) {
      $94a402d4fc0f5991$export$2d0294657ab35f1b = (typeof props.data === "function" ? await props.data() : props.data) || await $94a402d4fc0f5991$var$fetchJSON(`https://cdn.jsdelivr.net/npm/@emoji-mart/data@latest/sets/${emojiVersion}/${set2}.json`);
      $94a402d4fc0f5991$export$2d0294657ab35f1b.emoticons = {};
      $94a402d4fc0f5991$export$2d0294657ab35f1b.natives = {};
      $94a402d4fc0f5991$export$2d0294657ab35f1b.categories.unshift({
        id: "frequent",
        emojis: []
      });
      for (const alias in $94a402d4fc0f5991$export$2d0294657ab35f1b.aliases) {
        const emojiId = $94a402d4fc0f5991$export$2d0294657ab35f1b.aliases[alias];
        const emoji = $94a402d4fc0f5991$export$2d0294657ab35f1b.emojis[emojiId];
        if (!emoji) continue;
        emoji.aliases || (emoji.aliases = []);
        emoji.aliases.push(alias);
      }
    } else $94a402d4fc0f5991$export$2d0294657ab35f1b.categories = $94a402d4fc0f5991$export$2d0294657ab35f1b.categories.filter((c4) => {
      const isCustom = !!c4.name;
      if (!isCustom) return true;
      return false;
    });
    $94a402d4fc0f5991$export$dbe3113d60765c1a = (typeof props.i18n === "function" ? await props.i18n() : props.i18n) || (locale == "en" ? /* @__PURE__ */ $parcel$interopDefault($8d50d93417ef682a$exports) : await $94a402d4fc0f5991$var$fetchJSON(`https://cdn.jsdelivr.net/npm/@emoji-mart/data@latest/i18n/${locale}.json`));
    if (props.custom) for (let i3 in props.custom) {
      i3 = parseInt(i3);
      const category = props.custom[i3];
      const prevCategory = props.custom[i3 - 1];
      if (!category.emojis || !category.emojis.length) continue;
      category.id || (category.id = `custom_${i3 + 1}`);
      category.name || (category.name = $94a402d4fc0f5991$export$dbe3113d60765c1a.categories.custom);
      if (prevCategory && !category.icon) category.target = prevCategory.target || prevCategory;
      $94a402d4fc0f5991$export$2d0294657ab35f1b.categories.push(category);
      for (const emoji of category.emojis) $94a402d4fc0f5991$export$2d0294657ab35f1b.emojis[emoji.id] = emoji;
    }
    if (props.categories) $94a402d4fc0f5991$export$2d0294657ab35f1b.categories = $94a402d4fc0f5991$export$2d0294657ab35f1b.categories.filter((c4) => {
      return props.categories.indexOf(c4.id) != -1;
    }).sort((c1, c22) => {
      const i1 = props.categories.indexOf(c1.id);
      const i22 = props.categories.indexOf(c22.id);
      return i1 - i22;
    });
    let latestVersionSupport = null;
    let noCountryFlags = null;
    if (set2 == "native") {
      latestVersionSupport = $4b9b19f4b8cc4918$export$2e2bcd8739ae039.latestVersion();
      noCountryFlags = props.noCountryFlags || $4b9b19f4b8cc4918$export$2e2bcd8739ae039.noCountryFlags();
    }
    let categoryIndex = $94a402d4fc0f5991$export$2d0294657ab35f1b.categories.length;
    let resetSearchIndex = false;
    while (categoryIndex--) {
      const category = $94a402d4fc0f5991$export$2d0294657ab35f1b.categories[categoryIndex];
      if (category.id == "frequent") {
        let { maxFrequentRows, perLine } = props;
        maxFrequentRows || (maxFrequentRows = $8984b9eb096f95f2$export$2e2bcd8739ae039.maxFrequentRows.value);
        perLine || (perLine = $8984b9eb096f95f2$export$2e2bcd8739ae039.perLine.value);
        category.emojis = $de71c25967c746d9$export$2e2bcd8739ae039.get({
          maxFrequentRows,
          perLine
        });
      }
      if (!category.emojis || !category.emojis.length) {
        $94a402d4fc0f5991$export$2d0294657ab35f1b.categories.splice(categoryIndex, 1);
        continue;
      }
      const { categoryIcons } = props;
      if (categoryIcons) {
        const icon = categoryIcons[category.id];
        if (icon && !category.icon) category.icon = icon;
      }
      let emojiIndex = category.emojis.length;
      while (emojiIndex--) {
        const emojiId = category.emojis[emojiIndex];
        const emoji = emojiId.id ? emojiId : $94a402d4fc0f5991$export$2d0294657ab35f1b.emojis[emojiId];
        const ignore = () => {
          category.emojis.splice(emojiIndex, 1);
        };
        if (!emoji) {
          ignore();
          continue;
        }
        if (latestVersionSupport && emoji.version > latestVersionSupport) {
          ignore();
          continue;
        }
        if (noCountryFlags && category.id == "flags") {
          if (!$b3f33f946d94b4a4$export$bcb25aa587e9cb13.includes(emoji.id)) {
            ignore();
            continue;
          }
        }
        if (!emoji.search) {
          resetSearchIndex = true;
          emoji.search = "," + [
            [
              emoji.id,
              false
            ],
            [
              emoji.name,
              true
            ],
            [
              emoji.keywords,
              false
            ],
            [
              emoji.emoticons,
              false
            ]
          ].map(([strings, split]) => {
            if (!strings) return;
            return (Array.isArray(strings) ? strings : [
              strings
            ]).map((string) => {
              return (split ? string.split(/[-|_|\s]+/) : [
                string
              ]).map(
                (s4) => s4.toLowerCase()
              );
            }).flat();
          }).flat().filter(
            (a5) => a5 && a5.trim()
          ).join(",");
          if (emoji.emoticons) for (const emoticon of emoji.emoticons) {
            if ($94a402d4fc0f5991$export$2d0294657ab35f1b.emoticons[emoticon]) continue;
            $94a402d4fc0f5991$export$2d0294657ab35f1b.emoticons[emoticon] = emoji.id;
          }
          let skinIndex = 0;
          for (const skin of emoji.skins) {
            if (!skin) continue;
            skinIndex++;
            const { native } = skin;
            if (native) {
              $94a402d4fc0f5991$export$2d0294657ab35f1b.natives[native] = emoji.id;
              emoji.search += `,${native}`;
            }
            const skinShortcodes = skinIndex == 1 ? "" : `:skin-tone-${skinIndex}:`;
            skin.shortcodes = `:${emoji.id}:${skinShortcodes}`;
          }
        }
      }
    }
    if (resetSearchIndex) $e8e05d5d75c37ff8$export$2e2bcd8739ae039.reset();
    $94a402d4fc0f5991$var$initCallback();
  }
  function $94a402d4fc0f5991$export$75fe5f91d452f94b(props, defaultProps2, element) {
    props || (props = {});
    const _props = {};
    for (let k4 in defaultProps2) _props[k4] = $94a402d4fc0f5991$export$88c9ddb45cea7241(k4, props, defaultProps2, element);
    return _props;
  }
  function $94a402d4fc0f5991$export$88c9ddb45cea7241(propName, props, defaultProps2, element) {
    const defaults3 = defaultProps2[propName];
    let value = element && element.getAttribute(propName) || (props[propName] != null && props[propName] != void 0 ? props[propName] : null);
    if (!defaults3) return value;
    if (value != null && defaults3.value && typeof defaults3.value != typeof value) {
      if (typeof defaults3.value == "boolean") value = value == "false" ? false : true;
      else value = defaults3.value.constructor(value);
    }
    if (defaults3.transform && value) value = defaults3.transform(value);
    if (value == null || defaults3.choices && defaults3.choices.indexOf(value) == -1) value = defaults3.value;
    return value;
  }
  var $e8e05d5d75c37ff8$var$SHORTCODES_REGEX = /^(?:\:([^\:]+)\:)(?:\:skin-tone-(\d)\:)?$/;
  var $e8e05d5d75c37ff8$var$Pool = null;
  function $e8e05d5d75c37ff8$var$get(emojiId) {
    if (emojiId.id) return emojiId;
    return $94a402d4fc0f5991$export$2d0294657ab35f1b.emojis[emojiId] || $94a402d4fc0f5991$export$2d0294657ab35f1b.emojis[$94a402d4fc0f5991$export$2d0294657ab35f1b.aliases[emojiId]] || $94a402d4fc0f5991$export$2d0294657ab35f1b.emojis[$94a402d4fc0f5991$export$2d0294657ab35f1b.natives[emojiId]];
  }
  function $e8e05d5d75c37ff8$var$reset() {
    $e8e05d5d75c37ff8$var$Pool = null;
  }
  async function $e8e05d5d75c37ff8$var$search(value, { maxResults, caller } = {}) {
    if (!value || !value.trim().length) return null;
    maxResults || (maxResults = 90);
    await $94a402d4fc0f5991$export$2cd8252107eb640b(null, {
      caller: caller || "SearchIndex.search"
    });
    const values = value.toLowerCase().replace(/(\w)-/, "$1 ").split(/[\s|,]+/).filter((word, i3, words2) => {
      return word.trim() && words2.indexOf(word) == i3;
    });
    if (!values.length) return;
    let pool = $e8e05d5d75c37ff8$var$Pool || ($e8e05d5d75c37ff8$var$Pool = Object.values($94a402d4fc0f5991$export$2d0294657ab35f1b.emojis));
    let results, scores;
    for (const value1 of values) {
      if (!pool.length) break;
      results = [];
      scores = {};
      for (const emoji of pool) {
        if (!emoji.search) continue;
        const score = emoji.search.indexOf(`,${value1}`);
        if (score == -1) continue;
        results.push(emoji);
        scores[emoji.id] || (scores[emoji.id] = 0);
        scores[emoji.id] += emoji.id == value1 ? 0 : score + 1;
      }
      pool = results;
    }
    if (results.length < 2) return results;
    results.sort((a5, b5) => {
      const aScore = scores[a5.id];
      const bScore = scores[b5.id];
      if (aScore == bScore) return a5.id.localeCompare(b5.id);
      return aScore - bScore;
    });
    if (results.length > maxResults) results = results.slice(0, maxResults);
    return results;
  }
  var $e8e05d5d75c37ff8$export$2e2bcd8739ae039 = {
    search: $e8e05d5d75c37ff8$var$search,
    get: $e8e05d5d75c37ff8$var$get,
    reset: $e8e05d5d75c37ff8$var$reset,
    SHORTCODES_REGEX: $e8e05d5d75c37ff8$var$SHORTCODES_REGEX
  };
  var $b3f33f946d94b4a4$export$bcb25aa587e9cb13 = [
    "checkered_flag",
    "crossed_flags",
    "pirate_flag",
    "rainbow-flag",
    "transgender_flag",
    "triangular_flag_on_post",
    "waving_black_flag",
    "waving_white_flag"
  ];
  function $569a635a7f98f0e3$export$9cb4719e2e525b7a(a5, b5) {
    return Array.isArray(a5) && Array.isArray(b5) && a5.length === b5.length && a5.every(
      (val, index2) => val == b5[index2]
    );
  }
  async function $569a635a7f98f0e3$export$e772c8ff12451969(frames = 1) {
    for (let _26 in [
      ...Array(frames).keys()
    ]) await new Promise(requestAnimationFrame);
  }
  function $569a635a7f98f0e3$export$d10ac59fbe52a745(emoji, { skinIndex } = {}) {
    const skin = emoji.skins[skinIndex] || (() => {
      skinIndex = 0;
      return emoji.skins[skinIndex];
    })();
    const emojiData = {
      id: emoji.id,
      name: emoji.name,
      native: skin.native,
      unified: skin.unified,
      keywords: emoji.keywords,
      shortcodes: skin.shortcodes || emoji.shortcodes
    };
    if (emoji.skins.length > 1) emojiData.skin = skinIndex + 1;
    if (skin.src) emojiData.src = skin.src;
    if (emoji.aliases && emoji.aliases.length) emojiData.aliases = emoji.aliases;
    if (emoji.emoticons && emoji.emoticons.length) emojiData.emoticons = emoji.emoticons;
    return emojiData;
  }
  var $f8900ac4fc737037$var$categories = {
    activity: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M12 0C5.373 0 0 5.372 0 12c0 6.627 5.373 12 12 12 6.628 0 12-5.373 12-12 0-6.628-5.372-12-12-12m9.949 11H17.05c.224-2.527 1.232-4.773 1.968-6.113A9.966 9.966 0 0 1 21.949 11M13 11V2.051a9.945 9.945 0 0 1 4.432 1.564c-.858 1.491-2.156 4.22-2.392 7.385H13zm-2 0H8.961c-.238-3.165-1.536-5.894-2.393-7.385A9.95 9.95 0 0 1 11 2.051V11zm0 2v8.949a9.937 9.937 0 0 1-4.432-1.564c.857-1.492 2.155-4.221 2.393-7.385H11zm4.04 0c.236 3.164 1.534 5.893 2.392 7.385A9.92 9.92 0 0 1 13 21.949V13h2.04zM4.982 4.887C5.718 6.227 6.726 8.473 6.951 11h-4.9a9.977 9.977 0 0 1 2.931-6.113M2.051 13h4.9c-.226 2.527-1.233 4.771-1.969 6.113A9.972 9.972 0 0 1 2.051 13m16.967 6.113c-.735-1.342-1.744-3.586-1.968-6.113h4.899a9.961 9.961 0 0 1-2.931 6.113"
        })
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M16.17 337.5c0 44.98 7.565 83.54 13.98 107.9C35.22 464.3 50.46 496 174.9 496c9.566 0 19.59-.4707 29.84-1.271L17.33 307.3C16.53 317.6 16.17 327.7 16.17 337.5zM495.8 174.5c0-44.98-7.565-83.53-13.98-107.9c-4.688-17.54-18.34-31.23-36.04-35.95C435.5 27.91 392.9 16 337 16c-9.564 0-19.59 .4707-29.84 1.271l187.5 187.5C495.5 194.4 495.8 184.3 495.8 174.5zM26.77 248.8l236.3 236.3c142-36.1 203.9-150.4 222.2-221.1L248.9 26.87C106.9 62.96 45.07 177.2 26.77 248.8zM256 335.1c0 9.141-7.474 16-16 16c-4.094 0-8.188-1.564-11.31-4.689L164.7 283.3C161.6 280.2 160 276.1 160 271.1c0-8.529 6.865-16 16-16c4.095 0 8.189 1.562 11.31 4.688l64.01 64C254.4 327.8 256 331.9 256 335.1zM304 287.1c0 9.141-7.474 16-16 16c-4.094 0-8.188-1.564-11.31-4.689L212.7 235.3C209.6 232.2 208 228.1 208 223.1c0-9.141 7.473-16 16-16c4.094 0 8.188 1.562 11.31 4.688l64.01 64.01C302.5 279.8 304 283.9 304 287.1zM256 175.1c0-9.141 7.473-16 16-16c4.094 0 8.188 1.562 11.31 4.688l64.01 64.01c3.125 3.125 4.688 7.219 4.688 11.31c0 9.133-7.468 16-16 16c-4.094 0-8.189-1.562-11.31-4.688l-64.01-64.01C257.6 184.2 256 180.1 256 175.1z"
        })
      })
    },
    custom: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 448 512",
      children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
        d: "M417.1 368c-5.937 10.27-16.69 16-27.75 16c-5.422 0-10.92-1.375-15.97-4.281L256 311.4V448c0 17.67-14.33 32-31.1 32S192 465.7 192 448V311.4l-118.3 68.29C68.67 382.6 63.17 384 57.75 384c-11.06 0-21.81-5.734-27.75-16c-8.828-15.31-3.594-34.88 11.72-43.72L159.1 256L41.72 187.7C26.41 178.9 21.17 159.3 29.1 144C36.63 132.5 49.26 126.7 61.65 128.2C65.78 128.7 69.88 130.1 73.72 132.3L192 200.6V64c0-17.67 14.33-32 32-32S256 46.33 256 64v136.6l118.3-68.29c3.838-2.213 7.939-3.539 12.07-4.051C398.7 126.7 411.4 132.5 417.1 144c8.828 15.31 3.594 34.88-11.72 43.72L288 256l118.3 68.28C421.6 333.1 426.8 352.7 417.1 368z"
      })
    }),
    flags: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M0 0l6.084 24H8L1.916 0zM21 5h-4l-1-4H4l3 12h3l1 4h13L21 5zM6.563 3h7.875l2 8H8.563l-2-8zm8.832 10l-2.856 1.904L12.063 13h3.332zM19 13l-1.5-6h1.938l2 8H16l3-2z"
        })
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M64 496C64 504.8 56.75 512 48 512h-32C7.25 512 0 504.8 0 496V32c0-17.75 14.25-32 32-32s32 14.25 32 32V496zM476.3 0c-6.365 0-13.01 1.35-19.34 4.233c-45.69 20.86-79.56 27.94-107.8 27.94c-59.96 0-94.81-31.86-163.9-31.87C160.9 .3055 131.6 4.867 96 15.75v350.5c32-9.984 59.87-14.1 84.85-14.1c73.63 0 124.9 31.78 198.6 31.78c31.91 0 68.02-5.971 111.1-23.09C504.1 355.9 512 344.4 512 332.1V30.73C512 11.1 495.3 0 476.3 0z"
        })
      })
    },
    foods: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M17 4.978c-1.838 0-2.876.396-3.68.934.513-1.172 1.768-2.934 4.68-2.934a1 1 0 0 0 0-2c-2.921 0-4.629 1.365-5.547 2.512-.064.078-.119.162-.18.244C11.73 1.838 10.798.023 9.207.023 8.579.022 7.85.306 7 .978 5.027 2.54 5.329 3.902 6.492 4.999 3.609 5.222 0 7.352 0 12.969c0 4.582 4.961 11.009 9 11.009 1.975 0 2.371-.486 3-1 .629.514 1.025 1 3 1 4.039 0 9-6.418 9-11 0-5.953-4.055-8-7-8M8.242 2.546c.641-.508.943-.523.965-.523.426.169.975 1.405 1.357 3.055-1.527-.629-2.741-1.352-2.98-1.846.059-.112.241-.356.658-.686M15 21.978c-1.08 0-1.21-.109-1.559-.402l-.176-.146c-.367-.302-.816-.452-1.266-.452s-.898.15-1.266.452l-.176.146c-.347.292-.477.402-1.557.402-2.813 0-7-5.389-7-9.009 0-5.823 4.488-5.991 5-5.991 1.939 0 2.484.471 3.387 1.251l.323.276a1.995 1.995 0 0 0 2.58 0l.323-.276c.902-.78 1.447-1.251 3.387-1.251.512 0 5 .168 5 6 0 3.617-4.187 9-7 9"
        })
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M481.9 270.1C490.9 279.1 496 291.3 496 304C496 316.7 490.9 328.9 481.9 337.9C472.9 346.9 460.7 352 448 352H64C51.27 352 39.06 346.9 30.06 337.9C21.06 328.9 16 316.7 16 304C16 291.3 21.06 279.1 30.06 270.1C39.06 261.1 51.27 256 64 256H448C460.7 256 472.9 261.1 481.9 270.1zM475.3 388.7C478.3 391.7 480 395.8 480 400V416C480 432.1 473.3 449.3 461.3 461.3C449.3 473.3 432.1 480 416 480H96C79.03 480 62.75 473.3 50.75 461.3C38.74 449.3 32 432.1 32 416V400C32 395.8 33.69 391.7 36.69 388.7C39.69 385.7 43.76 384 48 384H464C468.2 384 472.3 385.7 475.3 388.7zM50.39 220.8C45.93 218.6 42.03 215.5 38.97 211.6C35.91 207.7 33.79 203.2 32.75 198.4C31.71 193.5 31.8 188.5 32.99 183.7C54.98 97.02 146.5 32 256 32C365.5 32 457 97.02 479 183.7C480.2 188.5 480.3 193.5 479.2 198.4C478.2 203.2 476.1 207.7 473 211.6C469.1 215.5 466.1 218.6 461.6 220.8C457.2 222.9 452.3 224 447.3 224H64.67C59.73 224 54.84 222.9 50.39 220.8zM372.7 116.7C369.7 119.7 368 123.8 368 128C368 131.2 368.9 134.3 370.7 136.9C372.5 139.5 374.1 141.6 377.9 142.8C380.8 143.1 384 144.3 387.1 143.7C390.2 143.1 393.1 141.6 395.3 139.3C397.6 137.1 399.1 134.2 399.7 131.1C400.3 128 399.1 124.8 398.8 121.9C397.6 118.1 395.5 116.5 392.9 114.7C390.3 112.9 387.2 111.1 384 111.1C379.8 111.1 375.7 113.7 372.7 116.7V116.7zM244.7 84.69C241.7 87.69 240 91.76 240 96C240 99.16 240.9 102.3 242.7 104.9C244.5 107.5 246.1 109.6 249.9 110.8C252.8 111.1 256 112.3 259.1 111.7C262.2 111.1 265.1 109.6 267.3 107.3C269.6 105.1 271.1 102.2 271.7 99.12C272.3 96.02 271.1 92.8 270.8 89.88C269.6 86.95 267.5 84.45 264.9 82.7C262.3 80.94 259.2 79.1 256 79.1C251.8 79.1 247.7 81.69 244.7 84.69V84.69zM116.7 116.7C113.7 119.7 112 123.8 112 128C112 131.2 112.9 134.3 114.7 136.9C116.5 139.5 118.1 141.6 121.9 142.8C124.8 143.1 128 144.3 131.1 143.7C134.2 143.1 137.1 141.6 139.3 139.3C141.6 137.1 143.1 134.2 143.7 131.1C144.3 128 143.1 124.8 142.8 121.9C141.6 118.1 139.5 116.5 136.9 114.7C134.3 112.9 131.2 111.1 128 111.1C123.8 111.1 119.7 113.7 116.7 116.7L116.7 116.7z"
        })
      })
    },
    frequent: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M13 4h-2l-.001 7H9v2h2v2h2v-2h4v-2h-4z"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512zM232 256C232 264 236 271.5 242.7 275.1L338.7 339.1C349.7 347.3 364.6 344.3 371.1 333.3C379.3 322.3 376.3 307.4 365.3 300L280 243.2V120C280 106.7 269.3 96 255.1 96C242.7 96 231.1 106.7 231.1 120L232 256z"
        })
      })
    },
    nature: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M15.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 15.5 8M8.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 8.5 8"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M18.933 0h-.027c-.97 0-2.138.787-3.018 1.497-1.274-.374-2.612-.51-3.887-.51-1.285 0-2.616.133-3.874.517C7.245.79 6.069 0 5.093 0h-.027C3.352 0 .07 2.67.002 7.026c-.039 2.479.276 4.238 1.04 5.013.254.258.882.677 1.295.882.191 3.177.922 5.238 2.536 6.38.897.637 2.187.949 3.2 1.102C8.04 20.6 8 20.795 8 21c0 1.773 2.35 3 4 3 1.648 0 4-1.227 4-3 0-.201-.038-.393-.072-.586 2.573-.385 5.435-1.877 5.925-7.587.396-.22.887-.568 1.104-.788.763-.774 1.079-2.534 1.04-5.013C23.929 2.67 20.646 0 18.933 0M3.223 9.135c-.237.281-.837 1.155-.884 1.238-.15-.41-.368-1.349-.337-3.291.051-3.281 2.478-4.972 3.091-5.031.256.015.731.27 1.265.646-1.11 1.171-2.275 2.915-2.352 5.125-.133.546-.398.858-.783 1.313M12 22c-.901 0-1.954-.693-2-1 0-.654.475-1.236 1-1.602V20a1 1 0 1 0 2 0v-.602c.524.365 1 .947 1 1.602-.046.307-1.099 1-2 1m3-3.48v.02a4.752 4.752 0 0 0-1.262-1.02c1.092-.516 2.239-1.334 2.239-2.217 0-1.842-1.781-2.195-3.977-2.195-2.196 0-3.978.354-3.978 2.195 0 .883 1.148 1.701 2.238 2.217A4.8 4.8 0 0 0 9 18.539v-.025c-1-.076-2.182-.281-2.973-.842-1.301-.92-1.838-3.045-1.853-6.478l.023-.041c.496-.826 1.49-1.45 1.804-3.102 0-2.047 1.357-3.631 2.362-4.522C9.37 3.178 10.555 3 11.948 3c1.447 0 2.685.192 3.733.57 1 .9 2.316 2.465 2.316 4.48.313 1.651 1.307 2.275 1.803 3.102.035.058.068.117.102.178-.059 5.967-1.949 7.01-4.902 7.19m6.628-8.202c-.037-.065-.074-.13-.113-.195a7.587 7.587 0 0 0-.739-.987c-.385-.455-.648-.768-.782-1.313-.076-2.209-1.241-3.954-2.353-5.124.531-.376 1.004-.63 1.261-.647.636.071 3.044 1.764 3.096 5.031.027 1.81-.347 3.218-.37 3.235"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 576 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M332.7 19.85C334.6 8.395 344.5 0 356.1 0C363.6 0 370.6 3.52 375.1 9.502L392 32H444.1C456.8 32 469.1 37.06 478.1 46.06L496 64H552C565.3 64 576 74.75 576 88V112C576 156.2 540.2 192 496 192H426.7L421.6 222.5L309.6 158.5L332.7 19.85zM448 64C439.2 64 432 71.16 432 80C432 88.84 439.2 96 448 96C456.8 96 464 88.84 464 80C464 71.16 456.8 64 448 64zM416 256.1V480C416 497.7 401.7 512 384 512H352C334.3 512 320 497.7 320 480V364.8C295.1 377.1 268.8 384 240 384C211.2 384 184 377.1 160 364.8V480C160 497.7 145.7 512 128 512H96C78.33 512 64 497.7 64 480V249.8C35.23 238.9 12.64 214.5 4.836 183.3L.9558 167.8C-3.331 150.6 7.094 133.2 24.24 128.1C41.38 124.7 58.76 135.1 63.05 152.2L66.93 167.8C70.49 182 83.29 191.1 97.97 191.1H303.8L416 256.1z"
        })
      })
    },
    objects: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M12 0a9 9 0 0 0-5 16.482V21s2.035 3 5 3 5-3 5-3v-4.518A9 9 0 0 0 12 0zm0 2c3.86 0 7 3.141 7 7s-3.14 7-7 7-7-3.141-7-7 3.14-7 7-7zM9 17.477c.94.332 1.946.523 3 .523s2.06-.19 3-.523v.834c-.91.436-1.925.689-3 .689a6.924 6.924 0 0 1-3-.69v-.833zm.236 3.07A8.854 8.854 0 0 0 12 21c.965 0 1.888-.167 2.758-.451C14.155 21.173 13.153 22 12 22c-1.102 0-2.117-.789-2.764-1.453z"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M14.745 12.449h-.004c-.852-.024-1.188-.858-1.577-1.824-.421-1.061-.703-1.561-1.182-1.566h-.009c-.481 0-.783.497-1.235 1.537-.436.982-.801 1.811-1.636 1.791l-.276-.043c-.565-.171-.853-.691-1.284-1.794-.125-.313-.202-.632-.27-.913-.051-.213-.127-.53-.195-.634C7.067 9.004 7.039 9 6.99 9A1 1 0 0 1 7 7h.01c1.662.017 2.015 1.373 2.198 2.134.486-.981 1.304-2.058 2.797-2.075 1.531.018 2.28 1.153 2.731 2.141l.002-.008C14.944 8.424 15.327 7 16.979 7h.032A1 1 0 1 1 17 9h-.011c-.149.076-.256.474-.319.709a6.484 6.484 0 0 1-.311.951c-.429.973-.79 1.789-1.614 1.789"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 384 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M112.1 454.3c0 6.297 1.816 12.44 5.284 17.69l17.14 25.69c5.25 7.875 17.17 14.28 26.64 14.28h61.67c9.438 0 21.36-6.401 26.61-14.28l17.08-25.68c2.938-4.438 5.348-12.37 5.348-17.7L272 415.1h-160L112.1 454.3zM191.4 .0132C89.44 .3257 16 82.97 16 175.1c0 44.38 16.44 84.84 43.56 115.8c16.53 18.84 42.34 58.23 52.22 91.45c.0313 .25 .0938 .5166 .125 .7823h160.2c.0313-.2656 .0938-.5166 .125-.7823c9.875-33.22 35.69-72.61 52.22-91.45C351.6 260.8 368 220.4 368 175.1C368 78.61 288.9-.2837 191.4 .0132zM192 96.01c-44.13 0-80 35.89-80 79.1C112 184.8 104.8 192 96 192S80 184.8 80 176c0-61.76 50.25-111.1 112-111.1c8.844 0 16 7.159 16 16S200.8 96.01 192 96.01z"
        })
      })
    },
    people: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M8 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 8 7M16 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 16 7M15.232 15c-.693 1.195-1.87 2-3.349 2-1.477 0-2.655-.805-3.347-2H15m3-2H6a6 6 0 1 0 12 0"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM256 432C332.1 432 396.2 382 415.2 314.1C419.1 300.4 407.8 288 393.6 288H118.4C104.2 288 92.92 300.4 96.76 314.1C115.8 382 179.9 432 256 432V432zM176.4 160C158.7 160 144.4 174.3 144.4 192C144.4 209.7 158.7 224 176.4 224C194 224 208.4 209.7 208.4 192C208.4 174.3 194 160 176.4 160zM336.4 224C354 224 368.4 209.7 368.4 192C368.4 174.3 354 160 336.4 160C318.7 160 304.4 174.3 304.4 192C304.4 209.7 318.7 224 336.4 224z"
        })
      })
    },
    places: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M6.5 12C5.122 12 4 13.121 4 14.5S5.122 17 6.5 17 9 15.879 9 14.5 7.878 12 6.5 12m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5M17.5 12c-1.378 0-2.5 1.121-2.5 2.5s1.122 2.5 2.5 2.5 2.5-1.121 2.5-2.5-1.122-2.5-2.5-2.5m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M22.482 9.494l-1.039-.346L21.4 9h.6c.552 0 1-.439 1-.992 0-.006-.003-.008-.003-.008H23c0-1-.889-2-1.984-2h-.642l-.731-1.717C19.262 3.012 18.091 2 16.764 2H7.236C5.909 2 4.738 3.012 4.357 4.283L3.626 6h-.642C1.889 6 1 7 1 8h.003S1 8.002 1 8.008C1 8.561 1.448 9 2 9h.6l-.043.148-1.039.346a2.001 2.001 0 0 0-1.359 2.097l.751 7.508a1 1 0 0 0 .994.901H3v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h6v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h1.096a.999.999 0 0 0 .994-.901l.751-7.508a2.001 2.001 0 0 0-1.359-2.097M6.273 4.857C6.402 4.43 6.788 4 7.236 4h9.527c.448 0 .834.43.963.857L19.313 9H4.688l1.585-4.143zM7 21H5v-1h2v1zm12 0h-2v-1h2v1zm2.189-3H2.811l-.662-6.607L3 11h18l.852.393L21.189 18z"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M39.61 196.8L74.8 96.29C88.27 57.78 124.6 32 165.4 32H346.6C387.4 32 423.7 57.78 437.2 96.29L472.4 196.8C495.6 206.4 512 229.3 512 256V448C512 465.7 497.7 480 480 480H448C430.3 480 416 465.7 416 448V400H96V448C96 465.7 81.67 480 64 480H32C14.33 480 0 465.7 0 448V256C0 229.3 16.36 206.4 39.61 196.8V196.8zM109.1 192H402.9L376.8 117.4C372.3 104.6 360.2 96 346.6 96H165.4C151.8 96 139.7 104.6 135.2 117.4L109.1 192zM96 256C78.33 256 64 270.3 64 288C64 305.7 78.33 320 96 320C113.7 320 128 305.7 128 288C128 270.3 113.7 256 96 256zM416 320C433.7 320 448 305.7 448 288C448 270.3 433.7 256 416 256C398.3 256 384 270.3 384 288C384 305.7 398.3 320 416 320z"
        })
      })
    },
    symbols: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M0 0h11v2H0zM4 11h3V6h4V4H0v2h4zM15.5 17c1.381 0 2.5-1.116 2.5-2.493s-1.119-2.493-2.5-2.493S13 13.13 13 14.507 14.119 17 15.5 17m0-2.986c.276 0 .5.222.5.493 0 .272-.224.493-.5.493s-.5-.221-.5-.493.224-.493.5-.493M21.5 19.014c-1.381 0-2.5 1.116-2.5 2.493S20.119 24 21.5 24s2.5-1.116 2.5-2.493-1.119-2.493-2.5-2.493m0 2.986a.497.497 0 0 1-.5-.493c0-.271.224-.493.5-.493s.5.222.5.493a.497.497 0 0 1-.5.493M22 13l-9 9 1.513 1.5 8.99-9.009zM17 11c2.209 0 4-1.119 4-2.5V2s.985-.161 1.498.949C23.01 4.055 23 6 23 6s1-1.119 1-3.135C24-.02 21 0 21 0h-2v6.347A5.853 5.853 0 0 0 17 6c-2.209 0-4 1.119-4 2.5s1.791 2.5 4 2.5M10.297 20.482l-1.475-1.585a47.54 47.54 0 0 1-1.442 1.129c-.307-.288-.989-1.016-2.045-2.183.902-.836 1.479-1.466 1.729-1.892s.376-.871.376-1.336c0-.592-.273-1.178-.818-1.759-.546-.581-1.329-.871-2.349-.871-1.008 0-1.79.293-2.344.879-.556.587-.832 1.181-.832 1.784 0 .813.419 1.748 1.256 2.805-.847.614-1.444 1.208-1.794 1.784a3.465 3.465 0 0 0-.523 1.833c0 .857.308 1.56.924 2.107.616.549 1.423.823 2.42.823 1.173 0 2.444-.379 3.813-1.137L8.235 24h2.819l-2.09-2.383 1.333-1.135zm-6.736-6.389a1.02 1.02 0 0 1 .73-.286c.31 0 .559.085.747.254a.849.849 0 0 1 .283.659c0 .518-.419 1.112-1.257 1.784-.536-.651-.805-1.231-.805-1.742a.901.901 0 0 1 .302-.669M3.74 22c-.427 0-.778-.116-1.057-.349-.279-.232-.418-.487-.418-.766 0-.594.509-1.288 1.527-2.083.968 1.134 1.717 1.946 2.248 2.438-.921.507-1.686.76-2.3.76"
        })
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M500.3 7.251C507.7 13.33 512 22.41 512 31.1V175.1C512 202.5 483.3 223.1 447.1 223.1C412.7 223.1 383.1 202.5 383.1 175.1C383.1 149.5 412.7 127.1 447.1 127.1V71.03L351.1 90.23V207.1C351.1 234.5 323.3 255.1 287.1 255.1C252.7 255.1 223.1 234.5 223.1 207.1C223.1 181.5 252.7 159.1 287.1 159.1V63.1C287.1 48.74 298.8 35.61 313.7 32.62L473.7 .6198C483.1-1.261 492.9 1.173 500.3 7.251H500.3zM74.66 303.1L86.5 286.2C92.43 277.3 102.4 271.1 113.1 271.1H174.9C185.6 271.1 195.6 277.3 201.5 286.2L213.3 303.1H239.1C266.5 303.1 287.1 325.5 287.1 351.1V463.1C287.1 490.5 266.5 511.1 239.1 511.1H47.1C21.49 511.1-.0019 490.5-.0019 463.1V351.1C-.0019 325.5 21.49 303.1 47.1 303.1H74.66zM143.1 359.1C117.5 359.1 95.1 381.5 95.1 407.1C95.1 434.5 117.5 455.1 143.1 455.1C170.5 455.1 191.1 434.5 191.1 407.1C191.1 381.5 170.5 359.1 143.1 359.1zM440.3 367.1H496C502.7 367.1 508.6 372.1 510.1 378.4C513.3 384.6 511.6 391.7 506.5 396L378.5 508C372.9 512.1 364.6 513.3 358.6 508.9C352.6 504.6 350.3 496.6 353.3 489.7L391.7 399.1H336C329.3 399.1 323.4 395.9 321 389.6C318.7 383.4 320.4 376.3 325.5 371.1L453.5 259.1C459.1 255 467.4 254.7 473.4 259.1C479.4 263.4 481.6 271.4 478.7 278.3L440.3 367.1zM116.7 219.1L19.85 119.2C-8.112 90.26-6.614 42.31 24.85 15.34C51.82-8.137 93.26-3.642 118.2 21.83L128.2 32.32L137.7 21.83C162.7-3.642 203.6-8.137 231.6 15.34C262.6 42.31 264.1 90.26 236.1 119.2L139.7 219.1C133.2 225.6 122.7 225.6 116.7 219.1H116.7z"
        })
      })
    }
  };
  var $f8900ac4fc737037$var$search = {
    loupe: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
        d: "M12.9 14.32a8 8 0 1 1 1.41-1.41l5.35 5.33-1.42 1.42-5.33-5.34zM8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12z"
      })
    }),
    delete: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
        d: "M10 8.586L2.929 1.515 1.515 2.929 8.586 10l-7.071 7.071 1.414 1.414L10 11.414l7.071 7.071 1.414-1.414L11.414 10l7.071-7.071-1.414-1.414L10 8.586z"
      })
    })
  };
  var $f8900ac4fc737037$export$2e2bcd8739ae039 = {
    categories: $f8900ac4fc737037$var$categories,
    search: $f8900ac4fc737037$var$search
  };
  function $52fb24fe07871f48$export$2e2bcd8739ae039(props) {
    let { id, skin, emoji } = props;
    if (props.shortcodes) {
      const matches = props.shortcodes.match($e8e05d5d75c37ff8$export$2e2bcd8739ae039.SHORTCODES_REGEX);
      if (matches) {
        id = matches[1];
        if (matches[2]) skin = matches[2];
      }
    }
    emoji || (emoji = $e8e05d5d75c37ff8$export$2e2bcd8739ae039.get(id || props.native));
    if (!emoji) return props.fallback;
    const emojiSkin = emoji.skins[skin - 1] || emoji.skins[0];
    const imageSrc = emojiSkin.src || (props.set != "native" && !props.spritesheet ? typeof props.getImageURL === "function" ? props.getImageURL(props.set, emojiSkin.unified) : `https://cdn.jsdelivr.net/npm/emoji-datasource-${props.set}@14.0.0/img/${props.set}/64/${emojiSkin.unified}.png` : void 0);
    const spritesheetSrc = typeof props.getSpritesheetURL === "function" ? props.getSpritesheetURL(props.set) : `https://cdn.jsdelivr.net/npm/emoji-datasource-${props.set}@14.0.0/img/${props.set}/sheets-256/64.png`;
    return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
      class: "emoji-mart-emoji",
      "data-emoji-set": props.set,
      children: imageSrc ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("img", {
        style: {
          height: props.size || "1em",
          width: "auto",
          display: "inline-block",
          position: "relative",
          top: ".1em"
        },
        alt: emojiSkin.native || emojiSkin.shortcodes,
        src: imageSrc
      }) : props.set == "native" ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
        style: {
          fontSize: props.size,
          fontFamily: '"EmojiMart", "Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI", "Apple Color Emoji", "Twemoji Mozilla", "Noto Color Emoji", "Android Emoji"'
        },
        children: emojiSkin.native
      }) : /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
        style: {
          display: "block",
          width: props.size,
          height: props.size,
          backgroundImage: `url(${spritesheetSrc})`,
          backgroundSize: `${100 * $94a402d4fc0f5991$export$2d0294657ab35f1b.sheet.cols}% ${100 * $94a402d4fc0f5991$export$2d0294657ab35f1b.sheet.rows}%`,
          backgroundPosition: `${100 / ($94a402d4fc0f5991$export$2d0294657ab35f1b.sheet.cols - 1) * emojiSkin.x}% ${100 / ($94a402d4fc0f5991$export$2d0294657ab35f1b.sheet.rows - 1) * emojiSkin.y}%`
        }
      })
    });
  }
  var $b92ac63a6c22c90c$var$WindowHTMLElement = typeof window !== "undefined" ? window.HTMLElement : Object;
  var $b92ac63a6c22c90c$export$2e2bcd8739ae039 = class extends $b92ac63a6c22c90c$var$WindowHTMLElement {
    static get observedAttributes() {
      return Object.keys(this.Props);
    }
    update(props = {}) {
      for (let k4 in props) this.attributeChangedCallback(k4, null, props[k4]);
    }
    attributeChangedCallback(attr, _26, newValue) {
      if (!this.component) return;
      const value = $94a402d4fc0f5991$export$88c9ddb45cea7241(attr, {
        [attr]: newValue
      }, this.constructor.Props, this);
      if (this.component.componentWillReceiveProps) this.component.componentWillReceiveProps({
        [attr]: value
      });
      else {
        this.component.props[attr] = value;
        this.component.forceUpdate();
      }
    }
    constructor(props = {}) {
      super();
      this.props = props;
      if (props.parent || props.ref) {
        let ref = null;
        const parent = props.parent || (ref = props.ref && props.ref.current);
        if (ref) ref.innerHTML = "";
        if (parent) parent.appendChild(this);
      }
    }
  };
  var $2136457ff873277a$export$2e2bcd8739ae039 = class extends $b92ac63a6c22c90c$export$2e2bcd8739ae039 {
    setShadow() {
      this.attachShadow({
        mode: "open"
      });
    }
    injectStyles(styles) {
      if (!styles) return;
      const style = document.createElement("style");
      style.textContent = styles;
      this.shadowRoot.insertBefore(style, this.shadowRoot.firstChild);
    }
    constructor(props, { styles } = {}) {
      super(props);
      this.setShadow();
      this.injectStyles(styles);
    }
  };
  var $6b82b7874e1b79a3$export$2e2bcd8739ae039 = {
    fallback: "",
    id: "",
    native: "",
    shortcodes: "",
    size: {
      value: "",
      transform: (value) => {
        if (!/\D/.test(value)) return `${value}px`;
        return value;
      }
    },
    // Shared
    set: $8984b9eb096f95f2$export$2e2bcd8739ae039.set,
    skin: $8984b9eb096f95f2$export$2e2bcd8739ae039.skin
  };
  var $ea42328f4878ac2b$export$2e2bcd8739ae039 = class extends $b92ac63a6c22c90c$export$2e2bcd8739ae039 {
    async connectedCallback() {
      const props = $94a402d4fc0f5991$export$75fe5f91d452f94b(this.props, $6b82b7874e1b79a3$export$2e2bcd8739ae039, this);
      props.element = this;
      props.ref = (component) => {
        this.component = component;
      };
      await $94a402d4fc0f5991$export$2cd8252107eb640b();
      $fb96b826c0c5f37a$export$b3890eb0ae9dca99(/* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($52fb24fe07871f48$export$2e2bcd8739ae039, {
        ...props
      }), this);
    }
    constructor(props) {
      super(props);
    }
  };
  $d74df3b4624fbf50$export$2e2bcd8739ae039($ea42328f4878ac2b$export$2e2bcd8739ae039, "Props", $6b82b7874e1b79a3$export$2e2bcd8739ae039);
  if (typeof customElements !== "undefined" && !customElements.get("em-emoji")) customElements.define("em-emoji", $ea42328f4878ac2b$export$2e2bcd8739ae039);
  var $1a9a8ef576b7773d$var$t;
  var $1a9a8ef576b7773d$var$u;
  var $1a9a8ef576b7773d$var$r;
  var $1a9a8ef576b7773d$var$i = [];
  var $1a9a8ef576b7773d$var$c = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b;
  var $1a9a8ef576b7773d$var$f = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r;
  var $1a9a8ef576b7773d$var$e = $fb96b826c0c5f37a$export$41c562ebe57d11e2.diffed;
  var $1a9a8ef576b7773d$var$a = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c;
  var $1a9a8ef576b7773d$var$v = $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount;
  function $1a9a8ef576b7773d$var$x() {
    var t1;
    for ($1a9a8ef576b7773d$var$i.sort(function(n3, t4) {
      return n3.__v.__b - t4.__v.__b;
    }); t1 = $1a9a8ef576b7773d$var$i.pop(); ) if (t1.__P) try {
      t1.__H.__h.forEach($1a9a8ef576b7773d$var$g), t1.__H.__h.forEach($1a9a8ef576b7773d$var$j), t1.__H.__h = [];
    } catch (u5) {
      t1.__H.__h = [], $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(u5, t1.__v);
    }
  }
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b = function(n3) {
    $1a9a8ef576b7773d$var$u = null, $1a9a8ef576b7773d$var$c && $1a9a8ef576b7773d$var$c(n3);
  }, $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r = function(n3) {
    $1a9a8ef576b7773d$var$f && $1a9a8ef576b7773d$var$f(n3), $1a9a8ef576b7773d$var$t = 0;
    var r3 = ($1a9a8ef576b7773d$var$u = n3.__c).__H;
    r3 && (r3.__h.forEach($1a9a8ef576b7773d$var$g), r3.__h.forEach($1a9a8ef576b7773d$var$j), r3.__h = []);
  }, $fb96b826c0c5f37a$export$41c562ebe57d11e2.diffed = function(t22) {
    $1a9a8ef576b7773d$var$e && $1a9a8ef576b7773d$var$e(t22);
    var o3 = t22.__c;
    o3 && o3.__H && o3.__H.__h.length && (1 !== $1a9a8ef576b7773d$var$i.push(o3) && $1a9a8ef576b7773d$var$r === $fb96b826c0c5f37a$export$41c562ebe57d11e2.requestAnimationFrame || (($1a9a8ef576b7773d$var$r = $fb96b826c0c5f37a$export$41c562ebe57d11e2.requestAnimationFrame) || function(n3) {
      var t4, u5 = function() {
        clearTimeout(r3), $1a9a8ef576b7773d$var$b && cancelAnimationFrame(t4), setTimeout(n3);
      }, r3 = setTimeout(u5, 100);
      $1a9a8ef576b7773d$var$b && (t4 = requestAnimationFrame(u5));
    })($1a9a8ef576b7773d$var$x)), $1a9a8ef576b7773d$var$u = null;
  }, $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c = function(t32, u5) {
    u5.some(function(t4) {
      try {
        t4.__h.forEach($1a9a8ef576b7773d$var$g), t4.__h = t4.__h.filter(function(n3) {
          return !n3.__ || $1a9a8ef576b7773d$var$j(n3);
        });
      } catch (r3) {
        u5.some(function(n3) {
          n3.__h && (n3.__h = []);
        }), u5 = [], $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(r3, t4.__v);
      }
    }), $1a9a8ef576b7773d$var$a && $1a9a8ef576b7773d$var$a(t32, u5);
  }, $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount = function(t4) {
    $1a9a8ef576b7773d$var$v && $1a9a8ef576b7773d$var$v(t4);
    var u5, r3 = t4.__c;
    r3 && r3.__H && (r3.__H.__.forEach(function(n3) {
      try {
        $1a9a8ef576b7773d$var$g(n3);
      } catch (n32) {
        u5 = n32;
      }
    }), u5 && $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(u5, r3.__v));
  };
  var $1a9a8ef576b7773d$var$b = "function" == typeof requestAnimationFrame;
  function $1a9a8ef576b7773d$var$g(n3) {
    var t4 = $1a9a8ef576b7773d$var$u, r3 = n3.__c;
    "function" == typeof r3 && (n3.__c = void 0, r3()), $1a9a8ef576b7773d$var$u = t4;
  }
  function $1a9a8ef576b7773d$var$j(n3) {
    var t4 = $1a9a8ef576b7773d$var$u;
    n3.__c = n3.__(), $1a9a8ef576b7773d$var$u = t4;
  }
  function $dc040a17866866fa$var$S(n3, t4) {
    for (var e2 in t4) n3[e2] = t4[e2];
    return n3;
  }
  function $dc040a17866866fa$var$C(n3, t4) {
    for (var e2 in n3) if ("__source" !== e2 && !(e2 in t4)) return true;
    for (var r3 in t4) if ("__source" !== r3 && n3[r3] !== t4[r3]) return true;
    return false;
  }
  function $dc040a17866866fa$export$221d75b3f55bb0bd(n3) {
    this.props = n3;
  }
  ($dc040a17866866fa$export$221d75b3f55bb0bd.prototype = new $fb96b826c0c5f37a$export$16fa2f45be04daa8()).isPureReactComponent = true, $dc040a17866866fa$export$221d75b3f55bb0bd.prototype.shouldComponentUpdate = function(n3, t4) {
    return $dc040a17866866fa$var$C(this.props, n3) || $dc040a17866866fa$var$C(this.state, t4);
  };
  var $dc040a17866866fa$var$w = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b;
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b = function(n3) {
    n3.type && n3.type.__f && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), $dc040a17866866fa$var$w && $dc040a17866866fa$var$w(n3);
  };
  var $dc040a17866866fa$var$R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  var $dc040a17866866fa$var$A = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e;
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e = function(n3, t4, e2) {
    if (n3.then) {
      for (var r3, u5 = t4; u5 = u5.__; ) if ((r3 = u5.__c) && r3.__c) return null == t4.__e && (t4.__e = e2.__e, t4.__k = e2.__k), r3.__c(n3, t4);
    }
    $dc040a17866866fa$var$A(n3, t4, e2);
  };
  var $dc040a17866866fa$var$O = $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount;
  function $dc040a17866866fa$export$74bf444e3cd11ea5() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function $dc040a17866866fa$var$U(n3) {
    var t4 = n3.__.__c;
    return t4 && t4.__e && t4.__e(n3);
  }
  function $dc040a17866866fa$export$998bcd577473dd93() {
    this.u = null, this.o = null;
  }
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount = function(n3) {
    var t4 = n3.__c;
    t4 && t4.__R && t4.__R(), t4 && true === n3.__h && (n3.type = null), $dc040a17866866fa$var$O && $dc040a17866866fa$var$O(n3);
  }, ($dc040a17866866fa$export$74bf444e3cd11ea5.prototype = new $fb96b826c0c5f37a$export$16fa2f45be04daa8()).__c = function(n3, t32) {
    var e2 = t32.__c, r22 = this;
    null == r22.t && (r22.t = []), r22.t.push(e2);
    var u5 = $dc040a17866866fa$var$U(r22.__v), o3 = false, i3 = function() {
      o3 || (o3 = true, e2.__R = null, u5 ? u5(l5) : l5());
    };
    e2.__R = i3;
    var l5 = function() {
      if (!--r22.__u) {
        if (r22.state.__e) {
          var n4 = r22.state.__e;
          r22.__v.__k[0] = function n5(t6, e3, r3) {
            return t6 && (t6.__v = null, t6.__k = t6.__k && t6.__k.map(function(t5) {
              return n5(t5, e3, r3);
            }), t6.__c && t6.__c.__P === e3 && (t6.__e && r3.insertBefore(t6.__e, t6.__d), t6.__c.__e = true, t6.__c.__P = r3)), t6;
          }(n4, n4.__c.__P, n4.__c.__O);
        }
        var t4;
        for (r22.setState({
          __e: r22.__b = null
        }); t4 = r22.t.pop(); ) t4.forceUpdate();
      }
    }, c4 = true === t32.__h;
    r22.__u++ || c4 || r22.setState({
      __e: r22.__b = r22.__v.__k[0]
    }), n3.then(i3, i3);
  }, $dc040a17866866fa$export$74bf444e3cd11ea5.prototype.componentWillUnmount = function() {
    this.t = [];
  }, $dc040a17866866fa$export$74bf444e3cd11ea5.prototype.render = function(n7, t7) {
    if (this.__b) {
      if (this.__v.__k) {
        var e3 = document.createElement("div"), r3 = this.__v.__k[0].__c;
        this.__v.__k[0] = function n8(t8, e2, r4) {
          return t8 && (t8.__c && t8.__c.__H && (t8.__c.__H.__.forEach(function(n3) {
            "function" == typeof n3.__c && n3.__c();
          }), t8.__c.__H = null), null != (t8 = $dc040a17866866fa$var$S({}, t8)).__c && (t8.__c.__P === r4 && (t8.__c.__P = e2), t8.__c = null), t8.__k = t8.__k && t8.__k.map(function(t4) {
            return n8(t4, e2, r4);
          })), t8;
        }(this.__b, e3, r3.__O = r3.__P);
      }
      this.__b = null;
    }
    var u5 = t7.__e && $fb96b826c0c5f37a$export$c8a8987d4410bf2d($fb96b826c0c5f37a$export$ffb0004e005737fa, null, n7.fallback);
    return u5 && (u5.__h = null), [
      $fb96b826c0c5f37a$export$c8a8987d4410bf2d($fb96b826c0c5f37a$export$ffb0004e005737fa, null, t7.__e ? null : n7.children),
      u5
    ];
  };
  var $dc040a17866866fa$var$T = function(n3, t4, e2) {
    if (++e2[1] === e2[0] && n3.o.delete(t4), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.o.size)) for (e2 = n3.u; e2; ) {
      for (; e2.length > 3; ) e2.pop()();
      if (e2[1] < e2[0]) break;
      n3.u = e2 = e2[2];
    }
  };
  ($dc040a17866866fa$export$998bcd577473dd93.prototype = new $fb96b826c0c5f37a$export$16fa2f45be04daa8()).__e = function(n3) {
    var t4 = this, e2 = $dc040a17866866fa$var$U(t4.__v), r3 = t4.o.get(n3);
    return r3[0]++, function(u5) {
      var o3 = function() {
        t4.props.revealOrder ? (r3.push(u5), $dc040a17866866fa$var$T(t4, n3, r3)) : u5();
      };
      e2 ? e2(o3) : o3();
    };
  }, $dc040a17866866fa$export$998bcd577473dd93.prototype.render = function(n3) {
    this.u = null, this.o = /* @__PURE__ */ new Map();
    var t4 = $fb96b826c0c5f37a$export$47e4c5b300681277(n3.children);
    n3.revealOrder && "b" === n3.revealOrder[0] && t4.reverse();
    for (var e2 = t4.length; e2--; ) this.o.set(t4[e2], this.u = [
      1,
      0,
      this.u
    ]);
    return n3.children;
  }, $dc040a17866866fa$export$998bcd577473dd93.prototype.componentDidUpdate = $dc040a17866866fa$export$998bcd577473dd93.prototype.componentDidMount = function() {
    var n3 = this;
    this.o.forEach(function(t4, e2) {
      $dc040a17866866fa$var$T(n3, e2, t4);
    });
  };
  var $dc040a17866866fa$var$j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
  var $dc040a17866866fa$var$P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
  var $dc040a17866866fa$var$V = "undefined" != typeof document;
  var $dc040a17866866fa$var$z = function(n3) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n3);
  };
  $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.isReactComponent = {}, [
    "componentWillMount",
    "componentWillReceiveProps",
    "componentWillUpdate"
  ].forEach(function(n3) {
    Object.defineProperty($fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype, n3, {
      configurable: true,
      get: function() {
        return this["UNSAFE_" + n3];
      },
      set: function(t4) {
        Object.defineProperty(this, n3, {
          configurable: true,
          writable: true,
          value: t4
        });
      }
    });
  });
  var $dc040a17866866fa$var$H = $fb96b826c0c5f37a$export$41c562ebe57d11e2.event;
  function $dc040a17866866fa$var$Z() {
  }
  function $dc040a17866866fa$var$Y() {
    return this.cancelBubble;
  }
  function $dc040a17866866fa$var$q() {
    return this.defaultPrevented;
  }
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.event = function(n3) {
    return $dc040a17866866fa$var$H && (n3 = $dc040a17866866fa$var$H(n3)), n3.persist = $dc040a17866866fa$var$Z, n3.isPropagationStopped = $dc040a17866866fa$var$Y, n3.isDefaultPrevented = $dc040a17866866fa$var$q, n3.nativeEvent = n3;
  };
  var $dc040a17866866fa$var$G;
  var $dc040a17866866fa$var$J = {
    configurable: true,
    get: function() {
      return this.class;
    }
  };
  var $dc040a17866866fa$var$K = $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode;
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode = function(n10) {
    var t4 = n10.type, e2 = n10.props, r3 = e2;
    if ("string" == typeof t4) {
      var u5 = -1 === t4.indexOf("-");
      for (var o3 in r3 = {}, e2) {
        var i3 = e2[o3];
        $dc040a17866866fa$var$V && "children" === o3 && "noscript" === t4 || "value" === o3 && "defaultValue" in e2 && null == i3 || ("defaultValue" === o3 && "value" in e2 && null == e2.value ? o3 = "value" : "download" === o3 && true === i3 ? i3 = "" : /ondoubleclick/i.test(o3) ? o3 = "ondblclick" : /^onchange(textarea|input)/i.test(o3 + t4) && !$dc040a17866866fa$var$z(e2.type) ? o3 = "oninput" : /^onfocus$/i.test(o3) ? o3 = "onfocusin" : /^onblur$/i.test(o3) ? o3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp)/.test(o3) ? o3 = o3.toLowerCase() : u5 && $dc040a17866866fa$var$P.test(o3) ? o3 = o3.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === i3 && (i3 = void 0), r3[o3] = i3);
      }
      "select" == t4 && r3.multiple && Array.isArray(r3.value) && (r3.value = $fb96b826c0c5f37a$export$47e4c5b300681277(e2.children).forEach(function(n3) {
        n3.props.selected = -1 != r3.value.indexOf(n3.props.value);
      })), "select" == t4 && null != r3.defaultValue && (r3.value = $fb96b826c0c5f37a$export$47e4c5b300681277(e2.children).forEach(function(n3) {
        n3.props.selected = r3.multiple ? -1 != r3.defaultValue.indexOf(n3.props.value) : r3.defaultValue == n3.props.value;
      })), n10.props = r3, e2.class != e2.className && ($dc040a17866866fa$var$J.enumerable = "className" in e2, null != e2.className && (r3.class = e2.className), Object.defineProperty(r3, "className", $dc040a17866866fa$var$J));
    }
    n10.$$typeof = $dc040a17866866fa$var$j, $dc040a17866866fa$var$K && $dc040a17866866fa$var$K(n10);
  };
  var $dc040a17866866fa$var$Q = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r;
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r = function(n3) {
    $dc040a17866866fa$var$Q && $dc040a17866866fa$var$Q(n3), $dc040a17866866fa$var$G = n3.__c;
  };
  var $4a239e09606b771e$var$THEME_ICONS = {
    light: "outline",
    dark: "solid"
  };
  var $4a239e09606b771e$export$2e2bcd8739ae039 = class extends $dc040a17866866fa$export$221d75b3f55bb0bd {
    renderIcon(category) {
      const { icon } = category;
      if (icon) {
        if (icon.svg) return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
          class: "flex",
          dangerouslySetInnerHTML: {
            __html: icon.svg
          }
        });
        if (icon.src) return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("img", {
          src: icon.src
        });
      }
      const categoryIcons = $f8900ac4fc737037$export$2e2bcd8739ae039.categories[category.id] || $f8900ac4fc737037$export$2e2bcd8739ae039.categories.custom;
      const style = this.props.icons == "auto" ? $4a239e09606b771e$var$THEME_ICONS[this.props.theme] : this.props.icons;
      return categoryIcons[style] || categoryIcons;
    }
    render() {
      let selectedCategoryIndex = null;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("nav", {
        id: "nav",
        class: "padding",
        "data-position": this.props.position,
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
          class: "flex relative",
          children: [
            this.categories.map((category, i3) => {
              const title = category.name || $94a402d4fc0f5991$export$dbe3113d60765c1a.categories[category.id];
              const selected = !this.props.unfocused && category.id == this.state.categoryId;
              if (selected) selectedCategoryIndex = i3;
              return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
                "aria-label": title,
                "aria-selected": selected || void 0,
                title,
                type: "button",
                class: "flex flex-grow flex-center",
                onMouseDown: (e2) => e2.preventDefault(),
                onClick: () => {
                  this.props.onClick({
                    category,
                    i: i3
                  });
                },
                children: this.renderIcon(category)
              });
            }),
            /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
              class: "bar",
              style: {
                width: `${100 / this.categories.length}%`,
                opacity: selectedCategoryIndex == null ? 0 : 1,
                transform: `translateX(${selectedCategoryIndex * 100}%)`
              }
            })
          ]
        })
      });
    }
    constructor() {
      super();
      this.categories = $94a402d4fc0f5991$export$2d0294657ab35f1b.categories.filter((category) => {
        return !category.target;
      });
      this.state = {
        categoryId: this.categories[0].id
      };
    }
  };
  var $f81a65d65797a567$export$2e2bcd8739ae039 = class extends $dc040a17866866fa$export$221d75b3f55bb0bd {
    shouldComponentUpdate(nextProps) {
      for (let k4 in nextProps) {
        if (k4 == "children") continue;
        if (nextProps[k4] != this.props[k4]) return true;
      }
      return false;
    }
    render() {
      return this.props.children;
    }
  };
  var $1b22a2469de9cd60$var$Performance = {
    rowsPerRender: 10
  };
  var $1b22a2469de9cd60$export$2e2bcd8739ae039 = class extends $fb96b826c0c5f37a$export$16fa2f45be04daa8 {
    getInitialState(props = this.props) {
      return {
        skin: $f7419c5d8054163a$export$2e2bcd8739ae039.get("skin") || props.skin,
        theme: this.initTheme(props.theme)
      };
    }
    componentWillMount() {
      this.observers = [];
      this.dir = $94a402d4fc0f5991$export$dbe3113d60765c1a.rtl ? "rtl" : "ltr";
      this.refs = {
        menu: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        navigation: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        scroll: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        search: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        searchInput: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        skinToneButton: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        skinToneRadio: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43()
      };
      this.initGrid();
      if (this.props.stickySearch == false && this.props.searchPosition == "sticky") {
        console.warn("[EmojiMart] Deprecation warning: `stickySearch` has been renamed `searchPosition`.");
        this.props.searchPosition = "static";
      }
    }
    componentDidMount() {
      this.register();
      this.shadowRoot = this.base.parentNode;
      if (this.props.autoFocus) {
        const { searchInput } = this.refs;
        if (searchInput.current) searchInput.current.focus();
      }
    }
    componentWillReceiveProps(nextProps) {
      this.nextState || (this.nextState = {});
      for (const k1 in nextProps) this.nextState[k1] = nextProps[k1];
      clearTimeout(this.nextStateTimer);
      this.nextStateTimer = setTimeout(() => {
        let requiresGridReset = false;
        for (const k4 in this.nextState) {
          this.props[k4] = this.nextState[k4];
          if (k4 === "custom" || k4 === "categories") requiresGridReset = true;
        }
        delete this.nextState;
        const nextState = this.getInitialState();
        if (requiresGridReset) return this.reset(nextState);
        this.setState(nextState);
      });
    }
    componentWillUnmount() {
      this.unregister();
    }
    async reset(nextState = {}) {
      await $94a402d4fc0f5991$export$2cd8252107eb640b(this.props);
      this.initGrid();
      this.unobserve();
      this.setState(nextState, () => {
        this.observeCategories();
        this.observeRows();
      });
    }
    register() {
      document.addEventListener("click", this.handleClickOutside);
      this.observe();
    }
    unregister() {
      document.removeEventListener("click", this.handleClickOutside);
      this.unobserve();
    }
    observe() {
      this.observeCategories();
      this.observeRows();
    }
    unobserve() {
      for (const observer of this.observers) observer.disconnect();
    }
    initGrid() {
      const { categories } = $94a402d4fc0f5991$export$2d0294657ab35f1b;
      this.refs.categories = /* @__PURE__ */ new Map();
      const navKey = $94a402d4fc0f5991$export$2d0294657ab35f1b.categories.map(
        (category) => category.id
      ).join(",");
      if (this.navKey && this.navKey != navKey) this.refs.scroll.current && (this.refs.scroll.current.scrollTop = 0);
      this.navKey = navKey;
      this.grid = [];
      this.grid.setsize = 0;
      const addRow = (rows, category) => {
        const row = [];
        row.__categoryId = category.id;
        row.__index = rows.length;
        this.grid.push(row);
        const rowIndex = this.grid.length - 1;
        const rowRef = rowIndex % $1b22a2469de9cd60$var$Performance.rowsPerRender ? {} : $fb96b826c0c5f37a$export$7d1e3a5e95ceca43();
        rowRef.index = rowIndex;
        rowRef.posinset = this.grid.setsize + 1;
        rows.push(rowRef);
        return row;
      };
      for (let category1 of categories) {
        const rows = [];
        let row = addRow(rows, category1);
        for (let emoji of category1.emojis) {
          if (row.length == this.props.perLine) row = addRow(rows, category1);
          this.grid.setsize += 1;
          row.push(emoji);
        }
        this.refs.categories.set(category1.id, {
          root: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
          rows
        });
      }
    }
    initTheme(theme) {
      if (theme != "auto") return theme;
      if (!this.darkMedia) {
        this.darkMedia = matchMedia("(prefers-color-scheme: dark)");
        if (this.darkMedia.media.match(/^not/)) return "light";
        this.darkMedia.addListener(() => {
          if (this.props.theme != "auto") return;
          this.setState({
            theme: this.darkMedia.matches ? "dark" : "light"
          });
        });
      }
      return this.darkMedia.matches ? "dark" : "light";
    }
    getEmojiByPos([p1, p22]) {
      const grid = this.state.searchResults || this.grid;
      const emoji = grid[p1] && grid[p1][p22];
      if (!emoji) return;
      return $e8e05d5d75c37ff8$export$2e2bcd8739ae039.get(emoji);
    }
    observeCategories() {
      const navigation = this.refs.navigation.current;
      if (!navigation) return;
      const visibleCategories = /* @__PURE__ */ new Map();
      const setFocusedCategory = (categoryId) => {
        if (categoryId != navigation.state.categoryId) navigation.setState({
          categoryId
        });
      };
      const observerOptions = {
        root: this.refs.scroll.current,
        threshold: [
          0,
          1
        ]
      };
      const observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          const id = entry.target.dataset.id;
          visibleCategories.set(id, entry.intersectionRatio);
        }
        const ratios = [
          ...visibleCategories
        ];
        const lastCategory = ratios[ratios.length - 1];
        if (lastCategory[1] == 1) return setFocusedCategory(lastCategory[0]);
        for (const [id, ratio] of ratios) if (ratio) {
          setFocusedCategory(id);
          break;
        }
      }, observerOptions);
      for (const { root } of this.refs.categories.values()) observer.observe(root.current);
      this.observers.push(observer);
    }
    observeRows() {
      const visibleRows = {
        ...this.state.visibleRows
      };
      const observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          const index2 = parseInt(entry.target.dataset.index);
          if (entry.isIntersecting) visibleRows[index2] = true;
          else delete visibleRows[index2];
        }
        this.setState({
          visibleRows
        });
      }, {
        root: this.refs.scroll.current,
        rootMargin: `${this.props.emojiButtonSize * ($1b22a2469de9cd60$var$Performance.rowsPerRender + 5)}px 0px ${this.props.emojiButtonSize * $1b22a2469de9cd60$var$Performance.rowsPerRender}px`
      });
      for (const { rows } of this.refs.categories.values()) {
        for (const row of rows) if (row.current) observer.observe(row.current);
      }
      this.observers.push(observer);
    }
    preventDefault(e2) {
      e2.preventDefault();
    }
    unfocusSearch() {
      const input = this.refs.searchInput.current;
      if (!input) return;
      input.blur();
    }
    navigate({ e: e2, input, left: left2, right: right2, up, down }) {
      const grid = this.state.searchResults || this.grid;
      if (!grid.length) return;
      let [p1, p22] = this.state.pos;
      const pos = (() => {
        if (p1 == 0) {
          if (p22 == 0 && !e2.repeat && (left2 || up)) return null;
        }
        if (p1 == -1) {
          if (!e2.repeat && (right2 || down) && input.selectionStart == input.value.length) return [
            0,
            0
          ];
          return null;
        }
        if (left2 || right2) {
          let row = grid[p1];
          const increment = left2 ? -1 : 1;
          p22 += increment;
          if (!row[p22]) {
            p1 += increment;
            row = grid[p1];
            if (!row) {
              p1 = left2 ? 0 : grid.length - 1;
              p22 = left2 ? 0 : grid[p1].length - 1;
              return [
                p1,
                p22
              ];
            }
            p22 = left2 ? row.length - 1 : 0;
          }
          return [
            p1,
            p22
          ];
        }
        if (up || down) {
          p1 += up ? -1 : 1;
          const row = grid[p1];
          if (!row) {
            p1 = up ? 0 : grid.length - 1;
            p22 = up ? 0 : grid[p1].length - 1;
            return [
              p1,
              p22
            ];
          }
          if (!row[p22]) p22 = row.length - 1;
          return [
            p1,
            p22
          ];
        }
      })();
      if (pos) e2.preventDefault();
      else {
        if (this.state.pos[0] > -1) this.setState({
          pos: [
            -1,
            -1
          ]
        });
        return;
      }
      this.setState({
        pos,
        keyboard: true
      }, () => {
        this.scrollTo({
          row: pos[0]
        });
      });
    }
    scrollTo({ categoryId, row }) {
      const grid = this.state.searchResults || this.grid;
      if (!grid.length) return;
      const scroll = this.refs.scroll.current;
      const scrollRect = scroll.getBoundingClientRect();
      let scrollTop = 0;
      if (row >= 0) categoryId = grid[row].__categoryId;
      if (categoryId) {
        const ref = this.refs[categoryId] || this.refs.categories.get(categoryId).root;
        const categoryRect = ref.current.getBoundingClientRect();
        scrollTop = categoryRect.top - (scrollRect.top - scroll.scrollTop) + 1;
      }
      if (row >= 0) {
        if (!row) scrollTop = 0;
        else {
          const rowIndex = grid[row].__index;
          const rowTop = scrollTop + rowIndex * this.props.emojiButtonSize;
          const rowBot = rowTop + this.props.emojiButtonSize + this.props.emojiButtonSize * 0.88;
          if (rowTop < scroll.scrollTop) scrollTop = rowTop;
          else if (rowBot > scroll.scrollTop + scrollRect.height) scrollTop = rowBot - scrollRect.height;
          else return;
        }
      }
      this.ignoreMouse();
      scroll.scrollTop = scrollTop;
    }
    ignoreMouse() {
      this.mouseIsIgnored = true;
      clearTimeout(this.ignoreMouseTimer);
      this.ignoreMouseTimer = setTimeout(() => {
        delete this.mouseIsIgnored;
      }, 100);
    }
    handleEmojiOver(pos) {
      if (this.mouseIsIgnored || this.state.showSkins) return;
      this.setState({
        pos: pos || [
          -1,
          -1
        ],
        keyboard: false
      });
    }
    handleEmojiClick({ emoji, pos }) {
      if (!this.props.onEmojiSelect) return;
      if (!emoji && pos) emoji = this.getEmojiByPos(pos);
      if (emoji) {
        const emojiData = $569a635a7f98f0e3$export$d10ac59fbe52a745(emoji, {
          skinIndex: this.state.skin - 1
        });
        if (this.props.maxFrequentRows) $de71c25967c746d9$export$2e2bcd8739ae039.add(emojiData, this.props);
        this.props.onEmojiSelect(emojiData);
      }
    }
    closeSkins() {
      if (!this.state.showSkins) return;
      this.setState({
        showSkins: null,
        tempSkin: null
      });
      this.base.removeEventListener("click", this.handleBaseClick);
      this.base.removeEventListener("keydown", this.handleBaseKeydown);
    }
    handleSkinMouseOver(tempSkin) {
      this.setState({
        tempSkin
      });
    }
    handleSkinClick(skin) {
      this.ignoreMouse();
      this.closeSkins();
      this.setState({
        skin,
        tempSkin: null
      });
      $f7419c5d8054163a$export$2e2bcd8739ae039.set("skin", skin);
    }
    renderNav() {
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($4a239e09606b771e$export$2e2bcd8739ae039, {
        ref: this.refs.navigation,
        icons: this.props.icons,
        theme: this.state.theme,
        unfocused: !!this.state.searchResults,
        position: this.props.navPosition,
        onClick: this.handleCategoryClick
      }, this.navKey);
    }
    renderPreview() {
      const emoji = this.getEmojiByPos(this.state.pos);
      const noSearchResults = this.state.searchResults && !this.state.searchResults.length;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        id: "preview",
        class: "flex flex-middle",
        dir: this.dir,
        "data-position": this.props.previewPosition,
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: "flex flex-middle flex-grow",
            children: [
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: "flex flex-auto flex-middle flex-center",
                style: {
                  height: this.props.emojiButtonSize,
                  fontSize: this.props.emojiButtonSize
                },
                children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($52fb24fe07871f48$export$2e2bcd8739ae039, {
                  emoji,
                  id: noSearchResults ? this.props.noResultsEmoji || "cry" : this.props.previewEmoji || (this.props.previewPosition == "top" ? "point_down" : "point_up"),
                  set: this.props.set,
                  size: this.props.emojiButtonSize,
                  skin: this.state.tempSkin || this.state.skin,
                  spritesheet: true,
                  getSpritesheetURL: this.props.getSpritesheetURL
                })
              }),
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: `margin-${this.dir[0]}`,
                children: emoji ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                  class: `padding-${this.dir[2]} align-${this.dir[0]}`,
                  children: [
                    /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                      class: "ellipsis",
                      style: {
                        fontSize: "1.1em"
                      },
                      children: emoji.name
                    }),
                    /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                      class: "ellipsis color-c",
                      style: {
                        fontSize: ".9em"
                      },
                      children: emoji.skins[0].shortcodes
                    })
                  ]
                }) : noSearchResults ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                  class: `padding-${this.dir[2]} align-${this.dir[0]}`,
                  children: [
                    /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                      class: "ellipsis",
                      style: {
                        fontSize: "1.1em"
                      },
                      children: $94a402d4fc0f5991$export$dbe3113d60765c1a.search_no_results_1
                    }),
                    /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                      class: "ellipsis color-c",
                      style: {
                        fontSize: ".9em"
                      },
                      children: $94a402d4fc0f5991$export$dbe3113d60765c1a.search_no_results_2
                    })
                  ]
                }) : /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                  class: "color-c",
                  style: {
                    fontSize: 21
                  },
                  children: $94a402d4fc0f5991$export$dbe3113d60765c1a.pick
                })
              })
            ]
          }),
          !emoji && this.props.skinTonePosition == "preview" && this.renderSkinToneButton()
        ]
      });
    }
    renderEmojiButton(emoji, { pos, posinset, grid }) {
      const size3 = this.props.emojiButtonSize;
      const skin = this.state.tempSkin || this.state.skin;
      const emojiSkin = emoji.skins[skin - 1] || emoji.skins[0];
      const native = emojiSkin.native;
      const selected = $569a635a7f98f0e3$export$9cb4719e2e525b7a(this.state.pos, pos);
      const key = pos.concat(emoji.id).join("");
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($f81a65d65797a567$export$2e2bcd8739ae039, {
        selected,
        skin,
        size: size3,
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
          "aria-label": native,
          "aria-selected": selected || void 0,
          "aria-posinset": posinset,
          "aria-setsize": grid.setsize,
          "data-keyboard": this.state.keyboard,
          title: this.props.previewPosition == "none" ? emoji.name : void 0,
          type: "button",
          class: "flex flex-center flex-middle",
          tabindex: "-1",
          onClick: () => this.handleEmojiClick({
            emoji
          }),
          onMouseEnter: () => this.handleEmojiOver(pos),
          onMouseLeave: () => this.handleEmojiOver(),
          style: {
            width: this.props.emojiButtonSize,
            height: this.props.emojiButtonSize,
            fontSize: this.props.emojiSize,
            lineHeight: 0
          },
          children: [
            /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
              "aria-hidden": "true",
              class: "background",
              style: {
                borderRadius: this.props.emojiButtonRadius,
                backgroundColor: this.props.emojiButtonColors ? this.props.emojiButtonColors[(posinset - 1) % this.props.emojiButtonColors.length] : void 0
              }
            }),
            /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($52fb24fe07871f48$export$2e2bcd8739ae039, {
              emoji,
              set: this.props.set,
              size: this.props.emojiSize,
              skin,
              spritesheet: true,
              getSpritesheetURL: this.props.getSpritesheetURL
            })
          ]
        })
      }, key);
    }
    renderSearch() {
      const renderSkinTone = this.props.previewPosition == "none" || this.props.skinTonePosition == "search";
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: "spacer"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: "flex flex-middle",
            children: [
              renderSkinTone && this.dir == "rtl" && this.renderSkinToneButton(),
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: "search relative flex-grow",
                children: [
                  /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("input", {
                    type: "search",
                    ref: this.refs.searchInput,
                    placeholder: $94a402d4fc0f5991$export$dbe3113d60765c1a.search,
                    onClick: this.handleSearchClick,
                    onInput: this.handleSearchInput,
                    onKeyDown: this.handleSearchKeyDown,
                    autoComplete: "off"
                  }),
                  /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
                    class: "icon loupe flex",
                    children: $f8900ac4fc737037$export$2e2bcd8739ae039.search.loupe
                  }),
                  this.state.searchResults && /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
                    title: "Clear",
                    "aria-label": "Clear",
                    type: "button",
                    class: "icon delete flex",
                    onClick: this.clearSearch,
                    onMouseDown: this.preventDefault,
                    children: $f8900ac4fc737037$export$2e2bcd8739ae039.search.delete
                  })
                ]
              }),
              renderSkinTone && this.dir == "ltr" && this.renderSkinToneButton()
            ]
          })
        ]
      });
    }
    renderSearchResults() {
      const { searchResults } = this.state;
      if (!searchResults) return null;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        class: "category",
        ref: this.refs.search,
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: `sticky padding-small align-${this.dir[0]}`,
            children: $94a402d4fc0f5991$export$dbe3113d60765c1a.categories.search
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            children: !searchResults.length ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
              class: `padding-small align-${this.dir[0]}`,
              children: this.props.onAddCustomEmoji && /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("a", {
                onClick: this.props.onAddCustomEmoji,
                children: $94a402d4fc0f5991$export$dbe3113d60765c1a.add_custom
              })
            }) : searchResults.map((row, i3) => {
              return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: "flex",
                children: row.map((emoji, ii2) => {
                  return this.renderEmojiButton(emoji, {
                    pos: [
                      i3,
                      ii2
                    ],
                    posinset: i3 * this.props.perLine + ii2 + 1,
                    grid: searchResults
                  });
                })
              });
            })
          })
        ]
      });
    }
    renderCategories() {
      const { categories } = $94a402d4fc0f5991$export$2d0294657ab35f1b;
      const hidden = !!this.state.searchResults;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        style: {
          visibility: hidden ? "hidden" : void 0,
          display: hidden ? "none" : void 0
        },
        children: categories.map((category) => {
          const { root, rows } = this.refs.categories.get(category.id);
          return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            "data-id": category.target ? category.target.id : category.id,
            class: "category",
            ref: root,
            children: [
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: `sticky padding-small align-${this.dir[0]}`,
                children: category.name || $94a402d4fc0f5991$export$dbe3113d60765c1a.categories[category.id]
              }),
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: "relative",
                style: {
                  height: rows.length * this.props.emojiButtonSize
                },
                children: rows.map((row, i3) => {
                  const targetRow = row.index - row.index % $1b22a2469de9cd60$var$Performance.rowsPerRender;
                  const visible = this.state.visibleRows[targetRow];
                  const ref = "current" in row ? row : void 0;
                  if (!visible && !ref) return null;
                  const start5 = i3 * this.props.perLine;
                  const end2 = start5 + this.props.perLine;
                  const emojiIds = category.emojis.slice(start5, end2);
                  return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                    "data-index": row.index,
                    ref,
                    class: "flex row",
                    style: {
                      top: i3 * this.props.emojiButtonSize
                    },
                    children: visible && emojiIds.map((emojiId, ii2) => {
                      const emoji = $e8e05d5d75c37ff8$export$2e2bcd8739ae039.get(emojiId);
                      return this.renderEmojiButton(emoji, {
                        pos: [
                          row.index,
                          ii2
                        ],
                        posinset: row.posinset + ii2,
                        grid: this.grid
                      });
                    })
                  }, row.index);
                })
              })
            ]
          });
        })
      });
    }
    renderSkinToneButton() {
      if (this.props.skinTonePosition == "none") return null;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        class: "flex flex-auto flex-center flex-middle",
        style: {
          position: "relative",
          width: this.props.emojiButtonSize,
          height: this.props.emojiButtonSize
        },
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
          type: "button",
          ref: this.refs.skinToneButton,
          class: "skin-tone-button flex flex-auto flex-center flex-middle",
          "aria-selected": this.state.showSkins ? "" : void 0,
          "aria-label": $94a402d4fc0f5991$export$dbe3113d60765c1a.skins.choose,
          title: $94a402d4fc0f5991$export$dbe3113d60765c1a.skins.choose,
          onClick: this.openSkins,
          style: {
            width: this.props.emojiSize,
            height: this.props.emojiSize
          },
          children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
            class: `skin-tone skin-tone-${this.state.skin}`
          })
        })
      });
    }
    renderLiveRegion() {
      const emoji = this.getEmojiByPos(this.state.pos);
      const contents = emoji ? emoji.name : "";
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        "aria-live": "polite",
        class: "sr-only",
        children: contents
      });
    }
    renderSkins() {
      const skinToneButton = this.refs.skinToneButton.current;
      const skinToneButtonRect = skinToneButton.getBoundingClientRect();
      const baseRect = this.base.getBoundingClientRect();
      const position = {};
      if (this.dir == "ltr") position.right = baseRect.right - skinToneButtonRect.right - 3;
      else position.left = skinToneButtonRect.left - baseRect.left - 3;
      if (this.props.previewPosition == "bottom" && this.props.skinTonePosition == "preview") position.bottom = baseRect.bottom - skinToneButtonRect.top + 6;
      else {
        position.top = skinToneButtonRect.bottom - baseRect.top + 3;
        position.bottom = "auto";
      }
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        ref: this.refs.menu,
        role: "radiogroup",
        dir: this.dir,
        "aria-label": $94a402d4fc0f5991$export$dbe3113d60765c1a.skins.choose,
        class: "menu hidden",
        "data-position": position.top ? "top" : "bottom",
        style: position,
        children: [
          ...Array(6).keys()
        ].map((i3) => {
          const skin = i3 + 1;
          const checked = this.state.skin == skin;
          return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            children: [
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("input", {
                type: "radio",
                name: "skin-tone",
                value: skin,
                "aria-label": $94a402d4fc0f5991$export$dbe3113d60765c1a.skins[skin],
                ref: checked ? this.refs.skinToneRadio : null,
                defaultChecked: checked,
                onChange: () => this.handleSkinMouseOver(skin),
                onKeyDown: (e2) => {
                  if (e2.code == "Enter" || e2.code == "Space" || e2.code == "Tab") {
                    e2.preventDefault();
                    this.handleSkinClick(skin);
                  }
                }
              }),
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
                "aria-hidden": "true",
                tabindex: "-1",
                onClick: () => this.handleSkinClick(skin),
                onMouseEnter: () => this.handleSkinMouseOver(skin),
                onMouseLeave: () => this.handleSkinMouseOver(),
                class: "option flex flex-grow flex-middle",
                children: [
                  /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
                    class: `skin-tone skin-tone-${skin}`
                  }),
                  /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
                    class: "margin-small-lr",
                    children: $94a402d4fc0f5991$export$dbe3113d60765c1a.skins[skin]
                  })
                ]
              })
            ]
          });
        })
      });
    }
    render() {
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("section", {
        id: "root",
        class: "flex flex-column",
        style: {
          width: this.props.perLine * this.props.emojiButtonSize + 28
        },
        "data-emoji-set": this.props.set,
        "data-theme": this.state.theme,
        "data-menu": this.state.showSkins ? "" : void 0,
        children: [
          this.props.previewPosition == "top" && this.renderPreview(),
          this.props.navPosition == "top" && this.renderNav(),
          this.props.searchPosition == "sticky" && /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: "padding-lr",
            children: this.renderSearch()
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            ref: this.refs.scroll,
            class: "scroll flex-grow padding-lr",
            children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
              style: {
                width: this.props.perLine * this.props.emojiButtonSize
              },
              children: [
                this.props.searchPosition == "static" && this.renderSearch(),
                this.renderSearchResults(),
                this.renderCategories(),
                /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                  class: "spacer"
                })
              ]
            })
          }),
          this.props.navPosition == "bottom" && this.renderNav(),
          this.props.previewPosition == "bottom" && this.renderPreview(),
          this.state.showSkins && this.renderSkins(),
          this.renderLiveRegion()
        ]
      });
    }
    constructor(props) {
      super();
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "handleClickOutside", (e2) => {
        const { element } = this.props;
        if (e2.target != element) {
          if (this.state.showSkins) this.closeSkins();
          if (this.props.onClickOutside) this.props.onClickOutside();
        }
      });
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "handleBaseClick", (e2) => {
        if (!this.state.showSkins) return;
        if (!e2.target.closest(".menu")) {
          e2.preventDefault();
          e2.stopImmediatePropagation();
          this.closeSkins();
        }
      });
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "handleBaseKeydown", (e2) => {
        if (!this.state.showSkins) return;
        if (e2.key == "Escape") {
          e2.preventDefault();
          e2.stopImmediatePropagation();
          this.closeSkins();
        }
      });
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "handleSearchClick", () => {
        const emoji = this.getEmojiByPos(this.state.pos);
        if (!emoji) return;
        this.setState({
          pos: [
            -1,
            -1
          ]
        });
      });
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "handleSearchInput", async () => {
        const input = this.refs.searchInput.current;
        if (!input) return;
        const { value } = input;
        const searchResults = await $e8e05d5d75c37ff8$export$2e2bcd8739ae039.search(value);
        const afterRender = () => {
          if (!this.refs.scroll.current) return;
          this.refs.scroll.current.scrollTop = 0;
        };
        if (!searchResults) return this.setState({
          searchResults,
          pos: [
            -1,
            -1
          ]
        }, afterRender);
        const pos = input.selectionStart == input.value.length ? [
          0,
          0
        ] : [
          -1,
          -1
        ];
        const grid = [];
        grid.setsize = searchResults.length;
        let row = null;
        for (let emoji of searchResults) {
          if (!grid.length || row.length == this.props.perLine) {
            row = [];
            row.__categoryId = "search";
            row.__index = grid.length;
            grid.push(row);
          }
          row.push(emoji);
        }
        this.ignoreMouse();
        this.setState({
          searchResults: grid,
          pos
        }, afterRender);
      });
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "handleSearchKeyDown", (e2) => {
        const input = e2.currentTarget;
        e2.stopImmediatePropagation();
        switch (e2.key) {
          case "ArrowLeft":
            this.navigate({
              e: e2,
              input,
              left: true
            });
            break;
          case "ArrowRight":
            this.navigate({
              e: e2,
              input,
              right: true
            });
            break;
          case "ArrowUp":
            this.navigate({
              e: e2,
              input,
              up: true
            });
            break;
          case "ArrowDown":
            this.navigate({
              e: e2,
              input,
              down: true
            });
            break;
          case "Enter":
            e2.preventDefault();
            this.handleEmojiClick({
              pos: this.state.pos
            });
            break;
          case "Escape":
            e2.preventDefault();
            if (this.state.searchResults) this.clearSearch();
            else this.unfocusSearch();
            break;
          default:
            break;
        }
      });
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "clearSearch", () => {
        const input = this.refs.searchInput.current;
        if (!input) return;
        input.value = "";
        input.focus();
        this.handleSearchInput();
      });
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "handleCategoryClick", ({ category, i: i3 }) => {
        this.scrollTo(i3 == 0 ? {
          row: -1
        } : {
          categoryId: category.id
        });
      });
      $d74df3b4624fbf50$export$2e2bcd8739ae039(this, "openSkins", (e2) => {
        const { currentTarget } = e2;
        const rect = currentTarget.getBoundingClientRect();
        this.setState({
          showSkins: rect
        }, async () => {
          await $569a635a7f98f0e3$export$e772c8ff12451969(2);
          const menu = this.refs.menu.current;
          if (!menu) return;
          menu.classList.remove("hidden");
          this.refs.skinToneRadio.current.focus();
          this.base.addEventListener("click", this.handleBaseClick, true);
          this.base.addEventListener("keydown", this.handleBaseKeydown, true);
        });
      });
      this.state = {
        pos: [
          -1,
          -1
        ],
        visibleRows: {
          0: true
        },
        ...this.getInitialState(props)
      };
    }
  };
  var $b802fbb11c9bd2dc$export$2e2bcd8739ae039 = class extends $2136457ff873277a$export$2e2bcd8739ae039 {
    async connectedCallback() {
      const props = $94a402d4fc0f5991$export$75fe5f91d452f94b(this.props, $8984b9eb096f95f2$export$2e2bcd8739ae039, this);
      props.element = this;
      props.ref = (component) => {
        this.component = component;
      };
      await $94a402d4fc0f5991$export$2cd8252107eb640b(props);
      $fb96b826c0c5f37a$export$b3890eb0ae9dca99(/* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($1b22a2469de9cd60$export$2e2bcd8739ae039, {
        ...props
      }), this.shadowRoot);
    }
    disconnectedCallback() {
      if (this.component) this.component.unregister();
    }
    constructor(props) {
      super(props, {
        styles: /* @__PURE__ */ $parcel$interopDefault($b77bcf1206efff3f$exports)
      });
    }
  };
  $d74df3b4624fbf50$export$2e2bcd8739ae039($b802fbb11c9bd2dc$export$2e2bcd8739ae039, "Props", $8984b9eb096f95f2$export$2e2bcd8739ae039);
  if (typeof customElements !== "undefined" && !customElements.get("em-emoji-picker")) customElements.define("em-emoji-picker", $b802fbb11c9bd2dc$export$2e2bcd8739ae039);
  var $b77bcf1206efff3f$exports = {};
  $b77bcf1206efff3f$exports = ':host {\n  display: flex;\n  width: -webkit-min-content;\n  width: -moz-min-content;\n  width: min-content;\n  height: 435px;\n  min-height: 230px;\n  border-radius: var(--border-radius);\n  box-shadow: var(--shadow);\n  --border-radius: 10px;\n  --category-icon-size: 18px;\n  --font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;\n  --font-size: 15px;\n  --shadow-color: 0deg 0% 0%;\n  --shadow:\n    0.3px 0.5px 2.7px hsl(var(--shadow-color) / 0.14),\n    0.4px 0.8px 1px -3.2px hsl(var(--shadow-color) / 0.14),\n    1px 2px 2.5px -4.5px hsl(var(--shadow-color) / 0.14);\n}\n\n[data-theme=light] {\n  --em-rgb-color: var(--rgb-color, 34, 36, 39);\n  --em-rgb-accent: var(--rgb-accent, 34, 102, 237);\n  --em-rgb-background: var(--rgb-background, 255, 255, 255);\n  --em-rgb-input: var(--rgb-input, 255, 255, 255);\n  --em-color-border: var(--color-border, rgba(0, 0, 0, .05));\n  --em-color-border-over: var(--color-border-over, rgba(0, 0, 0, .1));\n}\n\n[data-theme=dark] {\n  --em-rgb-color: var(--rgb-color, 222, 222, 221);\n  --em-rgb-accent: var(--rgb-accent, 58, 130, 247);\n  --em-rgb-background: var(--rgb-background, 21, 22, 23);\n  --em-rgb-input: var(--rgb-input, 0, 0, 0);\n  --em-color-border: var(--color-border, rgba(255, 255, 255, .1));\n  --em-color-border-over: var(--color-border-over, rgba(255, 255, 255, .2));\n}\n\n#root {\n  --color-a: rgb(var(--em-rgb-color));\n  --color-b: rgba(var(--em-rgb-color), .65);\n  --color-c: rgba(var(--em-rgb-color), .45);\n  --padding: 12px;\n  --padding-small: calc(var(--padding) / 2);\n  --sidebar-width: 16px;\n  --duration: 225ms;\n  --duration-fast: 125ms;\n  --duration-instant: 50ms;\n  --easing: cubic-bezier(.4, .0, .2, 1);\n  position: relative;\n  width: 100%;\n  text-align: left;\n  border-radius: var(--border-radius);\n  background-color: rgb(var(--em-rgb-background));\n}\n\n@media (prefers-reduced-motion) {\n  #root {\n    --duration: 0;\n    --duration-fast: 0;\n    --duration-instant: 0;\n  }\n}\n\n#root[data-menu] button {\n  cursor: auto;\n}\n\n#root[data-menu] .menu button {\n  cursor: pointer;\n}\n\n:host, #root, input, button {\n  color: rgb(var(--em-rgb-color));\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n*, *:before, *:after {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n  min-width: 0;\n}\n\n.relative {\n  position: relative;\n}\n\n.flex {\n  display: flex;\n}\n\n.flex-auto {\n  flex: 0 0 auto;\n}\n\n.flex-center {\n  justify-content: center;\n}\n\n.flex-column {\n  flex-direction: column;\n}\n\n.flex-grow {\n  flex: 1 1 auto;\n}\n\n.flex-middle {\n  align-items: center;\n}\n\n.flex-wrap {\n  flex-wrap: wrap;\n}\n\n.padding {\n  padding: var(--padding);\n}\n\n.padding-t {\n  padding-top: var(--padding);\n}\n\n.padding-lr {\n  padding-left: var(--padding);\n  padding-right: var(--padding);\n}\n\n.padding-r {\n  padding-right: var(--padding);\n}\n\n.padding-small {\n  padding: var(--padding-small);\n}\n\n.padding-small-b {\n  padding-bottom: var(--padding-small);\n}\n\n.padding-small-lr {\n  padding-left: var(--padding-small);\n  padding-right: var(--padding-small);\n}\n\n.margin {\n  margin: var(--padding);\n}\n\n.margin-r {\n  margin-right: var(--padding);\n}\n\n.margin-l {\n  margin-left: var(--padding);\n}\n\n.margin-small-l {\n  margin-left: var(--padding-small);\n}\n\n.margin-small-lr {\n  margin-left: var(--padding-small);\n  margin-right: var(--padding-small);\n}\n\n.align-l {\n  text-align: left;\n}\n\n.align-r {\n  text-align: right;\n}\n\n.color-a {\n  color: var(--color-a);\n}\n\n.color-b {\n  color: var(--color-b);\n}\n\n.color-c {\n  color: var(--color-c);\n}\n\n.ellipsis {\n  white-space: nowrap;\n  max-width: 100%;\n  width: auto;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.sr-only {\n  position: absolute;\n  left: -10000px;\n  top: auto;\n  width: 1px;\n  height: 1px;\n  overflow: hidden;\n}\n\na {\n  cursor: pointer;\n  color: rgb(var(--em-rgb-accent));\n}\n\na:hover {\n  text-decoration: underline;\n}\n\n.spacer {\n  height: 10px;\n}\n\n.scroll {\n  overflow: auto;\n  overflow-x: hidden;\n  padding-right: 0;\n}\n\n.scroll::-webkit-scrollbar {\n  width: var(--sidebar-width);\n  height: var(--sidebar-width);\n}\n\n.scroll::-webkit-scrollbar-track {\n  border: 0;\n}\n\n.scroll::-webkit-scrollbar-button {\n  width: 0;\n  height: 0;\n  display: none;\n}\n\n.scroll::-webkit-scrollbar-corner {\n  background-color: transparent;\n}\n\n.scroll::-webkit-scrollbar-thumb {\n  min-height: 20%;\n  min-height: 65px;\n  border: 4px solid rgb(var(--em-rgb-background));\n  border-radius: 8px;\n}\n\n.scroll::-webkit-scrollbar-thumb:hover {\n  background-color: var(--em-color-border-over) !important;\n}\n\n.scroll:hover::-webkit-scrollbar-thumb {\n  background-color: var(--em-color-border);\n}\n\n.sticky {\n  position: -webkit-sticky;\n  position: sticky;\n  z-index: 1;\n  top: -1px;\n  font-weight: 500;\n  background-color: rgba(var(--em-rgb-background), 0.9);\n  -webkit-backdrop-filter: blur(4px);\n          backdrop-filter: blur(4px);\n}\n\n.search {\n  z-index: 2;\n  position: relative;\n}\n\n.search input, .search button {\n  font-size: calc(var(--font-size) - 1px);\n}\n\n.search input[type=search] {\n  display: block;\n  border: 0;\n  outline: 0;\n  width: 100%;\n  padding: 10px 2em 10px 2.2em;\n  border-radius: 10px;\n  background-color: var(--em-color-border);\n  transition-duration: var(--duration);\n  transition-property: background-color, box-shadow;\n  transition-timing-function: var(--easing);\n}\n\n.search input[type=search]::-moz-placeholder {\n  color: inherit;\n  opacity: 0.6;\n}\n\n.search input[type=search]:-ms-input-placeholder {\n  color: inherit;\n  opacity: 0.6;\n}\n\n.search input[type=search]::placeholder {\n  color: inherit;\n  opacity: 0.6;\n}\n\n.search input[type=search], .search input[type=search]::-webkit-search-decoration, .search input[type=search]::-webkit-search-cancel-button, .search input[type=search]::-webkit-search-results-button, .search input[type=search]::-webkit-search-results-decoration {\n  -webkit-appearance: none;\n          appearance: none;\n}\n\n.search input[type=search]:focus {\n  background-color: rgb(var(--em-rgb-input));\n  box-shadow: inset 0 0 0 1px rgb(var(--em-rgb-accent)), 0 1px 3px rgba(65, 69, 73, 0.2);\n}\n\n.search .icon {\n  z-index: 1;\n  position: absolute;\n  top: 50%;\n  color: rgba(var(--em-rgb-color), 0.7);\n  transform: translateY(-50%);\n}\n\n.search .loupe {\n  left: 0.7em;\n  pointer-events: none;\n}\n\n.search .delete {\n  right: 0.7em;\n}\n\nsvg {\n  fill: currentColor;\n  width: 1em;\n  height: 1em;\n}\n\nbutton {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  cursor: pointer;\n  color: currentColor;\n  border: 0;\n  background-color: transparent;\n}\n\n#nav {\n  z-index: 2;\n  position: relative;\n  padding-top: 12px;\n  padding-bottom: 12px;\n  padding-right: var(--sidebar-width);\n}\n\n#nav button {\n  color: var(--color-b);\n  transition: color var(--duration) var(--easing);\n}\n\n#nav button:hover {\n  color: var(--color-a);\n}\n\n#nav svg, #nav img {\n  width: var(--category-icon-size);\n  height: var(--category-icon-size);\n}\n\n#nav .bar {\n  position: absolute;\n  bottom: -12px;\n  left: 0;\n  width: 100%;\n  height: 3px;\n  background-color: rgb(var(--em-rgb-accent));\n  border-radius: 3px 3px 0 0;\n  transition: transform var(--duration) var(--easing);\n}\n\n#nav button[aria-selected] {\n  color: rgb(var(--em-rgb-accent));\n}\n\n#preview {\n  z-index: 2;\n  position: relative;\n  padding: calc(var(--padding) + 4px) var(--padding);\n  padding-right: var(--sidebar-width);\n}\n\n#nav:before, #preview:before {\n  content: "";\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 2px;\n}\n\n#nav[data-position=top]:before, #preview[data-position=top]:before {\n  top: 100%;\n  background: linear-gradient(to bottom, var(--em-color-border), transparent);\n}\n\n#nav[data-position=bottom]:before, #preview[data-position=bottom]:before {\n  bottom: 100%;\n  background: linear-gradient(to top, var(--em-color-border), transparent);\n}\n\n.category button {\n  position: relative;\n  font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;\n}\n\n.category button > * {\n  position: relative;\n}\n\n.category button .background {\n  position: absolute;\n  inset: 0;\n  opacity: 0;\n  background-color: var(--em-color-border);\n  transition: opacity var(--duration-fast) var(--easing) var(--duration-instant);\n}\n\n.category button:hover .background {\n  transition-duration: var(--duration-instant);\n  transition-delay: 0ms;\n}\n\n.category button[aria-selected] .background {\n  opacity: 1;\n}\n\n.category button[data-keyboard] .background {\n  transition: none;\n}\n\n.row {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n}\n\n.skin-tone-button {\n  border-radius: 100%;\n  border: 1px solid transparent;\n}\n\n.skin-tone-button:hover {\n  border-color: var(--em-color-border);\n}\n\n.skin-tone-button:active .skin-tone {\n  transform: scale(0.85) !important;\n}\n\n.skin-tone-button .skin-tone {\n  transition: transform var(--duration) var(--easing);\n}\n\n.skin-tone-button[aria-selected] {\n  border-left-width: 0;\n  border-right-width: 0;\n  border-top-color: rgba(0, 0, 0, 0.05);\n  border-bottom-color: transparent;\n  background-color: var(--em-color-border);\n}\n\n.skin-tone-button[aria-selected] .skin-tone {\n  transform: scale(0.9);\n}\n\n.menu {\n  z-index: 2;\n  position: absolute;\n  white-space: nowrap;\n  padding: 4px;\n  border: 1px solid var(--em-color-border);\n  background-color: rgba(var(--em-rgb-background), 0.9);\n  -webkit-backdrop-filter: blur(4px);\n          backdrop-filter: blur(4px);\n  border-radius: 10px;\n  box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.05);\n  transition-property: opacity, transform;\n  transition-duration: var(--duration);\n  transition-timing-function: var(--easing);\n}\n\n.menu.hidden {\n  opacity: 0;\n}\n\n.menu[data-position=bottom] {\n  transform-origin: bottom right;\n}\n\n.menu[data-position=bottom].hidden {\n  transform: scale(0.9) rotate(-3deg) translateY(5%);\n}\n\n.menu[data-position=top] {\n  transform-origin: top right;\n}\n\n.menu[data-position=top].hidden {\n  transform: scale(0.9) rotate(3deg) translateY(-5%);\n}\n\n.menu input[type=radio] {\n  position: absolute;\n  overflow: hidden;\n  clip: rect(0 0 0 0);\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: 0;\n  border: 0;\n}\n\n.menu input[type=radio]:checked + .option {\n  box-shadow: 0 0 0 2px rgb(var(--em-rgb-accent));\n}\n\n.option {\n  width: 100%;\n  padding: 4px 6px;\n  border-radius: 6px;\n}\n\n.option:hover {\n  color: #fff;\n  background-color: rgb(var(--em-rgb-accent));\n}\n\n.skin-tone {\n  position: relative;\n  display: inline-block;\n  width: 16px;\n  height: 16px;\n  border-radius: 100%;\n  overflow: hidden;\n}\n\n.skin-tone:after {\n  content: "";\n  position: absolute;\n  inset: 0;\n  border-radius: 100%;\n  border: 1px solid rgba(0, 0, 0, 0.8);\n  mix-blend-mode: overlay;\n  box-shadow: inset 0 -2px 3px #000, inset 0 1px 2px #fff;\n  background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), transparent);\n}\n\n.skin-tone-1 {\n  background-color: #ffc93a;\n}\n\n.skin-tone-2 {\n  background-color: #ffdab7;\n}\n\n.skin-tone-3 {\n  background-color: #e7b98f;\n}\n\n.skin-tone-4 {\n  background-color: #c88c61;\n}\n\n.skin-tone-5 {\n  background-color: #a46134;\n}\n\n.skin-tone-6 {\n  background-color: #5d4437;\n}\n\n[data-emoji-set=twitter] .skin-tone:after {\n  border-color: rgba(0, 0, 0, 0.5);\n  box-shadow: none;\n}\n\n[data-emoji-set=twitter] .skin-tone-1 {\n  background-color: #FADE72;\n}\n\n[data-emoji-set=twitter] .skin-tone-2 {\n  background-color: #F3DFD0;\n}\n\n[data-emoji-set=twitter] .skin-tone-3 {\n  background-color: #EED3A8;\n}\n\n[data-emoji-set=twitter] .skin-tone-4 {\n  background-color: #CFAD8D;\n}\n\n[data-emoji-set=twitter] .skin-tone-5 {\n  background-color: #A8805D;\n}\n\n[data-emoji-set=twitter] .skin-tone-6 {\n  background-color: #765542;\n}\n\n[data-emoji-set=google] .skin-tone:after {\n  box-shadow: inset 0 0 2px 2px rgba(0, 0, 0, 0.4);\n}\n\n[data-emoji-set=google] .skin-tone-1 {\n  background-color: #F5C748;\n}\n\n[data-emoji-set=google] .skin-tone-2 {\n  background-color: #F1D5AA;\n}\n\n[data-emoji-set=google] .skin-tone-3 {\n  background-color: #D4B48D;\n}\n\n[data-emoji-set=google] .skin-tone-4 {\n  background-color: #AA876B;\n}\n\n[data-emoji-set=google] .skin-tone-5 {\n  background-color: #916544;\n}\n\n[data-emoji-set=google] .skin-tone-6 {\n  background-color: #61493F;\n}\n\n[data-emoji-set=facebook] .skin-tone:after {\n  border-color: rgba(0, 0, 0, 0.4);\n  box-shadow: inset 0 -2px 3px #000, inset 0 1px 4px #fff;\n}\n\n[data-emoji-set=facebook] .skin-tone-1 {\n  background-color: #F5C748;\n}\n\n[data-emoji-set=facebook] .skin-tone-2 {\n  background-color: #F1D5AA;\n}\n\n[data-emoji-set=facebook] .skin-tone-3 {\n  background-color: #D4B48D;\n}\n\n[data-emoji-set=facebook] .skin-tone-4 {\n  background-color: #AA876B;\n}\n\n[data-emoji-set=facebook] .skin-tone-5 {\n  background-color: #916544;\n}\n\n[data-emoji-set=facebook] .skin-tone-6 {\n  background-color: #61493F;\n}\n';

  // app/javascript/customer_center/controllers/emoji_dropdown_controller.js
  var emoji_dropdown_controller_default = class extends application_controller_default {
    connect() {
      this.initializePicker();
    }
    async getI18nConfig(language = "en") {
      try {
        const response2 = await fetch(`https://cdn.jsdelivr.net/npm/@emoji-mart/data/i18n/${language}.json`);
        if (response2.ok) {
          return await response2.json();
        }
      } catch {
        console.warn(`Failed to load i18n for ${language}, falling back to default`);
      }
      return null;
    }
    async initializePicker() {
      const dataResponse = await fetch("https://cdn.jsdelivr.net/npm/@emoji-mart/data");
      const locale = this.localeValue || "en";
      const i18nConfig = await this.getI18nConfig(locale);
      const pickerOptions = {
        data: await dataResponse.json(),
        onEmojiSelect: (emoji) => {
          let event2 = new CustomEvent("emoji-select", { detail: emoji, bubbles: true });
          this.element.dispatchEvent(event2);
          this.hide();
        }
      };
      if (i18nConfig) {
        pickerOptions.i18n = i18nConfig;
      }
      this.picker = new $b802fbb11c9bd2dc$export$2e2bcd8739ae039(pickerOptions);
      this.pickerTarget.appendChild(this.picker);
    }
    hide() {
      this.element.hide();
    }
  };
  __publicField(emoji_dropdown_controller_default, "targets", ["picker"]);
  __publicField(emoji_dropdown_controller_default, "values", { locale: String });

  // app/javascript/customer_center/controllers/trix_emojis_controller.js
  init_define_process();
  init_jquery();
  var trix_emojis_controller_default = class extends application_controller_default {
    handleEmojiSelect(e2) {
      let native = e2.detail.native;
      this.editor.insertString(native);
    }
    get editor() {
      return this.element.querySelector("trix-editor").editor;
    }
  };

  // app/javascript/customer_center/controllers/form_controller.js
  init_define_process();
  init_jquery();
  var form_controller_default = class extends application_controller_default {
    submit() {
      this.element.requestSubmit();
    }
  };

  // app/javascript/customer_center/controllers/scroll_nav_controller.js
  init_define_process();
  init_jquery();
  var scroll_nav_controller_default = class extends Controller {
    connect() {
      this.checkScroll();
      this.resizeObserver = new ResizeObserver(() => {
        this.checkScroll();
      });
      this.resizeObserver.observe(this.containerTarget);
    }
    disconnect() {
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
    }
    checkScroll() {
      const container = this.containerTarget;
      this.leftButtonTarget.classList.toggle("hidden", container.scrollLeft <= 0);
      this.rightButtonTarget.classList.toggle(
        "hidden",
        container.scrollLeft + container.clientWidth >= container.scrollWidth
      );
    }
    scrollLeft() {
      this.containerTarget.scrollBy({
        left: -200,
        behavior: "smooth"
      });
    }
    scrollRight() {
      this.containerTarget.scrollBy({
        left: 200,
        behavior: "smooth"
      });
    }
  };
  __publicField(scroll_nav_controller_default, "targets", ["container", "leftButton", "rightButton"]);

  // node_modules/@stimulus-components/read-more/dist/stimulus-read-more.mjs
  init_define_process();
  init_jquery();
  var _ReadMore = class _ReadMore2 extends Controller {
    connect() {
      this.open = false;
    }
    toggle(event2) {
      this.open === false ? this.show(event2) : this.hide(event2);
    }
    show(event2) {
      this.open = true;
      const target = event2.target;
      target.innerHTML = this.lessTextValue, this.contentTarget.style.setProperty("--read-more-line-clamp", "'unset'");
    }
    hide(event2) {
      this.open = false;
      const target = event2.target;
      target.innerHTML = this.moreTextValue, this.contentTarget.style.removeProperty("--read-more-line-clamp");
    }
  };
  _ReadMore.targets = ["content"], _ReadMore.values = {
    moreText: String,
    lessText: String
  };
  var ReadMore = _ReadMore;

  // app/javascript/customer_center/controllers/search_controller.js
  init_define_process();
  init_jquery();
  var import_lodash2 = __toESM(require_lodash2());
  var search_controller_default = class extends application_controller_default {
    initialize() {
      this.debouncedSearch = (0, import_lodash2.debounce)(this.submitSearch, 400);
    }
    openSearch({ params: { autoSearch = true } }) {
      this.show();
      if (!autoSearch) return;
      this.submitSearch();
    }
    search() {
      this.debouncedSearch();
    }
    submitSearch() {
      this.formTarget.requestSubmit();
    }
    show() {
      this.searchDialogTarget.show();
    }
    hide() {
      this.searchDialogTarget.hide();
    }
    remoteTrigger() {
      this.show();
      this.inputTarget.setAttribute("value", this.remoteTarget.value);
      this.submitSearch();
    }
  };
  __publicField(search_controller_default, "targets", ["searchDialog", "form", "input", "remote"]);

  // app/javascript/customer_center/controllers/index.js
  var application = Application.start();
  application.register("activity-chart", activity_chart_controller_default);
  application.register("affiliates--code", code_controller_default);
  application.register("alert", alert_controller_default);
  application.register("auto-enable", auto_enable_controller_default);
  application.register("autofocus", autofocus_controller_default);
  application.register("classlist", classlist_controller_default);
  application.register("clipboard-copy", clipboard_copy_controller_default);
  application.register("commandbar", commandbar_controller_default);
  application.register("comment-form", comment_form_controller_default);
  application.register("community-post", community_post_controller_default);
  application.register("community-post-view", community_post_view_controller_default);
  application.register("components--image-loader", image_loader_controller_default);
  application.register("country-and-region-select", country_and_region_select_controller_default);
  application.register("dark-mode-toggle", dark_mode_toggle_controller_default);
  application.register("direct-image-uploads", direct_image_uploads_controller_default);
  application.register("emoji-dropdown", emoji_dropdown_controller_default);
  application.register("fields--phone", phone_controller_default);
  application.register("fields--phone-verification", phone_verification_controller_default);
  application.register("fields--super-select", super_select_controller_default);
  application.register("fields--super-select-add-option", super_select_add_option_controller_default);
  application.register("fields--tom-select", tom_select_controller_default);
  application.register("form", form_controller_default);
  application.register("iframe-message-relay", iframe_message_relay_controller_default);
  application.register("iframe-resizer", iframe_resizer_controller_default);
  application.register("image-crop", image_crop_controller_default);
  application.register("image-file-field-preview", image_file_field_preview_controller_default);
  application.register("lesson-tree", lesson_tree_controller_default);
  application.register("lightbox", lightbox_controller_default);
  application.register("mobile-nav", mobile_nav_controller_default);
  application.register("orders--payment-methods", payment_methods_controller_default);
  application.register("orders--stripe-payment", stripe_payment_controller_default);
  application.register("orders--plan-preview", plan_preview_controller_default);
  application.register("payment-method-form", payment_method_form_controller_default);
  application.register("post-form", post_form_controller_default);
  application.register("prefetch-handler", prefetch_handler_controller_default);
  application.register("read-more", ReadMore);
  application.register("scroll-to", ScrollController);
  application.register("scroll-nav", scroll_nav_controller_default);
  application.register("search", search_controller_default);
  application.register("mixpanel", mixpanel_controller_default);
  application.register("share", share_controller_default);
  application.register("short-token", short_token_controller_default);
  application.register("shoelace--alert", alert_controller_default2);
  application.register("shoelace--base", base_controller_default);
  application.register("shoelace--confirm", confirm_controller_default);
  application.register("shoelace--dialog", dialog_controller_default);
  application.register("shoelace--drawer", drawer_controller_default);
  application.register("shoelace--dropdown", dropdown_controller_default);
  application.register("shoelace--dropdown-menu", dropdown_menu_controller_default);
  application.register("shoelace--switch", switch_controller_default);
  application.register("shoelace--tab-group", tab_group_controller_default);
  application.register("toast", toast_controller_default);
  application.register("toggle", toggle_controller_default);
  application.register("tooltip", tooltip_controller_default);
  application.register("trix-content-links-target-blank", trix_content_links_target_blank_controller_default);
  application.register("trix-editor", trix_editor_controller_default);
  application.register("trix-emojis", trix_emojis_controller_default);
  application.register("trix-mentions", trix_mentions_controller_default);
  application.register("trix-code-block", trix_code_block_controller_default);
  application.register("unsaved-changes", unsaved_changes_controller_default);
  application.register("video-embeds", video_embeds_controller_default);
  application.register("truncated-tooltip", truncated_tooltip_controller_default);
  St2.initialize({ application, Controller, Trix: oo });

  // app/javascript/customer_center/trix_editor.js
  init_define_process();
  init_jquery();
  document.addEventListener("trix-before-initialize", () => {
    const locale = document.documentElement.lang || api.get("locale") || "en";
    const newLang = i18next_default.t("trix", { returnObjects: true, lng: locale });
    Object.assign(oo.config.lang || {}, newLang);
  });
  document.addEventListener("trix-initialize", function() {
    addEventListener("trix-focus", updateTrixToolbarVisability);
    addEventListener("trix-blur", updateTrixToolbarVisability);
    updateTrixToolbarVisability();
  });
  function updateTrixToolbarVisability() {
    document.querySelectorAll("trix-editor").forEach(function(editorElement) {
      var toolbarElement = editorElement.toolbarElement;
      if (editorElement == document.activeElement) {
        toolbarElement.classList.add("visible");
      } else {
        if (!toolbarElement.contains(document.activeElement)) {
          toolbarElement.classList.remove("visible");
        }
      }
    });
  }

  // app/javascript/turbo_boost/index.js
  init_define_process();
  init_jquery();

  // node_modules/@turbo-boost/streams/app/assets/builds/@turbo-boost/streams.js
  init_define_process();
  init_jquery();
  var ue3 = Object.defineProperty;
  var fe3 = Object.defineProperties;
  var de3 = Object.getOwnPropertyDescriptors;
  var W2 = Object.getOwnPropertySymbols;
  var ce3 = Object.prototype.hasOwnProperty;
  var he3 = Object.prototype.propertyIsEnumerable;
  var $4 = (l5, o3, u5) => o3 in l5 ? ue3(l5, o3, { enumerable: true, configurable: true, writable: true, value: u5 }) : l5[o3] = u5;
  var y3 = (l5, o3) => {
    for (var u5 in o3 || (o3 = {})) ce3.call(o3, u5) && $4(l5, u5, o3[u5]);
    if (W2) for (var u5 of W2(o3)) he3.call(o3, u5) && $4(l5, u5, o3[u5]);
    return l5;
  };
  var O3 = (l5, o3) => fe3(l5, de3(o3));
  var z2 = "0.1.11";
  var me3 = { turboPermanentAttribute: "data-turbo-permanent" };
  var R3 = y3({}, me3);
  var J2 = function() {
    "use strict";
    let l5 = /* @__PURE__ */ new Set(), o3 = { morphStyle: "outerHTML", callbacks: { beforeNodeAdded: A4, afterNodeAdded: A4, beforeNodeMorphed: A4, afterNodeMorphed: A4, beforeNodeRemoved: A4, afterNodeRemoved: A4, beforeAttributeUpdated: A4 }, head: { style: "merge", shouldPreserve: function(e2) {
      return e2.getAttribute("im-preserve") === "true";
    }, shouldReAppend: function(e2) {
      return e2.getAttribute("im-re-append") === "true";
    }, shouldRemove: A4, afterHeadMorphed: A4 } };
    function u5(e2, t4, r3 = {}) {
      e2 instanceof Document && (e2 = e2.documentElement), typeof t4 == "string" && (t4 = ee5(t4));
      let n3 = te5(t4), i3 = Q5(e2, n3, r3);
      return c4(e2, n3, i3);
    }
    function c4(e2, t4, r3) {
      if (r3.head.block) {
        let n3 = e2.querySelector("head"), i3 = t4.querySelector("head");
        if (n3 && i3) {
          let a5 = I4(i3, n3, r3);
          Promise.all(a5).then(function() {
            c4(e2, t4, Object.assign(r3, { head: { block: false, ignore: true } }));
          });
          return;
        }
      }
      if (r3.morphStyle === "innerHTML") return b5(t4, e2, r3), e2.children;
      if (r3.morphStyle === "outerHTML" || r3.morphStyle == null) {
        let n3 = ne4(t4, e2, r3), i3 = n3 == null ? void 0 : n3.previousSibling, a5 = n3 == null ? void 0 : n3.nextSibling, s4 = f4(e2, n3, r3);
        return n3 ? re4(i3, s4, a5) : [];
      } else throw "Do not understand how to morph style " + r3.morphStyle;
    }
    function d5(e2, t4) {
      return t4.ignoreActiveValue && e2 === document.activeElement && e2 !== document.body;
    }
    function f4(e2, t4, r3) {
      if (!(r3.ignoreActive && e2 === document.activeElement)) return t4 == null ? r3.callbacks.beforeNodeRemoved(e2) === false ? e2 : (e2.remove(), r3.callbacks.afterNodeRemoved(e2), null) : V5(e2, t4) ? (r3.callbacks.beforeNodeMorphed(e2, t4) === false || (e2 instanceof HTMLHeadElement && r3.head.ignore || (e2 instanceof HTMLHeadElement && r3.head.style !== "morph" ? I4(t4, e2, r3) : (g4(t4, e2, r3), d5(e2, r3) || b5(t4, e2, r3))), r3.callbacks.afterNodeMorphed(e2, t4)), e2) : r3.callbacks.beforeNodeRemoved(e2) === false || r3.callbacks.beforeNodeAdded(t4) === false ? e2 : (e2.parentElement.replaceChild(t4, e2), r3.callbacks.afterNodeAdded(t4), r3.callbacks.afterNodeRemoved(e2), t4);
    }
    function b5(e2, t4, r3) {
      let n3 = e2.firstChild, i3 = t4.firstChild, a5;
      for (; n3; ) {
        if (a5 = n3, n3 = a5.nextSibling, i3 == null) {
          if (r3.callbacks.beforeNodeAdded(a5) === false) return;
          t4.appendChild(a5), r3.callbacks.afterNodeAdded(a5), S5(r3, a5);
          continue;
        }
        if (F5(a5, i3, r3)) {
          f4(i3, a5, r3), i3 = i3.nextSibling, S5(r3, a5);
          continue;
        }
        let s4 = Z5(e2, t4, a5, i3, r3);
        if (s4) {
          i3 = q4(i3, s4, r3), f4(s4, a5, r3), S5(r3, a5);
          continue;
        }
        let p4 = x4(e2, t4, a5, i3, r3);
        if (p4) {
          i3 = q4(i3, p4, r3), f4(p4, a5, r3), S5(r3, a5);
          continue;
        }
        if (r3.callbacks.beforeNodeAdded(a5) === false) return;
        t4.insertBefore(a5, i3), r3.callbacks.afterNodeAdded(a5), S5(r3, a5);
      }
      for (; i3 !== null; ) {
        let s4 = i3;
        i3 = i3.nextSibling, _26(s4, r3);
      }
    }
    function h4(e2, t4, r3, n3) {
      return e2 === "value" && n3.ignoreActiveValue && t4 === document.activeElement ? true : n3.callbacks.beforeAttributeUpdated(e2, t4, r3) === false;
    }
    function g4(e2, t4, r3) {
      let n3 = e2.nodeType;
      if (n3 === 1) {
        let i3 = e2.attributes, a5 = t4.attributes;
        for (let s4 of i3) h4(s4.name, t4, "update", r3) || t4.getAttribute(s4.name) !== s4.value && t4.setAttribute(s4.name, s4.value);
        for (let s4 = a5.length - 1; 0 <= s4; s4--) {
          let p4 = a5[s4];
          h4(p4.name, t4, "remove", r3) || e2.hasAttribute(p4.name) || t4.removeAttribute(p4.name);
        }
      }
      (n3 === 8 || n3 === 3) && t4.nodeValue !== e2.nodeValue && (t4.nodeValue = e2.nodeValue), d5(t4, r3) || T5(e2, t4, r3);
    }
    function v4(e2, t4, r3, n3) {
      if (e2[r3] !== t4[r3]) {
        let i3 = h4(r3, t4, "update", n3);
        i3 || (t4[r3] = e2[r3]), e2[r3] ? i3 || t4.setAttribute(r3, e2[r3]) : h4(r3, t4, "remove", n3) || t4.removeAttribute(r3);
      }
    }
    function T5(e2, t4, r3) {
      if (e2 instanceof HTMLInputElement && t4 instanceof HTMLInputElement && e2.type !== "file") {
        let n3 = e2.value, i3 = t4.value;
        v4(e2, t4, "checked", r3), v4(e2, t4, "disabled", r3), e2.hasAttribute("value") ? n3 !== i3 && (h4("value", t4, "update", r3) || (t4.setAttribute("value", n3), t4.value = n3)) : h4("value", t4, "remove", r3) || (t4.value = "", t4.removeAttribute("value"));
      } else if (e2 instanceof HTMLOptionElement) v4(e2, t4, "selected", r3);
      else if (e2 instanceof HTMLTextAreaElement && t4 instanceof HTMLTextAreaElement) {
        let n3 = e2.value, i3 = t4.value;
        if (h4("value", t4, "update", r3)) return;
        n3 !== i3 && (t4.value = n3), t4.firstChild && t4.firstChild.nodeValue !== n3 && (t4.firstChild.nodeValue = n3);
      }
    }
    function I4(e2, t4, r3) {
      let n3 = [], i3 = [], a5 = [], s4 = [], p4 = r3.head.style, k4 = /* @__PURE__ */ new Map();
      for (let m4 of e2.children) k4.set(m4.outerHTML, m4);
      for (let m4 of t4.children) {
        let E5 = k4.has(m4.outerHTML), H5 = r3.head.shouldReAppend(m4), C4 = r3.head.shouldPreserve(m4);
        E5 || C4 ? H5 ? i3.push(m4) : (k4.delete(m4.outerHTML), a5.push(m4)) : p4 === "append" ? H5 && (i3.push(m4), s4.push(m4)) : r3.head.shouldRemove(m4) !== false && i3.push(m4);
      }
      s4.push(...k4.values());
      let U5 = [];
      for (let m4 of s4) {
        let E5 = document.createRange().createContextualFragment(m4.outerHTML).firstChild;
        if (r3.callbacks.beforeNodeAdded(E5) !== false) {
          if (E5.href || E5.src) {
            let H5 = null, C4 = new Promise(function(se4) {
              H5 = se4;
            });
            E5.addEventListener("load", function() {
              H5();
            }), U5.push(C4);
          }
          t4.appendChild(E5), r3.callbacks.afterNodeAdded(E5), n3.push(E5);
        }
      }
      for (let m4 of i3) r3.callbacks.beforeNodeRemoved(m4) !== false && (t4.removeChild(m4), r3.callbacks.afterNodeRemoved(m4));
      return r3.head.afterHeadMorphed(t4, { added: n3, kept: a5, removed: i3 }), U5;
    }
    function Me3() {
    }
    function A4() {
    }
    function K4(e2) {
      let t4 = {};
      return Object.assign(t4, o3), Object.assign(t4, e2), t4.callbacks = {}, Object.assign(t4.callbacks, o3.callbacks), Object.assign(t4.callbacks, e2.callbacks), t4.head = {}, Object.assign(t4.head, o3.head), Object.assign(t4.head, e2.head), t4;
    }
    function Q5(e2, t4, r3) {
      return r3 = K4(r3), { target: e2, newContent: t4, config: r3, morphStyle: r3.morphStyle, ignoreActive: r3.ignoreActive, ignoreActiveValue: r3.ignoreActiveValue, idMap: oe4(e2, t4), deadIds: /* @__PURE__ */ new Set(), callbacks: r3.callbacks, head: r3.head };
    }
    function F5(e2, t4, r3) {
      return e2 == null || t4 == null ? false : e2.nodeType === t4.nodeType && e2.tagName === t4.tagName ? e2.id !== "" && e2.id === t4.id ? true : w5(r3, e2, t4) > 0 : false;
    }
    function V5(e2, t4) {
      return e2 == null || t4 == null ? false : e2.nodeType === t4.nodeType && e2.tagName === t4.tagName;
    }
    function q4(e2, t4, r3) {
      for (; e2 !== t4; ) {
        let n3 = e2;
        e2 = e2.nextSibling, _26(n3, r3);
      }
      return S5(r3, t4), t4.nextSibling;
    }
    function Z5(e2, t4, r3, n3, i3) {
      let a5 = w5(i3, r3, t4), s4 = null;
      if (a5 > 0) {
        let p4 = n3, k4 = 0;
        for (; p4 != null; ) {
          if (F5(r3, p4, i3)) return p4;
          if (k4 += w5(i3, p4, e2), k4 > a5) return null;
          p4 = p4.nextSibling;
        }
      }
      return s4;
    }
    function x4(e2, t4, r3, n3, i3) {
      let a5 = n3, s4 = r3.nextSibling, p4 = 0;
      for (; a5 != null; ) {
        if (w5(i3, a5, e2) > 0) return null;
        if (V5(r3, a5)) return a5;
        if (V5(s4, a5) && (p4++, s4 = s4.nextSibling, p4 >= 2)) return null;
        a5 = a5.nextSibling;
      }
      return a5;
    }
    function ee5(e2) {
      let t4 = new DOMParser(), r3 = e2.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (r3.match(/<\/html>/) || r3.match(/<\/head>/) || r3.match(/<\/body>/)) {
        let n3 = t4.parseFromString(e2, "text/html");
        if (r3.match(/<\/html>/)) return n3.generatedByIdiomorph = true, n3;
        {
          let i3 = n3.firstChild;
          return i3 ? (i3.generatedByIdiomorph = true, i3) : null;
        }
      } else {
        let i3 = t4.parseFromString("<body><template>" + e2 + "</template></body>", "text/html").body.querySelector("template").content;
        return i3.generatedByIdiomorph = true, i3;
      }
    }
    function te5(e2) {
      if (e2 == null) return document.createElement("div");
      if (e2.generatedByIdiomorph) return e2;
      if (e2 instanceof Node) {
        let t4 = document.createElement("div");
        return t4.append(e2), t4;
      } else {
        let t4 = document.createElement("div");
        for (let r3 of [...e2]) t4.append(r3);
        return t4;
      }
    }
    function re4(e2, t4, r3) {
      let n3 = [], i3 = [];
      for (; e2 != null; ) n3.push(e2), e2 = e2.previousSibling;
      for (; n3.length > 0; ) {
        let a5 = n3.pop();
        i3.push(a5), t4.parentElement.insertBefore(a5, t4);
      }
      for (i3.push(t4); r3 != null; ) n3.push(r3), i3.push(r3), r3 = r3.nextSibling;
      for (; n3.length > 0; ) t4.parentElement.insertBefore(n3.pop(), t4.nextSibling);
      return i3;
    }
    function ne4(e2, t4, r3) {
      let n3;
      n3 = e2.firstChild;
      let i3 = n3, a5 = 0;
      for (; n3; ) {
        let s4 = ie4(n3, t4, r3);
        s4 > a5 && (i3 = n3, a5 = s4), n3 = n3.nextSibling;
      }
      return i3;
    }
    function ie4(e2, t4, r3) {
      return V5(e2, t4) ? 0.5 + w5(r3, e2, t4) : 0;
    }
    function _26(e2, t4) {
      S5(t4, e2), t4.callbacks.beforeNodeRemoved(e2) !== false && (e2.remove(), t4.callbacks.afterNodeRemoved(e2));
    }
    function le4(e2, t4) {
      return !e2.deadIds.has(t4);
    }
    function ae4(e2, t4, r3) {
      return (e2.idMap.get(r3) || l5).has(t4);
    }
    function S5(e2, t4) {
      let r3 = e2.idMap.get(t4) || l5;
      for (let n3 of r3) e2.deadIds.add(n3);
    }
    function w5(e2, t4, r3) {
      let n3 = e2.idMap.get(t4) || l5, i3 = 0;
      for (let a5 of n3) le4(e2, a5) && ae4(e2, a5, r3) && ++i3;
      return i3;
    }
    function N5(e2, t4) {
      let r3 = e2.parentElement, n3 = e2.querySelectorAll("[id]");
      for (let i3 of n3) {
        let a5 = i3;
        for (; a5 !== r3 && a5 != null; ) {
          let s4 = t4.get(a5);
          s4 == null && (s4 = /* @__PURE__ */ new Set(), t4.set(a5, s4)), s4.add(i3.id), a5 = a5.parentElement;
        }
      }
    }
    function oe4(e2, t4) {
      let r3 = /* @__PURE__ */ new Map();
      return N5(e2, r3), N5(t4, r3), r3;
    }
    return { morph: u5, defaults: o3 };
  }();
  var P3;
  var j3 = 0;
  var pe3 = /TRIX-EDITOR/i;
  function Y3(l5) {
    return l5.nodeType === Node.ELEMENT_NODE;
  }
  function be3(l5) {
    return Y3(l5) ? l5.hasAttribute(R3.turboPermanentAttribute) && l5.getAttribute(R3.turboPermanentAttribute) !== "false" : false;
  }
  function ve3(l5) {
    return Y3(l5) ? l5 === document.activeElement : false;
  }
  function ge3(l5) {
    return !(be3(l5) || ve3(l5) && l5.tagName.match(pe3));
  }
  var X3 = { callbacks: { beforeNodeMorphed: (l5, o3) => ge3(l5) }, morphStyle: "outerHTML", ignoreActiveValue: true, head: { style: "merge" } };
  function Ee3(l5, o3, u5 = {}) {
    let c4 = y3(y3({}, X3.callbacks), u5.callbacks);
    return u5 = O3(y3(y3({}, X3), u5), { callbacks: c4 }), new Promise((d5) => {
      setTimeout(() => {
        J2.morph(l5, o3, u5), d5();
      }, j3);
    });
  }
  P3 = Ee3;
  var L3 = { get delay() {
    return j3;
  }, set delay(l5) {
    j3 = l5;
  }, get method() {
    return P3;
  }, set method(l5) {
    P3 = l5;
  } };
  var M2 = { before: "turbo-boost:stream:before-invoke", after: "turbo-boost:stream:after-invoke", finish: "turbo-boost:stream:finish-invoke" };
  function B2(l5, o3, u5) {
    let { object: c4, target: d5 } = l5;
    o3 = o3 || {}, o3 = O3(y3({}, o3), { object: l5.object });
    let f4 = { detail: o3, bubbles: true };
    d5.dispatchEvent(new CustomEvent(M2.before, f4));
    let { delay: b5 } = o3.invoke || {};
    b5 = b5 || 0;
    let h4 = () => {
      let g4 = u5(c4);
      f4.detail.result = g4, d5.dispatchEvent(new CustomEvent(M2.after, f4));
      let v4;
      g4 instanceof Animation && (v4 = g4.finished), g4 instanceof Promise && (v4 = g4), v4 ? v4.then(() => {
        f4.detail.promise = "fulfilled", d5.dispatchEvent(new CustomEvent(M2.finish, f4));
      }).catch((T5) => {
        f4.detail.promise = "rejected", f4.detail.error = T5, d5.dispatchEvent(new CustomEvent(M2.finish, f4));
      }) : d5.dispatchEvent(new CustomEvent(M2.finish, f4));
    };
    b5 > 0 ? setTimeout(h4, b5) : h4();
  }
  function Ae3(l5, o3, u5) {
    let c4 = o3[0], d5 = o3[1], f4 = { method: l5, eventName: c4, eventOptions: d5 };
    u5.forEach((b5) => B2(b5, f4, (h4) => h4.dispatchEvent(new CustomEvent(c4, d5))));
  }
  function ye3(l5, o3, u5) {
    let c4 = o3[0], d5 = { method: l5, html: c4 };
    u5.forEach((f4) => B2(f4, d5, (b5) => L3.method(b5, c4)));
  }
  function Se3(l5, o3, u5) {
    let c4 = l5.slice(0, -1).trim(), d5 = o3[0], f4 = { method: l5, property: c4, value: d5 };
    u5.forEach((b5) => B2(b5, f4, (h4) => h4[c4] = d5));
  }
  function ke3(l5, o3, u5) {
    let c4 = { method: l5, args: o3 };
    u5.forEach((d5) => B2(d5, c4, (f4) => f4[l5].apply(f4, o3)));
  }
  function G3(l5, o3, u5) {
    return l5.match(/^dispatch(Event)?$/) ? Ae3(l5, o3, u5) : l5.match(/^morph|mutate$/) ? ye3(l5, o3, u5) : l5.endsWith("=") ? Se3(l5, o3, u5) : ke3(l5, o3, u5);
  }
  function D3() {
    let l5 = JSON.parse(this.templateContent.textContent), { id: o3, selector: u5, receiver: c4, method: d5, args: f4, delay: b5 } = l5, h4 = [{ object: self, target: self }];
    u5 && (h4 = Array.from(document.querySelectorAll(u5)).map((g4) => ({ object: g4, target: g4 }))), c4 && (h4 = h4.map((g4) => {
      let { object: v4, target: T5 } = g4, I4 = c4.split(".");
      for (; I4.length > 0; ) v4 = v4[I4.shift()], v4.dispatchEvent && (T5 = v4);
      return { object: v4, target: T5 };
    })), b5 > 0 ? setTimeout(() => G3(d5, f4, h4), b5) : G3(d5, f4, h4);
  }
  if (!self.Turbo) throw new Error("`Turbo` is not defined! Be sure to import `@turbo-boost/streams` after `@hotwired/turbo` or `@hotwired/turbo-rails`.");
  if (!Turbo.StreamActions) throw new Error("`Turbo.StreamActions` is not defined! Verify that you are running >= `7.2.0` of `@hotwired/turbo`.");
  Turbo.StreamActions.invoke = D3;
  self.TurboBoost = self.TurboBoost || {};
  self.TurboBoost.Streams = { invoke: D3, invokeEvents: M2, morph: L3, schema: R3, VERSION: z2 };
  console.info("@turbo-boost/streams has initialized and registered new stream actions with Turbo.");
  var Ne3 = self.TurboBoost.Streams;

  // node_modules/@turbo-boost/commands/app/assets/builds/@turbo-boost/commands.js
  init_define_process();
  init_jquery();
  var mt2 = Object.defineProperty;
  var lt2 = Object.defineProperties;
  var ft2 = Object.getOwnPropertyDescriptors;
  var X4 = Object.getOwnPropertySymbols;
  var pt2 = Object.prototype.hasOwnProperty;
  var bt2 = Object.prototype.propertyIsEnumerable;
  var K2 = (t4, e2, r3) => e2 in t4 ? mt2(t4, e2, { enumerable: true, configurable: true, writable: true, value: r3 }) : t4[e2] = r3;
  var s3 = (t4, e2) => {
    for (var r3 in e2 || (e2 = {})) pt2.call(e2, r3) && K2(t4, r3, e2[r3]);
    if (X4) for (var r3 of X4(e2)) bt2.call(e2, r3) && K2(t4, r3, e2[r3]);
    return t4;
  };
  var p2 = (t4, e2) => lt2(t4, ft2(e2));
  var gt2 = "TurboBoost-Command";
  var y4 = { boost: "text/vnd.turbo-boost.html", stream: "text/vnd.turbo-stream.html", html: "text/html", xhtml: "application/xhtml+xml", json: "application/json" };
  var ht2 = (t4 = {}) => {
    t4 = s3({}, t4);
    let e2 = (t4.Accept || "").split(",").map((r3) => r3.trim()).filter((r3) => r3.length);
    return e2.unshift(y4.boost, y4.stream, y4.html, y4.xhtml), t4.Accept = [...new Set(e2)].join(", "), t4["Content-Type"] = y4.json, t4["X-Requested-With"] = "XMLHttpRequest", t4;
  };
  var vt2 = (t4) => {
    if (t4) {
      let [e2, r3, o3] = t4.split(", ");
      return { name: e2, status: r3, strategy: o3 };
    }
    return {};
  };
  var f2 = { prepare: ht2, tokenize: vt2, RESPONSE_HEADER: gt2 };
  var yt2 = (t4) => {
    document.body.insertAdjacentHTML("beforeend", t4);
  };
  var Et2 = (t4) => {
    var h4, k4, v4, C4;
    let r3 = new DOMParser().parseFromString(t4, "text/html"), o3 = document.querySelector("head"), n3 = document.querySelector("body"), i3 = r3.querySelector("head"), c4 = r3.querySelector("body");
    o3 && i3 && ((k4 = (h4 = TurboBoost == null ? void 0 : TurboBoost.Streams) == null ? void 0 : h4.morph) == null || k4.method(o3, i3)), n3 && c4 && ((C4 = (v4 = TurboBoost == null ? void 0 : TurboBoost.Streams) == null ? void 0 : v4.morph) == null || C4.method(n3, c4));
  };
  var w3 = (t4, e2) => {
    if (t4 && e2) {
      if (t4.match(/^Append$/i)) return yt2(e2);
      if (t4.match(/^Replace$/i)) return Et2(e2);
    }
  };
  var B3 = {};
  addEventListener("turbo:before-fetch-response", (t4) => {
    let e2 = t4.target.closest("turbo-frame");
    e2 != null && e2.id && (e2 != null && e2.src) && (B3[e2.id] = e2.src);
    let { fetchResponse: r3 } = t4.detail, o3 = r3.header(f2.RESPONSE_HEADER);
    if (!o3) return;
    t4.preventDefault();
    let { strategy: n3 } = f2.tokenize(o3);
    r3.responseHTML.then((i3) => w3(n3, i3));
  });
  addEventListener("turbo:frame-load", (t4) => {
    let e2 = t4.target.closest("turbo-frame");
    e2.dataset.src = B3[e2.id] || e2.src || e2.dataset.src, delete B3[e2.id];
  });
  var At2 = { frameAttribute: "data-turbo-frame", methodAttribute: "data-turbo-method", commandAttribute: "data-turbo-command", confirmAttribute: "data-turbo-confirm", stateAttributesAttribute: "data-turbo-boost-state-attributes" };
  var d3 = s3({}, At2);
  var a3 = { start: "turbo-boost:command:start", success: "turbo-boost:command:success", finish: "turbo-boost:command:finish", abort: "turbo-boost:command:abort", clientError: "turbo-boost:command:client-error", serverError: "turbo-boost:command:server-error" };
  var E3 = { stateChange: "turbo-boost:state:change", stateInitialize: "turbo-boost:state:initialize" };
  function u3(t4, e2, r3 = {}) {
    return new Promise((o3) => {
      r3 = r3 || {}, r3.detail = r3.detail || {}, e2 = e2 || document;
      let n3 = new CustomEvent(t4, p2(s3({}, r3), { bubbles: true }));
      e2.dispatchEvent(n3), o3(n3);
    });
  }
  var L4 = {};
  function St3(t4) {
    L4[t4.id] = t4;
  }
  function xt2(t4) {
    delete L4[t4];
  }
  var O4 = { add: St3, remove: xt2, get commands() {
    return [...Object.values(L4)];
  }, get length() {
    return Object.keys(L4).length;
  } };
  var G4 = { method: (t4) => Promise.resolve(confirm(t4)) };
  var kt2 = (t4) => t4.detail.driver === "method";
  var Ct2 = (t4) => {
    if (t4.detail.driver !== "form") return false;
    let e2 = t4.target, r3 = e2.closest("turbo-frame"), o3 = e2.closest(`[${d3.frameAttribute}]`);
    return !!(r3 || o3);
  };
  var wt2 = (t4) => kt2(t4) || Ct2(t4);
  document.addEventListener(a3.start, async (t4) => {
    let e2 = t4.target.getAttribute(d3.confirmAttribute);
    if (!e2 || (t4.detail.confirmation = true, wt2(t4))) return;
    await G4.method(e2) || t4.preventDefault();
  });
  var Q3 = G4;
  var l3 = [];
  var I2;
  function Lt2(t4, e2) {
    let r3 = l3.find((o3) => o3.name === t4);
    return r3 && l3.splice(l3.indexOf(r3), 1), l3 = [{ name: t4, selectors: e2 }, ...l3], document.removeEventListener(t4, I2, true), document.addEventListener(t4, I2, true), s3({}, l3.find((o3) => o3.name === t4));
  }
  function Ot2(t4) {
    return l3.find((e2) => e2.selectors.find((r3) => Array.from(document.querySelectorAll(r3)).find((o3) => o3 === t4)));
  }
  function Tt2(t4, e2) {
    let r3 = Ot2(e2);
    return r3 && r3.name === t4;
  }
  var m3 = { register: Lt2, isRegisteredForElement: Tt2, get events() {
    return [...l3];
  }, set handler(t4) {
    I2 = t4;
  } };
  function Rt2(t4) {
    return t4.closest(`[${d3.commandAttribute}]`);
  }
  function Pt2(t4) {
    return t4.closest("turbo-frame[src]") || t4.closest("turbo-frame[data-turbo-frame-src]") || t4.closest("turbo-frame");
  }
  function $t2(t4, e2 = {}) {
    if (t4.tagName.toLowerCase() !== "select") return e2.value = t4.value || null;
    if (!t4.multiple) return e2.value = t4.options[t4.selectedIndex].value;
    e2.values = Array.from(t4.options).reduce((r3, o3) => (o3.selected && r3.push(o3.value), r3), []);
  }
  function _t2(t4) {
    let e2 = Array.from(t4.attributes).reduce((r3, o3) => {
      let n3 = o3.value;
      return r3[o3.name] = n3, r3;
    }, {});
    return e2.tag = t4.tagName, e2.checked = !!t4.checked, e2.disabled = !!t4.disabled, $t2(t4, e2), delete e2.class, delete e2.action, delete e2.href, delete e2[d3.commandAttribute], delete e2[d3.frameAttribute], e2;
  }
  var A2 = { buildAttributePayload: _t2, findClosestCommand: Rt2, findClosestFrameWithSource: Pt2 };
  var Dt2 = (t4, e2 = {}) => {
    let r3 = t4.querySelector('input[name="turbo_boost_command"]') || document.createElement("input");
    r3.type = "hidden", r3.name = "turbo_boost_command", r3.value = JSON.stringify(e2), t4.contains(r3) || t4.appendChild(r3);
  };
  var Y4 = { invokeCommand: Dt2 };
  function Nt2(t4) {
    setTimeout(() => u3(a3.finish, t4.target, { detail: t4.detail }));
  }
  var Bt2 = [a3.abort, a3.serverError, a3.success];
  Bt2.forEach((t4) => addEventListener(t4, Nt2));
  addEventListener(a3.finish, (t4) => O4.remove(t4.detail.id), true);
  var Z3 = { events: a3 };
  var It2 = (t4) => {
    let e2 = document.createElement("a");
    return e2.href = t4, new URL(e2);
  };
  var tt2 = { get commandInvocationURL() {
    return It2("/turbo-boost-command-invocation");
  } };
  var et2 = (t4) => {
    let e2 = `Unexpected error performing a TurboBoost Command! ${t4.message}`;
    u3(Z3.events.clientError, document, { detail: { message: e2, error: t4 } }, true);
  };
  var jt2 = (t4) => {
    let { strategy: e2 } = f2.tokenize(t4.headers.get(f2.RESPONSE_HEADER));
    t4.text().then((r3) => w3(e2, r3));
  };
  var T3 = (t4 = {}) => {
    try {
      fetch(tt2.commandInvocationURL.href, { method: "POST", headers: f2.prepare({}), body: JSON.stringify(t4) }).then(jt2).catch(et2);
    } catch (e2) {
      et2(e2);
    }
  };
  var qt2 = (t4, e2) => T3(e2);
  var j4 = { invokeCommand: qt2 };
  var S3;
  var q2;
  var zt2 = () => {
    S3 = null, q2 = null;
  };
  var Ft2 = (t4, e2 = {}) => {
    S3 = t4, q2 = e2;
  };
  var Ht2 = (t4) => {
    try {
      if (!S3 || t4.getAttribute("method") !== S3.dataset.turboMethod || t4.getAttribute("action") !== S3.href) return;
      let e2 = t4.querySelector('input[name="turbo_boost_command"]') || document.createElement("input");
      e2.type = "hidden", e2.name = "turbo_boost_command", e2.value = JSON.stringify(q2), t4.contains(e2) || t4.appendChild(e2);
    } finally {
      zt2();
    }
  };
  document.addEventListener("submit", (t4) => Ht2(t4.target), true);
  var rt2 = { invokeCommand: Ft2 };
  var Jt2 = (t4, e2 = {}) => T3(e2);
  var ot2 = { invokeCommand: Jt2 };
  function z3(t4, e2) {
    return e2 = e2 || { dataset: {} }, t4.href || e2.src || e2.dataset.src || location.href;
  }
  function Mt2(t4) {
    let e2 = A2.findClosestFrameWithSource(t4), { turboFrame: r3, turboMethod: o3 } = t4.dataset;
    return t4.tagName.toLowerCase() === "form" ? { name: "form", reason: "Element is a form.", frame: e2, src: t4.action, invokeCommand: Y4.invokeCommand } : o3 != null && o3.length ? { name: "method", reason: "Element defines data-turbo-method.", frame: e2, src: t4.href, invokeCommand: rt2.invokeCommand } : r3 && r3 !== "_self" ? (e2 = document.getElementById(r3), { name: "frame", reason: "element targets a frame that is not _self", frame: e2, src: z3(t4, e2), invokeCommand: j4.invokeCommand }) : (!r3 || r3 === "_self") && e2 ? { name: "frame", reason: "element does NOT target a frame or targets _self and is contained by a frame", frame: e2, src: z3(t4, e2), invokeCommand: j4.invokeCommand } : { name: "window", reason: "element matches one or more of the following conditions (targets _top, does NOT target a frame, is NOT contained by a frame)", frame: null, src: z3(t4), invokeCommand: ot2.invokeCommand };
  }
  var F3 = { find: Mt2 };
  var P4 = "unknown";
  var nt2 = false;
  var R4 = [];
  var b3 = { debug: Object.values(a3), info: Object.values(a3), warn: [a3.abort, a3.clientError, a3.serverError], error: [a3.clientError, a3.serverError], unknown: [] };
  var Ut2 = (t4) => {
    if (!b3[P4].includes(t4.type) || typeof console[P4] != "function") return false;
    let { detail: e2 } = t4;
    if (!e2.id) return true;
    let r3 = `${t4.type}-${e2.id}`;
    return R4.includes(r3) ? false : (R4.length > 16 && R4.shift(), R4.push(r3), true);
  };
  var Vt2 = (t4) => b3.error.includes(t4.type) ? "error" : b3.warn.includes(t4.type) ? "warn" : b3.info.includes(t4.type) ? "info" : b3.debug.includes(t4.type) ? "debug" : "log";
  var Wt2 = (t4) => {
    if (Ut2(t4)) {
      let { target: e2, type: r3, detail: o3 } = t4, n3 = o3.id || "", i3 = o3.name || "", c4 = "";
      o3.startedAt && (c4 = `${Date.now() - o3.startedAt}ms `);
      let h4 = r3.split(":"), k4 = h4.pop(), v4 = `%c${h4.join(":")}:%c${k4}`, C4 = [`%c${i3}`, `%c${c4}`, v4];
      console[Vt2(t4)](C4.join(" ").replace(/\s{2,}/g, " "), "color:deepskyblue", "color:lime", "color:darkgray", v4.match(/abort|error/i) ? "color:red" : "color:deepskyblue", { id: n3, detail: o3, target: e2 });
    }
  };
  nt2 || (nt2 = true, Object.values(a3).forEach((t4) => addEventListener(t4, (e2) => Wt2(e2))));
  var at2 = { get level() {
    return P4;
  }, set level(t4) {
    return Object.keys(b3).includes(t4) || (t4 = "unknown"), P4 = t4;
  } };
  var H3;
  function $5(t4, e2 = null) {
    if (!t4 || typeof t4 != "object") return t4;
    let r3 = new Proxy(t4, { deleteProperty(o3, n3) {
      return delete o3[n3], u3(E3.stateChange, document, { detail: { state: H3 } }), true;
    }, set(o3, n3, i3, c4) {
      return o3[n3] = $5(i3, this), u3(E3.stateChange, document, { detail: { state: H3 } }), true;
    } });
    if (Array.isArray(t4)) t4.forEach((o3, n3) => t4[n3] = $5(o3, r3));
    else if (typeof t4 == "object") for (let [o3, n3] of Object.entries(t4)) t4[o3] = $5(n3, r3);
    return e2 || (H3 = r3), r3;
  }
  var J3 = $5;
  var st2 = (t4, e2, r3, o3 = 1) => {
    if (o3 > 20) return;
    let n3 = document.getElementById(t4);
    if (n3 != null && n3.isConnected) return n3.setAttribute(e2, r3);
    setTimeout(() => st2(t4, e2, r3, o3 + 1), o3 * 5);
  };
  var Xt2 = () => Array.from(document.querySelectorAll(`[id][${d3.stateAttributesAttribute}]`)).reduce((e2, r3) => {
    let o3 = JSON.parse(r3.getAttribute(d3.stateAttributesAttribute));
    if (r3.id) {
      let n3 = o3.reduce((i3, c4) => (r3.hasAttribute(c4) && (i3[c4] = r3.getAttribute(c4) || c4), i3), {});
      Object.values(n3).length && (e2[r3.id] = n3);
    }
    return e2;
  }, {});
  var Kt2 = (t4 = {}) => {
    for (let [e2, r3] of Object.entries(t4)) for (let [o3, n3] of Object.entries(r3)) st2(e2, o3, n3);
  };
  var _24 = { buildState: Xt2, restoreState: Kt2 };
  function Gt2(t4, e2) {
    return typeof e2 != "object" && (e2 = {}), localStorage.setItem(String(t4), JSON.stringify(e2));
  }
  function Qt2(t4) {
    let e2 = localStorage.getItem(String(t4));
    return e2 ? JSON.parse(e2) : {};
  }
  var D4 = { save: Gt2, find: Qt2 };
  var M3 = "TurboBoost::State";
  var U3 = { pages: {}, signed: null, unsigned: {} };
  var N3 = null;
  var x2 = {};
  var V3 = () => {
    let t4 = s3(s3({}, U3), D4.find(M3));
    N3 = t4.signed, x2 = J3(t4.unsigned), t4.pages[location.pathname] = t4.pages[location.pathname] || {}, _24.restoreState(t4.pages[location.pathname]);
  };
  var W3 = () => {
    let t4 = s3(s3({}, U3), D4.find(M3)), e2 = { signed: N3 || t4.signed, unsigned: s3(s3({}, t4.unsigned), x2), pages: s3({}, t4.pages) }, r3 = location.pathname, o3 = _24.buildState();
    Object.values(o3).length ? e2.pages[r3] = o3 : delete e2.pages[r3], D4.save(M3, e2);
  };
  var Yt2 = (t4) => {
    let e2 = s3(s3({}, U3), JSON.parse(t4));
    N3 = e2.signed, x2 = J3(e2.unsigned), W3(), u3(E3.stateInitialize, document, { detail: x2 });
  };
  addEventListener("DOMContentLoaded", V3);
  addEventListener("turbo:morph", V3);
  addEventListener("turbo:render", V3);
  addEventListener("turbo:before-fetch-request", W3);
  addEventListener("beforeunload", W3);
  var g3 = { initialize: Yt2, buildPageState: _24.buildState, get signed() {
    return N3;
  }, get unsigned() {
    return x2;
  } };
  function Zt2() {
    return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (t4) => (t4 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t4 / 4).toString(16));
  }
  var it2 = { v4: Zt2 };
  var dt2 = "0.3.2";
  var te3 = self.TurboBoost || {};
  var ut2 = { VERSION: dt2, active: false, confirmation: Q3, logger: at2, schema: d3, events: a3, registerEventDelegate: m3.register, get eventDelegates() {
    return m3.events;
  } };
  function ct2(t4, e2) {
    var r3;
    return { csrfToken: (r3 = document.querySelector('meta[name="csrf-token"]')) == null ? void 0 : r3.getAttribute("content"), id: t4, name: e2.getAttribute(d3.commandAttribute), elementId: e2.id.length ? e2.id : null, elementAttributes: A2.buildAttributePayload(e2), startedAt: Date.now(), state: { page: g3.buildPageState(), signed: g3.signed, unsigned: g3.unsigned } };
  }
  async function ee3(t4) {
    let e2, r3 = {};
    try {
      if (e2 = A2.findClosestCommand(t4.target), !e2 || !m3.isRegisteredForElement(t4.type, e2)) return;
      let o3 = it2.v4(), n3 = F3.find(e2), i3 = p2(s3({}, ct2(o3, e2)), { driver: n3.name, frameId: n3.frame ? n3.frame.id : null, src: n3.src }), c4 = await u3(a3.start, e2, { cancelable: true, detail: i3 });
      if (c4.defaultPrevented || c4.detail.confirmation && t4.defaultPrevented) return u3(a3.abort, e2, { detail: { message: `An event handler for '${a3.start}' prevented default behavior and blocked command invocation!`, source: c4 } });
      switch (n3 = F3.find(e2), i3 = p2(s3({}, ct2(o3, e2)), { driver: n3.name, frameId: n3.frame ? n3.frame.id : null, src: n3.src }), O4.add(i3), ["frame", "window"].includes(n3.name) && t4.preventDefault(), n3.name) {
        case "method":
          return n3.invokeCommand(e2, i3);
        case "form":
          return n3.invokeCommand(e2, i3, t4);
        case "frame":
          return n3.invokeCommand(n3.frame, i3);
        case "window":
          return n3.invokeCommand(self, i3);
      }
    } catch (o3) {
      u3(a3.clientError, e2, { detail: p2(s3({}, r3), { error: o3 }) });
    }
  }
  self.TurboBoost = s3({}, te3);
  self.TurboBoost.Commands || (m3.handler = ee3, m3.register("click", [`[${d3.commandAttribute}]`]), m3.register("submit", [`form[${d3.commandAttribute}]`]), m3.register("toggle", [`details[${d3.commandAttribute}]`]), m3.register("change", [`input[${d3.commandAttribute}]`, `select[${d3.commandAttribute}]`, `textarea[${d3.commandAttribute}]`]), self.TurboBoost.Commands = ut2, self.TurboBoost.State = { initialize: g3.initialize, get current() {
    return g3.unsigned;
  } });

  // node_modules/@turbo-boost/elements/app/assets/builds/@turbo-boost/elements.js
  init_define_process();
  init_jquery();
  var K3 = Object.defineProperty;
  var U4 = Object.defineProperties;
  var X5 = Object.getOwnPropertyDescriptors;
  var O5 = Object.getOwnPropertySymbols;
  var Y5 = Object.prototype.hasOwnProperty;
  var Q4 = Object.prototype.propertyIsEnumerable;
  var H4 = (t4, e2, o3) => e2 in t4 ? K3(t4, e2, { enumerable: true, configurable: true, writable: true, value: o3 }) : t4[e2] = o3;
  var c3 = (t4, e2) => {
    for (var o3 in e2 || (e2 = {})) Y5.call(e2, o3) && H4(t4, o3, e2[o3]);
    if (O5) for (var o3 of O5(e2)) Q4.call(e2, o3) && H4(t4, o3, e2[o3]);
    return t4;
  };
  var h3 = (t4, e2) => U4(t4, X5(e2));
  var Z4 = "0.0.6";
  function ee4(t4) {
    let e2 = document.createElement("template");
    return e2.innerHTML = t4, e2;
  }
  function $6(t4, e2) {
    e2 = e2 || document.body;
    let o3 = ee4(t4).content.cloneNode(true).querySelector("*");
    return e2.appendChild(o3);
  }
  function w4(t4, e2 = {}) {
    if (!t4) return;
    L5(t4);
    let { outline: o3, outlineOffset: r3 } = e2;
    o3 = o3 || "dashed 3px red", r3 = r3 || "0px", t4.originalStyles = t4.originalStyles || { display: t4.style.display, minHeight: t4.style.minHeight, minWidth: t4.style.minWidth, outline: t4.style.outline, outlineOffset: t4.style.outlineOffset }, getComputedStyle(t4).display.match(/^inline$/i) && t4.offsetWidth === 0 && t4.offsetHeight === 0 && (t4.style.display = "inline-block", t4.style.minHeight = "2px", t4.style.minWidth = "2px"), t4.style.outline = o3, t4.style.outlineOffset = r3, t4.dataset.turboBoostHighlight = true;
  }
  function L5(t4) {
    if (t4) {
      if (t4.originalStyles) {
        for (let [e2, o3] of Object.entries(t4.originalStyles)) o3 ? t4.style[e2] = o3 : t4.style[e2] = "";
        delete t4.originalStyles;
      }
      delete t4.dataset.turboBoostHighlight;
    }
  }
  function k3(t4) {
    if (!t4) return {};
    let e2 = t4.getBoundingClientRect(), o3 = t4.offsetWidth, r3 = t4.offsetHeight, s4 = e2.top + window.scrollY, i3 = e2.left + window.scrollX, n3 = i3 + o3, g4 = s4 + r3;
    return { top: s4, left: i3, right: n3, bottom: g4, width: o3, height: r3 };
  }
  function b4(t4) {
    try {
      t4();
    } catch (e2) {
    }
  }
  var te4 = class extends HTMLElement {
    constructor() {
      super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = this.html, this.labelElement.addEventListener("click", (t4) => {
        t4.preventDefault(), this.toggle();
      }), this.checkboxElement.addEventListener("change", (t4) => this.dispatchEvent(new CustomEvent("change", { bubbles: true })));
    }
    toggle() {
      this.checked ? this.uncheck() : this.check();
    }
    check() {
      this.checkboxElement.checked = true, this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    }
    uncheck() {
      this.checkboxElement.checked = false, this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    }
    get name() {
      return this.getAttribute("name");
    }
    get checked() {
      return this.checkboxElement.checked;
    }
    get checkboxElement() {
      return this.shadowRoot.querySelector("input");
    }
    get labelElement() {
      return this.shadowRoot.querySelector("label");
    }
    get html() {
      return `
      <style>${this.stylesheet}</style>
      <div>
        <input name="checkbox" type="checkbox">
        <label for="checkbox"><slot name="label"></slot></label>
      </div>
    `;
    }
    get stylesheet() {
      return `
      :host, :host * {
        cursor: pointer;
      }

      div {
        display: flex;
        margin-right: 10px;
      }

      input:checked + label{
        font-weight: bold;
      }

      label {
        color: black;
      }
    `;
    }
  };
  var oe3 = class extends HTMLElement {
    constructor() {
      super(), this.enabledDevtools = {}, this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = this.html, this.shadowRoot.querySelector("button").addEventListener("click", () => this.dispatchEvent(new CustomEvent("turbo-boost:devtools-close", { bubbles: true }))), this.addEventListener("change", (t4) => {
        let e2 = t4.target, { checked: o3, name: r3 } = e2;
        o3 ? this.enableDevtool(r3) : this.disableDevtool(r3);
      });
    }
    enableDevtool(t4) {
      this.enabledDevtools[t4] || (this.enabledDevtools[t4] = true, this.dispatchEvent(new CustomEvent("turbo-boost:devtool-enable", { bubbles: true, detail: { name: t4 } })));
    }
    disableDevtool(t4) {
      this.enabledDevtools[t4] && (delete this.enabledDevtools[t4], this.dispatchEvent(new CustomEvent("turbo-boost:devtool-disable", { bubbles: true, detail: { name: t4 } })));
    }
    close() {
      this.devtoolElements.forEach((t4) => {
        t4.checked && t4.uncheck();
      }), this.remove();
    }
    get devtoolElements() {
      return this.querySelectorAll('[slot="devtool"]');
    }
    get closeElement() {
      return this.querySelector("button");
    }
    get html() {
      return `
      <style>${this.stylesheet}</style>
      <div>
        <img src="https://ik.imagekit.io/hopsoft/turbo-boost-logo_zHiiimlvT.webp?ik-sdk-version=javascript-1.4.3&updatedAt=1671722004342">
        <slot name="devtool"></slot>
        <button>\u2715</button>
      </div>
    `;
    }
    get stylesheet() {
      return `
      :host {
        background-color: gainsboro;
        border-radius: 5px;
        bottom: 20px;
        display: block;
        filter: drop-shadow(3px 3px 3px rgba(0,0,0,0.3));
        left: 50%;
        outline-offset: 1px;
        outline: solid 2px black;
        padding: 5px 10px;
        position: fixed;
        transform: translateX(-50%);
        z-index: 8999;
      }

      * {
        -webkit-user-select: none;
        font-family: helvetica, sans-serif;
        font-size: 1rem;
        user-select: none;
      }

      img {
        align-self: center;
        cursor: grab;
        height: 25px;
        margin-left: -5px;
        vertical-align: middle;
      }

      div {
        display: flex;
        gap: 0 5px;
        position: relative;
      }

      [slot="devtool"] {
        align-self: center;
      }

      button {
        align-self: center;
        background-color: darkgray;
        border-radius: 50%;
        border: none;
        color: black;
        cursor: pointer;
        font-size: 10px;
        height: 18px;
        line-height: 18px;
        margin-right: -5px;
        opacity: 0.5;
        outline: solid 1px black;
        padding: 0 2px;
        width: 18px;
      }

      button:hover {
        opacity: 1;
      }
    `;
    }
  };
  var re3 = class extends HTMLElement {
    constructor() {
      super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = this.html;
    }
    connectedCallback() {
      let t4 = localStorage.getItem(`turbo-boost-devtools-${location.href}-${this.id}-transform`);
      t4 && (this.style.transform = t4);
    }
    disconnectedCallback() {
      this.id !== "undefined" && this.id !== "" && localStorage.setItem(`turbo-boost-devtools-${location.href}-${this.id}-transform`, this.style.transform);
    }
    get color() {
      return this.getAttribute("color") || "darkslategray";
    }
    get backgroundColor() {
      return this.getAttribute("background-color") || "gainsboro";
    }
    get position() {
      return this.getAttribute("position") || "top";
    }
    get html() {
      return `
      <style>${this.stylesheet}</style>
      <div role="container">
        <div role="title">
          <slot name="title"></slot>
          <img src="https://ik.imagekit.io/hopsoft/turbo-boost-logo_zHiiimlvT.webp?ik-sdk-version=javascript-1.4.3&updatedAt=1671722004342">
        </div>
        <slot name="subtitle"></slot>
        <slot name="content-top"></slot>
        <slot name="content"></slot>
        <slot name="content-bottom"></slot>
      </div>
    `;
    }
    get stylesheet() {
      return `
      :host {
        display: block;
        position: absolute;
        z-index: 8999;
      }

      * {
        color: ${this.color}
        font-size: 1rem;
      }

      [role="container"] {
        background-color: ${this.backgroundColor};
        border-radius: 15px;
        filter: drop-shadow(3px 3px 3px rgba(0,0,0,0.3));
        font-family: monospace;
        min-height: 30px;
        min-width: 100px;
        opacity: 0.9;
        outline-offset: 1px;
        outline: dashed 3px ${this.color};
        padding: 12px;
        position: relative;
        white-space: nowrap;
      }

      [role="title"] {
        display: flex;
      }

      [role="title"] slot[name="title"] {
        color: ${this.color};
        display: block;
        flex-grow: 1;
        font-weight: bold;
      }

      [role="title"] img {
        height: 25px;
        vertical-align: middle;
      }

      slot[name="subtitle"] {
        border-bottom: dotted 1px ${this.color};
        border-top: dotted 1px ${this.color};
        color: ${this.color};
        display: block;
        font-size: 0.8rem;
        font-weight: lighter;
        margin-bottom: 12px;
        margin-top: 8px;
        padding-bottom: 4px;
        padding-top: 4px;
        width: 100%;
      }

      slot[name="content-top"],
      slot[name="content"],
      slot[name="content-bottom"] {
        display: block;
        font-weight: normal;
      }

      slot[name="content-top"] {
        color: ${this.color};
        margin-bottom: 8px;
      }

      slot[name="content"],
      slot[name="content-bottom"] {
        opacity: 0.7;
        padding-left: 12px;
      }

      slot[name="content"] {
        color: ${this.color};
      }

      slot[name="content-bottom"] {
        color: red;
      }
    `;
    }
  };
  var u4 = [];
  var ie3 = { LeaderLine: { src: "https://cdnjs.cloudflare.com/ajax/libs/leader-line/1.0.7/leader-line.min.js", integrity: "sha512-0dNdzMjpT6pJdFGF1DwybFCfm3K/lzHhxaMXC/92J9/DZujHlqYFqmhTOAoD0o+LkeEsVK2ar/ESs7/Q2B6wJg==", global: "LeaderLine" }, PlainDraggable: { src: "https://cdn.jsdelivr.net/npm/plain-draggable@2.5.14/plain-draggable.min.js", global: "PlainDraggable" } };
  function se3(t4) {
    return t4.global && self[t4.global] || document.querySelector(`[src='${t4.src}']`) ? true : u4.includes(t4);
  }
  function le3(t4) {
    if (se3(t4)) return;
    u4.push(t4);
    let { src: e2, integrity: o3 } = t4, r3 = document.createElement("script");
    r3.setAttribute("src", e2), r3.setAttribute("crossorigin", "anonymous"), r3.setAttribute("referrerpolicy", "no-referrer"), o3 && r3.setAttribute("integrity", o3), document.head.appendChild(r3);
  }
  function M4(t4) {
    if (!u4.includes(t4)) return;
    u4.splice(u4.indexOf(t4), 1);
    let { src: e2 } = t4, o3 = document.querySelector(`script[src='${e2}']`);
    o3 && o3.remove(), t4.global && self[t4.global] && (self[t4.global] = null);
  }
  function ne3() {
    [...u4].forEach((t4) => M4(t4));
  }
  var p3 = h3(c3({}, ie3), { add: le3, remove: M4, removeAll: ne3 });
  customElements.define("turbo-boost-devtool", te4);
  customElements.define("turbo-boost-devtool-supervisor", oe3);
  customElements.define("turbo-boost-devtool-tooltip", re3);
  var l4;
  function j5() {
    if (l4) try {
      new PlainDraggable(l4);
    } catch (t4) {
      setTimeout(j5, 200);
    }
  }
  function A3() {
    N4() || (l4.close(), l4.dispatchEvent(new CustomEvent("turbo-boost:devtools-stop", { bubbles: true })), l4 = null, p3.removeAll());
  }
  function I3() {
    y5() || (p3.add(p3.LeaderLine), p3.add(p3.PlainDraggable), l4 = $6("<turbo-boost-devtool-supervisor></turbo-boost-devtool-supervisor>"), setTimeout(j5, 200), l4.dispatchEvent(new CustomEvent("turbo-boost:devtools-start", { bubbles: true })));
  }
  function ae3() {
    let t4 = l4 ? Object.keys(l4.enabledDevtools) : [];
    A3(), I3(), l4.devtoolElements.forEach((e2) => {
      t4.includes(e2.name) && e2.check();
    });
  }
  function y5() {
    return !!l4;
  }
  function N4() {
    return !y5();
  }
  var R5;
  function q3() {
    clearTimeout(R5), R5 = setTimeout(ae3, 25);
  }
  function v3() {
    y5() && q3();
  }
  addEventListener("turbo:load", v3);
  addEventListener("turbo-frame:load", v3);
  addEventListener("turbo-boost:devtools-connect", v3);
  addEventListener("turbo-boost:devtools-close", A3);
  window.TurboBoost && (addEventListener(TurboBoost.Commands.events.success, v3), addEventListener(TurboBoost.Commands.events.finish, v3));
  function de4(t4, e2) {
    if (l4) return $6(`
      <turbo-boost-devtool name="${t4}" slot="devtool">
        <span slot="label">${e2}</span>
      </turbo-boost-devtool>
    `, l4);
  }
  function ce4(t4) {
    return l4 ? l4.enabledDevtools[t4] : false;
  }
  var S4 = { enabled: ce4, register: de4, start: I3, stop: A3, restart: q3, get started() {
    return y5();
  }, get stopped() {
    return N4();
  } };
  function x3(t4, e2, o3, r3 = {}) {
    let { backgroundColor: s4, color: i3, position: n3, id: g4 } = r3;
    return i3 = i3 || "white", n3 = n3 || "top", $6(`
    <turbo-boost-devtool-tooltip id="${g4}" position="${n3}" background-color="${s4}" color="${i3}">
      <div slot='title'>${t4}</div>
      <div slot='subtitle'>${e2}</div>
      ${o3}
    </turbo-boost-devtool-tooltip>
  `);
  }
  var T4;
  var D5 = class {
    constructor(t4) {
      this.delegate = t4;
      let e2, o3 = () => {
        clearTimeout(e2), e2 = setTimeout(this.hide({ active: false }), 25);
      };
      this.eventListeners["turbo-boost:devtool-enable"] = (r3) => {
        let { name: s4 } = r3.detail;
        s4 === this.delegate.name && (w4(this.delegate.triggerElement, { outline: "3px dashed blueviolet", outlineOffset: "2px" }), this.hide({ active: false }), this.active && this.show());
      }, this.eventListeners["turbo-boost:devtool-disable"] = (r3) => {
        let { name: s4 } = r3.detail;
        s4 === this.delegate.name && L5(this.delegate.triggerElement);
      }, this.eventListeners.click = (r3) => {
        r3.target.closest("turbo-boost-devtool-tooltip") || o3();
      }, this.eventListeners["turbo:load"] = o3, this.eventListeners["turbo-frame:load"] = o3, window.TurboBoost && (this.eventListeners[TurboBoost.Commands.events.finish] = o3), this.registerEventListeners();
    }
    registerEventListeners() {
      Object.entries(this.eventListeners).forEach(([t4, e2]) => {
        addEventListener(t4, e2);
      });
    }
    unregisterEventListeners() {
      Object.entries(this.eventListeners).forEach(([t4, e2]) => {
        removeEventListener(t4, e2);
      });
    }
    get eventListeners() {
      return this._eventListeners || (this._eventListeners = {});
    }
    show() {
      if (!this.enabled || this.active) return;
      this.active = true, this.hide({ active: true }), w4(this.delegate.targetElement, { outline: "3px dashed darkcyan", outlineOffset: "-2px" }), w4(this.delegate.morphElement, { outline: "3px dashed chocolate", outlineOffset: "3px" }), this.renderingTooltip = this.createRenderingTooltip(), this.targetTooltip = this.createTargetTooltip(), this.triggerTooltip = this.createTriggerTooltip(this.targetTooltip, this.renderingTooltip), document.querySelectorAll(".leader-line").forEach((e2) => e2.style.zIndex = 1e5);
      let t4 = { morph: { partial: this.delegate.triggerElement.renders, id: this.delegate.triggerElement.morphs, status: this.delegate.morphElement ? "OK" : "Not Found" }, trigger: { partial: null, id: null, status: "Not Found" }, target: { partial: null, id: null, status: "Not Found" } };
      this.delegate.triggerElement && (t4.trigger = { partial: this.delegate.triggerElement.partial, id: this.delegate.triggerElement.id, status: "OK" }, t4.target.id = this.delegate.triggerElement.controls), this.delegate.targetElement && (t4.target = { partial: this.delegate.targetElement.partial, dom_id: this.delegate.targetElement.id, status: "OK" }), console.table(t4);
    }
    hide({ active: t4 = false }) {
      document.querySelectorAll("turbo-boost-devtool-tooltip").forEach((e2) => {
        b4(() => e2.line.remove()), b4(() => e2.drag.remove()), b4(() => e2.lineToRendering.remove()), b4(() => e2.lineToTarget.remove()), b4(() => e2.remove());
      }), document.querySelectorAll("[data-turbo-boost-highlight]").forEach((e2) => {
        e2.tagName.match(/turbo-boost-toggle-trigger/i) || L5(e2);
      }), this.active = t4;
    }
    get active() {
      return T4 === this.delegate;
    }
    set active(t4) {
      t4 ? T4 = this.delegate : T4 = null;
    }
    get enabled() {
      return S4.enabled(this.delegate.name);
    }
    static register(t4, e2) {
      S4.register(t4, e2);
    }
    createRenderingTooltip() {
      if (!this.delegate.triggerElement.renders) return console.debug("Unable to create the rendering tooltip! The trigger element must set the 'renders' attribute.");
      if (!this.delegate.triggerElement.morphs) return console.debug(`Unable to create the rendering tooltip! The trigger element specified the 'morphs' attrbiute but no element matches the DOM id: '${this.triggerElement.morphs}'`);
      let t4 = `
      <svg xmlns="http://www.w3.org/2000/svg" style="display:inline-block;" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle></svg>
      RENDERING - &lt;${this.delegate.triggerElement.tagName.toLowerCase()}&gt;
    `, e2 = `
      <b>partial</b>: ${this.delegate.triggerElement.renders || "unknown"}<br>
      <b>morphs</b>: ${this.delegate.triggerElement.morphs || "unknown"}<br>
    `, o3 = x3(t4, e2, `
      <div slot="content-top" style="font-size:85%; font-style:italic; font-weight:100;">
        The <b>TRIGGER</b> toggles the <b>TARGET</b> then renders the partial &amp; morphs the element.<br>
      </div>
    `, { id: `${this.delegate.id}-rendering`, backgroundColor: "lightyellow", color: "chocolate" }), r3 = k3(this.delegate.morphElement), s4 = Math.ceil(r3.top + r3.height / 2 - o3.offsetHeight / 2), i3 = Math.ceil(r3.left + r3.width + 100);
      return o3.style.top = `${s4}px`, o3.style.left = `${i3}px`, o3.line = new LeaderLine(o3, this.delegate.morphElement, h3(c3({}, this.leaderLineOptions), { color: "chocolate" })), o3.drag = new PlainDraggable(o3), o3;
    }
    createTargetTooltip() {
      var t4, e2;
      if (!this.delegate.targetElement) return console.debug(`Unable to create the target tooltip! No element matches the DOM id: '${this.delegate.triggerElement.controls}'`);
      let o3 = `
      <svg xmlns="http://www.w3.org/2000/svg" style="display:inline-block;" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>
      TARGET - &lt;${this.delegate.targetElement.tagName.toLowerCase()}&gt;
    `, r3 = x3(o3, ((t4 = this.delegate.targetTooltipData) == null ? void 0 : t4.subtitle) || "", ((e2 = this.delegate.targetTooltipData) == null ? void 0 : e2.content) || "", { id: `${this.delegate.id}-target`, backgroundColor: "lightcyan", color: "darkcyan", position: "bottom" }), s4 = k3(this.delegate.targetElement), i3 = Math.ceil(s4.top + r3.offsetHeight), n3 = Math.ceil(s4.left + s4.width + r3.offsetWidth / 3);
      return r3.style.top = `${i3}px`, r3.style.left = `${n3}px`, r3.line = new LeaderLine(r3, this.delegate.targetElement, h3(c3({}, this.leaderLineOptions), { color: "darkcyan" })), r3.drag = new PlainDraggable(r3), r3;
    }
    createTriggerTooltip(t4, e2) {
      var o3, r3;
      if (!this.delegate.triggerElement) return;
      let s4 = `
      <svg xmlns="http://www.w3.org/2000/svg" style="display:inline;" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
      TRIGGER - &lt;${this.delegate.triggerElement.tagName.toLowerCase()}&gt;
    `, i3 = x3(s4, ((o3 = this.delegate.triggerTooltipData) == null ? void 0 : o3.subtitle) || "", ((r3 = this.delegate.triggerTooltipData) == null ? void 0 : r3.content) || "", { id: `${this.delegate.id}-trigger`, backgroundColor: "lavender", color: "blueviolet" }), n3 = k3(this.delegate.triggerElement), g4 = Math.ceil(n3.top - i3.offsetHeight * 2), J4 = Math.ceil(n3.left + n3.width + i3.offsetWidth / 3);
      return i3.style.top = `${g4}px`, i3.style.left = `${J4}px`, i3.line = new LeaderLine(this.delegate.triggerElement, i3, h3(c3({}, this.leaderLineOptions), { color: "blueviolet" })), t4 && (i3.lineToTarget = new LeaderLine(i3, t4, h3(c3({}, this.leaderLineOptions), { color: "blueviolet", middleLabel: this.delegate.targetLineLabel, size: 2.1 })), t4.drag.onMove = () => {
        var m4, B4;
        t4.line.position(), (m4 = i3.lineToTarget) == null || m4.position(), (B4 = i3.lineToRendering) == null || B4.position();
      }), e2 && (i3.lineToRendering = new LeaderLine(i3, e2, h3(c3({}, this.leaderLineOptions), { color: "blueviolet", middleLabel: this.delegate.renderingLineLabel, size: 2.1 })), e2.drag.onMove = () => {
        var m4;
        e2.line.position(), i3.lineToTarget && i3.lineToTarget.position(), (m4 = i3.lineToRendering) == null || m4.position();
      }), i3.drag = new PlainDraggable(i3), i3.drag.onMove = () => {
        i3.line.position(), i3.lineToTarget && i3.lineToTarget.position(), i3.lineToRendering && i3.lineToRendering.position();
      }, i3;
    }
    get leaderLineOptions() {
      return { dash: { animation: true }, dropShadow: { opacity: 0.3 }, endPlug: "arrow3", endPlugSize: 1.7, size: 3, startPlug: "disc", startPlugSize: 1 };
    }
  };
  var { restart: he4, start: ue4, stop: ge4 } = S4;
  function z4(t4, e2, o3) {
    Object.assign(t4, { initializeDevtool() {
      let r3 = () => this.devtool.show();
      addEventListener("turbo-boost:devtools-start", () => {
        this.devtool = new D5(this), this.addEventListener("mouseenter", r3);
      }), addEventListener("turbo-boost:devtools-stop", () => {
        this.removeEventListener("mouseenter", r3), this.removeDevtool();
      }), this.dispatchEvent(new CustomEvent("turbo-boost:devtools-connect", { bubbles: true }));
    }, hideDevtool() {
      var r3;
      (r3 = this.devtool) == null || r3.hide({ active: false });
    }, removeDevtool() {
      var r3, s4;
      (r3 = this.devtool) != null && r3.hide && this.devtool.hide({ active: false }), (s4 = this.devtool) != null && s4.unregisterEventListeners && this.devtool.unregisterEventListeners(), delete this.devtool;
    }, name: e2, targetLineLabel: o3 }), ["triggerElement", "morphElement", "targetElement"].filter((r3) => t4[r3] === void 0).forEach((r3) => {
      Object.defineProperty(t4, r3, { get() {
        return t4;
      } });
    });
  }
  var P5 = { restart: he4, start: ue4, stop: ge4, VERSION: Z4 };
  var V4 = "0.1.0";
  var a4 = class extends HTMLElement {
    constructor(e2) {
      super(), this.devtool = "unknown", this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = e2 || "<slot></slot>";
    }
    connectedCallback() {
      this.ensureId();
    }
    ensureId() {
      this.id.trim().length || (this.id = `${this.tagName}-${this.uuidv4()}`.toLowerCase());
    }
    uuidv4() {
      return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (e2) => (e2 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> e2 / 4).toString(16));
    }
    get viewStack() {
      let e2 = this.getAttribute("view-stack");
      return e2 ? JSON.parse(e2) : [];
    }
    get partial() {
      return this.viewStack[0];
    }
  };
  var me4 = `
  <turbo-boost>
    <slot name="busy" hidden></slot>
    <slot></slot>
  </turbo-boost>
`;
  var F4 = 100;
  var C3 = 400;
  var d4 = class extends a4 {
    constructor() {
      super(me4);
    }
    showBusyElement() {
      clearTimeout(this.showBusyElementTimeout), clearTimeout(this.hideBusyElementTimeout), this.busyElement && (this.busyStartedAt = Date.now() + F4, this.showBusyElementTimeout = setTimeout(() => {
        this.busySlotElement.hidden = false, this.defaultSlotElement.hidden = true;
      }, F4));
    }
    hideBusyElement() {
      if (clearTimeout(this.showBusyElementTimeout), clearTimeout(this.hideBusyElementTimeout), !this.busyElement) return;
      let e2 = C3 - (Date.now() - this.busyStartedAt);
      e2 < 0 && (e2 = 0), delete this.busyStartedAt, this.hideBusyElementTimeout = setTimeout(() => {
        this.busySlotElement.hidden = true, this.defaultSlotElement.hidden = false;
      }, e2);
    }
    get busyElement() {
      return this.querySelector(':scope > [slot="busy"]');
    }
    get busySlotElement() {
      return this.shadowRoot.querySelector('slot[name="busy"]');
    }
    get defaultSlotElement() {
      return this.shadowRoot.querySelector("slot:not([name])");
    }
    get busy() {
      return this.getAttribute("busy") === "true";
    }
    set busy(e2) {
      e2 = !!e2, this.busy !== e2 && (this.setAttribute("busy", e2), e2 ? this.showBusyElement() : this.hideBusyElement());
    }
    get busyStartedAt() {
      return this.dataset.busyStartedAt ? Number(this.dataset.busyStartedAt) : 0;
    }
    set busyStartedAt(e2) {
      this.dataset.busyStartedAt = e2;
    }
  };
  var f3 = class extends d4 {
    connectedCallback() {
      super.connectedCallback(), this.mouseenterHandler = this.onMouseenter.bind(this), this.addEventListener("mouseenter", this.mouseenterHandler), this.collapseHandler = this.collapse.bind(this), this.collapseNowHandler = this.collapseNow.bind(this), this.collapseOn.forEach((e2) => {
        let o3 = e2.split("@"), r3 = o3[0];
        o3.length > 1 ? (o3[1].match(/^self|window$/) ? self : self[o3[1]]).addEventListener(r3, this.collapseNowHandler) : this.addEventListener(r3, this.collapseHandler);
      });
    }
    disconnectedCallback() {
      this.removeEventListener("mouseenter", this.mouseenterHandler), this.collapseOn.forEach((e2) => {
        let o3 = e2.split("@"), r3 = o3[0];
        o3.length > 1 ? (o3[1].match(/^self|window$/) ? self : self[o3[1]]).removeEventListener(r3, this.collapseNowHandler) : this.removeEventListener(r3, this.collapseHandler);
      });
    }
    cacheHTML() {
    }
    renderCachedHTML() {
    }
    onMouseenter() {
      clearTimeout(this.collapseTimeout);
    }
    collapse(e2 = 250) {
      if (clearTimeout(this.collapseTimeout), !this.busy) {
        if (typeof e2 != "number" && (e2 = 250), e2 > 0) return this.collapseTimeout = setTimeout(() => this.collapse(0), e2);
        this.innerHTML = "";
        try {
          this.expanded = false, this.triggerElement.hideDevtool();
        } catch (o3) {
        }
      }
    }
    collapseNow(e2) {
      e2.target.closest("turbo-boost-devtool-tooltip") || this.collapse(0);
    }
    collapseMatches() {
      document.querySelectorAll(this.collapseSelector).forEach((e2) => {
        e2.id !== this.id && e2.collapse && e2.collapse(0);
      });
    }
    get collapseSelector() {
      return this.triggerElement.collapseSelector || this.getAttribute("collapse-selector");
    }
    get focusSelector() {
      return this.getAttribute("focus-selector");
    }
    get triggerElement() {
      return document.getElementById(this.labeledBy);
    }
    get triggerElements() {
      return document.querySelectorAll(`[aria-controls="${this.id}"]`);
    }
    get labeledBy() {
      return this.getAttribute("aria-labeledby");
    }
    set labeledBy(e2) {
      return this.setAttribute("aria-labeledby", e2);
    }
    get collapseOn() {
      let e2 = this.getAttribute("collapse-on");
      return e2 ? JSON.parse(e2) : [];
    }
    get expanded() {
      return this.triggerElement ? this.triggerElement.expanded : false;
    }
    set expanded(e2) {
      this.triggerElements.forEach((o3) => o3.expanded = e2);
    }
    get busy() {
      return this.triggerElement && this.triggerElement.busy;
    }
  };
  var W4;
  function be4(t4) {
    ["bold", "bullet", "code", "heading1", "href", "italic", "number", "quote", "strike"].forEach((o3) => t4.deactivateAttribute(o3));
  }
  function pe4(t4) {
    if (t4.value.length === 0) return;
    let e2 = t4.editor, o3 = [];
    for (; o3[0] !== e2.getSelectedRange()[0] && o3[1] !== e2.getSelectedRange()[1]; ) o3 = e2.getSelectedRange(), e2.moveCursorInDirection("forward");
    e2.insertString(" "), e2.moveCursorInDirection("forward"), e2.setSelectedRange([o3[1], e2.getSelectedRange()[1]]), be4(e2), e2.setSelectedRange([e2.getSelectedRange()[1], e2.getSelectedRange()[1]]);
  }
  function ve4(t4) {
    clearTimeout(W4), W4 = setTimeout(() => {
      if (!t4) return;
      t4.focus();
      let e2 = t4.closest("trix-editor");
      try {
        e2 ? pe4(e2) : t4.selectionStart = t4.selectionEnd = t4.value.length;
      } catch (o3) {
      } finally {
        t4.scrollIntoView({ block: "center", behavior: "smooth" });
      }
    }, 100);
  }
  var G5 = (t4) => ve4(t4);
  document.addEventListener("turbo-boost:devtools-start", () => D5.register("toggle", "toggles"));
  var _25;
  var E4 = class extends d4 {
    constructor() {
      super(), z4(this, "toggle", "toggles");
    }
    connectedCallback() {
      super.connectedCallback();
      let { start: e2 } = TurboBoost.Commands.events;
      this.commandStartHandler = this.onCommandStart.bind(this), this.addEventListener(e2, this.commandStartHandler);
      let { before: o3 } = TurboBoost.Streams.invokeEvents;
      this.beforeInvokeHandler = this.onBeforeInvoke.bind(this), addEventListener(o3, this.beforeInvokeHandler), this.initializeDevtool();
    }
    disconnectedCallback() {
      setTimeout(() => {
        let { start: e2 } = TurboBoost.Commands.events;
        this.removeEventListener(e2, this.commandStartHandler);
        let { before: o3 } = TurboBoost.Streams.invokeEvents;
        removeEventListener(o3, this.beforeInvokeHandler), this.removeDevtool();
      }, 1e3);
    }
    onCommandStart(e2) {
      _25 = this.focusSelector, this.targetElement.labeledBy = this.id, this.targetElement.collapseMatches(), this.busy = true;
    }
    onBeforeInvoke(e2) {
      if (e2.detail.method !== "morph" || e2.target.id !== this.morphs) return;
      let o3 = `turbo-boost-toggle-target[aria-labeledby="${this.id}"]`;
      if (!e2.target.querySelector(o3)) return;
      let r3 = Date.now() - this.busyStartedAt, s4 = C3 - r3;
      s4 < 10 && (s4 = 10), e2.detail.invoke = { delay: s4 }, setTimeout(() => {
        this.busy = false, this.morphToggleTriggerElements.forEach((i3) => i3.busy = false);
      }, s4 - 10), setTimeout(() => G5(this.targetElement.querySelector(_25)), s4 + 100);
    }
    get sharedViews() {
      if (!this.targetElement) return [];
      if (!this.targetElement.viewStack) return [];
      let e2 = (o3, r3) => (this.targetElement.viewStack.includes(r3) && o3.push(r3), o3);
      return this.viewStack.reduce(e2.bind(this), []);
    }
    get renders() {
      return this.getAttribute("renders");
    }
    get morphs() {
      return this.getAttribute("morphs");
    }
    get morphToggleTriggerElements() {
      return Array.from(this.morphElement.querySelectorAll("turbo-boost-toggle-trigger"));
    }
    get controls() {
      return this.getAttribute("aria-controls");
    }
    get collapseSelector() {
      return this.getAttribute("collapse-selector");
    }
    get focusSelector() {
      return this.getAttribute("focus-selector") || this.targetElement.focusSelector;
    }
    get remember() {
      return this.getAttribute("remember") === "true";
    }
    set remember(e2) {
      return this.setAttribute("remember", !!e2);
    }
    get expanded() {
      return this.getAttribute("aria-expanded") === "true";
    }
    set expanded(e2) {
      this.setAttribute("aria-expanded", !!e2);
    }
    get collapsed() {
      return !this.expanded;
    }
    get command() {
      return this.dataset.turboCommand;
    }
    get renderingLineLabel() {
      return "renders & morphs";
    }
    get morphElement() {
      return this.morphs ? document.getElementById(this.morphs) : null;
    }
    get targetElement() {
      return this.controls ? document.getElementById(this.controls) : null;
    }
    get triggerTooltipData() {
      let e2 = this.triggerElement.viewStack.reverse().map((o3, r3) => this.triggerElement.sharedViews.includes(o3) ? `<div slot="content">${r3 + 1}. ${o3}</div>` : `<div slot="content-bottom">${r3 + 1}. ${o3}</div>`, this).join("");
      return { subtitle: `
      <b>id</b>: ${this.triggerElement.id}<br>
      <b>aria-controls</b>: ${this.triggerElement.controls}<br>
      <b>aria-expanded</b>: ${this.triggerElement.expanded}<br>
      <b>remember</b>: ${this.triggerElement.remember}<br>
    `, content: `
      <div slot="content-top">
        <svg xmlns="http://www.w3.org/2000/svg" style="display:inline-block;" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>
        <b>View Stack</b>
      </div>
      ${e2}
    ` };
    }
    get targetTooltipData() {
      let e2 = this.targetElement.viewStack.reverse().map((o3, r3) => this.triggerElement.sharedViews.includes(o3) ? `<div slot="content">${r3 + 1}. ${o3}</div>` : `<div slot="content-bottom">${r3 + 1}. ${o3}</div>`, this).join("");
      return { subtitle: `<b>id</b>: ${this.targetElement.id}<br>
      <b>aria-labeled-by</b>: ${this.targetElement.labeledBy}<br>
`, content: `
      <div slot="content-top">
        <svg xmlns="http://www.w3.org/2000/svg" style="display:inline-block;" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>
        <b>View Stack</b>
      </div>
      ${e2}
    ` };
    }
  };
  customElements.define("turbo-boost", a4);
  customElements.define("turbo-boost-toggle-target", f3);
  customElements.define("turbo-boost-toggle-trigger", E4);
  self.TurboBoost = self.TurboBoost || {};
  self.TurboBoost.devtools = P5;
  self.TurboBoost.Elements = { VERSION: V4 };
  var Pe3 = self.TurboBoost.Elements;

  // app/javascript/turbo_boost/commands.js
  init_define_process();
  init_jquery();
  TurboBoost.Commands.registerEventDelegate("debounced:keyup", [
    "input[data-turbo-command][data-turbo-command-event=keyup]"
  ]);
  var changeSelectors = [
    "input[data-turbo-command]:not([data-turbo-command-event=keyup])",
    "select[data-turbo-command]:not([data-turbo-command-event=keyup])",
    "textarea[data-turbo-command]:not([data-turbo-command-event=keyup])"
  ];
  TurboBoost.Commands.registerEventDelegate("change", changeSelectors);
  TurboBoost.Commands.registerEventDelegate("sl-change", ["sl-select[data-turbo-command]"]);
  document.addEventListener("mouseover", (event2) => {
    const el = event2.target.closest("[data-turbo-command]");
    if (!el) return;
    if (!el.dataset.bubblingMouseEnterInitialized) {
      el.dataset.bubblingMouseEnterInitialized = true;
      el.addEventListener("mouseleave", () => {
        el.mouseAbove = false;
      });
    }
    if (el.mouseAbove) return;
    el.mouseAbove = true;
    el.dispatchEvent(new CustomEvent("mouseabove", { bubbles: true }));
  });
  TurboBoost.Commands.registerEventDelegate("mouseabove", [
    'turbo-boost-toggle-trigger[data-event="mouseover"][data-turbo-command]'
  ]);
  TurboBoost.Commands.registerEventDelegate("cf:change", ['select[data-turbo-command][data-action^="cf:change"]']);
  TurboBoost.Commands.registerEventDelegate("action-cable-context:refresh", ['meta[name="action-cable-context"]']);

  // app/javascript/account/rails_ujs_overrides.js
  init_define_process();
  init_jquery();
  var import_ujs = __toESM(require_rails_ujs());
  import_ujs.default.confirm = function(message, element) {
    function dispatchEvent2(opts2) {
      const event2 = document.createEvent("CustomEvent");
      event2.initCustomEvent("confirm-display", true, true, opts2);
      window.document.dispatchEvent(event2);
    }
    let $element = $(element);
    let title = $element.data("title") ? $element.data("title") : "";
    let submit = $element.data("submit") ? $element.data("submit") : "Proceed";
    let back = $element.data("cancel") ? $element.data("cancel") : "Cancel";
    let type = $element.data("type") ? $element.data("type") : "neutral";
    const opts = {
      title,
      message,
      type,
      confirmButtonText: submit,
      cancelButtonText: back,
      originalElement: element
    };
    dispatchEvent2(opts);
  };

  // app/javascript/account/turbo_confirm.js
  init_define_process();
  init_jquery();
  window.Turbo.setConfirmMethod((message, element, submitter) => {
    let originalElement = submitter || element;
    if (!submitter || submitter.tagName == "INPUT") {
      let matchingElements = document.querySelectorAll(
        `a[data-turbo-confirm="${CSS.escape(message)}"][data-turbo-method="${element.getAttribute("method")}"]`
      );
      const matchedElement = [...matchingElements].find((el) => {
        let originalElementHrefWithoutParams = new URL(el.href).pathname;
        return element.action.includes(originalElementHrefWithoutParams);
      });
      if (matchedElement) {
        originalElement = matchedElement;
      }
    }
    let elementWithDataAttributes = originalElement.dataset.turboConfirm ? originalElement : element;
    const {
      type,
      title,
      turboConfirm: description2,
      cancel: cancel2,
      submit,
      turboConfirmDetail: eventDetail,
      guardPhrase,
      htmlSafeDescription,
      htmlSafeTitle,
      initiator,
      useIconButtons
    } = elementWithDataAttributes.dataset;
    let dialog = document.getElementById("turbo-confirm");
    if (type) {
      dialog.setAttribute("data-shoelace--confirm-type-value", type);
    }
    if (title) {
      dialog.setAttribute("data-shoelace--confirm-title-value", title);
    }
    if (description2) {
      dialog.setAttribute("data-shoelace--confirm-description-value", description2);
    }
    if (cancel2) {
      dialog.setAttribute("data-shoelace--confirm-cancel-value", cancel2);
    }
    if (submit) {
      dialog.setAttribute("data-shoelace--confirm-submit-value", submit);
    }
    if (eventDetail) {
      dialog.setAttribute("data-shoelace--confirm-event-detail-value", eventDetail);
    }
    if (guardPhrase) {
      dialog.setAttribute("data-shoelace--confirm-guard-phrase-value", guardPhrase);
    }
    if (htmlSafeDescription) {
      dialog.setAttribute("data-shoelace--confirm-html-safe-description-value", htmlSafeDescription);
    }
    if (htmlSafeTitle) {
      dialog.setAttribute("data-shoelace--confirm-html-safe-title-value", htmlSafeTitle);
    }
    if (initiator) {
      dialog.setAttribute("data-shoelace--confirm-initiator-value", initiator);
    }
    if (useIconButtons) {
      dialog.setAttribute("data-shoelace--confirm-use-icon-buttons-value", useIconButtons);
    }
    dialog.show();
    return new Promise((resolve2) => {
      dialog.addEventListener(
        "shoelace--confirm:confirm",
        (event2) => {
          const confirmed = event2.detail.confirm;
          if (!confirmed) {
            originalElement.disabled = false;
          }
          resolve2(confirmed);
        },
        { once: true }
      );
    });
  });

  // app/javascript/customer_center/application.js
  var import_lazysizes = __toESM(require_lazysizes());

  // node_modules/debounced/src/index.js
  init_define_process();
  init_jquery();

  // node_modules/debounced/src/events.js
  init_define_process();
  init_jquery();
  var wait2 = 200;
  var events_default = {
    DOMContentLoaded: { wait: wait2 },
    abort: { wait: wait2 },
    animationcancel: { wait: wait2 },
    animationend: { wait: wait2 },
    animationiteration: { wait: wait2 },
    animationstart: { wait: wait2 },
    auxclick: { wait: wait2 },
    change: { wait: wait2 },
    click: { wait: wait2 },
    compositionend: { wait: wait2 },
    compositionstart: { wait: wait2 },
    compositionupdate: { wait: wait2 },
    contextmenu: { wait: wait2 },
    copy: { wait: wait2 },
    cut: { wait: wait2 },
    dblclick: { wait: wait2 },
    drag: { wait: wait2 },
    dragend: { wait: wait2 },
    dragenter: { wait: wait2 },
    dragleave: { wait: wait2 },
    dragover: { wait: wait2 },
    dragstart: { wait: wait2 },
    drop: { wait: wait2 },
    error: { wait: wait2 },
    focusin: { wait: wait2 },
    focusout: { wait: wait2 },
    fullscreenchange: { wait: wait2 },
    fullscreenerror: { wait: wait2 },
    hashchange: { wait: wait2 },
    input: { wait: wait2 },
    keydown: { wait: wait2 },
    keyup: { wait: wait2 },
    mousedown: { wait: wait2 },
    mousemove: { wait: wait2 },
    mouseout: { wait: wait2 },
    mouseover: { wait: wait2 },
    mouseup: { wait: wait2 },
    paste: { wait: wait2 },
    pointercancel: { wait: wait2 },
    pointerdown: { wait: wait2 },
    pointerlockchange: { wait: wait2 },
    pointerlockerror: { wait: wait2 },
    pointermove: { wait: wait2 },
    pointerout: { wait: wait2 },
    pointerover: { wait: wait2 },
    pointerup: { wait: wait2 },
    popstate: { wait: wait2 },
    reset: { wait: wait2 },
    scroll: { wait: wait2 },
    select: { wait: wait2 },
    submit: { wait: wait2 },
    touchcancel: { wait: wait2 },
    touchend: { wait: wait2 },
    touchmove: { wait: wait2 },
    touchstart: { wait: wait2 },
    transitioncancel: { wait: wait2 },
    transitionend: { wait: wait2 },
    transitionrun: { wait: wait2 },
    transitionstart: { wait: wait2 },
    visibilitychange: { wait: wait2 },
    wheel: { wait: wait2 }
  };

  // node_modules/debounced/src/index.js
  var prefix = "debounced";
  var initializedEvents = {};
  var debounce7 = (fn3, options = {}) => {
    const { wait: wait3 } = options;
    let timeoutId;
    return (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        timeoutId = null;
        fn3(...args);
      }, wait3);
    };
  };
  var dispatch3 = (event2) => {
    const { bubbles, cancelable, composed } = event2;
    const debouncedEvent = new CustomEvent(`${prefix}:${event2.type}`, {
      bubbles,
      cancelable,
      composed,
      detail: { originalEvent: event2 }
    });
    setTimeout(event2.target.dispatchEvent(debouncedEvent));
  };
  var initializeEvent = (name2, options = {}) => {
    if (initializedEvents[name2]) return;
    initializedEvents[name2] = options || {};
    const debouncedDispatch = debounce7(dispatch3, options);
    document.addEventListener(name2, (event2) => debouncedDispatch(event2));
  };
  var initialize2 = (evts = events_default) => {
    prefix = evts.prefix || prefix;
    delete evts.prefix;
    for (const [name2, options] of Object.entries(evts)) {
      initializeEvent(name2, options);
    }
  };
  var src_default2 = {
    debounce: debounce7,
    events: events_default,
    initialize: initialize2,
    initializeEvent,
    initializedEvents
  };

  // app/javascript/customer_center/application.js
  var import_jstz = __toESM(require_jstz2());
  import_ujs2.default.start();
  ActiveStorage.start();
  start2(ApplicationCable_default.cable);
  global2.initialize({ consumer: ApplicationCable_default });
  src_default2.initialize();
  window.jstz = import_jstz.default;
  window.jstz = import_jstz.default;
  window.Turbo.setProgressBarDelay(define_process_default.env.RAILS_ENV === "test" ? 0 : 500);
  document.addEventListener("turbo:submit-end", (e2) => {
    if (e2.detail.success === false) {
      e2.target.scrollIntoView(true);
    }
  });
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);
})();
/*! Bundled license information:

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.5.1
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2020-05-04T22:49Z
   *)

select2/dist/js/select2.js:
  (*!
   * Select2 4.0.13
   * https://select2.github.io
   *
   * Released under the MIT license
   * https://github.com/select2/select2/blob/master/LICENSE.md
   *)
  (**
   * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
   * Released under MIT license, http://github.com/requirejs/almond/LICENSE
   *)

select2/dist/js/i18n/en.js:
  (*! Select2 4.0.13 | https://github.com/select2/select2/blob/master/LICENSE.md *)

select2/dist/js/i18n/es.js:
  (*! Select2 4.0.13 | https://github.com/select2/select2/blob/master/LICENSE.md *)

select2/dist/js/i18n/pt.js:
  (*! Select2 4.0.13 | https://github.com/select2/select2/blob/master/LICENSE.md *)

select2/dist/js/i18n/ja.js:
  (*! Select2 4.0.13 | https://github.com/select2/select2/blob/master/LICENSE.md *)

tom-select/dist/js/tom-select.complete.js:
  (*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) *)
  (*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) *)

cropperjs/dist/cropper.js:
  (*!
   * Cropper.js v1.6.2
   * https://fengyuanchen.github.io/cropperjs
   *
   * Copyright 2015-present Chen Fengyuan
   * Released under the MIT license
   *
   * Date: 2024-04-21T07:43:05.335Z
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

jstz/dist/jstz.js:
  (**
   * This script gives you the zone info key representing your device's time zone setting.
   *
   * @name jsTimezoneDetect
   * @version 1.0.6
   * @author Jon Nylander
   * @license MIT License - https://bitbucket.org/pellepim/jstimezonedetect/src/default/LICENCE.txt
   *
   * For usage and examples, visit:
   * http://pellepim.bitbucket.org/jstz/
   *
   * Copyright (c) Jon Nylander
   *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.5
  Copyright  2024 37signals LLC
   *)

@ungap/custom-elements/index.js:
  (*! (c) Andrea Giammarchi @webreflection ISC *)

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)

trix/dist/trix.esm.min.js:
  (*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE *)

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * @kurkle/color v0.2.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chart.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

lightgallery/lightgallery.es5.js:
  (*!
   * lightgallery | 2.7.2 | September 20th 2023
   * http://www.lightgalleryjs.com/
   * Copyright (c) 2020 Sachin Neravath;
   * @license GPLv3
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

lightgallery/plugins/zoom/lg-zoom.es5.js:
  (*!
   * lightgallery | 2.7.2 | September 20th 2023
   * http://www.lightgalleryjs.com/
   * Copyright (c) 2020 Sachin Neravath;
   * @license GPLv3
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

lightgallery/plugins/video/lg-video.es5.js:
  (*!
   * lightgallery | 2.7.2 | September 20th 2023
   * http://www.lightgalleryjs.com/
   * Copyright (c) 2020 Sachin Neravath;
   * @license GPLv3
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=/assets/customer-center.js-933d9280e8e15290d8278ba91f1a31748ab53de51a2cd7460bfe2db1aa7a9c6b.map
//!
;
